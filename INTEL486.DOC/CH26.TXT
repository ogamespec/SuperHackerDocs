══════════════════════════════════════════════════════════════════════════
`р`д`10Часть V.`05  Набор команд`*
==========================================================================

`м`дГлава 26.   Набор команд `*
--------------------------------------------------------------------------

В данной главе представлены  команды процессора i486 в  алфавитном порядке.
Для  каждой  команды   приводятся  ее  формы   при  различных   комбинациях
операндов,  включая  создаваемый  объектный  код, требуемые операнды, время
выполнения и описание.  Каждой команде соответствует  описание ее работы  и
краткий обзор генерируемых ею исключений.


`д`к26.1  Атрибуты размера операнда и размера адреса  `*

При выполнении  команды процессор  i486 может  адресовать память, используя
для  этого  либо  16-разрядные,  либо  32-разрядные  адреса. Следовательно,
каждая  команда,  адресующая  память,  имеет соответственно атрибут размера
адреса,  равный  16  или  32  битам.  Использование  16-разрядных   адресов
подразумевает использование  16-разрядных смещений  в командах  и генерацию
16-разрядных  адресных  смещений  (адресов  относительно начала сегмента) в
результате   вычисления   исполнительного   адреса.   32-разрядные   адреса
подразумевают использование  32-разрядных смещений  в командах  и генерацию
32-разрядных адресных смещений.  Аналогичным образом, команда,  выполняющая
доступ к  слову (16  битов) или  к двойному  слову (32  бита) имеет атрибут
размера операнда, равный 16 или 32 битам, соответственно.


`д`к26.1.1  Атрибут для сегмента по умолчанию`*

Для  программ,  работающих  в  защищенном  режиме,  бит  D  в  дескрипторах
выполняемых сегментов задает атрибут  по умолчанию как для  размера адреса,
так  и  для  размера  операнда.  Эти  атрибуты по умолчанию применяются при
выполнении  всех  команд  данного  сегмента.  Очищенный бит D задает размер
адреса и  размер операнда  по умолчанию,  равный 16  битам, а установленный
бит D - равный 32 битам.
Программы,  работающие  в  реальном  режиме  или в виртуальном режиме 8086,
имеют 16-разрядные адреса и операнды по умолчанию.


`д`к26.1.2  Префиксы размера операнда и размера адреса команд     `*

Внутреннее кодирование команды  может включать в  себя два префикса  длиной
по одному байту: префикс размера  адреса, 67H, и префикс размера  операнда,
66H.  (В  последующем  разделе,  "Формат  команды", показано положение этих
префиксов  в  кодировке  команды).  Эти  префиксы  переопределяют  атрибуты
сегмента  по  умолчанию  для  непосредственно  следующей за ними команды. В
Таблице 26-1 показано воздействие  каждой возможной комбинации умолчаний  и
переопределений.


Таблица 26-1. Действующие атрибуты размера

-----------------------------------------------------------------
Умолчание для сегмента D = ...  | 0 | 0 | 0 | 0 | 1 | 1 | 1 | 1 |
-----------------------------------------------------------------
Префикс размера операнда 66H    | N | N | Y | Y | N | N | Y | Y |
-----------------------------------------------------------------
Префикс размера адреса   67H    | N | Y | N | Y | N | Y | N | Y |
-----------------------------------------------------------------
Размер исполнительного операнда |16 |16 |32 |32 |32 |32 |16 |16 |
-----------------------------------------------------------------
Размер исполнительного адреса   |16 |32 |16 |32 |32 |16 |32 |16 |
-----------------------------------------------------------------

Y Да, этот префикс команды задан N Нет, этот префикс команды не задан


`д`к26.1.3  Атрибут размера адреса для стека`*

Команды, неявно использующие стек  (например, POP EAX) также  имеют атрибут
размера адреса стека, равный 16  или 32 битам. Команды с  атрибутом размера
адреса стека,  равным 16  битам, используют  16-разрядный регистр указателя
стека SP,  а команды  с атрибутом  размера адреса  стека, равным  32 битам,
используют  32-разрядный  регистр   ESP,  позволяющий  сформировать   адрес
вершины стека.
Атрибут  размера  адреса  стека  управляется  битом  B дескриптора сегмента
данных в  регистре SS.  Нулевое значение  бита B  выбирает атрибут  размера
адреса стека, равный  16 битам; значение  единицы выбирает атрибут  размера
адреса стека, равный 32.

`д`к26.2  Формат команды`*

Любые варианты  кодирования команд  представляют собой  подмножества общего
формата  команды,  показанного   на  Рисунке  26-1.   Команда  состоит   из
опциональных  префиксов  команды,  одного  или  двух  байтов основного кода
операции, возможно  описателя адреса,  состоящего из  байта ModR/M  и байта
SIB (Scale Index Base,  или Масштабный коэффициент Индекс  База), смещения,
если оно необходимо, и непосредственного поля данных, если оно необходимо.

------------------------------------------------------------------
    Префикс     |    Префикс     |     Префикс    |Переопределение
    команды     | размера адреса |размера операнда|    сегмента
------------------------------------------------------------------
    0 или 1     |   0 или 1      |     0 или 1    |   0 или 1
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                   Число байтов
------------------------------------------------------------------


------------------------------------------------------------------
   Код     |  MODR/M  |   SIB    |  Смещение   | Непосредственный
 операции  |          |          |             |    операнд
------------------------------------------------------------------
  1 или 2  |  0 или 1 |  0 или 1 | 0,1,2 или 4     0,1,2 или 4
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                   Число байтов
------------------------------------------------------------------

Рисунок 26-1. Формат команды процессора i486


Меньшие  поля  кодировки  могут  быть  определены  внутри  основного   кода
операции  или  кодов  операции.  Эти  поля  определяют  направление  работы
команды, размер  смещений, кодировку  регистров или  расширение знаком; эти
поля кодировки изменяются в зависимости от класса операции.
Большинство команд,  которые могут  обращаться к  операнду в  памяти, имеют
байт  формы  адресации,  следующий  после  байта  (байтов)  основного  кода
операции. Этот байт, называемый ModR/M , задает используемую форму  адреса.
Некоторые кодировки байта ModR /M  указывают на второй байт адресации,  SIB
(Масштабный коэффициент Индекс  База), который следует  за байтом ModR/M  и
необходим для полного определения формы адресации.
Некоторые   формы    адресации    могут   включать    величину    смещения,
непосредственно следующую за байтами  ModR/M или SIB. При  наличии смещения
оно может занимать 8, 16 или 32 бита.
Если в  команде задан  непосредственный операнд,  то он  всегда следует  за
байтами смещения. Непосредственный операнд, если он задан, всегда  является
последним полем команды.

Ниже приводятся допустимые коды префиксов команд:

F3H префикс REP (используется только со строковыми командами)
F3H префикс REPE/REPZ (используется только со строковыми командами).
F2H префикс REPNE/REPNZ (используется только со строковыми командами).
F0H префикс LOCK
Ниже приволятся префиксы переопределения сегментов:
2EH префикс переопределения сегмента CS
36H префикс переопределения сегмента SS
3EH префикс переопределения сегмента DS
26H префикс переопределения сегмента ES
64H префикс переопределения сегмента FS
65H префикс переопределения сегмента GS
66H переопределение размера операнда
67H переопределение размера адреса


`д`к26.2.1  Байты ModR/M и SIB  `*

Байты ModR/M  и SIB  следуют за  байтом (байтами)  кода операции  во многих
командах процессора i486. Они несут следующую информацию:

- Тип индексации или номер регистра, используемого в команде.
- Используемый регистр или дополнительная информация для выбора команды.
- Информация о базе, индексе и масштабном коэффициенте.
Байт ModR/M содержит три информационных поля:
- Поле mod,  которое занимает два  старших бита в  байте, и в  комбинации с
полем r/m  образует 32  возможных значения:  восемь регистров  и 24  режима
индексации.
-  Поле  reg,  занимающее  следующие  три  бита после поля mod, задает либо
номер регистра, либо следующие три  бита информации о коде операции.  Смысл
поля reg определяется первым байтом (кодом операции) команды.
-  Поле  r/m,  занимающее  три  младшие  бита  в байте, может либо задавать
регистр  в  качестве  местоположения  операнда,  либо  может в комбинации с
полем mod формировать  часть кодировки режима  адресации, как было  описано
выше.

Формы 32-разрядной  адресации типа  база-индекс или  масштаб-индекс требуют
наличия байта SIB. Наличие  байта SIB определяется определенной  кодировкой
байта ModR/M. Байт SIB в этом случае содержит следующие поля:
-  Поле  ss,  занимающее  два  старших  бита  в  байте,  задает  масштабный
коэффициент.
-  Поле  индекса  (index),  занимающее  следующие  три  бита после поля ss,
задает номер индексного регистра.
-  Поле  базы  (base),  занимающее  три  младших бита в байте, задает номер
базового регистра.

Форматы байтов ModR/M и SIB показaны на Рисунке 26-2.
Значения  и  соответствующие  формы  адресации  для  байтов  ModR/M  и  SIB
показаны  в  таблицах  26-2,  26-3  и  26-4.  16-разрядные формы адресации,
задаваемые  байтом  ModR/M,  показаны  в  Таблице 26-2. 32 -разрядные формы
адресации, задаваемые  байтом ModR/M,  показаны в  Таблице 26-3.  В Таблице
26-4 показаны 32-разрядные формы адресации, задаваемые байтом SIB.

Байт MODR/M

      7   6   5       4      3  2    1   0
     --------------------------------------
     | MOD  | REG/Код операции|   R/M     |
     --------------------------------------

         Байт SIB (Масштабный коэффициент,
                   Индекс, База)

      7    6    5    4    3    2    1    0
     --------------------------------------
     |  SS   |    Индекс    |     База    |
     --------------------------------------

Рисунок 26-2. Формат байтов ModR/M и SIB


Таблица 26-2. Формы 16-разрядной адресации для байта ModR/M

-------------------------------------------------------------------
|r8(/r)                   | AL | CL | DL | BL | AH | CH | DH | BH |
|r16(/r)                  | AX | CX | DX | BX | SP | BP | SI | DI |
|r32(/r)                  |EAX |ECX |EDX |EBX |ESP |EBP |ESI |EDI |
|/цифра (Код операции)    | 0  | 1  | 2  | 3  | 4  | 5  | 6  | 7  |
|REG                      |000 |001 |010 |011 |100 |101 |110 |111 |
|-----------------------------------------------------------------|
| Исполнительный | ModR/M |     Шестнадцатиричные значения        |
|    адрес       |        |             ModR/M                    |
|-----------------------------------------------------------------|
| [BX+SI]        |    000 | 00 | 08 | 10 | 18 | 20 | 28 | 30 | 38 |
| [BX+DI]        |    001 | 01 | 09 | 11 | 19 | 21 | 29 | 31 | 39 |
| [BP+SI]        |    010 | 02 | 0A | 12 | 1A | 22 | 2A | 32 | 3A |
| [BP+DI]        |    011 | 03 | 0B | 13 | 1B | 23 | 2B | 33 | 3B |
| [SI]           | 00 100 | 04 | 0C | 14 | 1C | 24 | 2C | 34 | 3C |
| [DI]           |    101 | 05 | 0D | 15 | 1D | 25 | 2D | 35 | 3D |
| смещ16         |    110 | 06 | 0E | 16 | 1E | 26 | 2E | 36 | 3E |
| [BX]           |    111 | 07 | 0F | 17 | 1F | 27 | 2F | 37 | 3F |
|-----------------------------------------------------------------|
| [BX+SI]+смещ8  |    000 | 40 | 48 | 50 | 58 | 60 | 68 | 70 | 78 |
| [BX+DI]+смещ8  |    001 | 41 | 49 | 51 | 59 | 61 | 69 | 71 | 79 |
| [BP+SI]+смещ8  |    010 | 42 | 4A | 52 | 5A | 62 | 6A | 72 | 7A |
| [BP+DI]+смещ8  |    011 | 43 | 4B | 53 | 5B | 63 | 6B | 73 | 7B |
| [SI]+смещ8     | 01 100 | 44 | 4C | 54 | 5C | 64 | 6C | 74 | 7C |
| [DI]+смещ8     |    101 | 45 | 4D | 55 | 5D | 65 | 6D | 75 | 7D |
| [BP]+смещ8     |    110 | 46 | 4E | 56 | 5E | 66 | 6E | 76 | 7E |
| [BX]+смещ8     |    111 | 47 | 4F | 57 | 5F | 67 | 6F | 77 | 7F |
|-----------------------------------------------------------------|
| [BX+SI]+смещ16 |    000 | 80 | 88 | 90 | 98 | A0 | A8 | B0 | B8 |
| [BX+DI]+смещ16 |    001 | 81 | 89 | 91 | 99 | A1 | A9 | B1 | B9 |
| [BP+SI]+смещ16 |    010 | 82 | 8A | 92 | 9A | A2 | AA | B2 | BA |
| [BP+DI]+смещ16 |    011 | 83 | 8B | 93 | 9B | A3 | AB | B3 | BB |
| [SI]+смещ16    | 10 100 | 84 | 8C | 94 | 9C | A4 | AC | B4 | BC |
| [DI]+смещ16    |    101 | 85 | 8D | 95 | 9D | A5 | AD | B5 | BD |
| [BP]+смещ16    |    110 | 86 | 8E | 96 | 9E | A6 | AE | B6 | BE |
| [BX]+смещ16    |    111 | 87 | 8F | 97 | 9F | A7 | AF | 77 | BF |
|-----------------------------------------------------------------|
| EAX/AX/AL      |    000 | C0 | C8 | D0 | D8 | E0 | E8 | F0 | F8 |
| ECX/CX/CL      |    001 | C1 | C9 | D1 | D9 | E1 | E9 | F1 | F9 |
| EDX/DX/DL      |    010 | C2 | CA | D2 | DA | E2 | EA | F2 | FA |
| EBX/BX/BL      |    011 | C3 | CB | D3 | DB | E3 | EB | F3 | FB |
| ESP/SP/AH      | 11 100 | C4 | CC | D4 | DC | E4 | EC | F4 | FC |
| EBP/BP/CH      |    101 | C5 | CD | D5 | DD | E5 | ED | F5 | FD |
| ESI/SI/DH      |    110 | C6 | CE | D6 | DE | E6 | EE | F6 | FE |
| EDI/DI/BH      |    111 | C7 | CF | D7 | DF | E7 | EF | F7 | FF |
-------------------------------------------------------------------

ПРИМЕЧАНИЯ: смещ8 означает, что  8-разрядное смещение, следующее за  байтом
ModR/M,  должно  быть  расширено  по  знаку  и прибавлено к индексу. смещ16
означает, что  16-разрядное смещение,  следующее за  байтом ModR/M,  должно
быть  прибавлено  к   индексу.  Сегментным  регистром   по  умолчанию   для
исполнительного адреса, содержащего  индекс BP, является  SS, а для  прочих
исполнительных адресов - DS.

Таблица 26-3. Формы 32-битовой адресации для байта ModR/M

-------------------------------------------------------------------
|r8(/r)                   | AL | CL | DL | BL | AH | CH | DH | BH |
|r16(/r)                  | AX | CX | DX | BX | SP | BP | SI | DI |
|r32(/r)                  |EAX |ECX |EDX |EBX |ESP |EBP |ESI |EDI |
|/цифра (Код операции)    | 0  | 1  | 2  | 3  | 4  | 5  | 6  | 7  |
|REG                      |000 |001 |010 |011 |100 |101 |110 |111 |
|-----------------------------------------------------------------|
| Исполнительный | ModR/M |     Шестнадцатиричные значения        |
|    адрес       |        |             ModR/M                    |
|-----------------------------------------------------------------|
| [EAX]          |    000 | 00 | 08 | 10 | 18 | 20 | 28 | 30 | 38 |
| [ECX]          |    001 | 01 | 09 | 11 | 19 | 21 | 29 | 31 | 39 |
| [EDX]          |    010 | 02 | 0A | 12 | 1A | 22 | 2A | 32 | 3A |
| [EBX]          |    011 | 03 | 0B | 13 | 1B | 23 | 2B | 33 | 3B |
| [--][--]       | 00 100 | 04 | 0C | 14 | 1C | 24 | 2C | 34 | 3C |
| смещ32         |    101 | 05 | 0D | 15 | 1D | 25 | 2D | 35 | 3D |
| [ESI]          |    110 | 06 | 0E | 16 | 1E | 26 | 2E | 36 | 3E |
| [EDI]          |    111 | 07 | 0F | 17 | 1F | 27 | 2F | 37 | 3F |
|-----------------------------------------------------------------|
| смещ8[EAX]     |    000 | 40 | 48 | 50 | 58 | 60 | 68 | 70 | 78 |
| смещ8[ECX]     |    001 | 41 | 49 | 51 | 59 | 61 | 69 | 71 | 79 |
| смещ8[EDX]     |    010 | 42 | 4A | 52 | 5A | 62 | 6A | 72 | 7A |
| смещ8[EBX]     |    011 | 43 | 4B | 53 | 5B | 63 | 6B | 73 | 7B |
| смещ8[--][--]  | 01 100 | 44 | 4C | 54 | 5C | 64 | 6C | 74 | 7C |
| смещ8[ebp]     |    101 | 45 | 4D | 55 | 5D | 65 | 6D | 75 | 7D |
| смещ8[ESI]     |    110 | 46 | 4E | 56 | 5E | 66 | 6E | 76 | 7E |
| смещ8[EDI]     |    111 | 47 | 4F | 57 | 5F | 67 | 6F | 77 | 7F |
|-----------------------------------------------------------------|
| смещ32[EAX]    |    000 | 80 | 88 | 90 | 98 | A0 | A8 | B0 | B8 |
| смещ32[ECX]    |    001 | 81 | 89 | 91 | 99 | A1 | A9 | B1 | B9 |
| смещ32[EDX]    |    010 | 82 | 8A | 92 | 9A | A2 | AA | B2 | BA |
| смещ32[EBX]    |    011 | 83 | 8B | 93 | 9B | A3 | AB | B3 | BB |
| смещ32[--][--] | 10 100 | 84 | 8C | 94 | 9C | A4 | AC | B4 | BC |
| смещ32[EBP]    |    101 | 85 | 8D | 95 | 9D | A5 | AD | B5 | BD |
| смещ32[ESI]    |    110 | 86 | 8E | 96 | 9E | A6 | AE | B6 | BE |
| смещ32[EDI]    |    111 | 87 | 8F | 97 | 9F | A7 | AF | 77 | BF |
|-----------------------------------------------------------------|
| EAX/AX/AL      |    000 | C0 | C8 | D0 | D8 | E0 | E8 | F0 | F8 |
| ECX/CX/CL      |    001 | C1 | C9 | D1 | D9 | E1 | E9 | F1 | F9 |
| EDX/DX/DL      |    010 | C2 | CA | D2 | DA | E2 | EA | F2 | FA |
| EBX/BX/BL      |    011 | C3 | CB | D3 | DB | E3 | EB | F3 | FB |
| ESP/SP/AH      | 11 100 | C4 | CC | D4 | DC | E4 | EC | F4 | FC |
| EBP/BP/CH      |    101 | C5 | CD | D5 | DD | E5 | ED | F5 | FD |
| ESI/SI/DH      |    110 | C6 | CE | D6 | DE | E6 | EE | F6 | FE |
| EDI/DI/BH      |    111 | C7 | CF | D7 | DF | E7 | EF | F7 | FF |
-------------------------------------------------------------------

ПРИМЕЧАНИЯ:  [--][--]  означает,  что  за  байтом  ModR/M следует байт SIB.
смещ8  означает,  что  8-разрядное  смещение,  следующее  за байтом ModR/M,
должно быть  расширено по  знаку и  прибавлено к  индексу. смещ32 означает,
что  32-разрядное  смещение,  следующее  за  байтом  ModR/M,  должно   быть
прибавлено к индексу.


Таблица 26-4. Формы 32-битовой адресации для байта SIB

-------------------------------------------------------------------
|r32                      |EAX |ECX |EDX |EBX |ESP |EBP |ESI |EDI |
|База                     | 0  | 1  | 2  | 3  | 4  | 5  | 6  | 7  |
|База                     |000 |001 |010 |011 |100 |101 |110 |111 |
|-----------------------------------------------------------------|
|Масштабированный| Индекс |     Шестнадцатиричные значения        |
|    индекс      |   SS   |             ModR/M                    |
|-----------------------------------------------------------------|
| [EAX]          |    000 | 00 | 08 | 10 | 18 | 20 | 28 | 30 | 38 |
| [ECX]          |    001 | 01 | 09 | 11 | 19 | 21 | 29 | 31 | 39 |
| [EDX]          |    010 | 02 | 0A | 12 | 1A | 22 | 2A | 32 | 3A |
| [EBX]          |    011 | 03 | 0B | 13 | 1B | 23 | 2B | 33 | 3B |
| отсутствует    | 00 100 | 04 | 0C | 14 | 1C | 24 | 2C | 34 | 3C |
| [EBP]          |    101 | 05 | 0D | 15 | 1D | 25 | 2D | 35 | 3D |
| [ESI]          |    110 | 06 | 0E | 16 | 1E | 26 | 2E | 36 | 3E |
| [EDI]          |    111 | 07 | 0F | 17 | 1F | 27 | 2F | 37 | 3F |
|-----------------------------------------------------------------|

| [EAX*2]        |    000 | 40 | 48 | 50 | 58 | 60 | 68 | 70 | 78 |
| [ECX*2]        |    001 | 41 | 49 | 51 | 59 | 61 | 69 | 71 | 79 |
| [EDX*2]        |    010 | 42 | 4A | 52 | 5A | 62 | 6A | 72 | 7A |
| [EBX*2]        |    011 | 43 | 4B | 53 | 5B | 63 | 6B | 73 | 7B |
| отсутствует    | 01 100 | 44 | 4C | 54 | 5C | 64 | 6C | 74 | 7C |
| [EBP*2]        |    101 | 45 | 4D | 55 | 5D | 65 | 6D | 75 | 7D |
| [ESI*2]        |    110 | 46 | 4E | 56 | 5E | 66 | 6E | 76 | 7E |
| [EDI*2]        |    111 | 47 | 4F | 57 | 5F | 67 | 6F | 77 | 7F |
|-----------------------------------------------------------------|
| [EAX*4]        |    000 | 80 | 88 | 90 | 98 | A0 | A8 | B0 | B8 |
| [ECX*4]        |    001 | 81 | 89 | 91 | 99 | A1 | A9 | B1 | B9 |
| [EDX*4]        |    010 | 82 | 8A | 92 | 9A | A2 | AA | B2 | BA |
| [EBX*4]        |    011 | 83 | 8B | 93 | 9B | A3 | AB | B3 | BB |
| отсутствует    | 10 100 | 84 | 8C | 94 | 9C | A4 | AC | B4 | BC |
| [EBP*4]        |    101 | 85 | 8D | 95 | 9D | A5 | AD | B5 | BD |
| [ESI*4]        |    110 | 86 | 8E | 96 | 9E | A6 | AE | B6 | BE |
| [EDI*4]        |    111 | 87 | 8F | 97 | 9F | A7 | AF | 77 | BF |
|-----------------------------------------------------------------|
| [EAX*8]        |    000 | C0 | C8 | D0 | D8 | E0 | E8 | F0 | F8 |
| [ECX*8]        |    001 | C1 | C9 | D1 | D9 | E1 | E9 | F1 | F9 |
| [EDX*8]        |    010 | C2 | CA | D2 | DA | E2 | EA | F2 | FA |
| [EBX*8]        |    011 | C3 | CB | D3 | DB | E3 | EB | F3 | FB |
| отсутствует    | 11 100 | C4 | CC | D4 | DC | E4 | EC | F4 | FC |
| [EBP*8]        |    101 | C5 | CD | D5 | DD | E5 | ED | F5 | FD |
| [ESI*8]        |    110 | C6 | CE | D6 | DE | E6 | EE | F6 | FE |
| [EDI*8]        |    111 | C7 | CF | D7 | DF | E7 | EF | F7 | FF |
-------------------------------------------------------------------

ПРИМЕЧАНИЯ: [*]  означает смещ32  без базы,  если MOD  равно 00,  и [ESP] в
противном   случае.   Это   обеспечивает   следующие   режимы    адресации:
смещ32[индекс]    (MOD    =    00)    смещ8[EBP][индекс]    (MOD    =   01)
смещ32[EBP][индекс] (MOD = 10)


`д`к26.2.2  Как читать описание набора команд `*

Ниже приводится  пример формата,  используемого в  описании каждой  команды
процессора i486 в данной главе:

CMC - Дополнение флага переноса

-----------------------------------------------------------------
|Код       Команда  Число      Описание                         |
|операции           тактовых                                    |
|                   циклов                                      |
| F5       CMC         2       Дополнение флага переноса        |
-----------------------------------------------------------------

За  приведенной   таблицей  следуют   параграфы  "Операция",    "Описание",
"Изменяемые  флаги",  "Исключения  защищенного  режима", "Исключения режима
реальных  адресов"  и  иногда  "Примечания".  В  следующих разделах описаны
условные  обозначения  и  аббревиатуры,  используемые  в  этих   параграфах
описания команд.


`д`к26.2.2.1  Колонка кода операции `*

Колонка  "Код  операции"  приводит  полный  объектный код, генерируемый кля
каждой   формы   команды.   Где    это   возможно,   коды   приводятся    в
шестнадцатиричной байтовой записи,  в последовательности их  расположения в
памяти. Определения элементов, помимо шестнадцатиричных байтов, следующие:

/цифра  (цифра  от  0  до  7)  указывает  на  то,  что  байт ModR/M команды
использует  только  операнд  r/m  (регистр  или  память). Поле reg содержит
цифру, представляющую собой расширение кода операции команды.

/r: указывает на то, что  байт ModR/M команды содержит и  операнд регистра,
и операнд r/m.

cb,  cw,  cd,  cp:  1-байтовое  (cb),  2-байтовое (cw), 4-байтовое (cd) или
6-байтовое (cp)  значение, следующее  за кодом  операции, используемое  для
задания  смещения  кода  и  возможно,  нового  значения  регистра  кодового
сегмента.

ib,  iw,  id:  1-байтовый  (ib),   2-байтовый  (iw)  или  4-байтовый   (id)
непосредственный  операнд  команды,  следующий  за  кодом операции, байтами
ModR/M  или  SIB.  Код  операции  определяет,  является  ли  данный операнд
значением со знаком. Все слова и двойные слова представлены таким  образом,
что первым следует младший байт.

  +rb, +rw, +rd:  Код регистра, от 0 до 7, складываемый с шестнадцатиричным
байтом,  находящимся  слева  от  знака  плюс,  образуя  единый  байт   кода
операции. Коды:

rb rw rd AL = 0 AX = 0 EAX = 0 CL = 1 CX = 1 ECX = 1 DL = 2 DX = 2 EDX =  2
BL = 3 BX = 3 EBX = 3

rb rw rd AH = 4 SP = 4 ESP = 4 CH = 5 BP = 5 EBP = 5 DH = 6 SI = 6 ESI =  6
BH = 7 DI = 7 EDI = 7

 +i: Используется в командах с плавающей точкой, когда один из  операндов -
это ST(i) из стека регистров модуля операций с плавающей точкой  процессора
(FPU). Число i (которое  может быть в диапазоне  от 0 до 7)  складывается с
шестнадцатиричным байтом, находящимся слева  от знака плюс, образуя  единый
байт кода операции:


`д`к26.2.2.2  Колонка "Команда" `*

Колонка "Команда" дает  синтаксис оператора команды  в том виде,  в котором
этот оператор записывается  в программе на  ASM386. Ниже приводится  список
символических имен, используемых  для представления операндов  в операторах
команды:

rel8: относительный  адрес в  диапазоне 128  байтов от  128 байтов до конца
команды до 127 байтов после конца команды.

rel16, rel32:  относительный адрес  в пределах  того же  кодового сегмента,
что и  ассемблируемая команда.  rel16 применяется  с командами  с атрибутом
размера  операнда,  равным  16  битам;  rel32  применяется  с  командами  с
атрибутом размера операнда, равным 32 битам.

ptr16:16,ptr16:32:  дальний  указатель,  обычно  установленный  на  кодовый
сегмент, отличный от  сегмент текущей команды.  Запись 16: 16  указывает на
то,  что  значение  указателя  состоит  из  двух  частей. Значение слева от
двоеточия  это  16-битовый  селектор  или  значение,  предназначенное   для
регистра  кодового  сегмента.  Значение  справа  от двоеточия соответствует
смещению  в  пределах  сегмента  назначения.  ptr16:16  используется, когда
атрибут размера операнда  команды равен 16  битам; ptr16:32 используется  в
случае 32-битового атрибута.

r8: один из байтовых регистров: AL,CL,DL,BL,AH,CH,DH или BH.

r16: один из регистров размером в слово: AX,CX,DX,BX,SP,BP,SI или DI.

r32:   один   из   регистров   размером   в   двойное  слово:  EAX,ECX,EDX,
EBX,ESP,EBP,ESI или EDI.

imm8:  непосредственное  значение  байта.  imm8  это  число  со  знаком   в
диапазоне  от  -127  до  +127,  включительно.  Для  команд,  в которых imm8
комбинируется   с   операндом   размером   в   слово   или  двойное  слово,
непосредственное значение расширяется по  знаку, образуя слово или  двойное
слово.   Старший    байт   слова    заполняется   самым    старшим    битом
непосредственного значения.

imm16:  непосредственное  значение  размером  в  слово,  используемое   для
команд,  атрибут  размера  операнда  которых  равен  16  битам. Это число в
диапазоне от -32768 до +32767, включительно.

imm32:  непосредственное  значение  размером  в двойное слово, используемое
для команд, атрибут  размера операнда которых  равен 32 битам.  Это число в
диапазоне от +2147483647 до -2147483648, включительно.

r/m8: однобайтовый операнд, представляющий собой либо содержимое  байтового
регистра (AL, BL, CL, DL, AH, BH, CH, DH), либо содержимое байта в памяти.

r/m16: операнд регистра-слова или операнд памяти, используемый в  командах,
атрибут размера  операнда которых  равен 16  битам. Регистры-слова  это AX,
BX,  CX,  DX,  SP,  BP,  SI,  DI.  Содержимое  памяти  находится по адресу,
получаемому при вычислении исполнительного адреса.

r/m32: операнд регистра-двойного слова  или операнд памяти, используемый  в
командах, атрибут размера операнда  которых равен 32 битам.  Регистры-слова
это EAX, EBX, ECX, EDX, ESP, EBP, ESI, EDI. Содержимое памяти находится  по
адресу, получаемому при вычислении исполнительного адреса.

m8:  байт  памяти,   адресуемый  DS:SI  или   ES:DI  (используется   только
строковыми командами).

m16:  слово  памяти,  адресуемое  DS:SI  или  ES:DI  (используется   только
строковыми командами).

m32: двойное слово памяти, адресуемое DS:SI или ES:DI (используется  только
строковыми командами).

m16:16, m16:32: операнд памяти, содержащий дальний указатель,  составленный
из двух чисел.  Число слева от  двоеточия соответствует селектору  сегмента
указателя. Число справа от двоеточия соответствует его смещению.

m16&32, m16&16, m32&32: операнд памяти, состоящий из пар элементов  данных,
размеры которых обозначены  слева и справа  от символа амперсанда  (&). Все
режимы адресации  памяти разрешены,  операнды m16&16  и m32&32 используются
командой  BOUND  для  получения  операнда,  содержащего  верхнюю  и  нижнюю
границы для индексов  массивов. m16&32 используется  командами LIDT и  LGDT
для получения слова,  которым загружается поле  границы, и двойного  слова,
которым   загружается   поле   базы   соответствующих   регистров    таблиц
дескрипторов - глобальной и прерываний.

moffs8, moffs16, moffs32: (смещение  в памяти) - простая  переменная памяти
типа BYTE, WORD или DWORD, используемая некоторыми вариантами команды  MOV.
Фактический адрес задается простым смещением относительно базы сегмента.  В
команде байт ModR/ M не используется. Число, указанное в moffs,  обозначает
размер, определяемый атрибут размера адреса команды.

Sreg:  сегментный  регистр.  Назначения  битов  сегментных регистров: ES=0,
CS=1, SS=2, DS=3, FS=4 и GS=5.

m32real,   m64real,   m80real:   (соответственно)   -   операнды  памяти  -
действительные числа  с плавающей  точкой одинарной,  двойной и расширенной
точности.

m16int,   m32int,   m64int:   (соответственно)   -   операнды   памяти    -
целочисленного типа word, short и long с плавающей точкой.

mNbyte:  N-байтовый  операнд  памяти  с  плавающей  точкой.   ST или ST(0):
старший элемент стека регистров FPU.   ST(i): i-й элемент от вершины  стека
регистров FPU (i =0...7).


`д`к26.2.2.3  Колонка "Число тактовых циклов"`*

Колонка "Число тактовых циклов" задает примерное число тактовых циклов,  за
которое  выполняется  команда.  Вычисления  тактовых  циклов   производятся
исходя из следующих предположений:

- При доступе  к данным или  командам происходит кэш-пападание  (нахождение
искомого в кеше).
- Цель команды перехода находится в кеше.
- Никакие циклы  аннулирования не конкурируют  с командой за  использование
кеша.
- Трансляция адреса страницы находит совпадение в TLB.
- Операнды памяти выравнены.
- Вычисления исполнительного  адреса используют один  базовый регистр и  ни
одного  индексного  регистра,  а  базовый  регистр  не  является  регистром
назначения предыдущей команды.
- Смещение и непосредственное значение не используются одновременно.
- Во время выполнения не происходит исключений.
- Задержки при записи в буфер отсутствуют.

Обсуждение  потерь  быстродействия   в  случаях,  когда   эти  условия   не
выполняются, находится в Приложении E.
В   спецификациях   подсчета   тактовых   циклов   используются   следующие
символические имена:

- n представляет число повторений.
- m представляет число  компонентов следующей выполняемой команды,  где все
смещение  целиком  (если  оно  имеется)  считается  за  один компонент, все
непосредственные  данные  в  команде  (если  они имеются) считаются за один
компонент, и  каждый другой  байт команды  и префикс(ы)  также считаются за
один компонент.
-  pm=  представляет  собой  счетчик  тактовых  циклов,  работающий,  когда
команда  выполняется  в  защищенном  режиме.  pm=  не задается, когда число
циклов одинаково для защищенного режима и режима реальных адресов.

Когда во  время выполнения  команды генерируется  исключение, а  обработчик
этого  исключения  находится  в  другой  задаче,  время  выполнения команды
увеличивается на число тактовых циклов, требуемых для переключения  задачи.
Этот параметр зависит от нескольких факторов:

- Типа TSS, используемого для представления новой задачи (TSS  центрального
процессора i486 или TSS 80286.)
- От того, находится ли текущая задача в режиме V86.
- От того, находится ли новая задача в режиме V86.
- От того, произошло ли кеша-попадание при попытке доступа.
- От того, используется ли шлюз задачи, или же шлюз прерывания/ловушки.

В  Таблице  26-5  приводятся  значения  времени  на переключение задачи для
исключений,  предполагая  попадание  в  кеш  и использование шлюзов задачи.
Полное описание см. в Приложении Е.

`д`к26.2.2.4  Колонка "Описание"  `*

Колонка  "Описание",  расположенная  после  колонки "Число тактовых циклов"
содержит краткое описание разных форм команды. В разделах "Работа  команды"
и "Описание" содержится более подробная информация о работе команды.


`д`к26.2.2.5 Работа команды  `*

В  разделе  "Работа  команды"  находится  алгоритмическое описание команды,
использующее  запись,  аналогичную  языкам   Алгол  и  Паскаль.   Алгоритмы
составлены из следующих элементов:

Комментарии заключаются в пары символов "(*" и "*)".

Составные  операторы  заключаются  между  ключевыми  словами оператора "if"
(IF, THEN,  ELSE, FI)  или оператора  "do" (DO,  OD), либо оператора "case"
(CASE...OF,ESAC).

Имя регистра подразумевает содержимое  регистра. Имя регистра в  квадратных
скобках подразумевает содержимое  позиции памяти, адрес  которой содержится
в  регистре.   Например,  ES:[DI]   означает  содержимое   адреса   памяти,
задаваемого  относительно   регистра  ES   содержимым  регистра   DI.  [SI]
указывает на  содержимое адреса,  содержащегося в  регистре SI относительно
сегмента  для  SI  по  умолчанию  (DS)  или  относительно переопределенного
сегмента.


Таблица 26-5. Время выполнения переключения задачи

-----------------------------------------------------------------
                    |          Новая задача
 Старая задача      |--------------------------------------------
                    |На TSS i486 | на TSS 80286 | на TSS VM
-----------------------------------------------------------------
VM/i486/80286 TSS   |    199     |     180      |    177
-----------------------------------------------------------------
VM = виртуальный режим
Квадратные  скобки  используются  также  для  операндов  памяти,  где   они
означают,  что  содержимое  адреса  памяти  задается смещением относительно
сегмента.  Например,  [SRC]  указывает,  что  содержимое исходного операнда
является смещением относительно сегмента.

A <- B означает, что значение B присваивается А.
Символы =, <>, >= и  <= это операции отношения, используемые  при сравнении
двух  величин,  означающие  равенство,  неравенство,  больше  или равно или
меньше или  равно, соответственно.  Выражение отношения,  например, A  = B,
имеет  результат  TRUE  (истина),  если  значение  А  равно  значению  В; в
противном случае оно равно FALSE (ложь).

В алгоритмических описаниях используются следующие идентификаторы:
- OperandSize  представляет собой  атрибут размера  операнд команды, равный
либо  16,  либо  32  битам.  AddressSize представляет собой атрибут размера
адреса, также равный 16 или 32 битам. Например,

     IF instruction = CMPSW
     THEN OperandSize <- 16;
     ELSE
        IF instruction = CMPSD
        THEN OperandSize <- 32;
        FI;
     FI;

означает,  что  атрибут  размера  операнда  зависит  от  формы используемой
команды CMPS. См.  описание атрибутов размера  адреса и размера  операнда в
начале   данной   главы,   где   приводятся   общие  указания  относительно
определения данных атрибутов.

-  StackAddrSize  представляет  собой  атрибут  размера  адреса  для стека,
связанный  с  данной  командой,  и  имеет  значение  16  или  32  бита, как
объяснялось выше в данной главе.
- SRC представляет собой исходный  операнд. При наличии двух операндов  SRC
это операнд справа.
- DEST представляет  собой операнд назначения.  При наличии двух  операндов
DEST это операнд слева.
-  LeftSRC,  RightSRC  позволяют  различить  два  операнда,  оба из которых
являются исходными операндами.
-  eSP  представляет  собой  либо   регистр  SP,  либо  регистром  ESP,   в
зависимости от установки бита B для текущего сегмента стека.

Следующие функции используются в алгоритмических описаниях:

- Truncate to 16 bits  (значение) уменьшает размер значения таким  образом,
чтобы  оно  помещалось  в  16  битах,  при необходимости отбрасывая старший
байт.
-  Addr(операнд)  возвращает   исполнительный  адрес  операнда   (результат
вычисления исполнительного адреса перед сложением с базой сегмента).
-   ZeroExtend(значение)   возвращает   значение,   расширенное   нулем   в
соответствии  с   атрибутом  размера   операнда  команды.   Например,  если
OperandSize  =  32,  ZeroExtend   для  байтового  значения,  равного   -10,
преобразует  байт  из  значения  F6H  в  двойное  слово с шестнадцатиричным
значением  000000F6H.  Если  значение,  переданное  ZeroExtend,  и  атрибут
размера операнда  имеют одинаковое  значение, то  ZeroExtend возвращает это
значение неизмененным.
-   SignExtend(значение)   возвращает   значение,   расширенное   знаком  в
соответствии  с   атрибутом  размера   операнда  команды.   Например,  если
OperandSize  =  32,  SignExtend   для  байтового  значения,  равного   -10,
преобразует  байт  из  значения  F6H  в  двойное  слово с шестнадцатиричным
значением  FFFFFFF6H.  Если  значение,  переданное  SignExtend,  и  атрибут
размера операнда  имеют одинаковое  значение, то  SignExtend возвращает это
значение неизмененным.
-  Push(значение)  помещает  значение  в  стек.  Число байтов, помещенных в
стек,  определяется  атрибутом  размера  операнда  команды.  Действие  Push
следующее:


     IF StackAddrSize = 16
     THEN
         IF OperandSize = 16
         THEN
             SP <- SP - 2;
             SS:[SP] <- значение (* присвоение 2 байтов, начиная
                                    с байта, адресуемого в SP *)
         ELSE (* OperandSize = 32 *)
             SP <- SP - 4;
             SS:[SP] <- значение (* присвоение 4 байтов, начиная
                                    с байта, адресуемого в SP *)
         FI;
     ELSE (* StackAddrSize = 32 *)
         IF OperandSize = 16
         THEN
             ESP <- ESP - 2;
             SS:[ESP] <- значение (* присвоение 2 байтов, начиная
                                    с байта, адресуемого в ESP *)
         ELSE (* OperandSize = 32 *)
             ESP <- ESP - 4;
             SS:[ESP] <- значение (* присвоение 4 байтов, начиная
                                    с байта, адресуемого в ESP *)
         FI;
     FI;

-  Pop(значение)  удаляет  значение  из  вершины  стека  и  возвращает его.
Оператор EAX  <- Pop();  присваивает EAX  32-битовое значение,  которое Pop
снимает с вершины стека. Pop  возвращает либо слово, либо двойное  слово, в
зависимости от атрибута размера операнда. Действие Pop следующее:

     IF StackAddrSize = 16
     THEN
         IF OperandSize = 16
         THEN
             значение возврата <- SS:[SP]; (* 2-байтовое знач *)
             SP <- SP + 2;
         ELSE (* OperandSize = 32 *)
             значение возврата <- SS:[SP]; (* 4-байтовое знач *)
             SP <- SP + 4;
         FI;
     ELSE (* StackAddrSize = 32 *)
         IF OperandSize = 16
         THEN
             значение возврата <- SS:[ESP]; (* 2-байтовое знач *)
             ESP <- ESP + 2;
         ELSE (* OperandSize = 32 *)
             значение возврата <- SS:[ESP]; (* 4-байтовое знач *)
             ESP <- ESP + 4;
         FI;
     FI;
     RETURN(значение возврата); (* возврат слова или двойного
                                   слова *)

Pop ST используется для страниц  с командами операций с плавающей  точкой и
означает извлечение из стека регистров FPU.
Bit[BitBase,  BitOffset]  (Бит  [БазаБита,  СмещениеБита]) возвращает адрес
бита  в  строке  битов,  представляющей  собой битовую последовательность в
памяти или регистре.  Биты нумеруются в  регистре или памяти  от младшего к
старшему.  В  памяти  два  байта  слова  располагаются  таким  образом, что
младший байт содержит младшие адреса битов.
Если базовым  операндом является  регистр, то  смещение может  находиться в
диапазоне  0...31.  Это  смещение   адресует  бит  в  указанном   регистре.
Например, 'BIT[EAX, 21]' показана на Рисунке 26-4.

-    I-O-Permission(I-O-Address,     width)    (Разрешение     ввода-вывода
(адрес-ввода-вывода,ширина))  возвращает   значения  TRUE   или  FALSE    в
зависимости от битового массива разрешения ввода/вывода и прочих  факторов.
Эта функция определяется следующим образом:

     IF тип TSS равен 80286 THEN RETURN FALSE; FI;
     Ptr <- [TSS +66]; (* выборка указателя битового массива *)
     BitStringAddr <- SHR(I-O-Address, 3) + Ptr;
     MaskShift <- I-O-Address AND 7;
     CASE width OF:
            BYTE:nBitMask <- 1;
            WORD:nBitMask <- 3;
            DWORD:nBitMask <- 15;

     31            21                               0
     -------------------------------------------------
     |             | |                               |
     -------------------------------------------------
                    ^                                ^
                    |_________BITOFFSET=21___________|

Рисунок 26-3. BitOffset (СмещениеБита) для BIT[EAX,21]

Индексация бита (положительное смещение)

     7 6 5 4 3 2 1 0 7 6 5 4 3 2 1 0 7 6 5 4 3 2 1 0
    -------------------------------------------------
    |   | |         |               |               |
    -------------------------------------------------
    | BITBASE + 1   |   BITBASE     |  BITBASE - 1  |
       ^                            |
       |_____OFFSET = -13___________|

Индексация бита (отрицательное смещение)

     7 6 5 4 3 2 1 0 7 6 5 4 3 2 1 0 7 6 5 4 3 2 1 0
    -------------------------------------------------
    |               |               |   | |         |
    -------------------------------------------------
    | BITBASE       |   BITBASE-1   |  BITBASE - 2  |
                    |               |     ^
                    |_____OFFSET = -11____|

Рисунок 26-4. Индексация битового массива

     ESAC;
     mask <- SHL (nBitMask, MaskShift);
     CheckString <- [BitStringAddr] AND mask;
     IF CheckString = 0
     THEN RETURN(TRUE);
     ELSE RETURN(FALSE);
     FI;

- Switch-Tasks - это функция переключения задачи, описанная в Главе 7.


`д`к26.2.2.6  Описание    `*

Раздел "Описание" содержит дальнейшие пояснения к работе команды.


`д`к26.2.2.7  Изменяемые флаги   `*

В разделе "изменяемые флаги" перечисляются флаги, изменяемые командой,  как
описано ниже:

- Если флаг всегда очищается или всегда устанавливаются командой, то  после
имени флага приводится это значение (0 или 1). Арифметические и  логические
команды обычно присваивают  значения флагам состояния  стандартным образом,
описанным в  Приложении С.  Отличные от  этих соглашений  присвоения флагам
описываются в разделе "Работа команды".
-  Значения  флагов,  описанные  как  "неопределенные", могут быть изменены
командой неопределенным образом.

Не описанные в этом разделе флаги командой не изменяются.

В  описаниях  команд  имеется  раздел  "Изменяемые  флаги  FPU",  в котором
сказано,  каким  образом  каждая  команда  может  повлиять  на  четыре бита
условного кода слова состояния FPU. В этих описаниях имеются также  разделы
"Числовые  исключения",  в  которых  перечислены  флаги  исключений   слова
состояния FPU, устанавливаемые командой.


`д`к26.2.2.8  Исключения защищенного режима`*

В данном  разделе описаны  исключения, которые  генерируются при выполнении
команды  в  защищенном  режиме.  Имена  этих исключений образуются из знака
фунта  (#),  за  которым  следуют  две  буквы  и  опциональный код ошибки в
круглых скобках.  Например, #GP  (0) обозначает  исключение общей  защиты с
кодом  ошибки   0.  В   Таблице  26-6   приводятся  соответствия    каждого
двухбуквенного имени номеру прерывания.
В Главе 9 описаны исключения и  состояние процессора i486 после входа в  то
или иное исключение.
Прикладные программисты  должны обращаться  к документации  по операционной
системе для  определения действий,  предпринимаемых, когда  генерируется то
или иное исключение.


`д`к26.2.2.9  Исключения режима реальных адресов `*

Поскольку  в  режиме  реальных  адресов  процессор  i486  выполняет меньшее
количество  проверок  на   ошибку,  данный  режим   имеет  меньше   условий
исключений. Более подробную информацию о таких исключениях см. в Главе 22.


`д`к26.2.2.10  Исключения виртуального режима 8086`*

Задачи  виртуального  режима  8086  обеспечивают  возможность моделирования
виртуальных  машин  8086.  Исключения  виртуального  режима 8086 аналогичны
исключениям  процессора  8086,  однако  с некоторыми отличиями. Подробности
см. в Главе 23.


Таблица 26-6. Исключения

-----------------------------------------------------------------
Мнемоника   Прерывание     Описание
-----------------------------------------------------------------
   #UD          6          Неверный код операции
   #NM          7          Устройство недоступно
   #DF          8          Двойной сбой
   #TS         10          Неверный TSS
   #NP         11          Сегмент или шлюз не присутствуют
   #SS         12          Сбой в стеке
   #GP         13          Сбой общей защиты
   #PF         14          Страничный сбой
   #MF         16          Ошибка операции с плавающей точкой
   #AC         17          Проверка выравнивания
-----------------------------------------------------------------


`м`д`05AAA`* - Преобразование к ASCII после сложения

-----------------------------------------------------------------
|Код       Команда  Число      Описание                         |
|операции           тактовых                                    |
|                   циклов                                      |
| 37       AAA         3       Преобразование к ASCII после     |
|                              сложения                         |
-----------------------------------------------------------------

Работа команды
IF ((AL AND 0FH) > 9) OR (AF = 1)  THEN AL <- (AL + 6) AND 0FH; AH <-  AH +
1; AF <- 1; CF <- 1; ELSE CF <- 0; AF <- 0; FI;

Описание
Команда AAA должна  выполняться только после  команды ADD, помещающей  байт
результата в  регистр AL.  Младшие полубайты  операндов команды  ADD должны
быть в диапазоне  от 0 до  9 (двоично -десятичные  цифры). В данном  случае
команда  AAA  преобразует  регистр  AL  таким  образом,  чтобы  он содержал
правильный  результат  десятичной  цифры.  Если  при  сложении был выполнен
десятичный  перенос,  то  регистр  AH  инкрементируется,  а  флаги  CF и AF
устанавливаются.  Если  десятичного  переноса  не  было,  то  флаги CF и AF
очищаются, а регистр AH остается без изменений. В любом случае, регистр  AL
остается со старшим полубайтом, установленным равным 0. Для  преобразования
регистра  AL  в  результат  ASCII  поместите  после  команды AAA команду OR
AL,30H.

Изменяемые флаги
В  случае  десятичного  переноса  устанавливаются  флаги  AF  и  CF,  а при
отсутствии десятичного переноса эти флаги очищаются; флаги OF, SF, ZF и  PF
неопределены.

Исключения защищенного режима
Отсутствуют

Исключения режима реальных адресов
Отсутствуют

Исключения виртуального режима 8086
Отсутствуют


`м`д`05AAD`* - Преобразование AX к ASCII перед делением
-----------------------------------------------------------------
|Код       Команда  Число      Описание                         |
|операции           тактовых                                    |
|                   циклов                                      |
|D5 0A     AAD         14      Преобразование AX к ASCII перед  |
|                              делением                         |
-----------------------------------------------------------------
 Работа команды
AL <- AH * 10 + AL; AH <- 0;
Описание
Команда  AAD  используется  для  подготовки  двух  двоично-десятичных  цифр
(младшая  цифра  в  регистре,  старшая  цифра  в  регистре  AH)  к операции
деления, которая даст  неупакованный результат. Это  выполняется установкой
регистра AL в  AL + (10  * AH), с  последующей очисткой регистра  AH. После
этого  регистр  AX  равен  двоичному  эквиваленту  исходного неупакованному
двухзначному числу.

Изменяемые флаги
Флаги SF, ZF и PF  устанавливаются в соответствии с результатом;  флаги OF,
AF и CF неопределены.

Исключения защищенного режима
Отсутствуют

Исключения режима реальных адресов
Отсутствуют

Исключения виртуального режима 8086
Отсутствуют


`м`д`05AAM`* - Преобразование AX к ASCII после умножения
-----------------------------------------------------------------
|Код       Команда  Число      Описание                         |
|операции           тактовых                                    |
|                   циклов                                      |
|D4 0A     AAM        15       Преобразование AX к ASCII после  |
|                              умножения                        |
-----------------------------------------------------------------

Работа команды
AH <- AL / 10; AL <- AL MOD 10;
Описание
Команда AAM должна  выполняться только после  команды MUL, выполняемой  для
двух  неупакованных  двоично-десятичных  цифр  и  помещающей  результат   в
регистр  AX.  Поскольку  результат  меньше  100,  он полностью помещается в
регистре AL.  Команда AAM  распаковывает результат  в AL,  деля AL  на 10 и
помещая частное (старшая цифра) в  регистр AH, а остаток (младшая  цифра) в
регистр AL.

Изменяемые флаги
Флаги SF, ZF и PF  устанавливаются в соответствии с результатом;  флаги OF,
AF и CF неопределены.

Исключения защищенного режима
Отсутствуют

Исключения режима реальных адресов
Отсутствуют

Исключения виртуального режима 8086
Отсутствуют

`м`д`05AAS`* - Преобразование AL к ASCII после вычитания

-----------------------------------------------------------------
|Код       Команда  Число      Описание                         |
|операции           тактовых                                    |
|                   циклов                                      |
| 3F       AAS         3       Преобразование AL к ASCII после  |
|                              вычитания                        |
-----------------------------------------------------------------

Работа команды

IF (AL AND 0FH) > 9 OR AF = 1
THEN
 AL <- AL - 6;
 AL <- AL AND 0FH;
 AH <- AH - 1;
 AF <- 1;
 CF <- 1;
ELSE
 CF <- 0;
 AF <- 0;
FI;

Описание
Команда AAS должна  выполняться только после  команды SUB, помещающей  байт
результата в  регистр AL.  Младшие полубайты  операндов команды  SUB должны
быть в диапазоне  от 0 до  9 (двоично -десятичные  цифры). В данном  случае
команда  AAS  преобразует  регистр  AL  таким  образом,  чтобы  он содержал
правильный  результат  десятичной  цифры.  Если  при вычитании был выполнен
десятичный  перенос,  то  регистр  AH  декрементируется,  а  флаги  CF и AF
устанавливаются.  Если  десятичного  переноса  не  было,  то  флаги CF и AF
очищаются, а регистр AH остается без изменений. В любом случае, регистр  AL
остается со старшим полубайтом, установленным равным 0. Для  преобразования
регистра  AL  в  результат  ASCII  поместите  после  команды AAS команду OR
AL,30H.

Изменяемые флаги
В  случае  десятичного  переноса  устанавливаются  флаги  AF  и  CF,  а при
отсутствии десятичного переноса эти флаги очищаются; флаги OF, SF, ZF и  PF
неопределены.

Исключения защищенного режима
Отсутствуют

Исключения режима реальных адресов
Отсутствуют

Исключения виртуального режима 8086
Отсутствуют


`м`д`05ADC`* - Сложение с флагом переноса

----------------------------------------------------------------
|Код       Команда     Число      Описание                     |
|операции              тактовых                                |
|                      циклов                                  |
|                                                              |
|14 ib    ADC AL,imm8     1   Сложение с флагом переноса непос-|
|                             редственного байта и AL          |
|15 iw    ADC AX,imm16    1   Сложение с флагом переноса непос-|
|                             редственного слова и AX          |
|15 id    ADC EAX,imm32   1   Сложение с флагом переноса непос-|
|                             редственного двойного слова и EAX|
|80 /2 ib ADC r/m8,imm8   1/3 Сложение с флагом переноса непос-|
|                             редственного байта и байта в r/m |
|81 /2 iw ADC r/m16,imm16 1/3 Сложение с флагом переноса непос-|
|                             редственного слова и слова в r/m |
|81 /2 id ADC r/m32,imm32 1/3 Сложение с флагом переноса непос-|
|                             редственного двойного слова и    |
|                             двойного слова в r/m             |
|83 /2 ib ADC r/m16,imm8  1/3 Сложение с флагом переноса непос-|
|                             редственного расширенного знаком |
|                             байта и слова в r/m              |
|83 /2 ib ADC r/m32,imm8  1/3 Сложение с флагом переноса непос-|
|                             редственного расширенного знаком |
|                             слова и двойного слова в r/m     |
|10 /r    ADC r/m8,r8     1/3 Сложение с флагом переноса       |
|                             байтового регистра и байта в r/m |
|11 /r    ADC r/m16,r16   1/3 Сложение с флагом переноса       |
|                             регистра-слова и слова в r/m     |

|11 /r    ADC r/m32,r32   1/3 Сложение с флагом переноса       |
|                             регистра-двойного слова и        |
|                             двойного слова в r/m             |
|12 /r    ADC r8,r/m8     1/2 Сложение с флагом переноса байта |
|                             в r/m и байтового регистра       |
|13 /r    ADC r16,r/m16   1/2 Сложение с флагом переноса слова |
|                             в r/m и регистра-слова           |
|13 /r    ADC r32,r/m32   1/2 Сложение с флагом переноса       |
|                             двойного слова в r/m и регистра- |
|                             двойного слова                   |
----------------------------------------------------------------

Работа команды

DEST <- DEST + SRC + CF
 Описание
Команда ADC выполняет целочисленное сложение двух операндов, DEST и SRC,  и
флага переноса,  CF. Результат  сложения помещается  в первый  из операндов
(DEST),  и  выполняется  соответствующая  установка  флагов.  Команда   ADC
обыкновенно  выполняется  как  часть  работающей  с несколькими байтами или
несколькими   словами   операции   сложения.   Когда   происходит  сложение
непосредственного байтового значения  и операнда-слова или  двойного слова,
непосредственное   значение   сначала   расширяется   знаком   до   размера
соответствующего операнда, слова или двойного слова.

Изменяемые флаги
Флаги  OF,  SF,  ZF,  AF,  CF   и  PF  устанавливаются  в  соответствии   с
результатом.

Исключения защищенного режима
#GP(0), если результат должен помещаться в сегмент, для которого  запрещена
запись;  #GP(0)  в  случае  недопустимого  исполнительного  адреса операнда
памяти в сегментах  CS, DS, ES,  FS или GS;  #SS(0) в случае  недопустимого
адреса в  сегменте SS;  #PF(код сбоя)  в случае  страничного сбоя;  #AC для
невыравненной  ссылки  к  памяти  при  текущем  уровне привилегированности,
равном 3.

Исключения режима реальных адресов
Прерывание  13,  если  какая-либо  часть  операнда  лежит  вне пространства
исполнительных адресов от 0 до 0FFFFH.

Исключения виртуального режима 8086
Те же исключения,  что и для  режима реальных адресов:  #PF (код сбоя)  для
страничных сбоев; #AC для невыравненной ссылки к памяти при текущем  уровне
привилегированности, равном 3.


`м`д`05ADD`* - Сложение
----------------------------------------------------------------
|Код       Команда     Число      Описание                     |
|операции              тактовых                                |
|                      циклов                                  |
|                                                              |
|04 ib    ADD AL,imm8     1   Сложение непосредст-             |
|                             венного байта и AL               |
|05 iw    ADD AX,imm16    1   Сложение непосредст-             |
|                             венного слова и AX               |
|05 id    ADD EAX,imm32   1   Сложение непосредст-             |
|                             венного двойного слова и EAX     |
|80 /0 ib ADD r/m8,imm8   1/3 Сложение непосредст-             |
|                             венного байта и байта в r/m      |
|81 /0 iw ADD r/m16,imm16 1/3 Сложение непосредст-             |
|                             венного слова и слова в r/m      |
|81 /0 id ADD r/m32,imm32 1/3 Сложение непосредст-             |
|                             венного двойного слова и двойного|
|                             слова в r/m                      |
|83 /0 ib ADD r/m16,imm8  1/3 Сложение непосредст-             |
|                             венного расширенного знаком байта|
|                             и слова в r/m                    |
|83 /0 ib ADD r/m32,imm8  1/3 Сложение непосредст-             |
|                             венного расширенного знаком слова|
|                             и двойного слова в r/m           |
|00 /r    ADD r/m8,r8     1/3 Сложение байтового               |
|                             регистра и байта в r/m           |
|01 /r    ADD r/m16,r16   1/3 Сложение регистра-               |
|                             слова и слова в r/m              |
|01 /r    ADD r/m32,r32   1/3 Сложение регистра-               |
|                             двойного слова и двойного слова  |
|                             в r/m                            |
|02 /r    ADD r8,r/m8     1/2 Сложение байта в r/m             |
|                             и байтового регистра             |
|03 /r    ADD r16,r/m16   1/2 Сложение слова в r/m             |
|                             и регистра-слова                 |

|03 /r    ADD r32,r/m32   1/2 Сложение двойного                |
|                             слова в r/m и регистра-двойного  |
|                             слова                            |
----------------------------------------------------------------

Работа команды

DEST <- DEST + SRC

Описание
Команда ADC выполняет  целочисленное сложение двух  операндов, DEST и  SRC.
Результат сложения помещается в  первый из операндов (DEST),  и выполняется
соответствующая установка флагов.
Когда   происходит   сложение   непосредственного   байтового   значения  и
операнда-слова  или  двойного  слова,  непосредственное  значение   сначала
расширяется  знаком  до  размера   соответствующего  операнда,  слова   или
двойного слова.

Изменяемые флаги
Флаги  OF,  SF,  ZF,  AF,  CF   и  PF  устанавливаются  в  соответствии   с
результатом.

Исключения защищенного режима
#GP(0), если результат должен помещаться в сегмент, для которого  запрещена
запись;  #GP(0)  в  случае  недопустимого  исполнительного  адреса операнда
памяти в сегментах  CS, DS, ES,  FS или GS;  #SS(0) в случае  недопустимого
адреса в  сегменте SS;  #PF(код сбоя)  в случае  страничного сбоя;  #AC для
невыравненной  ссылки  к  памяти  при  текущем  уровне привилегированности,
равном 3.

Исключения режима реальных адресов
Прерывание  13,  если  какая-либо  часть  операнда  лежит  вне пространства
исполнительных адресов от 0 до 0FFFFH.

Исключения виртуального режима 8086
Те же исключения,  что и для  режима реальных адресов:  #PF (код сбоя)  для
страничных сбоев; #AC для невыравненной ссылки к памяти при текущем  уровне
привилегированности, равном 3.


`м`д`05AND`* - Логическое И
----------------------------------------------------------------
|Код       Команда     Число      Описание                     |
|операции              тактовых                                |
|                      циклов                                  |
|                                                              |
|24 ib    AND AL,imm8     1   Операция логического И для непос-|
|                             редственного байта и AL          |
|25 iw    AND AX,imm16    1   Операция логического И для непос-|
|                             редственного слова и AX          |
|25 id    AND EAX,imm32   1   Операция логического И для непос-|
|                             редственного двойного слова и EAX|
|80 /4 ib AND r/m8,imm8   1/3 Операция логического И для непос-|
|                             редственного байта и байта в r/m |
|81 /4 iw AND r/m16,imm16 1/3 Операция логического И для непос-|
|                             редственного слова и слова в r/m |
|81 /4 id AND r/m32,imm32 1/3 Операция логического И для непос-|
|                             редственного двойного слова и    |
|                             двойного слова в r/m             |
|83 /4 ib AND r/m16,imm8  1/3 Операция логического И для непос-|
|                             редственного расширенного знаком |
|                             байта и слова в r/m              |
|83 /4 ib AND r/m32,imm8  1/3 Операция логического И для непос-|
|                             редственного расширенного знаком |
|                             слова и двойного слова в r/m     |
|20 /r    AND r/m8,r8     1/3 Операция логического И для       |
|                             байтового регистра и байта в r/m |
|21 /r    AND r/m16,r16   1/3 Операция логического И для       |
|                             регистра-слова и слова в r/m     |
|21 /r    AND r/m32,r32   1/3 Операция логического И для       |
|                             регистра-двойного слова и        |
|                             двойного слова в r/m             |
|22 /r    AND r8,r/m8     1/2 Операция логического И для байта |
|                             в r/m и байтового регистра       |
|23 /r    AND r16,r/m16   1/2 Операция логического И для слова |
|                             в r/m и регистра-слова           |
|23 /r    AND r32,r/m32   1/2 Операция логического И для       |
|                             двойного слова в r/m и регистра- |
|                             двойного слова                   |
----------------------------------------------------------------

Работа команды

DEST <- DEST AND SRC;
CF <- 0;
OF <- 0;

Описание
Каждый  бит   результата  выполнения   команды  AND   равен  1,   если  оба
сответствующих бита операндов  равны 1; в  противном случае бит  результата
равен 0.

Изменяемые флаги
Флаги CF и OF очищаются ; флаги PF, SF и ZF устанавливаются в  соответствии
с результатом.

Исключения защищенного режима
#GP(0), если результат должен помещаться в сегмент, для которого  запрещена
запись;  #GP(0)  в  случае  недопустимого  исполнительного  адреса операнда
памяти в сегментах  CS, DS, ES,  FS или GS;  #SS(0) в случае  недопустимого
адреса в  сегменте SS;  #PF(код сбоя)  в случае  страничного сбоя;  #AC для
невыравненной  ссылки  к  памяти  при  текущем  уровне привилегированности,
равном 3.

Исключения режима реальных адресов
Прерывание  13,  если  какая-либо  часть  операнда  лежит  вне пространства
исполнительных адресов от 0 до 0FFFFH.

Исключения виртуального режима 8086
Те же исключения,  что и для  режима реальных адресов:  #PF (код сбоя)  для
страничных сбоев; #AC для невыравненной ссылки к памяти при текущем  уровне
привилегированности, равном 3.


`м`д`05ARPL`* - Преобразование поля RPL селектора

----------------------------------------------------------------
|Код       Команда     Число      Описание                     |
|операции              тактовых                                |
|                      циклов                                  |
|                                                              |
|63 /r    ARPL r/m16,r16 9/9  Преобразование RPL r/m16 к не    |
|                             менее чем RPL r16                |
----------------------------------------------------------------

Работа команды

IF RPL биты(0,1) в DEST < RPL биты(0,1) в SRC
THEN
  ZF <- 1;
  RPL биты(0,1) в DEST <- RPL биты(0,1) в SRC;
ELSE
  ZF <- 0;
FI;

 Описание
Команда  ARPL  имеет  два  операнда.  Первый  операнд является 16-разрядной
переменной  памяти  или  регистром-словом,  содержащим  значение селектора.
Второй операнд - это  регистр-слово. Если поле RPL  ("запрашиваемый уровень
привилегированности" - младшие два  бита) первого операнда меньше  поля RPL
второго операнда, то флаг ZF  устанавливается, а поле RPL первого  операнда
увеличивается до  соответствующего значения  второго операнда.  В противном
случае флпг ZF очищается, и первый операнд не изменяется.
Команда  ARPL  используется  в  операционных  системах,  а  не   прикладных
программах.  Она  гарантирует,  что  параметр  селектора  подпрограммы   не
запросит  большую  привилегированность,  чем  это  позволено для вызывающей
программы.  Вторым   операндом  команды   ARPL  обычно   является  регистр,
содержащий значение селектора CS вызывающей программы.

Изменяемые флаги
Флаг  ZF   устанавливается,  если   поле  RPL   первого  операнда    меньше
соответствующего поля второго операнда.

Исключения защищенного режима
#GP(0), если результат должен помещаться в сегмент, для которого  запрещена
запись;  #GP(0)  в  случае  недопустимого  исполнительного  адреса операнда
памяти в сегментах  CS, DS, ES,  FS или GS;  #SS(0) в случае  недопустимого
адреса в  сегменте SS;  #PF(код сбоя)  в случае  страничного сбоя;  #AC для
невыравненной  ссылки  к  памяти  при  текущем  уровне привилегированности,
равном 3.

Исключения режима реальных адресов
Прерывание 6; команда ARPL в этом режиме не распознается.
Исключения виртуального режима 8086
Те же исключения,  что и для  режима реальных адресов:  #PF (код сбоя)  для
страничных сбоев; #AC для невыравненной ссылки к памяти при текущем  уровне
привилегированности, равном 3.


`м`д`05BOUND`* - Проверка индекса массива относительно границ массива

----------------------------------------------------------------
|Код       Команда     Число      Описание                     |
|операции              тактовых                                |
|                      циклов                                  |
|                                                              |
|62 /r  BOUND r16,m16&16   7     Проверка, находится ли r16 в  |
|                                пределах границ (тест пройден)|
|62 /r  BOUND r32,m32&32   7     Проверка, находится ли r32 в  |
|                                пределах границ (тест пройден)|
----------------------------------------------------------------

Работа команды

IF (LeftSCR < [RightSCR] OR LeftSCR > [RightSCR + Operandsize/8])
   (* Ниже нижней границы или выше верхней границы массива *)
THEN Прерывание 5;
FI;

Описание
Команда BOUND  обеспечивает, что  имеющий знак  индекс массива  находится в
пределах  границ,  заданных  блоком  памяти,  включающего  в себя верхнюю и
нижнюю границы массива. Каждая граница использует одно слово, если  атрибут
размера операнда  равен 16  битам, и  двойное слово,  если атрибут  размера
операнда равен 32  битам. Первый операнд  (регистр) должен быть  больше или
равен первой границе  в памяти (нижней  границе) и меньше  или равен второй
границе  в  памяти  (старшей  границе),  плюс  число байтов, занимаемых для
данного размера  операнда. Если  регистр не  находится в  этих границах, то
происходит прерывание 5; EIP возврата указывает на команду BOUND.
Структура данных о  границах массива обычно  помещается в память  до самого
массива, делая  границы адресуемыми  через константу  смещения относительно
начала массива.

Изменяемые флаги
Отсутствуют.

Исключения защищенного режима
Прерывание 5 при  нарушении границ массива;  #GP(0) в случае  недопустимого
исполнительного адреса операнда памяти в  сегментах CS, DS, ES, FS  или GS;
#SS(0) в случае недопустимого адреса в сегменте SS; #PF(код сбоя) в  случае
страничного сбоя; #AC для невыравненной ссылки к памяти при текущем  уровне
привилегированности, равном 3.

Второй  операнд  должен  являться  операндом  памяти,  а не регистром. Если
команда BOUND  выполняется с  байтом ModR/M,  представляющим второй операнд
как регистр, происходит #UD.

Исключения режима реальных адресов
Прерывание 5 при нарушении  границ массива; прерывание 13,  если какая-либо
часть  операнда  лежит  вне  пространства  исполнительных  адресов  от 0 до
0FFFFH; прерывание 6, если второй операнд является регистром.

Исключения виртуального режима 8086
Те же исключения,  что и для  режима реальных адресов:  #PF (код сбоя)  для
страничных сбоев; #AC для невыравненной ссылки к памяти при текущем  уровне
привилегированности, равном 3.


`м`д`05BSF`* - Поразрядное сканирование в прямом направлении

----------------------------------------------------------------
|Код       Команда     Число      Описание                     |
|операции              тактовых                                |
|                      циклов                                  |
|                                                              |
|0F BC  BSF r16,r/m16  6-42/7-43 Поразрядное сканирование      |
|                                в прямом направлении слова r/m|
|0F BC  BSF r32,r/m32  6-42/7-43 Поразрядное сканирование      |
|                                в прямом направлении двойного |
|                                слова в r/m                   |
----------------------------------------------------------------

Примечания

n - это число ведущих нулевых битов.

Работа команды

IF r/m = 0
THEN
  ZF <- 1;
  регистр <- неопределен;
ELSE
  врем <- 0;
  ZF <- 0;
  WHILE BIT[r/m,врем] = 0
  DO
   врем <- врем +1;
   регистр <- врем;
  OD;
FI;


Описание
Команда  BSF  сканирует  биты  второго  операнда-слова  или двойного слова,
начиная с  бита 0.  Если все  биты равны  0, то  устанавливается флаг ZF; в
противном  случае  флаг  ZF  очищается,  а в регистр назначения загружается
индекс первого найденного установленного бита.

Изменяемые флаги
Флаг ZF устанавливается, если все биты равны 0; в противном случае флаг  ZF
очищается.

Исключения защищенного режима
#GP(0)  в  случае  недопустимого  исполнительного  адреса операнда памяти в
сегментах CS, DS,  ES, FS или  GS; #SS(0) в  случае недопустимого адреса  в
сегменте  SS;   #PF(код  сбоя)   в  случае   страничного  сбоя;   #AC   для
невыравненной  ссылки  к  памяти  при  текущем  уровне привилегированности,
равном 3.

Исключения режима реальных адресов
Прерывание  13,  если  какая-либо  часть  операнда  лежит  вне пространства
исполнительных адресов от 0 до 0FFFFH.
Исключения виртуального режима 8086
Те же исключения,  что и для  режима реальных адресов:  #PF (код сбоя)  для
страничных сбоев; #AC для невыравненной ссылки к памяти при текущем  уровне
привилегированности, равном 3.


`м`д`05BSR`* - Поразрядное сканирование в обратном направлении

----------------------------------------------------------------
|Код       Команда     Число        Описание                   |
|операции              тактовых                                |
|                      циклов                                  |
|                                                              |
|0F BD  BSR r16,r/m16  6-103/7-104  Поразрядное сканирование   |
|                                   в обратном направлении     |
|                                   слова r/m                  |
|0F BD  BSR r32,r/m32  6-103/7-104  Поразрядное сканирование в |
|                                   обратном направлении       |
|                                   двойного слова в r/m       |
----------------------------------------------------------------

Работа команды
IF r/m = 0
THEN
  ZF <- 1;
  регистр <- неопределен;
ELSE
  врем <- OperandSize - 1;
  ZF <- 0;
  WHILE BIT[r/m,врем] = 0
  DO
   врем <- врем - 1;
   регистр <- врем;
  OD;
FI;

Описание
Команда  BSF  сканирует  биты  второго  операнда-слова  или двойного слова,
начиная со старшего бита в направлении  к младшему. Если все биты равны  0,
то  устанавливается  флаг  ZF;  в  противном  случае флаг ZF очищается, а в
регистр назначения загружается  индекс первого найденного  при сканировании
в обратном направлении установленного бита.

Изменяемые флаги
Флаг ZF устанавливается, если все биты равны 0; в противном случае флаг  ZF
очищается.

Исключения защищенного режима
#GP(0), если результат должен помещаться в сегмент, для которого  запрещена
запись;  #GP(0)  в  случае  недопустимого  исполнительного  адреса операнда
памяти в сегментах  CS, DS, ES,  FS или GS;  #SS(0) в случае  недопустимого
адреса в  сегменте SS;  #PF(код сбоя)  в случае  страничного сбоя;  #AC для
невыравненной  ссылки  к  памяти  при  текущем  уровне привилегированности,
равном 3.

Исключения режима реальных адресов
Прерывание  13,  если  какая-либо  часть  операнда  лежит  вне пространства
исполнительных адресов от 0 до 0FFFFH.

Исключения виртуального режима 8086
Те же исключения,  что и для  режима реальных адресов:  #PF (код сбоя)  для
страничных сбоев; #AC для невыравненной ссылки к памяти при текущем  уровне
привилегированности, равном 3.


`м`д`05BSWAP`* - Изменение последовательности байтов

-----------------------------------------------------------------
|Код       Команда  Число      Описание                         |
|операции           тактовых                                    |
|                   циклов                                      |
|OF C8/r   BSWAP r32   1       Изменение последовательности бай-|
|                              тов в 32-битовом регистре из пос-|
|                              ледовательности "от меньшего к   |
|                              большему" на "от большего к мень-|
|                              шему"                            |
-----------------------------------------------------------------

Работа команды

врем <- r32
r32(7..0) <- врем(31..24)
r32(15..8) <- врем(23..16)
r32(23..16) <- врем(15..8)
r32(31..24) <- врем(7..0)


Описание
Команда  BSWAP   реверсирует  последовательность   байтов  в   32-разрядном
регистре, преобразовывая форму "от меньшего  к большему" на "от большего  к
меньшему".  Когда  BSWAP  используется  с  16-разрядным  размером операнда,
результат остается в регистре назначения без изменений.

Изменяемые флаги
Отсутствуют.
Исключения защищенного режима
Отсутствуют
Исключения режима реальных адресов
Отсутствуют
Исключения виртуального режима 8086
Отсутствуют
Примечания
BSWAP  не  поддерживается  процессорами  386.  См. раздел 3.11, где описано
использование BSWAP совместимо с процессорами 386.


`м`д`05BT`*  - Проверка бита

----------------------------------------------------------------
|Код         Команда     Число      Описание                   |
|операции                тактовых                              |
|                        циклов                                |
|                                                              |
|0F A3       BT r/m16,r16  3/8      Сохранение бита во флаге   |
|                                   переноса                   |
|0F A3       BT r/m32,r32  3/8      Сохранение бита во флаге   |
|                                   переноса                   |
|0F BA/      BT r/m16,imm8 3/3      Сохранение бита во флаге   |
|                                   переноса                   |
|0F BA/4 ib  BT r/m32,imm8 3/3      Сохранение бита во флаге   |
|                                   переноса                   |
----------------------------------------------------------------

Работа команды

CF <- BIT[LeftSRC,RightSRC];

Описание
Команда BT сохраняет  значение бита, задаваемого  базой (первый операнд)  и
смещением бита (второй операнд), во флаг CF.

Изменяемые флаги
Флаг CF содержит значение выбранного бита.

Исключения защищенного режима
#GP(0)  в  случае  недопустимого  исполнительного  адреса операнда памяти в
сегментах CS, DS,  ES, FS или  GS; #SS(0) в  случае недопустимого адреса  в
сегменте  SS;   #PF(код  сбоя)   в  случае   страничного  сбоя;   #AC   для
невыравненной  ссылки  к  памяти  при  текущем  уровне привилегированности,
равном 3.

Исключения режима реальных адресов
Прерывание  13,  если  какая-либо  часть  операнда  лежит  вне пространства
исполнительных адресов от 0 до 0FFFFH.

Исключения виртуального режима 8086
Те же исключения,  что и для  режима реальных адресов:  #PF (код сбоя)  для
страничных сбоев; #AC для невыравненной ссылки к памяти при текущем  уровне
привилегированности, равном 3.

Примечания
Индекс  выбранного  бита  может  быть  задан  непосредственной константой в
команде или значением  в регистре общего  назначения. В команде  может быть
использовано  только  8-разрядное  непосредственное  значение. Этот операнд
берется  по  модулю  32,  так  что  диапазон непосредственных смещений бита
составляет 0...31. Это  позволяет выбор любого  бита в регистре.  Для строк
битов в  памяти это  непосредственное поле  задает только  смещение бита  в
слове или двойном слове.  Непосредственные смещения битов, превышающие  31,
поддерживаются  использованием  поля  непосредственного  смещения  бита   в
комбинации с  полем смещения  в операнде  памяти. Младшие  от 3  до 5  биты
непосредственного  смещения  бита  записываются  в  поле  непосредственного
смещения бита,  а старшие  биты от  27 до  29 сдвигаются  и объединяются со
смещением байта в режиме адресации.
При доступе  к биту  в памяти  процессор может  выполнить доступ  к четырем
байтам, начиная с адреса памяти, заданного как

Исполнительный адрес + (4 * (BitOffset DIV 32))
для размера операнда  32 бита ,  либо два байта,  начиная с адреса  памяти,
заданного как

Исполнительный адрес + (2 * (BitOffset DIV 16))
для  размера  операнда  16  битов.  Процессор может поступать таким образом
даже когда для доступа к  заданному биту достаточно выполнить доступ  всего
к  одному  байту.  Следовательно,  вы  можете  избежать  ссылок  к областям
памяти, близко  к разрывам  адресного пространства.  В частности, избегайте
ссылок к  регистрам ввода/вывода,  управляемого памятью.  Вместо этого  для
загрузки  и  сохранения  в  эти  адреса  используйте  команды  MOV,  а  для
манипулирования данными используйте регистровые формы этих команд.


`м`д`05BTC`*  - Проверка бита и дополнение

----------------------------------------------------------------
|Код         Команда     Число      Описание                   |
|операции                тактовых                              |
|                        циклов                                |
|                                                              |
|0F BB       BTC r/m16,r16  6/13    Сохранение бита во флаге   |
|                                   переноса и его дополнение  |
|0F BB       BTC r/m32,r32  6/13    Сохранение бита во флаге   |
|                                   переноса и его дополнение  |
|0F BA/7 ib  BTC r/m16,imm8 6/8     Сохранение бита во флаге   |
|                                   переноса и его дополнение  |
|0F BA/7 ib  BTC r/m32,imm8 6/8     Сохранение бита во флаге   |
|                                   переноса и его дополнение  |
----------------------------------------------------------------

Работа команды

CF <- BIT[LeftSRC,RightSRC];
BIT[LeftSCR, RightScr] <- NOT BIT[LeftSCR, RightSCR]

Описание
Команда BT сохраняет  значение бита, задаваемого  базой (первый операнд)  и
смещением бита (второй  операнд), во флаг  CF и затем  выполняет дополнение
этого бита.

Изменяемые флаги
Флаг CF содержит значение дополнения выбранного бита.

Исключения защищенного режима
#GP(0), если результат должен помещаться в сегмент, для которого  запрещена
запись;  #GP(0)  в  случае  недопустимого  исполнительного  адреса операнда
памяти в сегментах  CS, DS, ES,  FS или GS;  #SS(0) в случае  недопустимого
адреса в  сегменте SS;  #PF(код сбоя)  в случае  страничного сбоя;  #AC для
невыравненной  ссылки  к  памяти  при  текущем  уровне привилегированности,
равном 3.

Исключения режима реальных адресов
Прерывание  13,  если  какая-либо  часть  операнда  лежит  вне пространства
исполнительных адресов от 0 до 0FFFFH.

Исключения виртуального режима 8086
Те же исключения,  что и для  режима реальных адресов:  #PF (код сбоя)  для
страничных сбоев; #AC для невыравненной ссылки к памяти при текущем  уровне
привилегированности, равном 3.

Примечания
Индекс  выбранного  бита  может  быть  задан  непосредственной константой в
команде или значением  в регистре общего  назначения. В команде  может быть
использовано  только  8-разрядное  непосредственное  значение. Этот операнд
берется  по  модулю  32,  так  что  диапазон непосредственных смещений бита
составляет 0...31. Это  позволяет выбор любого  бита в регистре.  Для строк
битов в  памяти это  непосредственное поле  задает только  смещение бита  в
слове или двойном слове.  Непосредственные смещения битов, превышающие  31,
поддерживаются  использованием  поля  непосредственного  смещения  бита   в
комбинации с  полем смещения  в операнде  памяти. Младшие  от 3  до 5  биты
непосредственного  смещения  бита  записываются  в  поле  непосредственного
смещения бита,  а старшие  биты от  27 до  29 сдвигаются  и объединяются со
смещением байта в режиме адресации.

При доступе  к биту  в памяти  процессор может  выполнить доступ  к четырем
байтам, начиная с адреса памяти, заданного как

Исполнительный адрес + (4 * (BitOffset DIV 32))
для размера операнда  32 бита ,  либо два байта,  начиная с адреса  памяти,
заданного как

Исполнительный адрес + (2 * (BitOffset DIV 16))
для  размера  операнда  16  битов.  Процессор может поступать таким образом
даже когда для доступа к  заданному биту достаточно выполнить доступ  всего
к  одному  байту.  Следовательно,  вы  можете  избежать  ссылок  к областям
памяти, близко  к разрывам  адресного пространства.  В частности, избегайте
ссылок к  регистрам ввода/вывода,  управляемого памятью.  Вместо этого  для
загрузки  и  сохранения  в  эти  адреса  используйте  команды  MOV,  а  для
манипулирования данными используйте регистровые формы этих команд.


`м`д`05BTR`*  - Проверка бита и сброс

----------------------------------------------------------------
|Код         Команда     Число      Описание                   |
|операции                тактовых                              |
|                        циклов                                |
|                                                              |
|0F B3       BTR r/m16,r16  6/13     Сохранение бита во флаге  |
|                                    переноса и сброс          |
|0F B3       BTR r/m32,r32  6/13     Сохранение бита во флаге  |
|                                    переноса и сброс          |
|0F BA/6 ib  BTR r/m16,imm8 6/8      Сохранение бита во флаге  |
|                                    переноса и сброс          |
|0F BA/6 ib  BTR r/m32,imm8 6/8      Сохранение бита во флаге  |
|                                    переноса и сброс          |
----------------------------------------------------------------

Работа команды

CF <- BIT[LeftSRC,RightSRC];
BIT[LeftSRC,RightSRC] <- 0;

Описание
Команда BTS сохраняет значение  бита, задаваемого базой (первый  операнд) и
смещением бита (второй операнд), во флаг CF, а затем записывает в этот  бит
0.

Изменяемые флаги
Флаг CF содержит значение выбранного бита.

Исключения защищенного режима
#GP(0), если результат должен помещаться в сегмент, для которого  запрещена
запись;  #GP(0)  в  случае  недопустимого  исполнительного  адреса операнда
памяти в сегментах  CS, DS, ES,  FS или GS;  #SS(0) в случае  недопустимого
адреса в  сегменте SS;  #PF(код сбоя)  в случае  страничного сбоя;  #AC для
невыравненной  ссылки  к  памяти  при  текущем  уровне привилегированности,
равном 3.

Исключения режима реальных адресов
Прерывание  13,  если  какая-либо  часть  операнда  лежит  вне пространства
исполнительных адресов от 0 до 0FFFFH.

Исключения виртуального режима 8086
Те же исключения,  что и для  режима реальных адресов:  #PF (код сбоя)  для
страничных сбоев; #AC для невыравненной ссылки к памяти при текущем  уровне
привилегированности, равном 3.

Примечания
Индекс  выбранного  бита  может  быть  задан  непосредственной константой в
команде или значением  в регистре общего  назначения. В команде  может быть
использовано  только  8-разрядное  непосредственное  значение. Этот операнд
берется  по  модулю  32,  так  что  диапазон непосредственных смещений бита
составляет 0...31. Это  позволяет выбор любого  бита в регистре.  Для строк
битов в  памяти это  непосредственное поле  задает только  смещение бита  в
слове или  двойном слове.  Непосредственные смещения  битов, превышающие 31
(или  15),  поддерживаются  использованием  поля непосредственного смещения
бита в комбинации  с полем смещения  в операнде памяти.  Младшие от 3  до 5
биты непосредственного смещения бита записываются в поле  непосредственного
смещения бита,  а старшие  биты от  27 до  29 сдвигаются  и объединяются со
смещением байта в режиме адресации.

При доступе  к биту  в памяти  процессор может  выполнить доступ  к четырем
байтам, начиная с адреса памяти, заданного как

Исполнительный адрес + (4 * (BitOffset DIV 32))
для размера операнда  32 бита ,  либо два байта,  начиная с адреса  памяти,
заданного как

Исполнительный адрес + (2 * (BitOffset DIV 16))
для  размера  операнда  16  битов.  Процессор может поступать таким образом
даже когда для доступа к  заданному биту достаточно выполнить доступ  всего
к  одному  байту.  Следовательно,  вы  можете  избежать  ссылок  к областям
памяти, близко  к разрывам  адресного пространства.  В частности, избегайте
ссылок к  регистрам ввода/вывода,  управляемого памятью.  Вместо этого  для
загрузки  и  сохранения  в  эти  адреса  используйте  команды  MOV,  а  для
манипулирования данными используйте регистровые формы этих команд.


`м`д`05BTS`*  - Проверка бита и установка

----------------------------------------------------------------
|Код         Команда     Число      Описание                   |
|операции                тактовых                              |
|                        циклов                                |
|                                                              |
|0F AB       BTS r/m16,r16  6/13     Сохранение бита во флаге  |
|                                    переноса и установка      |
|0F AB       BTS r/m32,r32  6/13     Сохранение бита во флаге  |
|                                    переноса и установка      |
|0F BA/5 ib  BTS r/m16,imm8 6/8      Сохранение бита во флаге  |
|                                    переноса и установка      |
|0F BA/5 ib  BTS r/m32,imm8 6/8      Сохранение бита во флаге  |
|                                    переноса и установка      |
----------------------------------------------------------------

Работа команды

CF <- BIT[LeftSRC,RightSRC];
BIT[LeftSRC,RightSRC] <- 1;

Описание
Команда BTS сохраняет значение  бита, задаваемого базой (первый  операнд) и
смещением бита (второй операнд), во флаг CF, затем записывает в этот бит 1.

Изменяемые флаги
Флаг CF содержит значение выбранного бита.

Исключения защищенного режима
#GP(0), если результат должен помещаться в сегмент, для которого  запрещена
запись;  #GP(0)  в  случае  недопустимого  исполнительного  адреса операнда
памяти в сегментах  CS, DS, ES,  FS или GS;  #SS(0) в случае  недопустимого
адреса в  сегменте SS;  #PF(код сбоя)  в случае  страничного сбоя;  #AC для
невыравненной  ссылки  к  памяти  при  текущем  уровне привилегированности,
равном 3.

Исключения режима реальных адресов
Прерывание  13,  если  какая-либо  часть  операнда  лежит  вне пространства
исполнительных адресов от 0 до 0FFFFH.

Исключения виртуального режима 8086
Те же исключения,  что и для  режима реальных адресов:  #PF (код сбоя)  для
страничных сбоев; #AC для невыравненной ссылки к памяти при текущем  уровне
привилегированности, равном 3.

Примечания
Индекс  выбранного  бита  может  быть  задан  непосредственной константой в
команде или значением  в регистре общего  назначения. В команде  может быть
использовано  только  8-разрядное  непосредственное  значение. Этот операнд
берется  по  модулю  32,  так  что  диапазон непосредственных смещений бита
составляет 0...31. Это  позволяет выбор любого  бита в регистре.  Для строк
битов в  памяти это  непосредственное поле  задает только  смещение бита  в
слове или  двойном слове.  Непосредственные смещения  битов, превышающие 31
(или  15),  поддерживаются  использованием  поля непосредственного смещения
бита в комбинации  с полем смещения  в операнде памяти.  Младшие от 3  до 5
биты непосредственного смещения бита записываются в поле  непосредственного
смещения бита,  а старшие  биты от  27 до  29 сдвигаются  и объединяются со
смещением байта в режиме адресации.
При доступе  к биту  в памяти  процессор может  выполнить доступ  к четырем
байтам, начиная с адреса памяти, заданного как

Исполнительный адрес + (4 * (BitOffset DIV 32))
для размера операнда 32 бита , либо два байта, начиная с адреса памяти,
заданного как исполнительный адрес + (2 * (BitOffset DIV 16))
для  размера  операнда  16  битов.  Процессор может поступать таким образом
даже когда для доступа к  заданному биту достаточно выполнить доступ  всего
к  одному  байту.  Следовательно,  вы  можете  избежать  ссылок  к областям
памяти, близко  к разрывам  адресного пространства.  В частности, избегайте
ссылок к  регистрам ввода/вывода,  управляемого памятью.  Вместо этого  для
загрузки  и  сохранения  в  эти  адреса  используйте  команды  MOV,  а  для
манипулирования данными используйте регистровые формы этих команд.


`м`д`05CALL - Вызов процедуры`*

-----------------------------------------------------------------
|Код       Команда     Число      Описание                      |
|операции              тактовых                                 |
|                      циклов                                   |
|E8 cw     CALL rel16    3        Вызов ближний, смещение отно- |
|                                 сительно следующей команды    |
|FF /2     CALL r/m16    5/5      Вызов ближний, косвенный ре-  |
|                                 гистр/косвенная память        |
|9A cd     CALL ptr16:16 18,pm=20 Вызов межсегментный, на весь  |
|                                 заданный указатель            |
|9A cd     CALL ptr16:16 pm=35    Вызов шлюзом, та же привилеги-|
|                                 рованность                    |
|9A cd     CALL ptr16:16 pm=69    Вызов шлюзом, большая привиле-|
|                                 гированность, без параметров  |
|9A cd     CALL ptr16:16 pm=77+4x Вызов шлюзом, большая привиле-|
|                                 гированность, х параметров    |
|9A cd     CALL ptr16:16 pm=37+ts Вызов задачи                  |
|                                                               |
|FF /3     CALL m16:16   17,pm=20 Вызов межсегментный, адрес в  |
|                                 двойном слове r/m             |
|FF /3     CALL m16:16   pm=35    Вызов шлюзом, та же привилеги-|
|                                 рованность                    |
|FF /3     CALL m16:16   pm=69    Вызов шлюзом, большая привиле-|
|                                 гированность, без параметров  |
|FF /3     CALL m16:16   pm=77+4x Вызов шлюзом, большая привиле-|
|                                 гированность, х параметров    |
|FF /3     CALL m16:16   pm=37+ts Вызов задачи                  |
|                                                               |
|E8 cd     CALL rel32    3        Вызов ближний, смещение отно- |
|                                 сительно следующей команды    |
|FF /2     CALL r/m32    5/5      Вызов ближний, косвенный      |
|                                                               |
|9A cp     CALL ptr16:32 18,pm=20 Вызов межсегментный, на весь  |
|                                 заданный указатель            |
|9A cp     CALL ptr16:32 pm=35    Вызов шлюзом, та же привилеги-|
|                                 рованность                    |
|9A cp     CALL ptr16:32 pm=69    Вызов шлюзом, большая привиле-|
|                                 гированность, без параметров  |
|9A cp     CALL ptr32:32 pm=77+4x Вызов шлюзом, большая привиле-|
|                                 гированность, х параметров    |
|9A cp     CALL ptr16:32 pm=37+ts Вызов задачи                  |
|                                                               |
|FF /3     CALL m16:32   17,pm=20 Вызов межсегментный, адрес в  |
|                                 двойном слове в r/m           |

|FF /3     CALL m16:32   pm=35    Вызов шлюзом, та же привиле-  |
|                                 гированность                  |
|FF /3     CALL m16:32   pm=69    Вызов шлюзом, большая привиле-|
|                                 гированность, без параметров  |
|FF /3     CALL m16:32   pm=77+4x Вызов шлюзом, большая привиле-|
|                                 гированность, х параметров    |
|FF /3     CALL m16:32   pm=37+ts Вызов задачи                  |
-----------------------------------------------------------------

Примечание: значения ts задаются следующей таблицей:

-----------------------------------------------------------------
                     |          Новая задача
     Старая задача   |-------------------------------------------
                     | к TSS i486 | к TSS 80286 | к TSS VM
-----------------------------------------------------------------
 VM/i486/TSS 80286   |     199    |     180     |     177
-----------------------------------------------------------------

Работа команды

IF тип вызова rel16 или rel32
THEN (* ближний относительный вызов *)
  IF OperandSize = 16
  THEN
    Push(IP);
    EIP <- (EIP + rel16) AND 0000FFFFH;
  ELSE (* OperandSize = 32 *)
    Push(EIP);
    EIP <- EIP + rel32;
  FI;
FI;

IF тип вызова r/m16 или r/m32
THEN (* ближний абсолютный вызов *)
  IF OperandSize = 16
  THEN
    Push(IP);
    EIP <- [r/m16] AND 0000FFFFH;
  ELSE (* OperandSize = 32 *)
    Push(EIP);
    EIP <- [r/m32];
  FI;
FI;

IF (PE = 0 OR (PE = 1 AND VM = 1))
(* режим реальных адресов или виртуальный режим 8086 *)
  AND команда = дальний CALL
  (* т.е. тип операнда равен m16:16, m16:32, ptr16:16, ptr16:32 *)
THEN
  IF OperandSize = 16
  THEN
    Push(CS);
    Push(IP); (* адрес следующей команды; 16 битов *)
  ELSE
    Push(CS); (* 16 старших битов занято заполнителями *)
    Push(EIP); (* адрес следующей команды; 32 бита *)
  FI;
  IF тип операнда равен m16:16 или m16:32
  THEN (* косвенный дальний вызов *)
    IF OperandSize = 16
    THEN
      CS:IP <- [m16:16];
      EIP <- EIP AND 0000FFFFH; (* очистить старшие 16 битов *)
    ELSE (* OperandSize = 32 *)
      CS:IEP <- [m16:32];
    FI;
  FI;
  IF тип операнда равен ptr16:16 или ptr16:32
  THEN (* прямой дальний вызов *)
    If OperandSize =16 *)
    THEN
      CS:IP <- ptr16:16;
      EIP <- EIP AND 0000FFFFH; (* очистить старшие 16 битов *)
    ELSE (* OperandSize = 32 *)
      CS:EIP <- ptr16:32;
    FI;
  FI;
FI;

IF (PE = 1 AND VM = 0) (* Защищенный режим, но не режим V86 *)
  AND команда = дальний CALL
THEN

  При косвенном проверить доступ к двойному слову EA;
    #GP(0) при нарушении границы;
  Новый селектор CS не должен быть пустым, иначе #GP(0);
  Проверить, чтобы индекс селектора нового CS был в пределах
    границ дескрипторной таблицы; иначе #GP(селектор нового CS)
  Исследовать различные допустимые значения  байта  AR  выбранного
    дескриптора;
    В зависимости от значения;
    переход к КОНФОРМНЫЙ-КОДОВЫЙ-СЕГМЕНТ;
    переход к НЕКОНФОРМНЫЙ-КОДОВЫЙ-СЕГМЕНТ;
    переход к ШЛЮЗ-ВЫЗОВА;
    переход к ШЛЮЗ-ЗАДАЧИ;
    переход к СЕГМЕНТ-СОСТОЯНИЯ-ЗАДАЧИ;
  ELSE #GP(селектор кодового сегмента);
FI;

КОНФОРМНЫЙ-КОДОВЫЙ-СЕГМЕНТ:
  DPL должен быть <= CPL  ELSE  #GP(селектор кодового сегмента);
  Сегмент должен   присутствовать   ELSE  #NP  (селектор  кодового
                                                сегмента);
  Стек должен  быть  достаточно  велик  для  адреса  возврата ELSE
                                                #SS(0);
  Указатель команд должен быть в границах кодового сегмента ELSE
                                                #GP(0);
  Загрузить дескриптор кодового сегмента в регистр CS;
  Загрузить в CS селектор нового кодового сегмента;
  Загрузить в EIP с расширенем нулем (новое смещение);
  IF OperandSize = 16 THEN EIP <- EIP AND 0000FFFFH; FI;

НЕКОНФОРМНЫЙ-КОДОВЫЙ-СЕГМЕНТ:
  RPL должен быть <= CPL  ELSE  #GP(селектор кодового сегмента);
  DPL должен быть = CPL  ELSE  #GP(селектор кодового сегмента);
  Сегмент должен   присутствовать   ELSE  #NP  (селектор  кодового
                                                сегмента);
  Стек должен  быть  достаточно  велик  для  адреса  возврата ELSE
                                                #SS(0);
  Указатель команд должен быть в границах кодового сегмента ELSE
                                                #GP(0);
  Загрузить дескриптор кодового сегмента в регистр CS;
  Загрузить в CS селектор нового кодового сегмента;
  Установить RPL для CS равным CPL;
  Загрузить в EIP с расширенем нулем (новое смещение);
  IF OperandSize = 16 THEN EIP <- EIP AND 0000FFFFH; FI;

ШЛЮЗ-ВЫЗОВА:
  DPL шлюза вызова должен быть >= CPL  ELSE  #GP(селектор шлюза
                                                 вызова);
  DPL шлюза вызова должен быть >= RPL  ELSE  #GP(селектор шлюза
                                                 вызова);
  Шлюз вызова должен присутствовать    ELSE  #NP(селектор шлюза
                                                 вызова);
  Рассмотрим селектор кодового сегмента в дескрипторе шлюза
                                                 вызова:
    Селектор не должен быть пустым ELSE #GP(0)
    Селектор должен быть в пределах границ его дескрипторной
      таблицы ELSE #GP(селектор кодового сегмента)
    Байт AR выбранного дескриптора должен обозначать кодовый
      сегмент ELSE #GP (селектор кодового сегмента)
    DPL выбранного дескриптора должен быть <= CPL ELSE
      #GP(селектор кодового сегмента)
    IF неконформный кодовый сегмент AND DPL <CPL
    THEN переход к БОЛЬШАЯ-ПРИВИЛЕГИРОВАННОСТЬ
    ELSE переход к ТА-ЖЕ-ПРИВИЛЕГИРОВАННОСТЬ
    FI;

БОЛЬШАЯ-ПРИВИЛЕГИРОВАННОСТЬ:
  Взять селектор нового SS для нового уровня привилегированность в
  TSS
    Проверить селектор и дескриптор для нового SS:
       Селектор не должен быть пустым ELSE #TS(0)
       Индекс селектора  должен  находиться  в  пределах  границ
         его дескрипторной таблицы ELSE #TS(селектор SS)
       RPL селектора должен быть равен DPL кодового сегмента
         ELSE #TS(селектор SS)
       Дескриптор должен указывать на сегмент данных, доступный
         для записи ELSE #TS(селектор SS)
       Сегмент присутствует ELSE #SS(селектор SS)
    IF OperandSize = 32
    THEN
       Новый стек должен иметь место для параметров, плюс 16 байт
          ELSE  #SS(селектор сегмента)
       EIP должен быть в границе кодового сегмента ELSE #GP(0)

       Загрузить новое значение SS:eSP из TSS
       Загрузить новое значение CS:EIP из шлюза
    ELSE
       Новый стек должен иметь место для параметров, плюс 8 байт
          ELSE #SS(селектор SS)
       IP должен быть в границах кодового сегмента ELSE #GP(0)
       Загрузить новое значение SS:eSP из TSS
       Загрузить новое значение CS:IP из шлюза
    FI;
    Загрузить дескриптор CS
    Загрузить дескриптор SS
    Поместить дальний указатель старого стека в новый стек
    Взять слово счетчика из шлюза вызова, маскировать 5 битов
    Скопировать параметры из старого стека в новый
    Поместить в новый стек адрес возврата
    Установить CPL равным DPL стекового сегмента
    Установить RPL для CS равным CPL

ТА-ЖЕ-ПРИВИЛЕГИРОВАННОСТЬ:
  IF OperandSize = 32
  THEN
    Стек должен иметь место для 6-байтового адреса возврата  (до 8
      байтов дополненного заполнителями)
      ELSE #SS(0)
    EIP должен быть в пределах границы кодового сегмента
      ELSE #GP(0)
    Загрузить CS:EIP из шлюза
  ELSE
    Стек должен иметь место для 4-байтового адреса возврата
      ELSE #SS(0)
    IP должен быть в пределах границы кодового сегмента
      ELSE #GP(0)
    Загрузить CS:IP из шлюза
    Поместить в стек адрес возврата
    Загрузить дескриптор кодового сегмента в регистр CS
    Установить RPL для CS равным CPL

ШЛЮЗ-ЗАДАЧИ:
  DPL шлюза задачи должен быть >= CPL ELSE #TS(селектор шлюза)
  DPL шлюза задачи должен быть >= RPL ELSE #TS(селектор шлюза)
  Шлюз задачи должен присутствовать ELSE #NP(селектор шлюза)
  Исследовать селектор TSS, заданный в дескрипторе шлюза задачи:
    Он должен задавать бит Глобальный/Локальный как Глобальный
      ELSE #TS(селектор TSS)
    Индекс должен находиться в пределах границы GDT
      ELSE #TS(селектор TSS)
    Байт AR дескриптора TSS должен задавать неЗанятый TSS
      ELSE #TS(селектор TSS)
    Сегмент состояния задачи (TSS) должен присутствовать
      ELSE #NP(селектор TSS)
  ПЕРЕКЛЮЧЕНИЕ-ЗАДАЧ (со вложенностью) на TSS
  IP должен находиться в границе кодового сегмента ELSE #TS(0)

СЕГМЕНТ-СОСТОЯНИЯ-ЗАДАЧИ:
  DPL для TSS должен быть >= CPL ELSE #TS(селектор TSS)
  DPL для TSS должен быть >= RPL ELSE #TS(селектор TSS)
  Байт AR дескриптора TSS должен задавать доступный TSS
    ELSE #TS(селектор TSS)
    Сегмент состояния задачи (TSS) должен присутствовать
      ELSE #NP(селектор TSS)
  ПЕРЕКЛЮЧЕНИЕ-ЗАДАЧ (со вложенностью) на TSS
  IP должен находиться в границе кодового сегмента ELSE #TS(0)

Описание
Команда  CALL  вызывает  выполнение  процедуры,  указанной  в операнде. При
завершении процедуры  (команда возврата  выполняется вызванной  процедурой)
выполнение продолжается с команды, следующей за командой CALL.

Ниже описано действие для различных форм команды.
Ближними называются вызовы с назначениями типа r/m16, r/m32, rel16,  rel32;
изменение или сохранение значения сегментного регистра не требуется.  Формы
команды CALL  rel16 и  CALL rel32  складывают имеющее  знак смещение адреса
команды,  следующей  за  командой  CALL,  для определения назначения. Форма
rel16 используется, когда атрибут размера операнда команды равен 16  битам;
форма  rel32  используется  при  значении  этого атрибута, равном 32 битам.
Результат записывается в 32-битовый регистр EIP. В случае rel16 старшие  16
битов регистра EIP очищаются ,  что дает значение смещение, не  превышающее
16  битов.  Команды  CALL  r/  m16  и  CALL  r/m32 задают регистр или адрес
памяти,  из  которого  выполняется  выборка  абсолютного смещения сегмента.
Смещение, выбранное из  r/m, равно 32  битам для атрибута  размера операнда
32  (r/m32),  или  16  битам  для  атрибута  размера  операнда  16 (r/m16).
Смещение для команды,  следующей за командой  CALL, помещается в  стек. Она
будет снята из стека ближней  командой RET в пределах вызванной  процедуры.
Регистр CS этой формой команды CALL не изменяется.

Дальние  вызовы,  CALL  ptr16:16  и  CALL  ptr16:32,  используют в качестве
дальнего  указателя  на  вызываемую  процедуру  четырех- или шести-байтовый
операнд.  Формы  CALL  m16:16  и  m16:32  извлекают  дальний  указатель  из
заданного адреса памяти (косвенная  ссылка). В режиме реальных  адресов или
виртуальном режиме 8086  дальние указатели содержат  16 битов для  регистра
CS и 16  или 32 бита  для регистра EIP  (в зависимости от  атрибута размера
операнда). Эти  формы команды  помещают в  стек оба  регистра, IP  и EIP, в
качестве адреса возврата.
В защищенном режиме  обе формы дальних  указателей обращаются к  байту AR в
дескрипторе,  индексируемом  селекторной   частью  дальнего  указателя.   В
зависимости от  значения байта  AR вызов  выполнит один  из следующих типов
передачи управления:

- Дальний вызов к тому же самому уровню защиты
- Дальний вызов между разными уровнями защиты
- Переключение задачи
Более подробную информацию о передаче управления в защищенном режиме см.  в
главах 6 и 7.

Изменяемые флаги
При переключении задачи изменяются  все флаги; если же  переключение задачи
не происходит, то флаги не изменяются.

Исключения защищенного режима
Для дальних вызовов:  #GP, #NP, #SS  и #TS, как  указано в разделе  "Работа
команды".
Для ближних прямых вызовов:  #GP(0), если процедура находится  за пределами
границы кодового сегмента; #SS(0) в случае недопустимого адреса в  сегменте
SS; #PF(код сбоя) в случае  страничного сбоя; #AC для невыравненной  ссылки
к памяти при текущем уровне привилегированности, равном 3.

Исключения режима реальных адресов
Прерывание  13,  если  какая-либо  часть  операнда  лежит  вне пространства
исполнительных адресов от 0 до 0FFFFH.

Исключения виртуального режима 8086
Те же исключения,  что и для  режима реальных адресов:  #PF (код сбоя)  для
страничных сбоев; #AC для невыравненной ссылки к памяти при текущем  уровне
привилегированности, равном 3.

Примечания
Любой  дальний  вызов  из  32-разрядного  кодового  сегмента в 16-разрядный
кодовый  сегмент  должен  находиться  в  первых  64К 32-разрядного кодового
сегмента,  поскольку  атрибут  размера  операнда  команды  в  этом   случае
устанавливается на 16, что  позволяет сохранить только 16-битовое  смещение
адреса возврата.


`м`д`05CBW/CWDE`*  -  Преобразование байта в слово/Преобразование слова
                                в двойное слово

-----------------------------------------------------------------
|Код       Команда  Число      Описание                         |
|операции           тактовых                                    |
|                   циклов                                      |
|                                                               |
|98        CBW      3          AX <- расширение знаком AL       |
|98        CWDE     3          EAX<- расширение знаком AX       |
-----------------------------------------------------------------

Работа команды

IF OperandSize = 16 (* команда = CBW *)
THEN AX <- SignExtend(AL);
ELSE (OperandSize = 32, команда = CWDE *)
  EAX <- SignExtend(AX);
FI;

Описание
Команда CBW преобразовывает имеющий знак байт в регистре AL в имеющее  знак
слово  в  регистре  AX  путем  расширения  старшего  бита регистра AL (бита
знака) на все биты регистра  AH. Команда CWDE преобразовывает имеющее  знак
слово в  регистре AX  в имеющее  знак двойное  слово в  регистре ЕAX  путем
расширения старшего  бита регистра  AX (бита  знака) на  два старших  байта
регистра EAX.  Отметим, что  команда CWDE  отлична от  команды CWD. Команда
CWD использует  в качестве  назначения вместо  регистра EAX  пару регистров
DX:AX.

Изменяемые флаги
Отсутствуют

Исключения защищенного режима
Отсутствуют

Исключения режима реальных адресов
Отсутствуют

Исключения виртуального режима 8086
Отсутствуют


`м`д`05CLC`* - Очистить флаг переноса

-----------------------------------------------------------------
|Код       Команда  Число      Описание                         |
|операции           тактовых                                    |
|                   циклов                                      |
|                                                               |
| F8       CLC      2          Очистить флаг переноса           |
-----------------------------------------------------------------

Работа команды

CF <- 0;

Описание
Команда CLC очищает флаг CF. На другие флаги или регистры она не влияет.

Изменяемые флаги
Очищается флаг CF.

Исключения защищенного режима
Отсутствуют

Исключения режима реальных адресов
Отсутствуют

Исключения виртуального режима 8086
Отсутствуют


`м`д`05CLD`* - Очистить флаг направления

-----------------------------------------------------------------
|Код       Команда  Число      Описание                         |
|операции           тактовых                                    |
|                   циклов                                      |
|                                                               |
| FC       CLD      2          Очистить флаг направления: при   |
|                              выполнении строковых команд будет|
|                              происходить инкремент SI и DI    |
-----------------------------------------------------------------

Работа команды

DF <- 0;

Описание
Команда CLD очищает флаг направления.  На другие флаги или регистры  она не
влияет.   После   выполнения   команды   CLD   строковые   команды    будут
инкрементировать используемые ими индексные регистры (SI и/или DI).

Изменяемые флаги
Очищается флаг DF.

Исключения защищенного режима
Отсутствуют

Исключения режима реальных адресов
Отсутствуют

Исключения виртуального режима 8086
Отсутствуют


`м`д`05CLI`* - Очистить флаг прерывания

-----------------------------------------------------------------
|Код       Команда  Число      Описание                         |
|операции           тактовых                                    |
|                   циклов                                      |
|                                                               |
| FA       CLI      5          Очистить флаг прерывания;        |
|                              прерывания запрещены             |
-----------------------------------------------------------------

Работа команды

IF <- 0;

Описание
Команда   CLI   очищает   флаг   прерывания   IF,   если   текущий  уровень
привилегированности как минимум равен IOPL. На другие флаги она не  влияет.
Внешние прерывания не  распознаются в конце  команды CLI и  начиная с этого
момента до установки команды IF.

Изменяемые флаги
Очищается флаг IF.

Исключения защищенного режима
#GP(0), если текущий уровень привилегированности имеет больший номер  (т.е.
привилегированность меньше),  чем уровень  привилегированности ввода/вывода
в  регистре   флагов.  Уровень   привилегированности  ввода/вывода   задает
наименьший уровень привилегированности,  на котором допускается  выполнение
ввода/вывода.

Исключения режима реальных адресов
Отсутствуют

Исключения виртуального режима 8086
#GP(0) как для защищенного режима.


`м`д`05CLTS`* - Очистить флаг переключения задачи в CR0

-----------------------------------------------------------------
|Код       Команда  Число      Описание                         |
|операции           тактовых                                    |
|                   циклов                                      |
|                                                               |
| 0F 06    CLTS     7          Очистить флаг переключения задачи|
-----------------------------------------------------------------

Работа команды

Флаг TS в CR0 <- 0;

Описание
Команда CLTS  очищает флаг  переключения задачи  (TS) в  регистре CR0. Этот
флаг устанавливается процессором всякий раз, когда происходит  переключение
задачи.  Флаг  TS  используется  для  управления  расширениями   процессора
следующим образом:

-  Каждое  выполнение  команды  ESC  при  установленном  флаге  TS вызывает
исключение.
-  Выполнение  команды  WAIT  вызывает  исключение ловушки при одновременно
установленных флагах MP и TS.

Таким  образом,  если  переключение  задачи  произошло после начала команды
ESC,  может  потребоваться  сохранить   контекст  модуля  для  операции   с
плавающей  точкой,  прежде  чем  может  быть  выдана  новая  команда   ESC.
Обработчик сбоя сохраняет контекст и очищает флаг TS.
Команда CLTS используется  в операционном программном  обеспечении, а не  в
прикладных программах.  Это привилегированная  команда, которая  может быть
выполнена только на уровне привилегированности 0.

Изменяемые флаги
Очищается флаг TS (флаг в регистре CR0, а не во флаговом регистре).

Исключения защищенного режима
#GP(0),    если    команда    CLTS    выполняется    с    текущим   уровнем
привилегированности, не равным 0.

Исключения режима реальных адресов
Отсутствуют (допустима в режиме реальных адресов для того, чтобы  позволить
инициализацию для защищенного режима).

Исключения виртуального режима 8086
Отсутствуют


`м`д`05CMC`* - Дополнение флага переноса

-----------------------------------------------------------------
|Код       Команда  Число      Описание                         |
|операции           тактовых                                    |
|                   циклов                                      |
|                                                               |
| F5       CMC      2          Дополнение флага переноса        |
-----------------------------------------------------------------

Работа команды

CF <- NOT CF;

Описание
Команда CMC изменяет на противоположное значение флага CF. На другие  флаги
влияния не оказывает.

Изменяемые флаги
Флаг CF содержит дополнение его исходного значения.

Исключения защищенного режима
Отсутствуют

Исключения режима реальных адресов
Отсутствуют

Исключения виртуального режима 8086
Отсутствуют


`м`д`05CMP - Сравнение двух операндов`*

-----------------------------------------------------------------
|Код       Команда      Число    Описание                       |
|операции               тактовых                                |
|                       циклов                                  |
|                                                               |
|3C ib     CMP AL,imm8      1    Сравнение непосредственного    |
|                                байта с AL                     |
|3D iw     CMP AX,imm16     1    Сравнение непосредственного    |
|                                слова с AX                     |
|3D id     CMP EAX,imm32    1    Сравнение непосредственного    |
|                                двойного слова с EAX           |
|80 /7 ib  CMP r/m8,imm8    1/2  Сравнение непосредственного    |
|                                байта с байтом в r/m           |
|81 /7 iw  CMP r/m16,imm16  1/2  Сравнение непосредственного    |
|                                слова со словом в r/m          |
|81 /7 id  CMP r/m32,imm32  1/2  Сравнение непосредственного    |
|                                двойного слова с двойным словом|
|                                в r/m                          |
-----------------------------------------------------------------

Работа команды

LeftSRC - SignExtend(RightSRC);
(* CMP не выполняет запись результата;  ее назначение - установка
   флагов *)

Описание
Команда CMP  вычитает второй  операнд из  первого, но  в отличие от команды
SUB,  не  записывает  результат:  она  изменяет  только  состояния  флагов.
Команда  CMP  обычно  используется  в  сочетании  с  условными переходами и
командами  SETcc.  (Список  имеющихся  проверок  флагов,  со  знаком  и без
флагов, приводится  в Приложении  D). Если  операнд превышает  один байт  и
сравнивается с  непосредственным байтом,  то этот  байт сначала расширяется
знаком.

Изменяемые флаги
Флаги OF, SF, ZF, AF, PF и CF устанавливаются в соответствии с результатом.

Исключения защищенного режима
#GP(0)  в  случае  недопустимого  исполнительного  адреса операнда памяти в
сегментах CS, DS,  ES, FS или  GS; #SS(0) в  случае недопустимого адреса  в
сегменте  SS;   #PF(код  сбоя)   в  случае   страничного  сбоя;   #AC   для
невыравненной  ссылки  к  памяти  при  текущем  уровне привилегированности,
равном 3.

Исключения режима реальных адресов
Прерывание  13,  если  какая-либо  часть  операнда  лежит  вне пространства
исполнительных адресов от 0 до 0FFFFH.

Исключения виртуального режима 8086
Те же исключения,  что и для  режима реальных адресов:  #PF (код сбоя)  для
страничных сбоев; #AC для невыравненной ссылки к памяти при текущем  уровне
привилегированности, равном 3.

`м`д`05CMPS/CMPSB/CMPSW/CMPSD`*  -  Сравнение строковых операндов

-----------------------------------------------------------------
|Код       Команда  Число      Описание                         |
|операции           тактовых                                    |
|                   циклов                                      |
|                                                               |
|A6      CMPS m8,m8     8      Сравнение байтов в ES:[(E)DI]    |
|                              (второй операнд) с [(E)SI]       |
|                              (первый операнд)                 |
|A7      CMPS m16,m16   8      Сравнение слов     ES:[(E)DI]    |
|                              (второй операнд) с [(E)SI]       |
|                              (первый операнд)                 |
|A7      CMPS m32,m32   8      Сравнение двойных слов ES:[(E)DI]|
|                              (второй операнд) с [(E)SI]       |
|                              (первый операнд)                 |
|A6      CMPSB          8      Сравнение байтов в ES:[(E)DI]    |
|                                               с DS:[SI]       |
|A7      CMPSW          8      Сравнение слов   в ES:[(E)DI]    |
|                                               с DS:[SI]       |
|A7      CMPSD          8      Сравнение двойных слов ES:[(E)DI]|
|                                               с DS:[SI]       |
-----------------------------------------------------------------

Работа команды

IF (команда = CMPSD) OR
   (команда имеет операнды типа DWORD)
THEN OperandSize <- 32;
ELSE OperandSize <- 16;
FI;
IF AddressSize = 16
THEN
  используйте SI как индекс источника и DI как индекс назначения
ELSE (* AddressSize = 32 *)
  используйте ESI   как   индекс   источника  и  EDI  как  индекс
    назначения;
FI;
IF команда байтового типа
THEN
  [индекс-источника] - [индекс-назначения]; (* сравнение байтов *)
  IF DF = 0 THEN IncDec <- 1 ELSE IncDec <- -1; FI;
ELSE
  IF OperandSize = 16
  THEN
    [индекс-источника] - [индекс-назначения]; (* сравнение слов *)
    IF DF = 0 THEN IncDec <- 2 ELSE IncDec <- -2; FI;
  ELSE (* OperandSize = 32 *)
    [индекс-источника] - [индекс-назначения]; (* сравнение
                                                 двойных слов *)
    IF DF = 0 THEN IncDec <- 4 ELSE IncDec <- -4; FI;
  FI;
FI;
индекс-источника = индекс-источника + IncDec;
индекс-назначения = индекс-назначения + IncDec;

Описание
Команда  CMPS  сравнивает  байт,  слово  или  двойное  слово,  на   которое
указывает регистр индекса-источника, с  байтом, словом или двойным  словом,
на которое указывает регистр индекса-назначения.
Если атрибут  размера адреса  этой команды  равен 16  битов, то  в качестве
регистров индекса источника и назначения  используются регистры SI и DI;  в
противном  случае  используются  регистры  ESI  и  EDI.  Перед  выполнением
команды CMPS в  SI и DI  (или ESI и  EDI) должны быть  загружены правильные
значения индексов.
Сравнение  выполняется  посредством  вычитания  операнда,  индексированного
регистром  индекса-назначения,  из  операнда,  индексированного   регистром
индекса-источника.
Отметим, что  направление вычитания  для команды  CMPS это  [SI] - [DI] или
[ESI] -  [EDI]. Левый  операнд (SI  или ESI)  является источником, а правый
операнд  (DI  или  EDI)  это  назначение.  Это  направление  противоположно
направлению,  принятому  по  обычным  соглашениям  Intel, где левый операнд
является назначением, а правый - источником.
Результат  вычитания  не  записывается;  он  отражается  только  изменением
флагов. Тип операндов определяет, сравниваются ли байты, слова или  двойные
слова. Для  первого операнда  (SI или  ESI) используется  регистр DS,  если
отсутствует  байт  переопределения  сегмента.  Второй  операнд (DI или EDI)
должен  позволять  адресацию  из  регистра  ES;  переопределение   сегмента
невозможно.
После того, как сравнение выполнено, происходит автоматическое  продвижение
в регистрах индекса  источника и индекса  назначения. Если флаг  DF равен 0
(т.е.  была  использована  команда  CLD),  то  происходит  инкремент   этих
регистров;  если  же  флаг  DF  равен  1  (была  выполнена команда STD), то
происходит декремент регистра.  При сравнении байтов  выполняется инкремент

или декремент на 1, при сравнении  слов на 2, а при сравнении  двойных слов
- на 4.
Команды  CMPSB,  CMPSW  и  CMPSD  являются  синонимами  команды  CMPS   lkz
сравнения байтов, слов и двойных слов, соответственно.
Команде  CMPS  может  предшествовать  префикс  REPE  или REPNE для блочного
сравнения с использованием CX или ECX байтов, слов или двойных слов.  Более
подробную информацию об этом см. в описании команды REP.

Изменяемые флаги
Флаги OF, SF, ZF, AF, PF и CF устанавливаются в соответствии с результатом.

Исключения защищенного режима
#GP(0)  в  случае  недопустимого  исполнительного  адреса операнда памяти в
сегментах CS, DS,  ES, FS или  GS; #SS(0) в  случае недопустимого адреса  в
сегменте  SS;   #PF(код  сбоя)   в  случае   страничного  сбоя;   #AC   для
невыравненной  ссылки  к  памяти  при  текущем  уровне привилегированности,
равном 3.

Исключения режима реальных адресов
Прерывание  13,  если  какая-либо  часть  операнда  лежит  вне пространства
исполнительных адресов от 0 до 0FFFFH.

Исключения виртуального режима 8086
Те же исключения,  что и для  режима реальных адресов:  #PF (код сбоя)  для
страничных сбоев; #AC для невыравненной ссылки к памяти при текущем  уровне
привилегированности, равном 3.


`м`д`05CMPXCHG`* - Сравнение и обмен

-----------------------------------------------------------------
|Код        Команда      Число           Описание               |
|операции                тактовых                               |
|                        циклов                                 |
|                                                               |
|0F A6/r CMPXCHG r/m8,r8 6/7, если срав- Сравнение AL с байтом  |
|                        нение успешно,  r/m. При равенстве ус- |
|                        и 6/10 иначе    танавливает ZF и загру-|
|                                        жает байт регистра в   |
|                                        байт r/m. Иначе очищает|
|                                        ZF и загружает байт r/m|
|                                        в AL                   |
|0F A7/r CMPXCHG         6/7, если срав- Сравнение AL со словом |
|        r/m16,r16       нение успешно,  r/m. При равенстве ус- |
|                        и 6/10 иначе    танавливает ZF и загру-|
|                                        жает регистр-слово в   |
|                                       слово r/m. Иначе очищает|
|                                       ZF и загружает слово r/m|
|                                        в AX                   |
|0F A7/r CMPXCHG         6/7, если срав- Сравнение AL с двойным |
|        r/m32,r32       нение успешно,  словом r/m. При равенс-|
|                        и 6/10 иначе    тве устан-т ZF и загру-|
|                                        жает регистр-двойное   |
|                                       слово r/m. Иначе очищает|
|                                       ZF и загружает двойное  |
|                                       слово r/m в EAX.        |
-----------------------------------------------------------------

Работа команды

IF аккумулятор = DEST
      ZF <- 1
      DEST <- SRC
ELSE
      ZF <- 0
      аккумулятор <- DEST

Описание
Команда CMPXCHG  сравнивает аккумулятор  (регистр AL,  AX или  EAX) с DEST.
Если  они  равны,  то  SRC  загружается  в  DEST.  В  противном случае DEST
загружается в аккумулятор.
Изменяемые флаги
Флаги  CF,  PF,  AF,  SF  и  OF  изменяются таким образом, как если бы была
выполнена команда CMP с DEST и аккумулятором в качестве операндов. Флаг  ZF
устанавливается, если операнд назначения  и аккумулятор равны; в  противном
случае он очищается.

Исключения защищенного режима
#GP(0), если результат должен помещаться в сегмент, для которого  запрещена
запись;  #GP(0)  в  случае  недопустимого  исполнительного  адреса операнда
памяти в сегментах  CS, DS, ES,  FS или GS;  #SS(0) в случае  недопустимого
адреса в  сегменте SS;  #PF(код сбоя)  в случае  страничного сбоя;  #AC для
невыравненной  ссылки  к  памяти  при  текущем  уровне привилегированности,
равном 3.


Исключения режима реальных адресов
Прерывание  13,  если  какая-либо  часть  операнда  лежит  вне пространства
исполнительных адресов от 0 до 0FFFFH.

Исключения виртуального режима 8086
Те же исключения,  что и для  режима реальных адресов:  #PF (код сбоя)  для
страничных сбоев; #AC для невыравненной ссылки к памяти при текущем  уровне
привилегированности, равном 3.

Примечания
Эта  команда  может  быть  использоваться  с  префиксом LOCK. Для упрощения
интерфейса  с  шиной  процессора  операнд  назначения принимает цикл записи
безотносительно  к   результату  сравнения.   Если  сравнение   закончилось
неудачно,  то  DEST  записывается  назад,  а  в  противном случае в операнд
назначения записывается DEST. (Процессор  никогда не выдает цикла  чтения с
захватом без соответствующей записи  с захватом). Эта команда  процессорами
386  не  поддерживается.  Использование  команды  CMPXCHG совместимым с 386
образом см. в разделе 3.11.


`м`д`05CWD/CDQ`* - Преобразование слова в двойное слова/
                   Преобразование двойного слова в учетверенное слово

-----------------------------------------------------------------
|Код       Команда  Число      Описание                         |
|операции           тактовых                                    |
|                   циклов                                      |
|                                                               |
| 99       CWD        3        DX:AX <- расширение знаком AX    |
| 99       CDQ        3        EDX:EAX <- расширение знаком EAX |
-----------------------------------------------------------------

Работа команды

IF OperandSize = 16 (* команда CWD *)
THEN
  IF AX < 0 THEN DX <- 0FFFFH; ELSE DX <- 0; FI;
ELSE (* OperandSize = 32, команда CDQ *)
  IF EAX < 0 THEN EDX <- 0FFFFFFFFH; ELSE EDX <- 0; FI;
FI;

Описание
Команда CWD  преобразует имеющее  знак слово  в регистре  AX в имеющее знак
двойное слово в паре регистров  DX:AX, расширяя старший бит регистра  AX во
все биты регистра  DX. Команда CDQ  преобразует имеющее знак  двойное слово
из  регистра  EAX  в  имеющее  знак  64-разрядное  целое  в  паре регистров
EDX:EAX, расширяя  старший бит  регистра EAX  (знакового бита)  во все биты
регистра EDX. Отметим, что команда CWD отличается от команды CWDE.  Команда
CWDE использует как назначение регистр EAX, вместо пары регистров DX:AX.

Изменяемые флаги
Отсутствуют

Исключения защищенного режима
Отсутствуют

Исключения режима реальных адресов
Отсутствуют

Исключения виртуального режима 8086
Отсутствуют


`м`д`05DAA`* - Десятичное преобразование AL после сложения

-----------------------------------------------------------------
|Код       Команда  Число      Описание                         |
|операции           тактовых                                    |
|                   циклов                                      |
|                                                               |
| 27       DAA        2        Десятичное преобразование AL     |
|                              после сложения                   |
-----------------------------------------------------------------

Работа команды

IF ((AL AND 0FH) > 9) OR (AF = 1)
THEN
  AL <- AL + 6;
  AF <- 1;
ELSE
  AF <- 0;
FI;

IF (AL > 9FH) OR (CF = 1)
THEN
  AL <- AL + 60H;
  CF <- 1;
ELSE CF <- 0;
FI;

Описание
Команда  DAA  выполняется  только  после  команды  ADD, которая оставляет в
регистре AL результат, представляющий собой байт, в котором содержатся  две
двоично-десятичные цифры. Операнды ADD должны состоять из двух  упакованных
двоично-десятичных цифр. Команда DAA преобразует регистр AL таким  образом,
чтобы он содержал правильный двузначный упакованный десятичный результат.

Изменяемые флаги
Флаги AF и CF устанавливаются при наличии десятичного переноса и  очищаются
при его отсутствии; флаги SF, ZF, PF и CF устанавливаются в соответствии  с
результатом.

Исключения защищенного режима
Отсутствуют

Исключения режима реальных адресов
Отсутствуют

Исключения виртуального режима 8086
Отсутствуют


`м`д`05DAS`* - Десятичное преобразование AL после вычитания

-----------------------------------------------------------------
|Код       Команда  Число      Описание                         |
|операции           тактовых                                    |
|                   циклов                                      |
|                                                               |
| 2F       DAS        2        Десятичное преобразование AL     |
|                              после вычитания                  |
-----------------------------------------------------------------

Работа команды

IF ((AL AND 0FH) > 9) OR  AF = 1
THEN
  AL <- AL - 6;
  AF <- 1;
ELSE
  AF <- 0;
FI;
IF (AL > 9FH) OR (CF = 1)
THEN
  AL <- AL - 60H;
  CF <- 1;
ELSE CF <- 0;
FI;


Описание
Команда DAS выполняется только  после команды вычитания, которая  оставляет
в регистре AL  результат, представляющий собой  байт, в котором  содержатся
две двоично-десятичные цифры. Операнды должны состоять из двух  упакованных
двоично-десятичных цифр. Команда DAS преобразует регистр AL таким  образом,
чтобы он содержал правильный двузначный упакованный десятичный результат.

Изменяемые флаги
Флаги AF и CF устанавливаются при наличии десятичного переноса и  очищаются
при его отсутствии; флаги SF, ZF, PF и CF устанавливаются в соответствии  с
результатом.

Исключения защищенного режима
Отсутствуют

Исключения режима реальных адресов
Отсутствуют

Исключения виртуального режима 8086
Отсутствуют

`м`д`05DEC`* - Декремент на 1

-----------------------------------------------------------------
|Код       Команда  Число      Описание                         |
|операции           тактовых                                    |
|                   циклов                                      |
|                                                               |
|FE /1     DEC r/m8  1/3       Декремент байта r/m на 1         |
|FF /1     DEC r/m16 1/3       Декремент слова r/m на 1         |
|          DEC r/m32 1/3       Декремент двойного слова r/m на 1|
|48 + rw   DEC r16   1         Декремент слова в регистре на 1  |
|48 + rd   DEC r32   1         Декремент двойного слова         |
|                              в регистре на 1                  |
-----------------------------------------------------------------

Работа команды

DEST <- DEST - 1;

Описание
Команда DEC вычитает 1 из операнда.  Команда DEC не изменяет флага CF.  Для
воздействия  на  флаг  CF   используйте  команду  SUB  с   непосредственным
операндом, равным 1.

Изменяемые флаги
Флаги OF, SF, ZF, AF и PF устанавливаются в соответствии с результатом.

Исключения защищенного режима
#GP(0), если результат должен помещаться в сегмент, для которого  запрещена
запись;  #GP(0)  в  случае  недопустимого  исполнительного  адреса операнда
памяти в сегментах  CS, DS, ES,  FS или GS;  #SS(0) в случае  недопустимого
адреса в  сегменте SS;  #PF(код сбоя)  в случае  страничного сбоя;  #AC для
невыравненной  ссылки  к  памяти  при  текущем  уровне привилегированности,
равном 3.

Исключения режима реальных адресов
Прерывание  13,  если  какая-либо  часть  операнда  лежит  вне пространства
исполнительных адресов от 0 до 0FFFFH.

Исключения виртуального режима 8086
Те же исключения,  что и для  режима реальных адресов:  #PF (код сбоя)  для
страничных сбоев; #AC для невыравненной ссылки к памяти при текущем  уровне
привилегированности, равном 3.


`м`д`05DIV`* - Деление без знака

-----------------------------------------------------------------
|Код       Команда  Число      Описание                         |
|операции           тактовых                                    |
|                   циклов                                      |
|                                                               |
|F6 /6     DIV AL,r/m8  16/16  Деление без знака AX на байт r/m |
|                              (AL=частное, AH=остаток)         |
|F7 /6     DIV AX,r/m16 24/24  Деление без знака DX:AX на слово |
|                              r/m (AX=частное, DX = остаток)   |
|F7 /6    DIV EAX,r/m32 40/40  Деление без знака EDX:EAX на     |
|                              двойное слово r/m                |
|                              (EAX=частное,EDX = остаток)      |
-----------------------------------------------------------------

Работа команды

врем <- делимое / делитель;
IF врем не помещается в частном
THEN Прерывание 0;
ELSE
  частное <- врем;
  остаток <- делимое MOD (r/m);
FI;

Замечание: деление без  знака. Делитель задается  в операнде r/m.  Делимое,
частное  и  остаток  используют  неявно  задаваемые регистры. См. таблицу в
параграфе "Описание".

Описание
Команда  DIV  выполняет  деление  без  знака.  Делимое  задается  неявно: в
качестве  операнда   задается  только   делитель.  Остаток   всегда  меньше
делителя. Тип делителя определяет используемые регистры следующим образом:

  Размер      Делитель      Частное      Остаток      Делимое
-----------------------------------------------------------------
  байт        AX            r/m8         AL           AH
  слово       DX:AX         r/m16        AX           DX
  двойное
  слово       EDX:EAX       r/m32        EAX          EDX
-----------------------------------------------------------------

Изменяемые флаги
Флаги OF, SF, ZF, AF, PF, CF не определены.

Исключения защищенного режима
Прерывание  0,  если  частное  слишком  велико  для  назначенного  для него
регистра (AL,  AX или  EAX), или  если делитель  равен 0;  #GP(0) в  случае
недопустимого исполнительного  адреса операнда  памяти в  сегментах CS, DS,
ES, FS или GS; #SS(0) в случае недопустимого адреса в сегменте SS;  #PF(код
сбоя) в случае страничного сбоя; #AC для невыравненной ссылки к памяти  при
текущем уровне привилегированности, равном 3.

Исключения режима реальных адресов
Прерывание  0,  если  частное  слишком  велико  для  назначенного  для него
регистра (AL, AX или EAX), или  если делитель равен 0; Прерывание 13,  если
какая-либо часть операнда лежит вне пространства исполнительных адресов  от
0 до 0FFFFH.

Исключения виртуального режима 8086
Те же исключения,  что и для  режима реальных адресов:  #PF (код сбоя)  для
страничных сбоев; #AC для невыравненной ссылки к памяти при текущем  уровне
привилегированности, равном 3.


`м`д`05ENTER`* - Создание кадра стека для параметров процедуры

-----------------------------------------------------------------
|Код       Команда  Число      Описание                         |
|операции           тактовых                                    |
|                   циклов                                      |
|                                                               |
|C8 iw 00 ENTER imm16,0  14    Создание кадра стека             |
|                              процедуры                        |
|C8 iw 01 ENTER imm16,1  17    Создание кадра стека             |
|                              для параметров процедуры         |
|C8 iw ib ENTER imm16,  17+3n  Создание кадра стека             |
|               imm8           для параметров процедуры         |
-----------------------------------------------------------------

Работа команды

уровень <- уровень MOD 32
IF OperandSize = 16 THEN Push(BP) ELSE Push(EBP) FI;
  (* Сохранить указатель стека *)
указатель-стека <- eSP
IF уровень > 0
THEN (* уровень это крайний правый параметр *)
  FOR i <- 1 TO уровень - 1
  DO
    IF OperandSize = 16
    THEN
      BP <- BP -2;
      Push[BP]
    ELSE (* OperandSize = 32 *)
      EBP <- EBP - 4;
      Push[EBP];
    FI;
  OD;
  Push(указатель-стека)
FI;
IF OperandSize  =  16  THEN  BP  <-  указатель-стека  ELSE EBP <-
                                           указатель-стека; FI;
IF StackAddrSize = 16 (* Размер адреса стека = 16 *)
THEN SP <- SP - Первый операнд;
ELSE ESP <- ESP - ZeroExtend(Первый операнд); (* Расширение нулем*)
FI;

Описание
Команда  ENTER  создает  кадр  стека,  требуемый  для  большинства   языков
высокого  уровня  блочной  структуры.  Первый  операнд  задает число байтов
динамической памяти, распределяемой в  стеке при вхождении в  подпрограмму.
Второй  операнд  задает  уровень  лексической  вложенности  (  от  0 до 31)
подпрограммы в  исходном коде  языка высокого  уровня. Он  определяет число
указателей  кадра  стека,  копируемых  в  новый кадра стека из предыдущего.
Регистр BP  (или EBP,  если атрибут  размера операнда  равен 32  битам) это
указатель текущего кадра стека.

Если атрибут размера операнда равен 16 битам, процессор использует  регистр
BP в  качестве указателя  кадра и  регистр SP  в качестве  указателя стека.
Если  атрибут  размера  операнда  равен  32  битам, то процессор использует
регистр EBP в качестве указателя  кадра и регистр ESP в  качестве указателя
стека.
Если второй  операнд равен  0, то  команда ENTER  помещает в стек указатель
кадра (регистр BP или EBP); затем команда ENTER вычитает первый операнд  из
указателя стека  и устанавливает  указатель кадра  равным текущему значению
указателя стека.
Например, процедура с 12 байтами локальных переменных в точке входа  должна
иметь команду  ENTER 12,0  и команду  LEAVE перед  каждой командой  RET. 12
локальных байтов должны  адресоваться как негативные  смещения относительно
указателя кадра.

Изменяемые флаги
Отсутствуют

Исключения защищенного режима
#SS(0),  если  значение  SP  или  ESP  превысит границу стека в любой точке
выполнения команды; #PF(код сбоя) в случае страничного сбоя;

Исключения режима реальных адресов
Отсутствуют

Исключения виртуального режима 8086
Отсутствует


                    x
`м`д`05F2XM1`* - Вычисление 2 - 1
-----------------------------------------------------------------
|Код       Команда  Число      Описание                         |
|операции           тактовых                                    |
|                   циклов                                      |
|                                                ST             |
|D9 F0    F2XM1    242(140-279) Заменяет ST на (2  - 1)         |
-----------------------------------------------------------------

Работа команды
        ST
ST <- (2  - 1);

Описание ST  Команда F2XM1  заменяет содержимое  ST на  (2 -  1). ST должен
находиться в диапазоне -1 < ST < 1.

Изменяемые флаги модуля операций с плавающей точкой
C1, как описано в Таблице 15-1; C0, C2, C3 не определены.

Исключения числовых операций
P, U, D, I, IS

Исключения защищенного режима
#NM при установленном EM или TS в CR0.

Исключения режима реальных адресов
Прерывание 7 при установленном EM или TS в CR0.

Исключения виртуального режима 8086
#NM при установленном EM или TS в CR0.

Примечания
Если операнд находится вне допустимого диапазона, то результат F2XM1
неопределен.

Команда F2XM1 предназначениа для  получения очень точного результата,  даже
когда операнд  близок к  нулю. Для  операндов с  абсолютной величиной очень
близкой к 1 образуются большие значения погрешности.

Значения, не равные 2, могут возводиться в степень по формуле:

      y      (y x log x)
     X   = 2         2

Команды FLDL2T и FLDL2E загружают константы log 10 и log e,
                                               2        2
соответственно. FYL2X может быть использована для вычисления
y x log x для произвольного положительного x.
       2

`м`д`05FABS`* - Абсолютное значение

-----------------------------------------------------------------
|Код       Команда  Число      Описание                         |
|операции           тактовых                                    |
|                   циклов                                      |
|                                                               |
|D9 E1    FABS         3        Заменяет ST на его абсолютное   |
|                               значение                        |
-----------------------------------------------------------------

Работа команды

знаковый бит ST <- 0

Описание
Команда  абсолютного  значения  FABS  очищает  знаковый  бит  ST.  Операция
оставляет   положительное   значение    без   изменений,   либо    заменяет
отрицательное значение положительным, равным по абсолютной величине.

Изменяемые флаги модуля операций с плавающей точкой
C1, как описано в таблице 15-1; C0, C2, C3 не определены.

Исключения числовых операций
IS

Исключения защищенного режима
#NM при установленном EM или TS в CR0.

Исключения режима реальных адресов
Прерывание 7 при установленном EM или TS в CR0.

Исключения виртуального режима 8086
#NM при установленном EM или TS в CR0.

Примечания
Исключение неверной операции возникает только при потере значимости  стека,
даже если операнд сообщает о NaN или имеет неподдерживаемый формат.


`м`д`05FADD/FADDP/FIADD`* - Сложение

-----------------------------------------------------------------
|Код          Команда  Число     Парал-  Описание               |
|операции              тактовых  лельное                        |
|                      циклов    выпол-                         |
|                                нение                          |
|D8 /0   FADD m32real   10(8-20)  7(5-17) Сложение m32real с ST |
|DC /0   FADD m64real   10(8-20)  7(5-17) Сложение m64real с ST |
|D8 C0+i FADD ST,ST(i)  10(8-20)  7(5-17) Сложение ST(i)с  ST   |
|DC C0+i FADD ST(i),ST  10(8-20)  7(5-17) Сложение ST с ST(i)   |
|DE C0+i FADDP ST(i),ST 10(8-20)  7(5-17) Сложение ST с ST(i) и |
|                                         извлечение из стека ST|
|DE C1   FADD           10(8-20)  7(5-17) Сложение ST с ST(1) и |
|                                         извлечение из стека ST|
|DA /0  FIADD m32int  22.5(19-32) 7(5-17) Сложение m32int  с ST |
|DE /0  FIADD m16int   24(20-35)  7(5-17) Сложение m16int  с ST |
-----------------------------------------------------------------

Работа команды

DEST <- DEST + SRC;
IF команда = FADDP THEN извлечение из стека ST  FI;

Описание
Команды сложения  складывают операнды  источника и  назначения и возвращают
сумму  в  операнд  назначения.  Операнд  в  вершине стека может быть удвоен
кодированием:

FADD ST, ST(0)
Изменяемые флаги модуля операций с плавающей точкой
C1, как описано в таблице 15-1; C0, C2, C3 не определены.

Исключения числовых операций
P, U, O, D, I, IS

Исключения защищенного режима
#GP(0)  в  случае  недопустимого  исполнительного  адреса операнда памяти в
сегментах CS, DS,  ES, FS или  GS; #SS(0) в  случае недопустимого адреса  в
сегменте  SS;   #PF(код  сбоя)   в  случае   страничного  сбоя;   #NM   при
установленном EM или TS  в CR0; #AC для  невыравненной ссылки к памяти  при
текущем уровне привилегированности, равном 3.

Исключения режима реальных адресов
Прерывание  13,  если  какая-либо  часть  операнда  лежит  вне пространства
исполнительных адресов от  0 до 0FFFFH;  Прерывание 7 при  установленном EM
или TS в CR0.

Исключения виртуального режима 8086
Те же исключения,  что и для  режима реальных адресов:  #PF (код сбоя)  для
страничных сбоев; #AC для невыравненной ссылки к памяти при текущем  уровне
привилегированности, равном 3.

Примечания
Если   исходный   операнд    находится   в    памяти,   он    автоматически
преобразовывается в расширенный действительный формат.


`м`д`05FBLD`* - Загрузка двоично-кодированного десятичного

-----------------------------------------------------------------
|Код          Команда  Число     Парал-     Описание            |
|операции              тактовых  лельное                        |
|                      циклов    выпол-                         |
|                                нение                          |
|                                                               |
|D8 /4      FBLD m80dec 75(70-103) 7.7(2-8) Помещение в стек FPU|
|                                           m80dec              |
-----------------------------------------------------------------

Работа команды

Декремент указателя вершины стека модуля с плавающей точкой (FPU);
ST(0) <- SRC;

Описание
FBLD   преобразует   двоично-десятичный   операнд-источник   в  расширенный
действительный   формат   и   помещает   его   в   стек   FPU.    Структура
двоично-десятичных данных показана на Рисунке 15-10.

Изменяемые флаги модуля операций с плавающей точкой
C1, как описано в таблице 15-1; C0, C2, C3 не определены.

Исключения числовых операций
IS

Исключения защищенного режима
#GP(0)  в  случае  недопустимого  исполнительного  адреса операнда памяти в
сегментах CS, DS,  ES, FS или  GS; #SS(0) в  случае недопустимого адреса  в
сегменте  SS;   #PF(код  сбоя)   в  случае   страничного  сбоя;   #NM   при
установленном EM или TS  в CR0; #AC для  невыравненной ссылки к памяти  при
текущем уровне привилегированности, равном 3.

Исключения режима реальных адресов
Прерывание  13,  если  какая-либо  часть  операнда  лежит  вне пространства
исполнительных адресов от  0 до 0FFFFH;  Прерывание 7 при  установленном EM
или TS в CR0.

Исключения виртуального режима 8086
Те же исключения,  что и для  режима реальных адресов:  #PF (код сбоя)  для
страничных сбоев; #AC для невыравненной ссылки к памяти при текущем  уровне
привилегированности, равном 3.

Примечания
Источник  загружается  без  ошибки  округления. Знак источника сохраняется,
включая случай, когда значение представляет собой отрицательный ноль.
Упакованные десятичные  цифры предполагаются  принадлежащими диапазону  0 -
9.  Команда  не  проверяет  наличия  недопустимых  цифр (A-FH), и результат
попытки загрузки при неверном кодировании неопределен.
ST(7) должен быть пустым, чтобы избежать исключения неверной операции.


`м`д`05FBSTR`* -  Сохранить двоично-кодированное  десятичное и  выполнить
                        извлечение из стека

-----------------------------------------------------------------
|Код          Команда  Число      Описание                      |
|операции              тактовых                                 |
|                      циклов                                   |
|                                                               |
|                                                               |
|D8 /6     FBSTR m80dec 175        Сохранение ST в m80dec и     |
|                       (172-176)  извлечение из стека ST       |
-----------------------------------------------------------------

Работа команды

DEST <- ST(0);
извлечение из стека ST;  FI;

Описание
Команда FBSTR  преобразует значение  в ST  в упакованное  десятичное целое,
сохраняет результат в  операнд назначения в  памяти и выполняет  извлечение
из стека ST. Не-целочисленные  значения сначала округляются в  соответствии
с  полем  RC  управляющего   слова.  Структура  двоично-десятичных   данных
показана на Рисунке 15-10.

Изменяемые флаги модуля операций с плавающей точкой
C1, как описано в Таблице 15-1; C0, C2, C3 не определены.

Исключения числовых операций
P, I, IS

Исключения защищенного режима
#GP(0), если результат должен помещаться в сегмент, для которого  запрещена
запись;  #GP(0)  в  случае  недопустимого  исполнительного  адреса операнда
памяти в сегментах  CS, DS, ES,  FS или GS;  #SS(0) в случае  недопустимого
адреса в  сегменте SS;  #PF(код сбоя)  в случае  страничного сбоя;  #NM при
установленном EM или TS  в CR0; #AC для  невыравненной ссылки к памяти  при
текущем уровне привилегированности, равном 3.

Исключения режима реальных адресов
Прерывание  13,  если  какая-либо  часть  операнда  лежит  вне пространства
исполнительных адресов от  0 до 0FFFFH;  Прерывание 7 при  установленном EM
или TS в CR0.

Исключения виртуального режима 8086
Те же исключения,  что и для  режима реальных адресов:  #PF (код сбоя)  для
страничных сбоев; #AC для невыравненной ссылки к памяти при текущем  уровне
привилегированности, равном 3.


`м`д`05FCHS`* - Изменение знака

-----------------------------------------------------------------
|Код       Команда  Число      Описание                         |
|операции           тактовых                                    |
|                   циклов                                      |
|                                                               |
|D9 E0    FCHS         6        Заменяет ST на его же значение, |
|                               но с противоположным знаком     |
-----------------------------------------------------------------

Работа команды

знаковый бит ST <- NOT (знаковый бит в ST)

Описание
Команда  изменение  знака  FCHS  меняет  на  противоположный  знак  ST. Эта
операция  заменяет  положительное  значение  на  отрицательное  при  той же
абсолютной величине, и наоборот.

Изменяемые флаги модуля операций с плавающей точкой
C1, как описано в Таблице 15-1; C0, C2, C3 не определены.

Исключения числовых операций
IS

Исключения защищенного режима
#NM при установленном EM или TS в CR0.

Исключения режима реальных адресов
Прерывание 7 при установленном EM или TS в CR0.

Исключения виртуального режима 8086
#NM при установленном EM или TS в CR0.

Примечания
Исключение неверной операции возникает только при потере значимости  стека,
даже если операнд сообщает о NaN или имеет неподдерживаемый формат.

`м`д`05FCLEX/FNCLEX`* - Очистить исключения

-----------------------------------------------------------------
|Код       Команда  Число      Описание                         |
|операции           тактовых                                    |
|                   циклов                                      |
|                                                               |
|DB DB E2  FCLEX  7+минимум 3  Очищает флаги исключения         |
|                 для FWAIT    после проверки условий ошибки    |
|                              с плавающей точкой               |
|DB E2    FNCLEX  7            Очищает флаги исключения         |
|                              без   проверки условий ошибки    |
|                              с плавающей точкой               |
-----------------------------------------------------------------

Работа команды

SW[0..7] <- 0;
SW[15] <- 0;

Описание
FCLEX очищает флаги  исключений, флаг состояния  исключения и флаг  Занят в
слове состояния FPU.

Изменяемые флаги модуля операций с плавающей точкой
C0, C2, C3 не определены.

Исключения числовых операций
Отсутствуют

Исключения защищенного режима
#NM при установленном EM или TS в CR0.

Исключения режима реальных адресов
Прерывание 7 при установленном EM или TS в CR0.

Исключения виртуального режима 8086
#NM при установленном EM или TS в CR0.

Примечания
FCLEX проверяет  условия немаскируемых  ошибок операций  с плавающей точкой
перед тем,  как будут  очищены флаги  исключений; команда  FNCLEX этого  не
делает.


`м`д`05FCOM/FCOMP/FCOMPP`* - Сравнение действительных чисел

-----------------------------------------------------------------
|Код       Команда  Число      Описание                         |
|операции           тактовых                                    |
|                   циклов                                      |
|                                                               |
|D8 /2   FCOM m32real  4       Сравнение ST с m32real           |
|DC /2   FCOM m64real  4       Сравнение ST с m64real           |
|D8 D0+i FCOM ST(i)    4       Сравнение ST с ST(i)             |
|D8 D1   FCOM          4       Сравнение ST с ST(1)             |
|D8 /3   FCOMP m32real 4       Сравнение ST с m32real           |
|                              и извлечение из стека ST         |
|DC /3   FCOMP m64real 4       Сравнение ST с m64real           |
|                              и извлечение из стека ST         |
|D8 D8+i FCOMP ST(i)   4       Сравнение ST с ST(i)             |
|                              и извлечение из стека ST         |
|D8 D9   FCOMP         4       Сравнение ST с ST(1)             |
|                              и извлечение из стека ST         |
|DE D9   FCOMPP        5       Сравнение ST с ST(1)             |
|                              и извлечение из стека ST дважды  |
-----------------------------------------------------------------

Работа команды

CASE (отношение операндов) OF
   Не сравнимы:   C3, C2, C0 <- 111;
   ST > SRC:      C3, C2, C0 <- 000;
   ST < SRC:      C3, C2, C0 <- 001;
   ST = SRC:      C3, C2, C0 <- 100;
IF команда = FCOMP THEN извлечение из стека ST; FI;
IF команда = FCOMPP THEN извлечение  из  стека  ST;извлечение  из
                                                   стека ST; FI;

-----------------------------------------------------------------
           Флаги FPU          |            EFlags
-----------------------------------------------------------------
             C0                              CF
             C1                              отсутствует
             C2                              PF
             C3                              ZF
-----------------------------------------------------------------

Описание
Команды  сравнения   действительных  чисел   сравнивают  вершину   стека  с
источником,  который  может  являться   регистром  или  операндом   памяти,
являющимся  действительным  числом  одинарной  или  двойной  точности. Если
операнд не  задан, то  ST сравнивается  с ST(1).  После выполнения  команды
условные коды отражают отношение между ST и исходным операндом.

Изменяемые флаги модуля операций с плавающей точкой
C1, как описано в таблице 15-1; C0, C2, C3 не определены.

Исключения числовых операций
D, I, IS

Исключения защищенного режима
#GP(0)  в  случае  недопустимого  исполнительного  адреса операнда памяти в
сегментах CS, DS,  ES, FS или  GS; #SS(0) в  случае недопустимого адреса  в
сегменте  SS;   #PF(код  сбоя)   в  случае   страничного  сбоя;   #NM   при
установленном EM или TS  в CR0; #AC для  невыравненной ссылки к памяти  при
текущем уровне привилегированности, равном 3.

Исключения режима реальных адресов
Прерывание  13,  если  какая-либо  часть  операнда  лежит  вне пространства
исполнительных адресов от  0 до 0FFFFH;  Прерывание 7 при  установленном EM
или TS в CR0.

Исключения виртуального режима 8086
Те же исключения,  что и для  режима реальных адресов:  #PF (код сбоя)  для
страничных сбоев; #AC для невыравненной ссылки к памяти при текущем  уровне
привилегированности, равном 3.

Примечания
Если  любой  из  операндов  имеет  значение  NaN,  или имеет неопределенный
формат,  либо  при  сбое  в  стеке,  то  генерируется  исключение  неверной
операции, а биты условия устанавливаются в значение "неупорядочен".

Знак нулевого значения игнорируется, таким образом что -0.0 = - +0.0.


`м`д`05FCOS`* - Косинус

-----------------------------------------------------------------
|Код      Команда  Число       Парал-  Описание                 |
|операции          тактовых    лельное                          |
|                  циклов      выпол-                           |
|                              нение                            |
|D8 FF    FCOS    241(193-279)   2     Замена ST его косинусом  |
-----------------------------------------------------------------


Работа команды

IF операнд в допустимом диапазоне
THEN
   C2 <- 0;
   ST <- cos(ST);
ELSE
   C2 <- 1;
FI;

 Описание
Команда FCOS заменяет содержимое ST  на cos(ST). Значение ST, выраженное  в
радианах, должно лежать в диапазоне | O | < 2**63.

Изменяемые флаги модуля операций с плавающей точкой
C1,C2 как описано в Таблице 15-1; C0, C3 не определены.

Исключения числовых операций
P, U, D, I, IS

Исключения защищенного режима
#NM при установленном EM или TS в CR0.

Исключения режима реальных адресов
Прерывание 7 при установленном EM или TS в CR0.

Исключения виртуального режима 8086
#NM при установленном EM или TS в CR0.

Примечания
Если операнд находится вне допустимого диапазона, то флаг C2 установлен,  а
ST  остается  неизмененным.  Программист  сам  ответственен  за  то,  чтобы
уменьшить  операнд  до  абсолютного  значения,  меньшего чем 2**63, вычитая
соответствующее число,  кратное 2  пи. См.м  раздел 17.5,  где описано, как
правильно записать значение числа пи при выполнении такого рода вычитания.
При выполнении данной команды процессор i486 проверяет наличие  прерываний.
Для обслуживания прерывания выполнение команды отменяется (abort).


`м`д`05FDECSTP`* - Декремент указателя вершины стека

-----------------------------------------------------------------
|Код       Команда  Число      Описание                         |
|операции           тактовых                                    |
|                   циклов                                      |
|                                                               |
|D9 F6     FDECSTP     3       Декремент указателя вершины стека|
|                              для регистрового стека FPU       |
-----------------------------------------------------------------

Работа команды

IF TOP = 0
THEN TOP <- 7;
ELSE TOP <- TOP -1;
FI;

Описание
FDECSTP вычитает  единицу (без  переноса) из  трех-битового поля  TOP слова
состояния модуля операций с плавающей точкой (FPU).

Изменяемые флаги модуля операций с плавающей точкой
C1, как описано в Таблице 15-1; C0, C2, C3 не определены.

Исключения числовых операций
Отсутствуют

Исключения защищенного режима
#NM при установленном EM или TS в CR0.

Исключения режима реальных адресов
Прерывание 7 при установленном EM или TS в CR0.

Исключения виртуального режима 8086
#NM при установленном EM или TS в CR0.

Примечания
Действие  команды  RDECSTP  состоит  в  циклическом  сдвиге  стека.  Она не
изменяет теги регистров или их содержимое и не выполняет пересылки данных.


`м`д`05FDIV/FDIVP/FIDIV`*  - Деление

-----------------------------------------------------------------
|Код      Команда  Число       Парал-  Описание                 |
|операции          тактовых    лельное                          |
|                  циклов      выпол-                           |
|                              нение                            |
|D8 /6   FDIV m32real   73      70     Деление ST на m32real    |
|DC /6   FDIV m64real   73      70     Деление ST на m64real    |
|D8 F0+i FDIV ST,ST(i)  73      70     Деление ST на ST(i)      |
|DC F8+i FDIV ST(i),ST  73      70     Замена ST(i) на ST/ST(i) |
|DE F8+i FDIVP ST(i),ST 73      70     Замена ST(i) на ST/ST(i);|
|                                      извлечение из стека ST   |
|DE F9   FDIV           73      70     Замена ST(1) на ST/ST(1);|
|                                      извлечение из стека ST   |
|DA /6   FIDIV m32int   73      70     Деление ST на m32int     |
|DE /6   FIDIV m64int   73      70     Деление ST на m64int     |
-----------------------------------------------------------------

Работа команды

DEST <- ST / Другой операнд;
IF команда = FDIVP THEN извлечение из стека ST  FI;

Описание
Команды  деления  делят  вершину  стека  на  прочие  операнды  и возвращают
частное в операнд назначения.

Изменяемые флаги модуля операций с плавающей точкой
C1, как описано в Таблице 15-1; C0, C2, C3 не определены.

Исключения числовых операций
P,U,O,Z,D,I,IS

Исключения защищенного режима
#GP(0)  в  случае  недопустимого  исполнительного  адреса операнда памяти в
сегментах CS, DS,  ES, FS или  GS; #SS(0) в  случае недопустимого адреса  в
сегменте  SS;   #PF(код  сбоя)   в  случае   страничного  сбоя;   #NM   при
установленном EM или TS  в CR0; #AC для  невыравненной ссылки к памяти  при
текущем уровне привилегированности, равном 3.

Исключения режима реальных адресов
Прерывание  13,  если  какая-либо  часть  операнда  лежит  вне пространства
исполнительных адресов от  0 до 0FFFFH;  Прерывание 7 при  установленном EM
или TS в CR0.

Исключения виртуального режима 8086
Те же исключения,  что и для  режима реальных адресов:  #PF (код сбоя)  для
страничных сбоев; #AC для невыравненной ссылки к памяти при текущем  уровне
привилегированности, равном 3.

Примечания
Если   исходный   операнд   находится   в   памяти,   то  он  автоматически
преобразуется к расширенному действительному формату.
Быстродействие  команды  зависит  от   поля  PC  (Управление  Точностью   -
Precision Control) слова управления FPU.  Если PC задает точность 53  бита,
то команда  деления выполняется  за 62  тактовых циклов.  Если же PC задает
точность  24  бита,  то  команда  деления  выполняется всего за 35 тактовых
циклов.


`м`д`05FDIVR/FDIVPR/FIDIVR`*  - Деление в обратном порядке

-----------------------------------------------------------------
|Код      Команда  Число       Парал-  Описание                 |
|операции          тактовых    лельное                          |
|                  циклов      выпол-                           |
|                              нение                            |
|D8 /7   FDIVR m32real   73     70     Замена ST на m32real/ST  |
|DC /7   FDIVR m64real   73     70     Замена ST на m64real/ST  |
|D8 F8+i FDIVR ST,ST(i)  73     70     Замена ST на ST(i)/ST    |
|DC F0+i FDIVR ST(i),ST  73     70     Деление ST(i) на ST      |
|DE F0+i FDIVRP ST(i),ST 73     70     Деление ST(i) на ST и    |
|                                      извлечение из стека ST   |
|DE F1   FDIVR           73     70     Деление ST(1) на ST и    |
|                                      извлечение из стека ST   |
|DA /7   FIDIVR m32int   73     70     Замена ST на m32int/ST   |
|DE /7   FIDIVR m16int   73     70     Замена ST на m16int/ST   |
-----------------------------------------------------------------

Работа команды

DEST <- Другой операнд / ST;
IF команда = FDIVRP THEN извлечение из стека ST  FI;

Описание
Команды деления делят другой операнд на вершину стека и возвращают  частное
в операнд назначения.

Изменяемые флаги модуля операций с плавающей точкой
C1, как описано в Таблице 15-1; C0, C2, C3 не определены.

Исключения числовых операций
P,U,O,Z,D,I,IS

Исключения защищенного режима
#GP(0)  в  случае  недопустимого  исполнительного  адреса операнда памяти в
сегментах CS, DS,  ES, FS или  GS; #SS(0) в  случае недопустимого адреса  в
сегменте  SS;   #PF(код  сбоя)   в  случае   страничного  сбоя;   #NM   при
установленном EM или TS  в CR0; #AC для  невыравненной ссылки к памяти  при
текущем уровне привилегированности, равном 3.

Исключения режима реальных адресов
Прерывание  13,  если  какая-либо  часть  операнда  лежит  вне пространства
исполнительных адресов от  0 до 0FFFFH;  Прерывание 7 при  установленном EM
или TS в CR0.

Исключения виртуального режима 8086
Те же исключения,  что и для  режима реальных адресов:  #PF (код сбоя)  для
страничных сбоев; #AC для невыравненной ссылки к памяти при текущем  уровне
привилегированности, равном 3.

Примечания
Если   исходный   операнд   находится   в   памяти,   то  он  автоматически
преобразуется к расширенному действительному формату.
Быстродействие команд зависит от поля PC (Управление Точностью -  Precision
Control) слова управления FPU. Если PC задает точность 53 бита, то  команда
деления выполняется за  62 тактовых циклов.  Если же PC  задает точность 24
бита, то команда деления выполняется всего за 35 тактовых циклов.


`м`д`05FFREE`*   - Освободить регистр операций с плавающей точкой

-----------------------------------------------------------------
|Код       Команда  Число      Описание                         |
|операции           тактовых                                    |
|                   циклов                                      |
|                                                               |
|DD C0+i   FFREE ST(i) 3       Пометить тег (признак) ST(i) как |
|                              пустой                           |
-----------------------------------------------------------------

Работа команды

TAG(i) <- 11B;

Описание
FDECSTP помечает регистр назначения как пустой.
Изменяемые флаги модуля операций с плавающей точкой
C0, C0, C2, C3 не определены.
Исключения числовых операций
Отсутствуют
Исключения защищенного режима
#NM при установленном EM или TS в CR0.
Исключения режима реальных адресов
Прерывание 7 при установленном EM или TS в CR0.
Исключения виртуального режима 8086
#NM при установленном EM или TS в CR0.
Примечания
FFREE не влияет на содержимое  регистра назначения. Она также не  влияет на
содержимое указателя вершины стека с плавающей точкой (TOP).


`м`д`05FICOM/FICOMP `*- Сравнение целочисленных значений

-----------------------------------------------------------------
|Код      Команда  Число       Парал-  Описание                 |
|операции          тактовых    лельное                          |
|                  циклов      выпол-                           |
|                              нение                            |
|DE /2   FICOM m16real 18(16-20)   1   Сравнение ST с m16int    |
|DA /2   FICOM m32real 16.5(15-17) 1   Сравнение ST с m32int    |
|DE /3  FICOMP m16int  18(16-20)   1   Сравнение ST с m16int и  |
|                                      извлечение из стека ST   |
|DA /3  FICOMP m32int  16.5(15-17) 1   Сравнение ST с m32int и  |
|                                      извлечение из стека ST   |
-----------------------------------------------------------------

Работа команды

CASE (отношение операндов) OF
   Не сравнимы:   C3, C2, C0 <- 111;
   ST > SRC:      C3, C2, C0 <- 000;
   ST < SRC:      C3, C2, C0 <- 001;
   ST = SRC:      C3, C2, C0 <- 100;
IF команда = FICOMP THEN извлечение из стека ST; FI;

-----------------------------------------------------------------
           Флаги FPU          |            EFlags
-----------------------------------------------------------------
             C0                              CF
             C1                              отсутствует
             C2                              PF
             C3                              ZF
-----------------------------------------------------------------

Описание
Команды  целочисленного  сравнения  сравнивают  вершину  стека  с  исходным
операндом.  После  выполнения  команды  условные  коды отражают соотношение
между ST и исходным операндом.

Изменяемые флаги модуля операций с плавающей точкой
C1, как описано в таблице 15-1; C0, C2, C3 не определены.

Исключения числовых операций
D,I,IS

Исключения защищенного режима
#GP(0)  в  случае  недопустимого  исполнительного  адреса операнда памяти в
сегментах CS, DS,  ES, FS или  GS; #SS(0) в  случае недопустимого адреса  в
сегменте  SS;   #PF(код  сбоя)   в  случае   страничного  сбоя;   #NM   при
установленном EM или TS  в CR0; #AC для  невыравненной ссылки к памяти  при
текущем уровне привилегированности, равном 3.

Исключения режима реальных адресов
Прерывание  13,  если  какая-либо  часть  операнда  лежит  вне пространства
исполнительных адресов от  0 до 0FFFFH;  Прерывание 7 при  установленном EM
или TS в CR0.

Исключения виртуального режима 8086
Те же исключения,  что и для  режима реальных адресов:  #PF (код сбоя)  для
страничных сбоев; #AC для невыравненной ссылки к памяти при текущем  уровне
привилегированности, равном 3.

Примечания
Если   исходный   операнд   находится   в   памяти,   то  он  автоматически
преобразуется к расширенному действительному формату.
Если  любой  из  операндов  имеет  значение  NaN,  или имеет неопределенный
формат,  либо  при  сбое  в  стеке,  то  генерируется  исключение  неверной
операции, а биты условия устанавливаются в значение "неупорядочен".


`м`д`05FILD`* - Загрузка целочисленного операнда

-----------------------------------------------------------------
|Код      Команда  Число       Парал-  Описание                 |
|операции          тактовых    лельное                          |
|                  циклов      выпол-                           |
|                              нение                            |
|DF /0   FILD m16int 14.5(13-16)  4    Поместить m16int в стек  |
|                                      FPU                      |
|DB /0   FILD m32int 11.5(9-12) 4(2-4) Поместить m32int в стек  |
|                                      FPU                      |
|DF /5   FILD m64int 16.8(10-18) 7.8   Поместить m64int в стек  |
|                               (2-8)  FPU                      |
-----------------------------------------------------------------

Работа команды

Декремент указателя вершины стека FPU;
ST(0) <- SRC;

Описание
FILD  преобразует  исходный  имеющий  знак  целочисленный  операнд в формат
расширенного действительного и помещает его в стек FPU.

Изменяемые флаги модуля операций с плавающей точкой
C1, как описано в Таблице 15-1; C0, C2, C3 не определены.

Исключения числовых операций
IS

Исключения защищенного режима
#GP(0)  в  случае  недопустимого  исполнительного  адреса операнда памяти в
сегментах CS, DS,  ES, FS или  GS; #SS(0) в  случае недопустимого адреса  в
сегменте  SS;   #PF(код  сбоя)   в  случае   страничного  сбоя;   #NM   при
установленном EM или TS  в CR0; #AC для  невыравненной ссылки к памяти  при
текущем уровне привилегированности, равном 3.

Исключения режима реальных адресов
Прерывание  13,  если  какая-либо  часть  операнда  лежит  вне пространства
исполнительных адресов от  0 до 0FFFFH;  Прерывание 7 при  установленном EM
или TS в CR0.

Исключения виртуального режима 8086
Те же исключения,  что и для  режима реальных адресов:  #PF (код сбоя)  для
страничных сбоев; #AC для невыравненной ссылки к памяти при текущем  уровне
привилегированности, равном 3.

Примечания
Исходный операнд загружается погрешностью округления.
ST(0) должен быть пустым, чтобы избежать исключения неверной операции.

`м`д`05FINCSTP`* - Инкремент указателя вершины стека

-----------------------------------------------------------------
|Код       Команда  Число      Описание                         |
|операции           тактовых                                    |
|                   циклов                                      |
|                                                               |
|D9 F7     FINCSTP     3       Инкремент указателя вершины стека|
|                              для регистрового стека FPU       |
-----------------------------------------------------------------

Работа команды

IF TOP = 7
THEN TOP <- 0;
ELSE TOP <- TOP +1;
FI;

Описание
FINCSTP прибавляет единицу  (без переноса) к  трех-битовому полю TOP  слова
состояния модуля операций с плавающей точкой (FPU).

Изменяемые флаги модуля операций с плавающей точкой
C1, как описано в Таблице 15-1; C0, C2, C3 не определены.

Исключения числовых операций
Отсутствуют

Исключения защищенного режима
#NM при установленном EM или TS в CR0.

Исключения режима реальных адресов
Прерывание 7 при установленном EM или TS в CR0.

Исключения виртуального режима 8086
#NM при установленном EM или TS в CR0.

Примечания
Действие  команды  RDECSTP  состоит  в  циклическом  сдвиге  стека.  Она не
изменяет теги регистров или их содержимое и не выполняет пересылки  данных.
Она не  эквивалентна извлечению  из стека,  поскольку не  устанавливает тег
старой вершины стека как "пустой".


`м`д`05FINIT/FNINIT`* - Инициализация модуля операций с плавающей точкой
                                 (FPU)

-----------------------------------------------------------------
|Код       Команда  Число        Описание                       |
|операции           тактовых                                    |
|                   циклов                                      |
|                                                               |
|DB E3     FINIT    17+минимум  Инициализация FPU после проверки|
|                   3 для FWAIT условия немаскируемой ошибки    |
|                               операции с плавающей точкой     |
|DB /E3    FNINIT   17          Инициализация FPU  без  проверки|
|                               условия немаскируемой ошибки    |
|                               операции с плавающей точкой     |
-----------------------------------------------------------------

Работа команды

CW <- 037FH;                   (* Управляющее слово *)
SW <- 0;                       (* Слово состояния   *)
TW <- FFFFH;                   (* Слово тега        *)
FEA <- 0; FDS <- 0;            (* Указатель данных  *)
FIP <- 0; FOP <- 0; FCS <- 0;  (* Указатель команд  *)

Описание
Команды инициализации устанавливают  FPU в известное  состояния, независимо
от действий, выполнявшихся им ранее.

Управляющее  слово  FPU  установлено   в  значение  037FY  (округление   до
ближайшего,    все    исключения    маскируются,    64-битовая     точность
представления).   Слово   состояния   очищается   (флаги   исключений    не
установлены, регистр  стека R0  = вершине  стека). Стековые  регистры имеют
теги "пусто". Указатели ошибки (как команд, так и данных) очищены.

Изменяемые флаги модуля операций с плавающей точкой
C0, C1, C2, C3 очищены.

Исключения числовых операций
Отсутствуют

Исключения защищенного режима
#NM при установленном EM или TS в CR0.

Исключения режима реальных адресов
Прерывание 7 при установленном EM или TS в CR0.

Исключения виртуального режима 8086
#NM при установленном EM или TS в CR0.

Примечания
FINIT  проверяет  наличие  немаскируемых  условий  ошибки  для  операций  с
плавающей точкой,  прежде чем  выполнить инциализацию;  FNINIT же  этого не
делает.
FINIT и FNINIT оставляют  FPU в том же  состоянии, которое бывает в  случае
аппаратного сигнала сброса RESET со встроенным автотестированием.
В отличие  от математического  сопроцессора 387,  в случае  процессора i486
команды FINIT и FNINIT очищают указатели ошибки.


`м`д`05FIST/FISTP`* - Сохранение целочисленного операнда

-----------------------------------------------------------------
|Код      Команда     Число         Описание                    |
|операции             тактовых                                  |
|                     циклов                                    |
|                                                               |
|DF /2   FIST  m16int  33.4(29-34)  Сохранение ST в m16int      |
|DB /2   FIST  m32int  33.4(29-34)  Сохранение ST в m32int      |
|DF /3   FISTP m16int  33.4(29-34)  Сохранение ST в m16int и    |
|                                   извлечение из стека ST      |
|DB /3   FISTP m32int  33.4(29-34)  Сохранение ST в m32int и    |
|                                   извлечение из стека ST      |
|DF /7   FISTP m64int  33.4(29-34)  Сохранение ST в m64int и    |
|                                   извлечение из стека ST      |
-----------------------------------------------------------------

Работа команды

DEST <- ST(0);
IF команда = FISTP THEN извлечение из стека ST  FI;

Описание
FISP преобразует значение в ST в имеющее знак целое в соответствии с  полем
RC  управляющего  слова  и  пересылает  результат  в операнд назначения. ST
остается без изменений. FIST допускает в качестве назначения слово и  short
integer; FISTP, помимо того, допускает в этом качестве тип long integer.

Изменяемые флаги модуля операций с плавающей точкой
C1, как описано в Таблице 15-1; C0, C2, C3 не определены.

Исключения числовых операций
P, I, IS

Исключения защищенного режима
#GP(0), если результат должен помещаться в сегмент, для которого  запрещена
запись;  #GP(0)  в  случае  недопустимого  исполнительного  адреса операнда
памяти в сегментах  CS, DS, ES,  FS или GS;  #SS(0) в случае  недопустимого
адреса в  сегменте SS;  #PF(код сбоя)  в случае  страничного сбоя;  #AC для
невыравненной  ссылки  к  памяти  при  текущем  уровне привилегированности,
равном 3.

Исключения режима реальных адресов
Прерывание  13,  если  какая-либо  часть  операнда  лежит  вне пространства
исполнительных адресов от  0 до 0FFFFH;  Прерывание 7 при  установленном EM
или TS в CR0.

Исключения виртуального режима 8086
Те же исключения,  что и для  режима реальных адресов:  #PF (код сбоя)  для
страничных сбоев; #AC для невыравненной ссылки к памяти при текущем  уровне
привилегированности, равном 3.

Примечания
Отрицательный  ноль  записывается  в  той  же  кодировке  (00..00),  что  и
положительный.
Если  значение   слишком  велико   и  не   может  быть   представлено   как
целочисленное значение, возникает исключение I. Маскируемая реакция на  это
состоит  в  записи  в  память  самого  большого  по  абсолютному   значению
отрицательного числа.

`м`д`05FLD`* - Загрузка действительного значения

-----------------------------------------------------------------
|Код      Команда     Число         Описание                    |
|операции             тактовых                                  |
|                     циклов                                    |
|                                                               |
|D9 /0    FLD m32real    3        Поместить в стек FPU m32real  |
|DD /0    FLD m64real    3        Поместить в стек FPU m64real  |
|DB /5    FLD m80real    6        Поместить в стек FPU m80real  |
|D9 /C0+i FLD ST(i)      4        Поместить в стек FPU ST(i)    |
-----------------------------------------------------------------

Работа команды

Декремент указателя вершины стека FPU;
ST(0) <- SRC;

Описание
FLD помещает  в стек  FPU исходный  операнд. Если  им является  регистр, то
используется  номер регистра, который  был до декремента указателя  вершины
стека. В частности,

FLD ST(0)
дублирует вершину стека.

Изменяемые флаги модуля операций с плавающей точкой
C1, как описано в Таблице 15-1; C0, C2, C3 не определены.

Исключения числовых операций
D, I, IS

Исключения защищенного режима
#GP(0)  в  случае  недопустимого  исполнительного  адреса операнда памяти в
сегментах CS, DS,  ES, FS или  GS; #SS(0) в  случае недопустимого адреса  в
сегменте  SS;   #PF(код  сбоя)   в  случае   страничного  сбоя;   #AC   для
невыравненной  ссылки  к  памяти  при  текущем  уровне привилегированности,
равном 3.

Исключения режима реальных адресов
Прерывание  13,  если  какая-либо  часть  операнда  лежит  вне пространства
исполнительных адресов от  0 до 0FFFFH;  Прерывание 7 при  установленном EM
или TS в CR0.

Исключения виртуального режима 8086
Те же исключения,  что и для  режима реальных адресов:  #PF (код сбоя)  для
страничных сбоев; #AC для невыравненной ссылки к памяти при текущем  уровне
привилегированности, равном 3.

Примечания
Если исходный операнд имеет  формат действительного значения одинарной  или
двойной  точности,   то  он   автоматически  преобразуется   в  расширенный
действительный формат.  Загрузка расширенного  действительного расширенного
операнда не требует преобразований, поэтому в данном случае исключений I  и
D не происходит.
ST(7) должен быть пустым, чтобы избежать исключения неверной операции.


`м`д`05FLD1/FLDL2T/FLDL2E/FLDPI/
FLDLG2/FLDLN2/FLDZ `* - Загрузка константы

-----------------------------------------------------------------
|Код      Команда  Число       Парал-  Описание                 |
|операции          тактовых    лельное                          |
|                  циклов      выпол-                           |
|                              нение                            |
|D9 E8    FLD1        4          -     Поместить  +1.0  в стек  |
|                                      FPU                      |
|D9 E9    FLDL2T      8          2     Поместить log 10 в стек  |
|                                      FPU          2           |
|D9 EA    FLDL2E      8          2     Поместить log e  в стек  |
|                                      FPU          2           |
|D9 EB    FLDPI       8          2     Поместить число Пи в стек|
|                                      FPU                      |
|D9 EC    FLDLG2      8          2     Поместить log 2  в стек  |
|                                      FPU          10          |
|D9 ED    FLDLN2      8          2     Поместить log 2  в стек  |
|                                      FPU          e           |
|D9 EE    FLDZ        4          -     Поместить  +0.0  в стек  |
|                                      FPU                      |
-----------------------------------------------------------------

Работа команды

Декремент указателя вершины стека FPU;
ST(0) <- CONSTANT;

Описание
Каждая команда  загрузки константы  помещает в  стек FPU  одну из указанных
выше общепринятых констант (в расширенном действительном формате).

Изменяемые флаги модуля операций с плавающей точкой
C1, как описано в Таблице 15-1; C0, C2, C3 не определены.

Исключения числовых операций
IS

Исключения защищенного режима
#NM при установленном EM или TS в CR0.

Исключения режима реальных адресов
Прерывание 7 при установленном EM или TS в CR0.

Исключения виртуального режима 8086
#NM при установленном EM или TS в CR0.

Примечания
ST(7) должен быть пустым, чтобы избежать исключения неверной операции.
Используется внутренняя 66-битовая  константа, округляемая до  расширенного
действительного формата (как задают биты RC управляющих слов).  Исключение,
связанное с точностью представления, не возникает.


`м`д`05FLDCW`* - Загрузка управляющего слова

-----------------------------------------------------------------
|Код      Команда     Число         Описание                    |
|операции             тактовых                                  |
|                     циклов                                    |
|                                                               |
|D9 /5    FNLDCW m2byte  4        Загрузить управляющее слово   |
|                                 FPU из m2byte                 |
-----------------------------------------------------------------

Работа команды

CW <- SRC;

Описание
FLDCW  заменяет   текущее  значение   управляющего  слова   FPU  значением,
находящимся в заданном слове памяти.

Изменяемые флаги модуля операций с плавающей точкой
C0, C1, C2, C3 не определены.

Исключения числовых операций
Отсутствуют, за исключением демаскирования существующего исключения.

Исключения защищенного режима
#GP(0)  в  случае  недопустимого  исполнительного  адреса операнда памяти в
сегментах CS, DS,  ES, FS или  GS; #SS(0) в  случае недопустимого адреса  в
сегменте  SS;   #PF(код  сбоя)   в  случае   страничного  сбоя;   #AC   для
невыравненной  ссылки  к  памяти  при  текущем  уровне привилегированности,
равном 3.

Исключения режима реальных адресов
Прерывание  13,  если  какая-либо  часть  операнда  лежит  вне пространства
исполнительных адресов от  0 до 0FFFFH;  Прерывание 7 при  установленном EM
или TS в CR0.

Исключения виртуального режима 8086
Те же исключения,  что и для  режима реальных адресов:  #PF (код сбоя)  для
страничных сбоев; #AC для невыравненной ссылки к памяти при текущем  уровне
привилегированности, равном 3.

Примечания
FLDCW обычно используется для установки или изменения режима работы FPU.
При  установленном  бите  исключение  в  слове  состояния  загрузка  нового
управляющего  слова,  демаскирующего  это  исключение,  приводит  к условию
ошибки операции с плавающей  точкой. При изменении рекомендуемая  процедура
заключается  в  том,  чтобы  перед  загрузкой  нового  управляющего   слова
очистить все подвешенные исключения.

`м`д`05FLDENV`* - Загрузка контекста FPU

-----------------------------------------------------------------
|Код      Команда     Число         Описание                    |
|операции             тактовых                                  |
|                     циклов                                    |
|                                                               |
|D9 /4    FLDENV m14/ 44 действ.  Загрузить управляющее слово   |
|         28byte      или вирт/   FPU из m2byte                 |
|                     34 защищ.                                 |
-----------------------------------------------------------------

Работа команды

среда FPU <- SRC;

Описание
FLDENV перезагружает контекст FPU из области памяти, определяемой  исходным
операндом. Эти данные должны  быть записаны предыдущей командой  FSTENV или
FNSTENV.
Контекст  FPU  состоит  из  управляющего  слова FPU, слова состояния, слова
тега  и  указателей  ошибки  (данных  и  команд).  Макет контекста в памяти
зависит  одновременно  от  размера   операнда  и  текущего  режима   работы
процессора.  Атрибут  USE  текущего  кодового  сегмента  определяет  размер
операнда: 14-байтовый  операнд относится  к сегменту  USE16, а  28-байтовый
операнд относится к сегменту USE32. На рисунках 15-5 - 15-8 показано  макет
контекста  для  обоих  размеров  операндов  в  режимах  реальных  адресов и
защищенном.  (В  виртуальном  режиме  8086  используется  макет   контекста
реального режима). FLDENV должна выполняться  в том же рабочем режиме,  что
и соответствующие команды FSTENV и FNSTENV.

Изменяемые флаги модуля операций с плавающей точкой
C0, C1, C2, C3 в соответствии с загрузкой.

Исключения числовых операций
Отсутствуют, за исключением загрузки немаскируемого исключения

Исключения защищенного режима
#GP(0)  в  случае  недопустимого  исполнительного  адреса операнда памяти в
сегментах CS, DS,  ES, FS или  GS; #SS(0) в  случае недопустимого адреса  в
сегменте  SS;   #PF(код  сбоя)   в  случае   страничного  сбоя;   #AC   для
невыравненной  ссылки  к  памяти  при  текущем  уровне привилегированности,
равном 3.

Исключения режима реальных адресов
Прерывание  13,  если  какая-либо  часть  операнда  лежит  вне пространства
исполнительных адресов от  0 до 0FFFFH;  Прерывание 7 при  установленном EM
или TS в CR0.

Исключения виртуального режима 8086
Те же исключения,  что и для  режима реальных адресов:  #PF (код сбоя)  для
страничных сбоев; #AC для невыравненной ссылки к памяти при текущем  уровне
привилегированности, равном 3.

Примечания
Если  образ  контекста  содержит  немаскируемое  исключение,  загрузка  его
приведет к условию ошибки операции с плавающей точкой.


`м`д`05FMUL/FMULP/FIMUL`* - Умножение

-----------------------------------------------------------------
|Код      Команда   Число       Парал-    Описание              |
|операции           тактовых    лельное                         |
|                   циклов      выпол-                          |
|                               нение                           |
|D8 /1    FMUL m32real   11         8  Умножение ST на m32real  |
|DC /1    FMUL m64real   14        11  Умножение ST на m64real  |
|D8 C8+i  FMUL ST,ST(i)  16        13  Умножение ST на ST(i)    |
|DC C8+i  FMUL ST(i),ST  16        13  Умножение ST(i) на ST    |
|DE C8+i  FMULP ST(i),ST 16        13  Умножение ST(i) на ST    |
|                                      и извлечение из стека ST |
|DE C9    FIMUL          16        13  Умножение ST(1) на ST    |
|                                      и извлечение из стека ST |
|DA /1    FIMUL m32int 23.5(22-24) 8   Умножение ST на m32int   |
|DE /1    FIMUL m16int  25(23-27)  8   Умножение ST на m16int   |
-----------------------------------------------------------------

Работа команды

DEST <- DEST x SCR;
IF команда = FMULP THEN извлечение из стека ST  FI;

Описание
Команды  умножения   умножают  операнд   назначения  на   исходный  операнд
(источник) и возвращают произведение в операнд назначения.

Изменяемые флаги модуля операций с плавающей точкой
C1, как описано в Таблице 15-1; C0, C2, C3 не определены.

Исключения числовых операций
P, U, O, D, IS

Исключения защищенного режима
#GP(0)  в  случае  недопустимого  исполнительного  адреса операнда памяти в
сегментах CS, DS,  ES, FS или  GS; #SS(0) в  случае недопустимого адреса  в
сегменте  SS;   #PF(код  сбоя)   в  случае   страничного  сбоя;   #AC   для
невыравненной  ссылки  к  памяти  при  текущем  уровне привилегированности,
равном 3.

Исключения режима реальных адресов
Прерывание  13,  если  какая-либо  часть  операнда  лежит  вне пространства
исполнительных адресов от  0 до 0FFFFH;  Прерывание 7 при  установленном EM
или TS в CR0.

Исключения виртуального режима 8086
Те же исключения,  что и для  режима реальных адресов:  #PF (код сбоя)  для
страничных сбоев; #AC для невыравненной ссылки к памяти при текущем  уровне
привилегированности, равном 3.

Примечания
Если   исходный   операнд   находится   в   памяти,   то  он  автоматически
преобразуется в расширенный действительный формат.


`м`д`05FNOP`* - Нет операции

-----------------------------------------------------------------
|Код      Команда     Число         Описание                    |
|операции             тактовых                                  |
|                     циклов                                    |
|                                                               |
|D9 D0    FNOP           3          Никакая операция не выпол-  |
|                                   няется                      |
-----------------------------------------------------------------

Описание
Команда NOP  не выполняет  никакой операции.  Она не  влияет ни  на что, за
исключением указателей команд.

Изменяемые флаги модуля операций с плавающей точкой
C0, C1, C2, C3 не определены.

Исключения числовых операций
Отсутствуют

Исключения защищенного режима
#NM при установленном EM или TS в CR0.

Исключения режима реальных адресов
Прерывание 7 при установленном EM или TS в CR0.

Исключения виртуального режима 8086
#NM при установленном EM или TS в CR0.


`м`д`05FPATAN`* - Частичный арктангенс

-----------------------------------------------------------------
|Код      Команда  Число       Парал-  Описание                 |
|операции          тактовых    лельное                          |
|                  циклов      выпол-                           |
|                              нение                            |
|D9 F3    FPATAN  289(218-303) 5(2-17) Замена   ST(1) на        |
|                                      arctan(ST(1)/ST) и       |
|                                      извлечение из стека ST   |
-----------------------------------------------------------------

Работа команды

ST(1) <- arctan(ST(1)/ST);
извлечение из стека ST;

Описание
Частичный  арктангенс  вычисляет  арктангенс   от  ST(1)/ST  и   возвращает
вычисленное значение в  радианах в ST(1).  Затем выполняется извлечение  из
стека  ST.  Результат  имеет  тот  же  знак,  что  и операнд из ST(1), и по
величине меньше числа Пи.

Изменяемые флаги модуля операций с плавающей точкой
C1, как описано в Таблице 15-1; C0, C2, C3 не определены.

Исключения числовых операций
P, U, D, I, IS

Исключения защищенного режима
#NM при установленном EM или TS в CR0.

Исключения режима реальных адресов
Прерывание 7 при установленном EM или TS в CR0.

Исключения виртуального режима 8086
#NM при установленном EM или TS в CR0.

Примечания
Ограничений на диапазон принимаемых FPATAN аргументов не имеется.
Тот факт,  что FPATAN  принимает два  аргумента и  вычисляет арктангенс  их
отношения,   упрощает   вычмсление   других   тригонометрических   функций.
Например,  arcsin(x)  (равный  арктангенсу  x  /  кв. корень из (1 - x**2))
может  быть  вычислен  при  помощи  следующей  последовательности операций:
помещение x в стек  FPU; вычисление кв. корня  из (1 - x**2)  и помещение в
стек результата; выполнение FPATAN.
Процессор  i486  во  время  выполнения  данной  команды  проверяет  наличие
прерываний.  Для  обслуживания  прерывания  процессор  отменяет  выполнение
данной команды (abort).


`м`д`05FPREM`*  - Частичный остаток

-----------------------------------------------------------------
|Код      Команда  Число       Парал-  Описание                 |
|операции          тактовых    лельное                          |
|                  циклов      выпол-                           |
|                              нение                            |
|D9 F8    FPREM   84(70-138)   2(2-8)  Замена ST остатком от    |
|                                      деления ST на ST(1)      |
-----------------------------------------------------------------

Работа команды

EXPDIF <- экспонент(ST) - экспонент(ST(1));
IF EXPDIF < 64
THEN
   Q <-  целое,  полученное дроблением ST / ST(1) в направлении
нуля;
   ST <- ST - (ST(1) x Q);
   C2 <- 0;
   C0,C1,C3 <- три младших бита Q; (* Q2, Q1, Q0 *)
ELSE
   C2 <- 1;
   N <- число между 32 и 63;
   QQ <- целое,  полученное дроблением (ST/ST(1))/2**EXPDIF-N в
направлении нуля;
   ST <- ST - (ST(1) x QQ x 2**EXPDIF-N);
FI;

Описание
Команда частичного остатка вычисляет  остаток, полученный от деления  ST на
ST(1),  и  помещает  результат  в  ST.  Знак  остатка  тот  же,  что и знак
исходного делимого в ST. Величина остатка меньше величины модуля.

Изменяемые флаги модуля операций с плавающей точкой
C0, C1, C2, C3, как описано в таблице 15-1.

Исключения числовых операций
U, D, I, IS

Исключения защищенного режима
#NM при установленном EM или TS в CR0.

Исключения режима реальных адресов
Прерывание 7 при установленном EM или TS в CR0.

Исключения виртуального режима 8086
#NM при установленном EM или TS в CR0.

Примечания
FPREM  производит   точный  результат;   исключение  потери   точности   не
генерируется, и управление округлением не действует.
Команда FPREM не есть  операция получения остатка, определяемая  стандартом
IEEE 754.  Для получения  последнего следует  использовать команду  FPREM1.
FPREM  поддерживается  для  совместимости  с математическими сопроцессорами
8087 и 80287.
FPREM работает методом итеративных  вычитаний и может уменьшить  экспоненту
ST не более чем на 63 за одно выполнение. Если FPREM успешно дала  остаток,
меньший модуля, то работа завершена,  и флаг C2 очищен. В  противном случае
C2  устанавливается,  и  результат  в  ST  называется  частичным  остатком.
Экспонент от  частичного остатка  меньше экспонента  исходного делимого как
минимум  на  32.  Программное  обеспечение  может  циклически выполнять эту
команду (используя  как делимое  частичный остаток  в ST)  до тех пор, пока
флаг C2 не будет очищен  командой. Подпрограммы прерывания с более  высоким
приоритетом,  которым  потребовался   FPU,  могут  выполнить   переключение
контекста между командами цикла получения остатка.
Важное использование  FPREM состоит  в приведении  аргументов периодических
функций.  После  завершения  этой  операции  FPREM  задает три младших бита
частного  во  флагах  C3,  C1  и  C0.  Это  важно  для приведениия величины
аргумента для функции тангенса  (при использовании модуля Пи/4),  поскольку
позволяет  найти  исходное  значение  угла  в  одном  из  восьми   секторов
единичной окружности.


`м`д`05FPREM1`*  - Частичный остаток

-----------------------------------------------------------------
|Код      Команда  Число       Парал-    Описание               |
|операции          тактовых    лельное                          |
|                  циклов      выпол-                           |
|                              нение                            |
|D9 F5    FPREM1  94.5(72-167) 5.5(2-18) Замена ST остатком от  |
|                                        деления ST на ST(1)    |
-----------------------------------------------------------------

Работа команды

EXPDIF <- экспонент(ST) - экспонент(ST(1));
IF EXPDIF < 64
THEN
   Q <-  целое,  полученное дроблением ST / ST(1) в направлении
нуля;
   ST <- ST - (ST(1) x Q);
   C2 <- 0;
   C0,C1,C3 <- три младших бита Q; (* Q2, Q1, Q0 *)
ELSE
   C2 <- 1;
   N <- число между 32 и 63;
   QQ <- целое, ближайшее к (ST/ST(1))/2**EXPDIF-N в
направлении нуля;
   ST <- ST - (ST(1) x QQ x 2**EXPDIF-N);
FI;

Описание
Команда частичного остатка вычисляет  остаток, полученный от деления  ST на
ST(1),  и  помещает  результат  в  ST.  Величина  остатка  меньше  половины
величины модуля.

Изменяемые флаги модуля операций с плавающей точкой
C0, C1, C2, C3, как описано в Таблице 15-1.

Исключения числовых операций
U, D, I, IS

Исключения защищенного режима
#NM при установленном EM или TS в CR0.

Исключения режима реальных адресов
Прерывание 7 при установленном EM или TS в CR0.

Исключения виртуального режима 8086
#NM при установленном EM или TS в CR0.

Примечания
FPREM1  производит   точный  результат;   исключение  потери   точности  не
генерируется, и управление округлением не действует.
Команда  FPREM1  есть  операция  получения остатка, определяемая стандартом
IEEE 754. Она отличается от  FPREM способом округления частного от  деления
ST и ST(1).

FPREM1 работает методом итеративных вычитаний и может уменьшить  экспоненту
ST  не  более  чем  на  63  за  одно  выполнение.  Если FPREM1 успешно дала
остаток, меньший половины модуля, то работа завершена, и флаг C2 очищен.  В
противном случае C2 устанавливается, и результат в ST называется  частичным
остатком.  Экспонент  от  частичного  остатка  меньше  экспонента исходного
делимого  как  минимум  на  32.  Программное  обеспечение  может циклически
выполнять эту  команду (используя  как делимое  частичный остаток  в ST) до
тех пор, пока флаг C2  не будет очищен командой. Подпрограммы  прерывания с
более  высоким  приоритетом,  которым  потребовался  FPU,  могут  выполнить
переключение контекста между командами цикла получения остатка.
Важное использование FPREM1  состоит в приведении  аргументов периодических
функций.  После  завершении  этой  операции  FPREM1 задает три младших бита
частного  во  флагах  C3,  C1  и  C0.  Это  важно  для приведениия величины
аргумента для функции тангенса  (при использовании модуля Пи/4),  поскольку
позволяет  найти  исходное  значение  угла  в  одном  из  восьми   секторов
единичной окружности.


`м`д`05FPTAN`* - Частичный тангенс

-----------------------------------------------------------------
|Код      Команда  Число       Парал-  Описание                 |
|операции          тактовых    лельное                          |
|                  циклов      выпол-                           |
|                              нение                            |
|D9 F2    FATAN   244(200-273) 70      Замена   ST(1) на        |
|                                      его тангенс и помещение  |
|                                      в стек FPU числа 1       |
-----------------------------------------------------------------

Работа команды

IF операнд в допустимом диапазоне
THEN
   C2 <- 0;
   ST <- tan(ST);
   Декремент указателя вершины стека;
   ST <- 1.0;
ELSE
   C2 <- 1;
FI;

Описание
Частичный тангенс  заменяет содержимое  ST на  tan(ST) и  затем помещает  в
стек FPU величину 1.0. Значение ST  в радианах должно лежать в диапазоне  |
O | < 2**63. (Тета)

Изменяемые флаги модуля операций с плавающей точкой
C1, C2, как описано в Таблице 15-1; C0, C3 не определены.

Исключения числовых операций
P, U, D, I, IS

Исключения защищенного режима
#NM при установленном EM или TS в CR0.

Исключения режима реальных адресов
Прерывание 7 при установленном EM или TS в CR0.

Исключения виртуального режима 8086
#NM при установленном EM или TS в CR0.

Примечания
Если операнд лежит вне допустимого  диапазона, то флаг C2 установлен,  а ST
остается без изменений. Программист  сам отвечает за приведение  операнда к
абсолютной  величине  меньшей,  чем   2**63,  вычитая  из  него   некоторое
произведение целого  на 2Пи.  См. раздел  17.5, где  описано, какое  именно
значение  следует  брать  для  числа  Пи  при  выполнении  таких   операций
приведения операнда.
То, что FPTAN  помещает в стек  FPU значение 1.0  после вычисления tan(ST),
обеспечивает совместимость с математическими сопроцессорами 8087 и 80287  и
упрощает вычисление прочих тригонометрических функций. Например,  котангенс
(величина,  обратная  тангенсу)  можно  вычислить,  выполнив  после   FPTAN
команду FDIVR.
ST(7) должен быть пустым, чтобы избежать исключения неверной операции.
Процессор i486  во время  выполнения данной  команды периодически проверяет
наличие  прерываний.   Для  обслуживания   прерывания  процессор   отменяет
выполнение данной команды (abort).

`м`д`05FRNDINT`* - Округление к целому

-----------------------------------------------------------------
|  Код    Команда  Число       Парал-        Описание           |
|операции          тактовых    лельное                          |
|                  циклов      выпол-                           |
|                              нение                            |
|D9 FC    FRNDINT  29.1(21-30) 7.4(2-8) Округление ST к целому  |
-----------------------------------------------------------------

Работа команды

ST <- округленный ST;

Описание
Команда  округления  к   целому  округляет  значение   в  ST  к   целому  в
соответствии с полем RC управляющего слова FPU.

Изменяемые флаги модуля операций с плавающей точкой
C1, как описано в Таблице 15-1; C0, C2, C3 не определены.

Исключения числовых операций
P, D, I, IS

Исключения защищенного режима
#NM при установленном EM или TS в CR0.

Исключения режима реальных адресов
Прерывание 7 при установленном EM или TS в CR0.

Исключения виртуального режима 8086
#NM при установленном EM или TS в CR0.


`м`д`05FRSTOR`* - Восстановить состояние FPU

-----------------------------------------------------------------
|Код       Команда    Число         Описание                    |
|операции             тактовых                                  |
|                     циклов                                    |
|                                                               |
|DB /4   FRSTOR m94/  131 реальный  Загрузка состояния FPU из   |
|        108byte      или вирт./    m94byte или m108byte        |
|                     120 защищ.                                |
-----------------------------------------------------------------

Работа команды
Состояние FPU <- SRC;

Описание
FRSTOR  перезагружает  состояние  FPU  (контекст  и  регистровый  стек)  из
области памяти, заданной  исходным операндом. Эти  данные должны были  быть
записаны туда предыдущей командой FSAVE или FNSAVE.
Контекст  FPU  состоит  из  управляющего  слова FPU, слова состояния, слова
тега  и  указателей  ошибки  (данных  и  команд).  Макет контекста в памяти
зависит  одновременно  от  размера   операнда  и  текущего  режима   работы
процессора.  Атрибут  USE  текущего  кодового  сегмента  определяет  размер
операнда: 14-разрядный операнд относится  к сегменту USE16, а  28-разрядный
операнд относится к сегменту USE32.  На рисунках 15-5 - 15-8  показан макет
контекста  для  обоих  размеров  операндов  в  режимах  реальных  адресов и
защищенном.  (В  виртуальном  режиме  8086  используется  макет   контекста
реального режима). Регистры стека, начиная  с ST и кончая ST(7),  находятся
в 80 байтах, непосредственно следующих за образом контекста. FRSTOR  должна
выполняться в том же рабочем режиме, что и соответствующие команды FSAVE  и
FNSAVE.

Изменяемые флаги модуля операций с плавающей точкой
C0, C1, C2, C3 в соответствии с загрузкой.

Исключения числовых операций
Отсутствуют, за исключением загрузки немаскируемого исключения.

Исключения защищенного режима
#GP(0)  в  случае  недопустимого  исполнительного  адреса операнда памяти в
сегментах CS, DS,  ES, FS или  GS; #SS(0) в  случае недопустимого адреса  в
сегменте  SS;   #PF(код  сбоя)   в  случае   страничного  сбоя;   #AC   для
невыравненной  ссылки  к  памяти  при  текущем  уровне привилегированности,
равном 3.

Исключения режима реальных адресов
Прерывание  13,  если  какая-либо  часть  операнда  лежит  вне пространства
исполнительных адресов от  0 до 0FFFFH;  Прерывание 7 при  установленном EM
или TS в CR0.

Исключения виртуального режима 8086
Те же исключения,  что и для  режима реальных адресов:  #PF (код сбоя)  для
страничных сбоев; #AC для невыравненной ссылки к памяти при текущем  уровне
привилегированности, равном 3.

Примечания
Если  образ  контекста  содержит  немаскируемое  исключение,  загрузка  его
приведет к условию ошибки операции с плавающей точкой.


`м`д`05FSAVE/FNSAVE`* - Сохранить состояние FPU

-----------------------------------------------------------------
|Код       Команда    Число         Описание                    |
|операции             тактовых                                  |
|                     циклов                                    |
|                                                               |
|DB DD /6 FSAVE m94/  154 реальный  Сохранение состояния FPU в  |
|         109byte     или вирт./    m94byte или m108byte после  |
|                     143 защищ.+   проверки условия немаскиру- |
|                     минимум 3     емой ошибки с плавающей     |
|                     для FWAIT     точкой. Затем ре-инициализа-|
|                                   ция FPU.                    |
|DD /6   FNSAVE m94/  154 реальный  Сохранение состояния FPU в  |
|         109byte     или вирт./    m94byte или m108byte без    |
|                     143 защищ.    проверки условия немаскиру- |
|                                   емой ошибки с плавающей     |
|                                   точкой. Затем ре-инициализа-|
|                                   ция FPU.                    |
-----------------------------------------------------------------

Работа команды

DEST <- состояние FPU;
инициализация FPU; (* Эквивалентно FNINIT *)

Описание
Команды сохранения  записывают текущее  состояние FPU  (контекст и регистры
стека) по заданному назначению и затем ре-инициализируют FPU. Контекст  FPU
состоит  из  управляющего  слова  FPU,   слова  состояния,  слова  тега   и
указателей ошибки (данных и команд).
Макет  контекста  в  памяти  зависит  одновременно  от  размера  операнда и
текущего режима работы процессора.  Атрибут USE текущего кодового  сегмента
определяет  размер  операнда:  94-разрядный  операнд  относится  к сегменту
USE16,  а  108-разрядный  операнд  относится  к сегменту USE32. На рисунках
15-5 - 15-8 показан макет контекста для обоих размеров операндов в  режимах
реальных  адресов  и  защищенном.  (В  виртуальном режиме 8086 используется
макет контекста реального  режима). Регистры стека,  начиная с ST  и кончая
ST(7),  находятся  в  80  байтах,  непосредственно  следующих  за   образом
контекста.

Изменяемые флаги модуля операций с плавающей точкой
C0, C1, C2, C3 очищаются.

Исключения числовых операций
Отсутствуют

Исключения защищенного режима
#GP(0), если результат должен помещаться в сегмент, для которого  запрещена
запись;  #GP(0)  в  случае  недопустимого  исполнительного  адреса операнда
памяти в сегментах  CS, DS, ES,  FS или GS;  #SS(0) в случае  недопустимого
адреса в  сегменте SS;  #PF(код сбоя)  в случае  страничного сбоя;  #AC для
невыравненной  ссылки  к  памяти  при  текущем  уровне привилегированности,
равном 3.

Исключения режима реальных адресов
Прерывание  13,  если  какая-либо  часть  операнда  лежит  вне пространства
исполнительных адресов от  0 до 0FFFFH;  Прерывание 7 при  установленном EM
или TS в CR0.

Исключения виртуального режима 8086
Те же исключения,  что и для  режима реальных адресов:  #PF (код сбоя)  для
страничных сбоев; #AC для невыравненной ссылки к памяти при текущем  уровне
привилегированности, равном 3.

Примечания
FSAVE  и  FNSAVE  не  сохраняют  состояния  FPU  до  тех пор, пока не будут
завершены  действия   FPU.  Таким   образом,  сохраненный   образ  отражает
состояние FPU после выполнения любой ранее декодированной команды.
Если  программа  должна  читать  образ  в  памяти  состояния, следующего за
командой  сохранения,   то  она   должна  выдать   команду  FWAIT,    чтобы
гарантировать, что сохранение завершено.

Команды  сохранения   обычно  используются,   когда  операционной   системе
необходимо  выполнить  переключение  контекста,  или обработчику исключения
требуется  использовать  FPU,  либо  когда  прикладная программа собирается
передать в подпрограмму "чистый" FPU.


`м`д`05FSCALE`* - Умножение на масштабный коэффициент

-----------------------------------------------------------------
|Код      Команда  Число       Парал-  Описание                 |
|операции          тактовых    лельное                          |
|                  циклов      выпол-                           |
|                              нение                            |
|D9 FD    FSCALE   31(30-32)     2     Умножение ST на масштаб- |
|                                      ный коэффициент в ST(1)  |
-----------------------------------------------------------------


Работа команды

ST <- ST x 2**ST(1);

 Описание
Команда  масштабирования  интерпретирует  значение  в  ST(1)  как  целое  и
прибавляет его к экспоненте ST. Таким образом, FSCALE обеспечивает  быстрое
умножение или деление на целочисленные степени 2.

Изменяемые флаги модуля операций с плавающей точкой
C1, как описано в таблице 15-1; C0, C2, C3 не определены.

Исключения числовых операций
P, U, O, D, I, IS

Исключения защищенного режима
#NM при установленном EM или TS в CR0.

Исключения режима реальных адресов
Прерывание 7 при установленном EM или TS в CR0.

Исключения виртуального режима 8086
#NM при установленном EM или TS в CR0.

Примечания
Команда FSCALE может  использоваться как команда,  обратная по отношению  к
FXTRACT.  Поскольку  FSCALE  не  извлекает  из стека экспонентную часть, за
FSCALE  должна  следовать  команда  FSTP  ST(1),  чтобы  полностью отменить
действие предыдущей команды FXTRACT.
Ограничений на  диапазон масштабного  коэффициента в  ST(1) не  существует.
Если значение  не является  целочисленнным, то  FSCALE использует ближайшее
целое, меньшее  данной величины;  т.е. это  значение округляется  в сторону
нуля.  Если  результирующее  целое  равно   нулю,  то  значение  в  ST   не
изменяется.


`м`д`05FSIN`* - Синус

-----------------------------------------------------------------
|Код      Команда  Число       Парал-  Описание                 |
|операции          тактовых    лельное                          |
|                  циклов      выпол-                           |
|                              нение                            |
|D9 FE    FSIN    241(193-279)   2     Замена ST его   синусом  |
-----------------------------------------------------------------


Работа команды

IF операнд в допустимом диапазоне
THEN
   C2 <- 0;
   ST <- sin(ST);
ELSE
   C2 <- 1;
FI;

 Описание
Команда FSIN заменяет содержимое ST  на sin(ST). Значение ST, выраженное  в
радианах, должно лежать в диапазоне | O | < 2**63.

Изменяемые флаги модуля операций с плавающей точкой
C1,C2 как описано в Таблице 15-1; C0, C3 не определены.

Исключения числовых операций
P, U, D, I, IS

Исключения защищенного режима
#NM при установленном EM или TS в CR0.

Исключения режима реальных адресов
Прерывание 7 при установленном EM или TS в CR0.

Исключения виртуального режима 8086
#NM при установленном EM или TS в CR0.

Примечания
Если операнд находится вне допустимого диапазона, то флаг C2 установлен,  а
ST  остается  неизмененным.  Программист  сам  ответственен  за  то,  чтобы
уменьшить  операнд  до  абсолютного  значения,  менбшего чем 2**63, вычитая
соответствующее число,  кратное 2  пи. См.  раздел 17.5,  где описано,  как
правильно записать значение числа пи при выполнении такого рода вычитания.
При выполнении данной команды процессор i486 проверяет наличие  прерываний.
Для обслуживания прерывания выполнение команды отменяется (abort).


`м`д`05FSINCOS`* - Синус и косинус

-----------------------------------------------------------------
|Код      Команда  Число       Парал-  Описание                 |
|операции          тактовых    лельное                          |
|                  циклов      выпол-                           |
|                              нение                            |
|D9 FB   FSINCOS  291(243-329)   2     Вычисление синуса и      |
|                                      косинуса ST; замена ST на|
|                                      синус и затем помещение  |
|                                      косинуса в стек FPU      |
-----------------------------------------------------------------


Работа команды

IF операнд в допустимом диапазоне
THEN
   C2 <- 0;
   врем <- cos(ST);
   ST <- sin(ST);
   Декремент указателя вершины стека FPU;
   ST <- врем;
ELSE
   C2 <- 1;
FI;

 Описание
Команда FSINCOS вычисляет сразу sin(ST)  и cos(ST), заменяет ST на  синус и
затем помещает  косинус в  стек FPU.  Значение ST,  выраженное в  радианах,
должно лежать в диапазоне | O | < 2**63.

Изменяемые флаги модуля операций с плавающей точкой
C1,C2 как описано в таблице 15-1; C0, C3 не определены.

Исключения числовых операций
P, U, D, I, IS

Исключения защищенного режима
#NM при установленном EM или TS в CR0.

Исключения режима реальных адресов
Прерывание 7 при установленном EM или TS в CR0.

Исключения виртуального режима 8086
#NM при установленном EM или TS в CR0.

Примечания
Если операнд находится вне допустимого диапазона, то флаг C2 установлен,  а
ST  остается  неизмененным.  Программист  сам  ответственен  за  то,  чтобы
уменьшить  операнд  до  абсолютного  значения,  менбшего чем 2**63, вычитая
соответствующее  число,  кратное  2Пи.  См.  раздел  17.5, где описано, как
правильно записать значение числа пи при выполнении такого рода вычитания.
Команда FSINCOS выполняется быстрее, чем FSIN и FCOS по отдельности.
При выполнении данной команды процессор i486 проверяет наличие  прерываний.
Для обслуживания прерывания выполнение команды отменяется (abort).

`м`д`05FSQRT`* - Квадратный корень

-----------------------------------------------------------------
|Код      Команда  Число       Парал-  Описание                 |
|операции          тактовых    лельное                          |
|                  циклов      выпол-                           |
|                              нение                            |
|D9 FA   FSQRT    85.5(83-87)  70      Замена ST его квадратным |
|                                      корнем                   |
-----------------------------------------------------------------

Работа команды

ST <- квадратный корень ST

Описание
Команда FSQRT заменяет значение в ST на его квадратный корень.
Изменяемые флаги модуля операций с плавающей точкой
C1, как описано в Таблице 15-1; C0, C2, C3 не определены.
Исключения числовых операций
P, D, I, IS
Исключения защищенного режима
#NM при установленном EM или TS в CR0.
Исключения режима реальных адресов
Прерывание 7 при установленном EM или TS в CR0.
Исключения виртуального режима 8086
#NM при установленном EM или TS в CR0.
Примечания
Квадратный корень -0 равен -0.


`м`д`05FST/FSTP`* - Сохранить действительное число

-----------------------------------------------------------------
|Код       Команда  Число      Описание                         |
|операции           тактовых                                    |
|                   циклов                                      |
|                                                               |
|D9 /2   FST  m32real  7       Копирование ST в m32real         |
|DD /2   FST  m64real  8       Копирование ST в m64real         |
|DD D0+i FST  ST(i)    3       Копирование ST в ST(i)           |
|D9 /3   FSTP m32real  7       Копирование ST в m32real         |
|                              и извлечение из стека ST         |
|DD /3   FSTP m64real  8       Копирование ST в m64real         |
|                              и извлечение из стека ST         |
|DB /7   FSTP m80real  6       Копирование ST в m80real         |
|                              и извлечение из стека ST         |
|DD D8+i FSTP ST(i)    3       Копирование ST в ST(i)           |
|                              и извлечение из стека ST         |
-----------------------------------------------------------------

Работа команды

DEST <- ST(0);
IF команда = FSTP THEN извлечение из стека ST;  FI;

Описание
FST копирует  текущее значение  регистра ST  в операнд  назначения, который
может   являться   либо   другим    регистром,   либо   операндом    памяти
действительного  формата  одинарной  или  двойной  точности. FSTP выполняет
сначала  копирование,  а  затем  извлечение  из  стека  ST;  помимо  типов,
разрешенных  в  FST,   она  работает  и   с  расширенными   действительными
операндами.
Если источник является регистром,  то используется номер регистра,  который
был до извлечения из стека.

Изменяемые флаги модуля операций с плавающей точкой
C1, как описано в Таблице 15-1; C0, C2, C3 не определены.

Исключения числовых операций
Операнды назначения или расширенного действительного формата : IS.
Операнды  назначения   действительного  формата   одинарной  или    двойной
точности: P, U, O, D, I, IS.

Исключения защищенного режима
#GP(0), если результат должен помещаться в сегмент, для которого  запрещена
запись;  #GP(0)  в  случае  недопустимого  исполнительного  адреса операнда
памяти в сегментах  CS, DS, ES,  FS или GS;  #SS(0) в случае  недопустимого
адреса в  сегменте SS;  #PF(код сбоя)  в случае  страничного сбоя;  #AC для
невыравненной  ссылки  к  памяти  при  текущем  уровне привилегированности,
равном 3.

Исключения режима реальных адресов
Прерывание  13,  если  какая-либо  часть  операнда  лежит  вне пространства
исполнительных адресов от  0 до 0FFFFH;  Прерывание 7 при  установленном EM
или TS в CR0.

Исключения виртуального режима 8086
Те же исключения,  что и для  режима реальных адресов:  #PF (код сбоя)  для
страничных сбоев; #AC для невыравненной ссылки к памяти при текущем  уровне
привилегированности, равном 3.

Примечания
Если  операнд  назначения  это  действительное  число одинарной или двойной
точности,  то  мантисса  округляется   до  ширины  операнда  назначения   в
соответствии с полем  RC управляющего слова,  а экспонента преобразуется  к
ширине  и  характеристике  формата  назначения.  Также выполняется проверка
условия переполнения/потери значимости.
Если ST содержит ST, +- бесконечность или NaN, то мантисса не  округляется,
а усекается (справа) таким образом, чтобы помещаться в операнд  назначения.
Также не выполняется преобразования  экспоненты: она усекается справа.  Эти
операции   сохраняют   идентичность   значения   бесконечности   или    NaN
(экспоненты).
Когда операнд назначения является  непустым элементом стека, то  исключение
неверной операции не генерируется.


`м`д`05FSTCW/FNSTCW`* - Сохранить управляющее слово

-----------------------------------------------------------------
|Код       Команда      Число        Описание                   |
|операции               тактовых                                |
|                       циклов                                  |
|                                                               |
|9B D9 /7  FSTCW m2byte  3+минимум   Сохранение управляющего    |
|                        3 для FWAIT слова FPU в m2byte после   |
|                                    проверки условия немаскиру-|
|                                    емой ошибки операции с     |
|                                    плавающей точкой           |
|99 /7    FNSTCW m2byte  3           Сохранение управляющего    |
|                                    слова FPU в m2byte без     |
|                                    проверки условия немаскиру-|
|                                    емой ошибки операции с     |
|                                    плавающей точкой           |
-----------------------------------------------------------------

Работа команды

DEST <- CW;

Описание
Команды FSTCW и FNSTCW  записывают текущее значение управляющего  слова FPU
по заданному назначению.

Изменяемые флаги модуля операций с плавающей точкой
C0, C1, C2, C3 не определены.

Исключения числовых операций
Отсутствуют

Исключения защищенного режима
#GP(0), если результат должен помещаться в сегмент, для которого  запрещена
запись;  #GP(0)  в  случае  недопустимого  исполнительного  адреса операнда
памяти в сегментах  CS, DS, ES,  FS или GS;  #SS(0) в случае  недопустимого
адреса в  сегменте SS;  #PF(код сбоя)  в случае  страничного сбоя;  #AC для
невыравненной  ссылки  к  памяти  при  текущем  уровне привилегированности,
равном 3.

Исключения режима реальных адресов
Прерывание  13,  если  какая-либо  часть  операнда  лежит  вне пространства
исполнительных адресов от  0 до 0FFFFH;  Прерывание 7 при  установленном EM
или TS в CR0.

Исключения виртуального режима 8086
Те же исключения,  что и для  режима реальных адресов:  #PF (код сбоя)  для
страничных сбоев; #AC для невыравненной ссылки к памяти при текущем  уровне
привилегированности, равном 3.

Примечания
FSTCW проверяет условия немаскируемой  ошибки операции с плавающей  точкой,
прежде чем сохранить управляющее слово; FNSTCW этого не делает.

`м`д`05FSTENV/FNSTENV`* - Сохранить контекст  FPU

-----------------------------------------------------------------
|Код       Команда    Число         Описание                    |
|операции             тактовых                                  |
|                     циклов                                    |
|                                                               |
|9B D9 /6 FSTENVm14/   67 реальный  Сохранение контекста FPU в  |
|          28byte     или вирт./    m14byte или  m28byte после  |
|                      56 защищ.+   проверки условия немаскиру- |
|                     минимум 3     емой ошибки с плавающей     |
|                     для FWAIT     точкой. Затем маскирование  |
|                                   всех исключений с           |
|                                   плавающей точкой.           |
|D9 /6   FNSTENVm14/   67 реальный  Сохранение контекста FPU в  |
|          28byte     или вирт./    m14byte или  m28byte без    |
|                      56 защищ.    проверки условия немаскиру- |
|                                   емой ошибки с плавающей     |
|                                   точкой. Затем маскирование  |
|                                   всех исключений             |
|                                   плавающей точкой.           |
-----------------------------------------------------------------

Работа команды

DEST <- контекст  FPU;
CW[0..5] <- 111111B;

Описание
Команды сохранения контекста записывают  текущий контекст FPU по  заданному
назначению и затем  маскируют все исключения  операций с плавающей  точкой.
Контекст  FPU  состоит  из  управляющего  слова FPU, слова состояния, слова
тега и указателей ошибки (данных и команд).
Макет  контекста  в  памяти  зависит  одновременно  от  размера  операнда и
текущего режима работы процессора.  Атрибут USE текущего кодового  сегмента
определяет  размер  операнда:  14-разрядный  операнд  относится  к сегменту
USE16, а 28-разрядный операнд относится к сегменту USE32. На рисунках  15-5
-  15-8  показан  макет  контекста  для  обоих размеров операндов в режимах
реальных  адресов  и  защищенном.  (В  виртуальном режиме 8086 используется
макет контекста реального режима).

Изменяемые флаги модуля операций с плавающей точкой
C0, C1, C2, C3 не определены.

Исключения числовых операций
Отсутствуют

Исключения защищенного режима
#GP(0), если результат должен помещаться в сегмент, для которого  запрещена
запись;  #GP(0)  в  случае  недопустимого  исполнительного  адреса операнда
памяти в сегментах  CS, DS, ES,  FS или GS;  #SS(0) в случае  недопустимого
адреса в  сегменте SS;  #PF(код сбоя)  в случае  страничного сбоя;  #AC для
невыравненной  ссылки  к  памяти  при  текущем  уровне привилегированности,
равном 3.

Исключения режима реальных адресов
Прерывание  13,  если  какая-либо  часть  операнда  лежит  вне пространства
исполнительных адресов от  0 до 0FFFFH;  Прерывание 7 при  установленном EM
или TS в CR0.

Исключения виртуального режима 8086
Те же исключения,  что и для  режима реальных адресов:  #PF (код сбоя)  для
страничных сбоев; #AC для невыравненной ссылки к памяти при текущем  уровне
привилегированности, равном 3.

Примечания
FSTENV и  FNSTENV не  сохраняют контекста  FPU до  тех пор,  пока не  будут
завершены  действия  FPU.  Таким  образом,  сохраненный  контекст  отражает
состояние FPU после выполнения любой ранее декодированной команды.
Команды сохранения контекста часто используются в обработчиках  исключений,
поскольку они обеспечивают доступ к указателям ошибки FPU. Контекст  обычно
сохраняется  в  стеке  оперативной  памяти.  После  этого  FSTENV и FNSTENV
устанавливают  все   маски  исключений   в  управляющем   слове  FPU.   Это
предотвращает   прерывания   обработчика   исключений   вследствие  ошибкок
операции с плавающей точкой.
FSTENV  проверяет  условия  немаскируемого  исключения  с плавающей точкой,
прежде чем сохранить контекст FPU; FNSTENV этого не делает.

`м`д`05FSTSW/FNSTSW`* - Сохранить слово состояния

-----------------------------------------------------------------
|Код       Команда       Число       Описание                   |
|операции                тактовых                               |
|                        циклов                                 |
|                                                               |
|9B DF /7  FSTSW m2byte  3+минимум   Сохранение слова состояния |
|                        3 для FWAIT FPU в m2byte после         |
|                                    проверки условия немаскиру-|
|                                    емой ошибки операции с     |
|                                    плавающей точкой           |
|9B DF E0  FSTSW         3+минимум   Сохранение слова состояния |
|                        3 для FWAIT FPU в регистр AX после     |
|                                    проверки условия немаскиру-|
|                                    емой ошибки операции с     |
|                                    плавающей точкой           |
|9F /7    FNSTSW m2byte  3           Сохранение слова состояния |
|                                    FPU в m2byte без           |
|                                    проверки условия немаскиру-|
|                                    емой ошибки операции с     |
|                                    плавающей точкой           |
|9F E0    FNSTSW AX      3           Сохранение слова состояния |
|                                    FPU в регистре AX без      |
|                                    проверки условия немаскиру-|
|                                    емой ошибки операции с     |
|                                    плавающей точкой           |
-----------------------------------------------------------------

Работа команды

DEST <- SW;

Описание
Команды FSTSW и FNSTSW записывают  текущее значение слова состояния FPU  по
заданному  назначению,  которое  может  являться либо двух-байтовым адресом
памяти, либо регистром AX.

Изменяемые флаги модуля операций с плавающей точкой
C0, C1, C2, C3 не определены.

Исключения числовых операций
Отсутствуют

Исключения защищенного режима
#GP(0), если результат должен помещаться в сегмент, для которого  запрещена
запись;  #GP(0)  в  случае  недопустимого  исполнительного  адреса операнда
памяти в сегментах  CS, DS, ES,  FS или GS;  #SS(0) в случае  недопустимого
адреса в  сегменте SS;  #PF(код сбоя)  в случае  страничного сбоя;  #AC для
невыравненной  ссылки  к  памяти  при  текущем  уровне привилегированности,
равном 3.

Исключения режима реальных адресов
Прерывание  13,  если  какая-либо  часть  операнда  лежит  вне пространства
исполнительных адресов от  0 до 0FFFFH;  Прерывание 7 при  установленном EM
или TS в CR0.

Исключения виртуального режима 8086
Те же исключения,  что и для  режима реальных адресов:  #PF (код сбоя)  для
страничных сбоев; #AC для невыравненной ссылки к памяти при текущем  уровне
привилегированности, равном 3.

Примечания
FSTSW проверяет условия немаскируемой  ошибки операции с плавающей  точкой,
прежде чем сохранить слово состояния; FNSTSW этого не делает.
FSTSW и FNSTSW  используются в основном  в конструкциях условного  перехода
(после выполнения сравнения  командами FPREM, FPREMI  или FXAM). Они  также
могут использоваться для активизации обработчиков исключений (путем  опроса
битов исключений) в контекстах, не использующих прерываний.
При  выполнении  команды  FNSTSW  AX  регистр  AX  обновляется до того, как
процессор i486 выполнит любую  другую команду. Сохраняемое состояние  - это
состояния по завершении предыдущей команды ESC.


`м`д`05FSUB/FSUBP/FISUB`* - Вычитание

------------------------------------------------------------------
|Код      Команда     Число     Парал-   Описание                |
|операции             тактовых  лельное                          |
|                     циклов    выпол-                           |
|                               нение                            |
|D8 /4   FSUB  m32real  10(8-20) 7(5-17) Вычитание m32real из ST |
|DC /4   FSUB  m64real  10(8-20) 7(5-17) Вычитание m64real из ST |

|D8 E0+i FSUB  ST,ST(i) 10(8-20) 7(5-17) Вычитание  ST(i)  из ST |
|DC E8+i FSUB  ST(i),ST 10(8-20) 7(5-17) Замена ST(i) на ST-ST(i)|
|DE E8+i FSUBP ST(i),ST 10(8-20) 7(5-17) Замена ST(i) на ST-ST(i)|
|                                        извлечение из стека ST  |
|DE E9   FSUB           10(8-20) 7(5-17) Замена ST(1) на ST-ST(1)|
|                                        извлечение из стека ST  |
|DA /4   FISUB m32int 22.5(19-32)7(5-17) Вычитание m32int из ST  |
|DE /4   FISUB m16int  24(20-35) 7(5-17) Вычитание m16int из ST  |
------------------------------------------------------------------

Работа команды

DEST <- ST - Другой операнд;
IF команда = FSUBP THEN извлечение из стека ST;  FI;

Описание
Команды вычитания  вычитают из  вершины стека  другой операнд  и возвращают
разность в регистр назначения.

Изменяемые флаги модуля операций с плавающей точкой
C1, как описано в Таблице 15-1; C0, C2, C3 не определены.

Исключения числовых операций
P, U, O, D, I, IS.

Исключения защищенного режима
#GP(0)  в  случае  недопустимого  исполнительного  адреса операнда памяти в
сегментах CS, DS,  ES, FS или  GS; #SS(0) в  случае недопустимого адреса  в
сегменте  SS;   #PF(код  сбоя)   в  случае   страничного  сбоя;   #AC   для
невыравненной  ссылки  к  памяти  при  текущем  уровне привилегированности,
равном 3.

Исключения режима реальных адресов
Прерывание  13,  если  какая-либо  часть  операнда  лежит  вне пространства
исполнительных адресов от  0 до 0FFFFH;  Прерывание 7 при  установленном EM
или TS в CR0.

Исключения виртуального режима 8086
Те же исключения,  что и для  режима реальных адресов:  #PF (код сбоя)  для
страничных сбоев; #AC для невыравненной ссылки к памяти при текущем  уровне
привилегированности, равном 3.

Примечания
Если  исходный  операнд   находится  в  памяти,   он  автоматически   будет
преобразован к расширенному действительному формату.


`м`д`05FSUBR/FSUBPR/FISUBR`* - Обратное вычитание

------------------------------------------------------------------
|Код      Команда     Число     Парал-   Описание                |
|операции             тактовых  лельное                          |
|                     циклов    выпол-                           |
|                               нение                            |
|D8 /5   FSUBR m32real  10(8-20) 7(5-17) Замена ST на m32real-ST |
|DC /5   FSUBR m64real  10(8-20) 7(5-17) Замена ST на m64real-ST |
|D8 E8+i FSUBR ST,ST(i) 10(8-20) 7(5-17) Замена ST на ST(i) - ST |
|DC E0+i FSUBR ST(i),ST 10(8-20) 7(5-17) Вычитание ST из ST(i)   |
|DE E0+i FSUBRP ST(i),  10(8-20) 7(5-17) Вычитание ST из ST(i) и |
|               ST                       извлечение из стека ST  |
|DE E1   FSUBR          10(8-20) 7(5-17) Вычитание ST из ST(1) и |
|                                        извлечение из стека ST  |
|DA /5  FISUBR m32int 22.5(19-32)7(5-17) Замена ST на m32int-ST  |
|DE /5  FISUBR m16int  24(20-35) 7(5-17) Замена ST на m16int-ST  |
------------------------------------------------------------------

Работа команды

DEST <- Другой операнд - ST;
IF команда = FSUBRP THEN извлечение из стека ST;  FI;

Описание
Команды обратного вычитания  вычитают вершину стека  из другого операнда  и
возвращают разность в регистр назначения.

Изменяемые флаги модуля операций с плавающей точкой
C1, как описано в Таблице 15-1; C0, C2, C3 не определены.

Исключения числовых операций
P, U, O, D, I, IS.

Исключения защищенного режима
#GP(0)  в  случае  недопустимого  исполнительного  адреса операнда памяти в

сегментах CS, DS,  ES, FS или  GS; #SS(0) в  случае недопустимого адреса  в
сегменте  SS;   #PF(код  сбоя)   в  случае   страничного  сбоя;   #AC   для
невыравненной  ссылки  к  памяти  при  текущем  уровне привилегированности,
равном 3.

Исключения режима реальных адресов
Прерывание  13,  если  какая-либо  часть  операнда  лежит  вне пространства
исполнительных адресов от  0 до 0FFFFH;  Прерывание 7 при  установленном EM
или TS в CR0.

Исключения виртуального режима 8086
Те же исключения,  что и для  режима реальных адресов:  #PF (код сбоя)  для
страничных сбоев; #AC для невыравненной ссылки к памяти при текущем  уровне
привилегированности, равном 3.

Примечания
Если  исходный  операнд   находится  в  памяти,   он  автоматически   будет
преобразован к расширенному действительному формату.


`м`д`05FTST`* - Тестирование

-----------------------------------------------------------------
|Код      Команда  Число       Парал-  Описание                 |
|операции          тактовых    лельное                          |
|                  циклов      выпол-                           |
|                              нение                            |
|D9 E4   FTST         4            1   Сравнение ST с 0.0       |
-----------------------------------------------------------------

Работа команды

CASE (отношение операндов) OF
   Не сравнимы:   C3, C2, C0 <- 111;
   ST > SRC:      C3, C2, C0 <- 000;
   ST < SRC:      C3, C2, C0 <- 001;
   ST = SRC:      C3, C2, C0 <- 100;

-----------------------------------------------------------------
           Флаги FPU          |            EFlags
-----------------------------------------------------------------
             C0                              CF
             C1                              отсутствует
             C2                              PF
             C3                              ZF
-----------------------------------------------------------------

Описание
Команда  тестирования  сравнивает  вершину  стека  с  0.0. После выполнения
команды условные коды отражают результат сравнения.

Изменяемые флаги модуля операций с плавающей точкой
C1, как описано в Таблице 15-1; C0, C2, C3 не определены.

Исключения числовых операций
D,I,IS

Исключения защищенного режима
#NM при установленном EM или TS в CR0.

Исключения режима реальных адресов
Прерывание 7 при установленном EM или TS в CR0.

Исключения виртуального режима 8086
#NM при установленном EM или TS в CR0.

Примечания
Если  ST  имеет  значение  NaN,  или объект, имеющий неопределенный формат,
либо при  сбое в  стеке, то  генерируется исключение  неверной операции,  а
биты условия устанавливаются в значение "неупорядочен".
Знак нулевого значения игнорируется, таким образом что -0.0 = - +0.0.



`м`д`05FUCOM/FUCOMP/FUCOMPP`* -
       -  Неупорядоченное сравнение действительных чисел

-----------------------------------------------------------------
|Код       Команда  Число    Парал-  Описание                   |
|операции           тактовых лельное                            |
|                   циклов   выпол-                             |
|                            нение                              |
|DD E0+i FUCOM ST(i)   4       1   Сравнение ST с ST(i)         |

|DD E1   FUCOM         4       1   Сравнение ST с ST(1)         |
|DD E8+i FUCOMP ST(i)  4       1   Сравнение ST с ST(i)         |
|                                  и извлечение из стека ST     |
|DD E9   FUCOMP        4       1   Сравнение ST с ST(1)         |
|                                  и извлечение из стека ST     |
|DD E9   FUCOMPP       5       1   Сравнение ST с ST(1)         |
|                                и извлечение из стека ST дважды|
-----------------------------------------------------------------

Работа команды

CASE (отношение операндов) OF
   Не сравнимы:   C3, C2, C0 <- 111;
   ST > SRC:      C3, C2, C0 <- 000;
   ST < SRC:      C3, C2, C0 <- 001;
   ST = SRC:      C3, C2, C0 <- 100;
IF команда = FUCOMP THEN извлечение из стека ST; FI;
IF команда = FUCOMPP THEN извлечение  из  стека  ST;извлечение из
                                                   стека ST; FI;

-----------------------------------------------------------------
           Флаги FPU          |            EFlags
-----------------------------------------------------------------
             C0                              CF
             C1                              отсутствует
             C2                              PF
             C3                              ZF
-----------------------------------------------------------------

Описание
Команды неупорядоченного сравнения действительных чисел сравнивают  вершину
стека  с  источником,  который  должен  являться регистром. Если операнд не
задан, то ST сравнивается с  ST(1). После выполнения команды условные  коды
отражают отношение между ST и исходным операндом.

Изменяемые флаги модуля операций с плавающей точкой
C1, как описано в Таблице 15-1; C0, C2, C3 не определены.

Исключения числовых операций
D, I, IS

Исключения защищенного режима
#NM при установленном EM или TS в CR0.

Исключения режима реальных адресов
Прерывание 7 при установленном EM или TS в CR0.

Исключения виртуального режима 8086
#NM при установленном EM или TS в CR0.

Примечания
Если  любой  из  операндов  имеет  значение  SNaN, или имеет неопределенный
формат, либо при сбое  в стеке, генерируется исключение  неверной операции,
а биты условия устанавливаются в значение "неупорядочен".
Если любой из операндов имеет значение QNaN , биты условия  устанавливаются
в значение "неупорядочен".  В отличие от  обычных команд сравнения  (FCOM и
т.д.),  неупорядоченные  команды  сравнения  не  дают  исключения  неверной
операции вследствие наличия операнда QNaN.
Знак нулевого значения игнорируется, таким образом что -0.0 = - +0.0.


`м`д`05FWAIT`* - Ожидание

-----------------------------------------------------------------
|Код       Команда       Число       Описание                   |
|операции                тактовых                               |
|                        циклов                                 |
|                                                               |
|9B        FWAIT         (1-3)       Алиас команды WAIT         |
-----------------------------------------------------------------


Описание
Команда   FWAIT   заставляет   процессор   проверить   наличие  подвешенных
немаскируемых  числовых  исключений,  прежде  чем  перейти  к   дальнейшему
выполнению.

Изменяемые флаги модуля операций с плавающей точкой
C0, C1, C2, C3 не определены.

Исключения числовых операций
Отсутствуют

Исключения защищенного режима
#NM при установленном EM или TS в CR0.

Исключения режима реальных адресов
Прерывание 7 при установленном EM или TS в CR0.

Исключения виртуального режима 8086
#NM при установленном EM или TS в CR0.

Примечания
Как  показывает  ее  код  операции,  команда  FWAIT не является фактической
командой ESC, а просто альтернативной мнемонической формой команды WAIT.
Кодирование команды  FWAIT после  команды ESC  обеспечивает обработку любых
немаскируемых исключений с плавающей точкой, вызываемых командой, до  того,
как процессор сможет каким-либо образом изменить результат команды.
Информация об  использовании команды  FWAIT дается  в главе  18, в  разделе
"Параллельная обработка".


`м`д`05FXAM`* - Рассмотреть

-----------------------------------------------------------------
|Код       Команда  Число            Описание                   |
|операции           тактовых                                    |
|                   циклов                                      |
|                                                               |
|D9 E5      FXAM       8   Сообщить о типе объекта в регистре ST|
-----------------------------------------------------------------

Работа команды

C1 <-   знаковый   бит   ST;   (*  0  для  положительных,  1  для
                                   отрицательных *)
CASE (тип объекта в ST) OF
   Не поддерживается:  C3, C2, C0 <- 000;
   NaN: (не-число)     C3, C2, C0 <- 001;
   Нормированный:      C3, C2, C0 <- 010;
   Неопределенность:   C3, C2, C0 <- 011;
   Ноль:               C3, C2, C0 <- 100;
   Пустой:             C3, C2, C0 <- 101;
   Денормированный:    C3, C2, C0 <- 111;


           Флаги FPU          |            EFlags
-----------------------------------------------------------------
             C0                              CF
             C1                              отсутствует
             C2                              PF
             C3                              ZF
-----------------------------------------------------------------

Описание
Команда сообщает о типе объекта, содержащегося в регистре ST,  устанавливая
флаги FPU.

Изменяемые флаги модуля операций с плавающей точкой
C0, C1, C2, C3, как показано выше.

Исключения числовых операций
Отсутствуют

Исключения защищенного режима
#NM при установленном EM или TS в CR0.

Исключения режима реальных адресов
Прерывание 7 при установленном EM или TS в CR0.

Исключения виртуального режима 8086
#NM при установленном EM или TS в CR0.


`м`д`05FXCH`* - Поменять местами содержимое регистров

-----------------------------------------------------------------
|Код       Команда  Число            Описание                   |
|операции           тактовых                                    |
|                   циклов                                      |
|                                                               |
|D9 C8+i  FXCH ST(i)   4       Поменять местами содержимое ST  и|
|                              ST(i)                            |
|D9 C9    FXCH         4       Поменять местами содержимое ST  и|
|                              ST(1)                            |
-----------------------------------------------------------------

Работа команды

врем <- ST;
ST <- DEST;
DEST <- врем;

Описание
Команда меняет  местами содержимое  регистров назначения  и вершины  стека.
Если назначение явно не задано, то используется ST (1).

Изменяемые флаги модуля операций с плавающей точкой
C1, как описано в Таблице 15-1; C0, C2, C3 не определены.

Исключения числовых операций
IS

Исключения защищенного режима
#NM при установленном EM или TS в CR0.

Исключения режима реальных адресов
Прерывание 7 при установленном EM или TS в CR0.

Исключения виртуального режима 8086
#NM при установленном EM или TS в CR0.

Примечания

Многие  числовые  константы   работают  только  с   вершиной  стека;   FXCH
обеспечивает простое средство использования этих команд в отношении  нижних
элементов стека.  Например, следующая  последовательность берет  квадратный
корень  из  содержимого  третьего  регистра  сверху  (предполагая,  что  ST
непустой):

FXCH ST(3)
FSQRT
FXCH ST(3)


`м`д`05FXTRACT`* - выделение экспоненты и мантиссы

-----------------------------------------------------------------
|Код      Команда  Число       Парал-  Описание                 |
|операции          тактовых    лельное                          |
|                  циклов      выпол-                           |
|                              нение                            |
|D9 F4    FXTRACT  19(16-20)   4(2-4)  Разделение ST на экспоне-|
|                                      нту и мантиссу: ST заме- |
|                                      няется экспонентой, в    |
|                                      мантисса помещается в    |
|                                      стек FPU                 |
-----------------------------------------------------------------


Работа команды

врем <- мантисса ST;
ST <- экспонента ST;
Декремент указателя вершины стека FPU;
ST <- врем;

Описание
FXTRACT  разделяет  значение  в  ST  на  экспоненту  и мантиссу. Экспонента
заменяет исходный  операнд на  стеке, и  затем в  стек помещается мантисса.
После  выполнения  команды  FXTRACT  ST  (новая  вершина  стека)   содержит
значение исходной мантиссы, выраженное действительным числом: его знак  тот
же, что и знак операнда, экспонента равна истинному нулю (16.383 или  3FFFH
со  смещением),  а  мантисса  идентична  мантиссе исходного операнда. ST(1)
содержит  значение  истинной  (несмещенной)  экспоненты исходного операнда,
выраденное действиельным числом.
Для того, чтобы проиллюстрировать работу команды FXTRACT, предположим,  что
ST содержит  число, истинная  экспонента которого  равна +4  (т.е. его поле
экспоненты содержит 4003H). После выполнения FXTRACT ST(1) будет  содержать
действительное число  +4.0; его  знак будет  положительным, поле экспоненты
будет содержать  4001H (истинное  +2), а  поле мантиссы  будет содержать  1
00..00В. Другими словами,  значение в ST(1)  будет равно 1.0  x 2* *2  = 4.
Если ST содержит операнд, истинная компонента которого равна -7 (т.е.  поле
экспоненты его содержит значение 3FF8H), то FXTRACT возвратит  "экспоненту"
равную -7.0l после выполнения команды  поля ST(1) знака и экспоненты  будут
содержать C001H  (отрицательный знак,  истинная экспонента  2), а  мантисса
будет равна  1 1100..00В.  Другими словами,  значение в  ST(1) будет  равно
-1.75  x  2**2  =  -7.0.  В  обоих  случаях  после  FXTRACT поля ST знака и
мантиссы  будут  равны  соответствующим  полям  исходного  операнда, а поле
экспоненты будет содержать 3FFFH (истинный 0).

Изменяемые флаги модуля операций с плавающей точкой
С1, как описано в Таблице 15-1; C0, C2, C3 не определены.

Исключения числовых операций
Z, D, I, IS

Исключения защищенного режима
#NM при установленном EM или TS в CR0.

Исключения режима реальных адресов
Прерывание 7 при установленном EM или TS в CR0.

Исключения виртуального режима 8086
#NM при установленном EM или TS в CR0.

Примечания
FXTRACT (выделить экспоненту и мантиссу) выполняет надмножество
рекомендуемой IEEE функции logb(x).
Если  исходный  операнд  равен  нулю,  то  FXTRACT  оставляет в ST(1) минус
бесконечность  (экспонента),  а  ST  будет  присвоено  нулевое  значение со
знаком,  равным  знаку  исходного  операнда.  В  этом случае также возможно
генерирование исключения деления на ноль.
ST(7) должен быть пустым, чтобы избежать исключения неверной операции.
Команда ST(7)  полезна для  выполнения операций  масштабирования степени  и
диапазона. Для выполнения общей операции возведения в степень  используются
обе команды, FXTRACT и команда экспоненцирования по основанию 2 F2XM1.  Для
преобразования  чисел  в  расширенном  действительном формате к десятичному
представлению (например,  для печати  или вывода  на дисплей)  требуется не
только команда  FBSTP, но  и команда  FXTRACT, позволяющая масштабирование,
не ведущее  к переполнению  диапазона расширенного  формата. FXTRACT  также
может быть полезна при отладке, поскольку позволяет отдельно  рассматривать
экспоненту и мантиссу действительного числа.


`м`д`05FYL2X`* - Вычисление  y  x  log x
                             2
-----------------------------------------------------------------
|Код      Команда  Число       Парал-  Описание                 |
|операции          тактовых    лельное                          |
|                  циклов      выпол-                           |
|                              нение                            |
|D9 F1    FYL2X  311(196-329)  13      Замена ST(1) на          |
|                                      ST(1) x log ST и  извле- |
|                                                 2             |
|                                      чение из стека ST        |
-----------------------------------------------------------------

Работа команды

ST(1) <- ST(1) x log ST;
                    2
извлечение из стека ST;

Описание
Команда FYL2X вычисляет  логарифм ST по  основанию 2, умножает  логарифм на
ST(1) и возвращает полученное значение в ST(1). Операнд в ST не может  быть
отрицательным.

Изменяемые флаги модуля операций с плавающей точкой
C1, как описано в Таблице 15-1; C0, C2, C3 не определены.

Исключения числовых операций
P, U, O, Z, D, I, IS

Исключения защищенного режима
#NM при установленном EM или TS в CR0.

Исключения режима реальных адресов
Прерывание 7 при установленном EM или TS в CR0.

Исключения виртуального режима 8086
#NM при установленном EM или TS в CR0.

Примечания
Если  операнд  в  ST  отрицателен,  то  генерируется  исключение   неверной
операции.
Команда  FYL2X  предназначена,  совместно  с  встроенным  умножением,   для
оптимизации вычисления логарифмов с произвольным положительным основанием:

                    1
     log x = (log b)   x  log  x
        b        2           2

Команды FLDL2T и FLDL2E загружают константы log 10 и  log e,
                                               2        2
соответственно.

Центральный процессор i486 периодически во время выполнения данной  команды
проверяет  прерывания.  Для   обслуживания  прерывания  выполнение   данной
команды отменяется (abort).


`м`д`05FYL2XP1`* - Вычисление  y  x  log (x+1)
                              2
-----------------------------------------------------------------
|Код      Команда  Число       Парал-  Описание                 |
|операции          тактовых    лельное                          |
|                  циклов      выпол-                           |
|                              нение                            |
|D9 F9  FYL2XP1  313(171-326)  13      Замена ST(1) на          |
|                                      ST(1) x log (ST+1.0) и   |
|                                                 2             |
|                                      извлечение из стека ST   |
-----------------------------------------------------------------

Работа команды

ST(1) <- ST(1) x log (ST+1.0);
                    2
извлечение из стека ST;

Описание
Команда  FYL2X  вычисляет  логарифм  (ST+1.0)  по  основанию  2,   умножает
логарифм на ST(1) и возвращает полученное  значение в ST (1). Операнд в  ST
должен лежать в диапазоне:

-(1-(кв.корень из 2/2)) <= ST <= кв.корени из 2 - 1

Изменяемые флаги модуля операций с плавающей точкой
C1, как описано в Таблице 15-1; C0, C2, C3 не определены.

Исключения числовых операций
P, U, D, I, IS

Исключения защищенного режима
#NM при установленном EM или TS в CR0.

Исключения режима реальных адресов
Прерывание 7 при установленном EM или TS в CR0.

Исключения виртуального режима 8086
#NM при установленном EM или TS в CR0.

Примечания
Если операнд в ST лежит вне допустимого диапазона, то результат  выполнения
команды FYL2XP1 неопределен.
Команда FYL2Xp1 обеспечивает повышенную  точность сравнительно с FYL2X  при
вычислении логарифмов чисел, очень близких к 1. При малом значении  эпсилон
большее  количество  значащих  цифр  можно  получить,  передав  эпсилон как
аргумент команды FYL2XP1, чем передав 1+эпсилон команде FYL2X.
Центральный процессор i486 периодически во время выполнения данной  команды
проверяет  прерывания.  Для   обслуживания  прерывания  выполнение   данной
команды отменяется (abort).


`м`д`05HLT`* - Останов

-----------------------------------------------------------------
|Код       Команда  Число      Описание                         |
|операции           тактовых                                    |
|                   циклов                                      |
|                                                               |
| F4        HLT        4       Останов                          |
-----------------------------------------------------------------

Работа команды

Вход в режим останова.

 Описание
Команда HLT останавливает выполнение  команд и переводит процессор  в режим
HLT.   Выполнение   будет   продолжено   после   разрешенного   прерывания,
немаскируемого  прерывания  или  сброса.  Если для возобновления выполнения
после  команды  HLT  используется  прерывание  (включая  немаскируемые), то
сохраненное  значение  CS:IP  (или  CS:EIP)  будет  указывать  на  команду,
следующую за командой HLT.

Изменяемые флаги
Отсутствуют

Исключения защищенного режима
Команда  HLT  является  привилегированной  командой;  #GP(0),  если текущий
уровень привилегированности не равен 0.

Исключения режима реальных адресов
Отсутствуют

Исключения виртуального режима 8086
#GP(0); команда HLT является привилегированной командой.


`м`д`05IDIV`* - Деление со знаком

-----------------------------------------------------------------
|Код       Команда  Число      Описание                         |
|операции           тактовых                                    |
|                   циклов                                      |
|                                                               |
|F6 /7    IDIV r/m8     19/20  Деление со знаком AX на байт r/m |
|                              (AL=частное, AH=остаток)         |
|F7 /7    IDIV AX,r/m16 27/28  Деление со знаком DX:AX на слово |
|                              EA  (AX=частное, DX = остаток)   |
|F7 /7    DIV EAX,r/m32 43/44  Деление со знаком EDX:EAX на     |
|                              двойное слово r/m                |
|                              (EAX=частное,EDX = остаток)      |
-----------------------------------------------------------------

Работа команды

врем <- делимое / делитель;
IF врем не помещается в частном
THEN Прерывание 0;
ELSE
  частное <- врем;
  остаток <- делимое MOD (r/m);
FI;

Замечание: деление со  знаком. Делитель задается  в операнде r/m.  Делимое,
частное  и  остаток  используют  неявно  задаваемые регистры. См. таблицу в
параграфе "Описание".

Описание
Команда DIV выполняет деление со знаком. Делимое, частное и остаток  неявно
распределены фиксированным  регистрам. Только  делитель задается  как явный
операнд  r/m   (регистр/память).  Тип   делителя  определяет   используемые
регистры следующим образом:

-----------------------------------------------------------------
  Размер      Делитель      Частное      Остаток      Делимое
-----------------------------------------------------------------
  байт        r/m8          AL           AH           AX
  слово       r/m16         AX           DX           DX:AX
  двойное
  слово       r/m32         EAX          EDX          EDX:EAX
-----------------------------------------------------------------

Если полученное частное  слишком велико и  не может поместиться  в операнде
назначения,  либо  при  делении  на  0,  генерируется прерывание 0. Нецелые
частные усекаются до  0. Остаток имеет  тот же знак,  что и делимое,  а его
абсолютное значение всегда меньше абсолютного значения делителя.

Изменяемые флаги
Флаги OF, SF, ZF, AF, PF, CF не определены.

Исключения защищенного режима
Прерывание  0,  если  частное  слишком  велико  для  назначенного  для него
регистра  (AL  или  AX),  или  если  делитель  равен  0;  #GP(0)  в  случае
недопустимого исполнительного  адреса операнда  памяти в  сегментах CS, DS,
ES, FS или GS; #SS(0) в случае недопустимого адреса в сегменте SS;  #PF(код
сбоя) в  случае страничного  сбоя; #  AC для  невыравненной ссылки к памяти
при текущем уровне привилегированности, равном 3.

Исключения режима реальных адресов
Прерывание  0,  если  частное  слишком  велико  для  назначенного  для него
регистра  (AL  или  AX),  или  если  делитель  равен 0; Прерывание 13, если
какая-либо часть операнда лежит вне пространства исполнительных адресов  от
0 до 0FFFFH.

Исключения виртуального режима 8086
Те же исключения,  что и для  режима реальных адресов:  #PF (код сбоя)  для
страничных сбоев; #AC для невыравненной ссылки к памяти при текущем  уровне
привилегированности, равном 3.


`м`д`05IMUL`* - Умножение со знаком

-----------------------------------------------------------------
|Код       Команда  Число      Описание                         |
|операции           тактовых                                    |
|                   циклов                                      |
|                                                               |
|F6 /5    IMUL r/m8    13-18/13-18  AX <- AL * байт r/m         |
|F7 /5    IMUL r/m16   13-26/13-26  DX:AX <- AX * слово r/m     |
|F7 /5    IMUL r/m32   12-42/13-42  EDX:EAX <- EAX * двойное    |
|                                   слово r/m                   |
|0F AF /r IMUL r16,    13-26/13-26  регистр-слово <- регистр-   |
|           r/m16                   слово * слово r/m           |
|0F AF /r IMUL r32,    13-42/13-42  регистр-двойное слово <-    |
|           r/m32                   регистр-двойное слово *     |
|                                   двойное слово r/m           |
|6B /r ib IMUL r16,    13-26/13-26  регистр-слово <- r/m16 *    |
|         r/m16,imm8                расширенный знаком непосред-|
|                                   ственный байт               |
|6B /r ib IMUL r32,    13-42/13-42  регистр-двойное слово <-    |
|         r/m32,imm8                r/m32 * расширенный знаком  |
|                                   непосредственный байт       |
|6B /r ib IMUL r16,    13-26        регистр-слово <- регистр-   |
|               imm8                слово * расширенный знаком  |
|                                   непосредственный байт       |
|6B /r ib IMUL r32,    13-26        регистр-двойное слово <-    |
|               imm8                регистр-двойное слово * рас-|
|                                   ширенный знаком непоср.байт |
|69 /r iw IMUL r16,    13-26/13-26  регистр-слово <- r/m16 *    |
|         r/m16,imm16               непосредственное слово      |
|69 /r id IMUL r32,    13-42/13-42  регистр-двойное слово <-    |
|         r/m32,imm32               r/m32 * непосредственное    |
|                                   двойное слово               |
|69 /r iw IMUL r16,    13-26/13-26  регистр-слово <- r/m16 *    |
|               imm16               непосредственное слово      |
|69 /r id IMUL r32,    13-42/13-42  регистр-двойное слово <-    |
|               imm32               r/m32 * непосредственное    |
|                                   двойное слово               |
-----------------------------------------------------------------

Примечания: Процессор i486 использует алгоритм умножения типа  "early-out".
Фактическое число  тактовых циклов  зависит от  позиции наиболее  значащего
бита  в   оптимизируемом  множителе.   Оптимизация  выполняется   как   для
положительных,  так  и  для  отрицательных  значений.  Вследствие   данного
алгоритма  даются  минимальные  и  максимальные количества тактовых циклов.
Для вычисления  фактического числа  тактовых циклов  используется следующая
формула:

Фактическое число тактовых циклов = если m <> 0 то
max(наименьшее целое число, большее (log |m|)) + 6 циклов.
                                        2
Фактическое число тактовых циклов = если m = 0 то 9 циклов.
(где m это множитель)

Если множитель есть операнд памяти, то прибавляется три цикла.
Работа команды
результат <- множимое * множитель

Описание
Команда IMUL выполняет  умножение со знаком.  Некоторые формы этой  команды
используют неявные  операнды-регистры. Комбинации  операндов для  всех форм
команды показаны в колонке "Описание" выше.

Команда IMUL очищает флаги OF и CF в следующих условиях:

-----------------------------------------------------------------
   Форма команды       |      Условие очистки флагов CF и OF
-----------------------------------------------------------------
     r/m8                 AL = расширение знаком AL до 16 битов
     r/m16                AX = расширение знаком AX до 32 битов
     r/m32                EDX:EAX = расширение знаком EAX до 16
                          битов
     r16,r/m16            Результат в точности помещается в r16
     r32,r/m32            Результат в точности помещается в r32
     r16,r/m16,imm16      Результат в точности помещается в r16
     r32,r/m32,imm32      Результат в точности помещается в r32
-----------------------------------------------------------------

Изменяемые флаги

Флаги OF и CF описаны выше в разделе "описание"; флаги SF, ZF,
AF, PF не определены.

Исключения защищенного режима
#GP(0)  в  случае  недопустимого  исполнительного  адреса операнда памяти в
сегментах CS, DS,  ES, FS или  GS; #SS(0) в  случае недопустимого адреса  в
сегменте  SS;   #PF(код  сбоя)   в  случае   страничного  сбоя;   #AC   для
невыравненной  ссылки  к  памяти  при  текущем  уровне привилегированности,
равном 3.

Исключения режима реальных адресов
Прерывание  13,  если  какая-либо  часть  операнда  лежит  вне пространства
исполнительных адресов от 0 до 0FFFFH.

Исключения виртуального режима 8086
Те же исключения,  что и для  режима реальных адресов:  #PF (код сбоя)  для
страничных сбоев; #AC для невыравненной ссылки к памяти при текущем  уровне
привилегированности, равном 3.

Примечания
При использовании некоторых форм аккумулятора  (IMUL r/m8, IMUL r /m16  или
IMUL  r/m32)  результат  умножения  доступен  даже  при установленном флаге
переполнения,  поскольку  размер  результата  в  два  раза превышает размер
множимого  и  множителя.  Это  достаточно  для  обработки любого возможного
результата.


`м`д`05IN`* - Ввод из порта

-----------------------------------------------------------------
|Код       Команда  Число      Описание                         |
|операции           тактовых                                    |
|                   циклов                                      |
|                                                               |
|E4 ib    IN AL,imm8  14,pm=8*/     Ввод байта из непосредствен-|
|                     28**,vm=27    но заданного порта в AL     |
|E5 ib    IN AX,imm8  14,pm=8*/     Ввод слова из непосредствен-|
|                     28**,vm=27    но заданного порта в AX     |
|E5 ib   IN EAX,imm8  14,pm=8*/     Ввод двойного слова из непо-|
|                     28**,vm=27    средственно заданного порта |
|                                   в EAX                       |
|EC       IN AL,DX    14,pm=8*/     Ввод байта из порта DX в AL |
|                     28**,vm=27                                |
|ED       IN AX,DX    14,pm=8*/     Ввод слова из пора DX в AX  |
|                     28**,vm=27                                |
|ED      IN EAX,DX    14,pm=8*/     Ввод двойного слова из порта|
|                     28**,vm=27    DX в EAX                    |
-----------------------------------------------------------------

     Примечания: * если CPL <= IOPL
                ** если CPL >= IOPL

Работа команды

IF (PE = 1) AND ((VM = 1) OR (CPL > IOPL))
THEN (* Виртуальный режим 8086 или защищенный  режим  при  CPL  >
        IOPL *)
  IF NOT I-O-Permission(SRC, width(SRC))
  THEN #GP(0);
  FI;
FI;
DEST <- [SRC]; (* Чтение из адресного пространства ввода/вывода *)

Описание
Команда IN пересылает байт или  слово данных из заданного числом  во втором
операнде  порта  в  регистр  (AL,  AX  или EAX), заданный первым операндом.
Доступ к  любому порту  от 0  до 65535  выполняется путем  помещения номера
порта в регистр  DX и использования  команды IN с  регистром DX в  качестве
второго параметра.  Эти команды  ввода/вывода могут  быть несколько  короче
при  использовании  ввода/вывода  через  8-битовый  порт в команде. Старшие
восемь битов  адреса порта  при использовании  ввода/вывода через 8-битовый
порт будут равны 0.

Изменяемые флаги
Отсутствуют

Исключения защищенного режима
#GP(0),   если   текущий    уровень   привилегированности   больше    (т.е.
привилегированность меньше) уровня привилегированности ввода/вывода  (IOPL)
или  если  любой  из  соответствующих  битов  разрешения ввода/вывода в TSS
равен 1.

Исключения режима реальных адресов
Отсутствуют

Исключения виртуального режима 8086
Сбой #GP(0), если любой из соответствующих битов разрешения ввода/вывода  в
TSS равен 1.


`м`д`05INC`* - Инкремент на 1

-----------------------------------------------------------------
|Код       Команда  Число      Описание                         |
|операции           тактовых                                    |
|                   циклов                                      |
|                                                               |
|FE /0     INC r/m8  1/3       Инкремент байта r/m на 1         |
|FF /0     INC r/m16 1/3       Инкремент слова r/m на 1         |
|FF /6     INC r/m32 1/3       Инкремент двойного слова r/m на 1|
|40 + rw   INC r16   1         Инкремент слова в регистре на 1  |
|40 + rd   INC r32   1         Инкремент двойного слова         |
|                              в регистре на 1                  |
-----------------------------------------------------------------

Работа команды

DEST <- DEST + 1;

Описание
Команда DEC прибавляет 1 к операнду. Команда INC не изменяет флага CF.  Для
воздействия  на  флаг  CF   используйте  команду  ADD  с   непосредственным
операндом, равным 1.

Изменяемые флаги
Флаги OF, SF, ZF, AF и PF устанавливаются в соответствии с результатом.

Исключения защищенного режима
#GP(0), если результат должен помещаться в сегмент, для которого  запрещена
запись;  #GP(0)  в  случае  недопустимого  исполнительного  адреса операнда
памяти в сегментах  CS, DS, ES,  FS или GS;  #SS(0) в случае  недопустимого
адреса в  сегменте SS;  #PF(код сбоя)  в случае  страничного сбоя;  #AC для
невыравненной  ссылки  к  памяти  при  текущем  уровне привилегированности,
равном 3.

Исключения режима реальных адресов
Прерывание  13,  если  какая-либо  часть  операнда  лежит  вне пространства
исполнительных адресов от 0 до 0FFFFH.

Исключения виртуального режима 8086
Те же исключения,  что и для  режима реальных адресов:  #PF (код сбоя)  для
страничных сбоев; #AC для невыравненной ссылки к памяти при текущем  уровне
привилегированности, равном 3.


`м`д`05INS/INSB/INSW/INSD`*  - Ввод из порта в строку

-----------------------------------------------------------------
|Код       Команда  Число      Описание                         |
|операции           тактовых                                    |
|                   циклов                                      |
|                                                               |
|6C      INS r/m8,DX  17,pm=10*/    Ввод байта из порта DX в    |
|                     32**,vm=30    ES:(E)DI                    |
|6D      INS r/m16,DX 17,pm=10*/    Ввод слова из порта DX в    |
|                     32**,vm=30    ES:(E)DI                    |
|6D      INS r/m32,DX 17,pm=10*/    Ввод двойного слова из      |
|                     32**,vm=30    порта DX в ES:(E)DI         |
|6C      INSB         17,pm=10*/    Ввод байта из порта DX в    |
|                     32**,vm=30    ES:(E)DI                    |
|6D      INSW         17,pm=10*/    Ввод слова из порта DX в    |
|                     32**,vm=30    ES:(E)DI                    |
|6D      INSD         17,pm=10*/    Ввод двойного слова из порта|
|                     32**,vm=30    DX в ES:(E)DI               |
-----------------------------------------------------------------

     Примечания: * если CPL <= IOPL
                ** если CPL >= IOPL

Работа команды

IF AddressSize = 16
THEN использование DI для индексации назначения;
ELSE (* AddressSize = 32 *)
     использование EDI для индексации назначения;

FI;
IF (PE = 1) AND ((VM = 1) OR (CPL > IOPL))
THEN (* Виртуальный режим 8086 или защищенный  режим  при  CPL  >
        IOPL *)
  IF NOT I-O-Permission(SRC, width(SRC))
  THEN #GP(0);
  FI;
FI;
IF команда байтового типа
THEN
  ES:[индекс-назначения] <- [DX];  (* Чтение байта  из  адресного
      пространства ввода/вывода согласно DX *)
  IF DF = 0 THEN IncDec <- 1 ELSE IncDec <- -1; FI;
FI;
IF AddressSize = 16
THEN
  ES:[индекс-назначения] <- [DX];  (* Чтение слова  из  адресного
      пространства ввода/вывода согласно DX *)
  IF DF = 0 THEN IncDec <- 2 ELSE IncDec <- -2; FI;
FI;
IF AddressSize = 32
THEN
  ES:[индекс-назначения] <- [DX];  (* Чтение двойного слова
      из  адресного пространства ввода/вывода согласно DX *)
  IF DF = 0 THEN IncDec <- 4 ELSE IncDec <- -4; FI;
FI;
индекс-назначения <- индекс-назначения + IncDec;

 Описание
Команда INS пересылает данные из заданного регистром DX порта ввода в  байт
памяти  или  слово  памяти  по  адресу ES:индекс-назначения. Операнд памяти
должен  адресоваться  регистром  ES;  переопределение  сегмента невозможно.
Регистр назначения -  это регистр DI,  если атрибут размера  адреса команды
равен  16  битам,  или  регистр  EDI,  если атрибут размера адреса равен 32
бита.
Команда INS не позволяет  задавать номер порта непосредственным  значением.
Порт  должен  адресоваться  значением  в  регистре  DX.  Перед  выполнением
команды INS в DX должно быть загружено правильное значение.
Адрес  назначения  определяется  содержимым  регистра  индекса  назначения.
Перед  выполнением  команды  INS  в  регистр индекса назначения должно быть
загружено правильное значение.
После  выполнения  пересылки  регистр  DI  или  EDI  автоматически получает
соответствующее приращение. Если  флаг DF равен  0 (была выполнена  команда
CLD), то происходит инкремент  регистров DI или EDI;  Если флаг DF равен  1
(была  выполнена  команда  STD),  то  происходит декремент регистров DI или
EDI.  Инкремент  или  декремент  регистров  равен  1 при вводе байта, 2 при
вводе слова и 4 при вводе двойного слова.
Команды INSB, INSW и INSD - это синонимы команды INS, работающие с  байтом,
словом и двойным словом,  соответственно. Команде INS может  предшествовать
префикс  REP  для  ввода  блока,  равного  CX байтов или слов. Эта операция
описана для команды REP.

Изменяемые флаги
Отсутствуют

Исключения защищенного режима
#GP(0),  если  текущий  уровень  привилегированности численно больше уровня
привилегированности ввода/вывода (IOPL)  или если любой  из соответствующих
битов  разрешения  ввода/вывода  в  TSS  равен  1.  #GP (0), если результат
должен  помещаться  в  сегмент,  для  которого  запрещена  запись; #GP(0) в
случае  недопустимого  исполнительного  адреса  операнда памяти в сегментах
CS, DS, ES, FS или GS; #SS(0) в случае недопустимого адреса в сегменте  SS;
#PF(код сбоя)  в случае  страничного сбоя;  #AC для  невыравненной ссылки к
памяти при текущем уровне привилегированности, равном 3.

Исключения режима реальных адресов
Прерывание  13,  если  какая-либо  часть  операнда  лежит  вне пространства
исполнительных адресов от 0 до 0FFFFH.

Исключения виртуального режима 8086
Сбой #GP(0), если любой из соответствующих битов разрешения ввода/вывода  в
TSS равен  1. #PF  (код сбоя)  для страничных  сбоев; #AC для невыравненной
ссылки к памяти при текущем уровне привилегированности, равном 3.


`м`д`05CALL/INTO`* - Вызов процедуры прерывания

-----------------------------------------------------------------
|Код       Команда     Число      Описание                      |
|операции              тактовых                                 |
|                      циклов                                   |
|CC        INT 3       26        Прерывание 3 -                 |
|                                ловушка для отладчика          |

|CC        INT 3       44        Прерывание 3 -Защищенный режим,|
|                                та же привилегированность      |
|CC        INT 3       71        Прерывание 3 -Защищенный режим,|
|                                большая привилегированность    |
|CC        INT 3       82        Прерывание 3 - из режима V86, к|
|                                уровню прив-сти PL 0           |
|CC        INT 3       37+TS     Прерывание 3 -Защищенный режим,|
|                                через шлюз задачи              |
|CD ib     INT imm8    30        Прерывание, заданное непосред- |
|                                ственным байтом                |
|CD ib     INT imm8    44        Прерывание  - Защищенный режим,|
|                                та же привилегированность      |
|CD ib     INT imm8    71        Прерывание  - Защищенный режим,|
|                                большая привилегированность    |
|CD ib     INT imm8    86        Прерывание  -  из режима V86, к|
|                                уровню прив-сти PL 0           |
|CD ib     INT imm8    37+TS     Прерывание  - Защищенный режим,|
|                                через шлюз задачи              |
|CE        INTO     Успешно:28   Прерывание 4 - Если флаг пере- |
|                    Сбой  : 3   полнения равен 1               |
|CE        INTO        46        Прерывание 4 -Защищенный режим,|
|                                та же привилегированность      |
|CE        INTO        73        Прерывание 4 -Защищенный режим,|
|                                большая привилегированность    |
|CE        INTO        84        Прерывание 4 - из режима V86, к|
|                                уровню прив-сти PL 0           |
|CE        INTO        39+TS     Прерывание 4 -Защищенный режим,|
|                                через шлюз задачи              |
-----------------------------------------------------------------

Примечание: приближенные значения ts задаются следующей таблицей:

-----------------------------------------------------------------
                     |          Новая задача
     Старая задача   |-------------------------------------------
                     | к TSS i486 | к TSS 80286 | к TSS VM
-----------------------------------------------------------------
 VM/i486/TSS 80286   |     199    |     180     |     177
-----------------------------------------------------------------

Работа команды

Примечание: Следующее операционное описание применимо не только
к вышеупомянутым командам, но и к внешним прерываниям и
исключениям.

IF PE = 0
THEN GOTO РЕЖИМ-РЕАЛЬНЫХ-АДРЕСОВ;
pELSE GOTO ЗАЩИЩЕННЫЙ РЕЖИМ;
FI;

РЕЖИМ-РЕАЛЬНЫХ_АДРЕСОВ:
  Push(FLAGS);
  IF <- 0; (* Очистить флаг прерывания *)
  TF <- 0; (* Очистить флаг ловушки *)
  Push(CS);
  Push(IP);
  (* Коды ошибки в стек не помещались *)
  CS <- IDT[Номер прерывания * 4].селектор;
  IP <- IDT[Номер прерывания * 4].смещение;

ЗАЩИЩЕННЫЙ-РЕЖИМ:
  Вектор прерывания должен быть в пределах границы таблицы IDT,
     иначе #GP(номер вектора * 8 + 2 + EXT);
  Байт дескриптора AR должен указывать на шлюз  прерывания,  шлюз
                                          ловушки или шлюз задачи,
     иначе #GP(номер вектора * 8 + 2 + EXT);
  IF программное  прерывание (* т.е.  вызванное INT n,  INT 3 или
                                          INTO *)
  THEN
    IF DPL дескриптора шлюза < CPL
    THEN #GP(номер вектора * 8 + 2 + EXT);
    FI;
  FI;
  Шлюз должен присутствовать,  иначе #NP(номер вектора * 8 + 2  +
                                          EXT);
  IF шлюз ловушки OR шлюз прерывания
  THEN GOTO ШЛЮЗ-ПРЕРЫВАНИЯ-ИЛИ-ШЛЮЗ-ПРЕРЫВАНИЯ;
  ELSE GOTO ШЛЮЗ-ЗАДАЧИ;
  FI;

ШЛЮЗ-ЛОВУШКИ-ИЛИ-ШЛЮЗ-ПРЕРЫВАНИЯ:
  Рассмотрим селектор  CS  и  дескриптор,  заданный в дескрипторе
                               шлюза;

  Селектор должен быть не-пустым, иначе #GP(EXT);
  Селектор должен быть в границах его дескрипторной таблицы
    ELSE #GP(селектор+EXT);
  Байт дескриптора AR должен указывать кодовый сегмент
    ELSE #GP(селектор+EXT);
  Сегмент должен присутствовать, иначе #NP(селектор+EXT);

  IF не-конформный кодовый сегмент AND DPL < CPL
  THEN GOTO ПРЕРЫВАНИЕ-НА-ВНУТРЕННЕЕ-КОЛЬЦО-ПРИВИЛЕГИРОВАННОСТИ;
  ELSE
    IF конформный кодовый сегмент AND DPL = CPL
    THEN GOTO ПРЕРЫВАНИЕ-НА-ТОТ-ЖЕ-УРОВЕНЬ-ПРИВИЛЕГИРОВАННОСТИ;
    ELSE #GP(селектор CS + EXT);
    FI;
  FI;

ПРЕРЫВАНИЕ-НА-ВНУТРЕННЕЕ-КОЛЬЦО-ПРИВИЛЕГИРОВАННОСТИ:
  Проверка селектора и дескриптора нового стека в текущем TSS;
    Селектор должен быть не-пустым, иначе #TS(EXT);
    Индекс селектора должен быть в границах дескрипторной таблицы
      ELSE #TS(селектор SS + EXT);
    RPL селектора должен быть равен DPL кодового сегмента
      ELSE #TS(селектор SS + EXT);
    RPL сегмента стека должен быть равен DPL кодового сегмента
      ELSE #TS(селектор SS + EXT);
    Дескриптор должен указывать на доступный для  записи  сегмент
            данных
      ELSE #TS(селектор SS + EXT);
    Сегмент должен присутствовать
      ELSE #SS(селектор SS + EXT);
  IF 32-битовый шлюз
  THEN новый стек должен иметь место для 20 байтов иначе #SS(0)
  ELSE новый стек должен иметь место для 10 байтов иначе #SS(0)
  FI;
  Указатель команд  должен  быть  в  границах  сегмента  CS иначе #GP(0);
  Загрузка нового значения SS и eSP из TSS;
  IF 32-байтовый шлюз
  THEN CS:EIP <- селектор:смещение из шлюза;
  ELSE CS:IP <- селектор:смещение из шлюза;
  FI;
  Загрузка дескриптора CS в невидимую часть регистра CS;
  Загрузка дескриптора SS в невидимую часть регистра SS;
  IF 32-битовый шлюз
  THEN
    Push (дальний указатель на старый стек) (* 3 слова дополняются
                     заполнителями до 4 *);
    Push (EFLAGS);
    Push (дальний   указатель  на  адрес  возврата)  (*  3  слова
                     дополняются заполнителями до 4 *);
  ELSE
    Push (дальний указатель на старый стек) (* 2 слова *)
    Push (FLAGS);
    Push (дальний   указатель  на  адрес  возврата)  (* 2 слова *)

  FI;
  Установка CPL в значение DPL нового кодового сегмента;
  Установка RPL CS в значение CPL;
  IF шлюз   прерывания   THEN  IF  <-  0  (*  флаг  прерывания  0
               (запрещение)  *);  FI;
  TF <- 0;
  NT <- 0;


ПРЕРЫВАНИЕ-ИЗ-РЕЖИМА-V86:
  ВремEFlags <- EFLAGS;
  VM <- 0;
  TF <- 0;
  IF обслуживается через шлюз прерывания THEN IF <- 0;
  ВремSS <- SS;
  ВремESP <- ESP;
  SS <- TSS.SS0; (* изменение на стековый сегмент уровня 0 *)
  ESP <- TSS.ESP0; (* изменение на стековый сегмент уровня 0 *)
  Push(GS);  (* Дополняется до двух слов *)
  Push(FS);  (* Дополняется до двух слов *)
  Push(DS);  (* Дополняется до двух слов *)
  Push(ES);  (* Дополняется до двух слов *)
  GS <- 0;
  FS <- 0;
  DS <- 0;
  ES <- 0;
  Push(ВремSS);  (* Дополняется до двух слов *)
  Push(ВремESP);
  Push(ВремEflags);
  Push(CS);  (* Дополняется до двух слов *)

  Push(EIP);
  CS:EIP <- селектор:смещение из шлюза прерывания;
(* Начинается выполнение новой подпрограммы в защищенном режиме *)

ПРЕРЫВАНИЕ-НА-ТОТ-ЖЕ-УРОВЕНЬ-ПРИВИЛЕГИРОВАННОСТИ:
  IF 32-битовый шлюз
  THEN Границы  текущего  стека должны позволить поместить туда 10
        байтов, иначе #SS(0);
  ELSE Границы  текущего  стека должны позволить поместить туда 6
        байтов, иначе #SS(0);
  FI;
  IF прерывание было вызвано исключением с кодом ошибки
  THEN Границы  стека должны позволить поместить туда еще 2 байта;
  ELSE #SS(0);
  FI;
  Указатель команд должен находиться в границах CS, иначе #GP(0);
  IF 32-битовый шлюз
  THEN
    Push(EFLAGS);
    Push(дальний указатель  на  адрес  возврата);  (*  3   слова,
         дополненные до 4 слов  *)
    CS:IP <- селектор:смещение из шлюза;
  ELSE (* 16-битовый шлюз *)
    Push(FLAGS);
    Push(дальний указатель  на  адрес  возврата);  (*  2 слова *)
    CS:IP <- селектор:смещение из шлюза;
  FI;
  Загрузка дескриптора CS в невидимую часть регистра CS;
  Установка поля RPL CS равным CPL;
  Push(код ошибки); (* если он имеется *)
  IF шлюз прерывания THEN IF <- 0; FI;
  TF <- 0;
  NT <- 0;

ШЛЮЗ-ЗАДАЧИ:
  Рассмотрим селектор  CS, заданный в дескрипторе шлюза задачи;
    В бите   Локальный/Глобальный  должно  быть  задано  значение
               Глобальный, иначе #TS(селектор TSS);
    Индекс должен быть в границах GDT, иначе #TS(селектор TSS);
    Байт AR должен задавать доступный TSS (нижние биты 00001),
      иначе #TS(селектор TSS);
    TSS должен присутствовать, иначе #NP(селектор TSS);
  ПЕРЕКЛЮЧЕНИЕ-ЗАДАЧ со вложенностью в TSS;
  IF прерывание было вызвано сбоем с кодом ошибки
  THEN
    Границы стека должны позволить поместить туда еще 2 байта,
       иначе ##SS(0);
    Помещение в стек код ошибки;
  FI;
  Указатель команд должен быть в пределах CS, иначе #GP(0);


Описание
Команда  INT   n  программно   генерирует  вызов   оработчика   прерывания.
Непосредственный  операнд,  от  0  до  255,  задает номер индекса в таблице
дескрипторов  прерываний  (IDT)  для  вызываемой подпрограммы прерывания. В
защищенном  режиме  IDT  состоит  из  массива восьми-байтовых дескрипторов;
дескриптор  для   активизированного  прерывания   должен  обозначать   шлюз
прерывания, ловушки или задачи. В режиме реальных адресов IDT  представляет
собой массив  из указателей  длиной в  четыре байта.  В защищенном режиме и
режиме реальных  адресов базовый  линейный адрес  IDT определен  содержимым
IDTR.
Условная команда INTO  идентична команде прерывания  INT n, за  исключением
того, что номер  прерывания неявно устанавливается  равным 4, и  прерывание
происходит только при установленном флаге переполнения процессора i486.
Первые 32 прерывания резервированы Intel для системных целей. Некоторые  из
этих прерываний используются для внутренних исключений.
Команда INT n в  целом ведет себя как  дальний вызов, за исключением  того,
что  флаговый  регистр  помещается  в  стек  до  адреса возврата. Процедуры
прерывания выполняют  возврат посредством  команды IRET,  которая извлекает
из стека флаги и адрес возврата.
В режиме реальных адресов команда INT  n помещает в стек флаги, регистр  CS
и IP для возврата в указанной последовательности и затем выполняет  переход
к дальнему указателю, индексируемому номером прерывания.

Изменяемые флаги
Отсутствует

Исключения защищенного режима
#GP, #NP, #SS и #TS, как указано выше в разделе "Работа команды".

Исключения режима реальных адресов
Отсутствуют; если регистр  SP или ESP  равен 1, 3  или 5 перед  выполнением
команды INT или  INTO, то процессор  переходит в режим  закрытия вследствие
недостаточного размера стека.

Исключения виртуального режима 8086
Сбой #GP(0), если IOPL  меньше 3, только для  команды INT n, что  позволяет
эмуляцию;  Прерывание  3  (0CCH)  генерирует  исключение контрольной точки;
команда  INTO  генерирует  исключение  переполнения при установленном флаге
OF.


`м`д`05INVD`* - Аннулирование кеша

-----------------------------------------------------------------
|Код       Команда  Число      Описание                         |
|операции           тактовых                                    |
|                   циклов                                      |
|                                                               |
|0F 08     INVD       4        Аннулирование всего кеша         |
-----------------------------------------------------------------

Работа команды

Очистка внутреннего кеша
Сигнал внешнему кешу на очистку

Описание
Происходит  очистка  внутреннего  кеша,  и  выдается специальный цикл шины,
указывающий на необходимость очистки внешних кешей. Данные, находящиеся  во
внешних кешах с обратной записью, теряются.

Изменяемые флаги
Отсутствуют

Исключения защищенного режима
Отсутствуют

Исключения режима реальных адресов
Отсутствуют

Исключения виртуального режима 8086
Отсутствуют

Примечания
Данная  команда  зависима  от  реализации:  разные  процессоры  Intel могут
реализовывать ее функции по-разному.
Ответственность  за  реакцию  на  сигнал  очистки  внешнего  кеша  лежит на
аппаратном обеспечении.
Данная команда процессорами  386 не поддерживается.  Использование команды,
совместимой  с  процессорами  386  см.  в  разделе  3.11.  Обратная  запись
"грязных" данных из  кеша в оперативную  память рассматривается в  описании
команды WBINVD.

Запрещение кеширования рассматривается в разделе 12.2.


`м`д`05INVLPG`* - Аннулирование элемента TLB

-----------------------------------------------------------------
|Код       Команда  Число      Описание                         |
|операции           тактовых                                    |
|                   циклов                                      |
|                                                               |
|0F 01/7   INVLPG   12 в случае  Аннулирование элемента TLB     |
|                   совпадения                                  |
-----------------------------------------------------------------

Работа команды

Аннулирование элемента TLB

Описание
Команда  INVLPG  используется  для  аннулирования  одного  элемента  в TLB,
который  представляет  собой  кеш,  используемый  для  хранения   элементов
страничных  таблиц.  Если  TLB  содержит  достоверный элемент, отображающий
адрес операнда памяти, то этот элемент будет помечен как недостоверный.

Изменяемые флаги
Отсутствуют

Исключения защищенного режима
При  использовании  команды  с  операндом-регистров генерируется исключение
неверного кода операции.

Исключения режима реальных адресов
Отсутствуют

Исключения виртуального режима 8086
При  использовании  команды  с  операндом-регистров генерируется исключение
неверного кода операции.

Примечания
Данная  команда  зависима  от  реализации:  разные  процессоры  Intel могут
реализовывать ее функции по-разному.
Данная команда процессорами  386 не поддерживается.  Использование команды,
совместимой с процессорами 386 см. в разделе 3.11

Запрещение кеширования рассматривается в разделе 12.2.


`м`д`05IRET/IRETD`* - Возврат из прерывания

-----------------------------------------------------------------
|Код       Команда     Число      Описание                      |
|операции              тактовых                                 |
|                      циклов                                   |
|                                                               |
|CF        IRET        15        Возврат из прерывания          |
|                                (дальний возврат и извлечение  |
|                                из стека флагов)               |
|CF        IRET        36        Возврат из прерывания          |
|                                к меньшему уровню              |
|                                привилегированности            |
|CF        IRET        TS+32     Возврат из прерывания,         |
|                                другая задача (NT = 1)         |
|CF        IRETD       15        Возврат из прерывания          |
|                                (дальний возврат и извлечение  |
|                                из стека флагов)               |
|CF        IRETD       36        Возврат из прерывания          |
|                                к меньшему уровню              |
|                                привилегированности            |
|CF        IRETD       15        Возврат из прерывания,         |
|                                к режиму V86                   |
|CF        IRET        TS+32     Возврат из прерывания,         |
|                                другая задача (NT = 1)         |
-----------------------------------------------------------------

Примечание: приближенные значения ts задаются следующей
таблицей:

-----------------------------------------------------------------
                     |          Новая задача
     Старая задача   |-------------------------------------------
                     | к TSS i486 | к TSS 80286 | к TSS VM
-----------------------------------------------------------------
 VM/i486/TSS 80286   |     199    |     180     |     177
-----------------------------------------------------------------

Работа команды

IF PE = 0
THEN (* Режим реальных адресов *)
  IF operandSize = 32 (* Команда = IRETD *)
  THEN EIP <- Pop();
  ELSE (* Команда = IRET *)
    IP <- Pop();
  FI;
  CS <- Pop();
  IF OperandSize = 32 (* Команда = IRETD *)
  THEN EFLAGS <- Pop();
  ELSE (* Команда = IRET *)
    FLAGS <- Pop();
  FI;
ELSE (* Защищенный режим *)
  IF VM = 1
  THEN #GP(0);
  ELSE
    IF NT = 1
    THEN GOTO ВОЗВРАТ-ЗАДАЧИ;
    ELSE
      IF VM = 1 в образе флагов, находящемся в стеке
      THEN GOTO ВОЗВРАТ-СТЕКА-К-V86;
      ELSE GOTO ВОЗВРАТ-СТЕКА;
      FI;
    FI;
  FI;
FI; ВОЗВРАТ-СТЕКА-К-V86:  (* Прерванная процедура в режиме V86 *)
  IF верхние 36 байтов стека не в пределах границ

  THEN #SS(0);
  FI;
  IF указатель команд не в границах кодового сегмента THEN #GP(0);
  FI;

  EFLAGS <-   SS:[ESP   +  8];  (*  Устанавливает  VM  прерванной
                                    подпрограммы *)
  EIP <- Pop();
  CS <- Pop(); (* CS ведет себя, как в 8086, т.к. VM = 1 *)
  Потеря <-   Pop();   (*  извлечение  из  стека  с  потерей  уже
                           считанного EFLAGS *)
  ВремESP <- Pop();
  ВремSS <- Pop();
  ES <-  Pop();  (*  Извлекаются из стека 2 слова;  старшее слово
                     отбрасывается *)
  DS <-  Pop();  (*  Извлекаются из стека 2 слова;  старшее слово
                     отбрасывается *)
  FS <-  Pop();  (*  Извлекаются из стека 2 слова;  старшее слово
                     отбрасывается *)
  GS <-  Pop();  (*  Извлекаются из стека 2 слова;  старшее слово
                     отбрасывается *)
    SS:ESP <- ВремSS:ВремESP;

  (* Возобновление выполнения в виртуальном режиме 8086 *)

ВОЗВРАТ-ЗАДАЧИ:
  Рассмотрим селектор обратной компоновки задач в TSS, адресуемом
    регистром текущей задачи;
    В бите   Локальный/Глобальный  должно  быть  задано  значение
               Глобальный, иначе #TS(селектор нового TSS);
    Индекс должен быть в границах GDT,  иначе #TS(селектор нового
                                                   TSS);
    Байт AR должен задавать TSS, иначе #TS(селектор нового TSS);
    TSS должен присутствовать, иначе #NP(селектор нового TSS);
  ПЕРЕКЛЮЧЕНИЕ-ЗАДАЧ без вложенности в TSS,  заданный  селектором
                           обратной компоновки задач;
  Обозначение прерванной задачи как NOT BUSY (не занято);
  Указатель команд должен быть в пределах границ кодового сегмента,
  ELSE #GP(0);

ВОЗВРАТ-СТЕКА:
  IF OperandSize = 32
  THEN Третье слово в стеке должно быть в пределах границ стека,
       иначе #SS(0);
  ELSE Второе слово в стеке должно быть в пределах границ стека,
       иначе #SS(0);
  FI;
  RPL селектора   CS   возврата   должен   быть   >=  CPL,  иначе
                       #GP(селектор возврата);
  IF RPL селектора возврата = CPL
  THEN GOTO ВОЗВРАТ-НА-ТОТ-ЖЕ-УРОВЕНЬ;
  ELSE GOTO ВОЗВРАТ-НА-ВНЕШНИЙ-УРОВЕНЬ;
  FI;

ВОЗВРАТ-НА-ТОТ-ЖЕ-УРОВЕНЬ:
  IF OperandSize = 32
  THEN
    Верхние 12  байтов  в  стеке  должны  быть в пределах границ,
                    иначе #SS(0);
    Селектор CS возврата (в eSP+4) должен быть не-пустым, иначе #
                          #GP(0);
  ELSE
    Верхние 6   байтов  в  стеке  должны  быть в пределах границ,
                    иначе #SS(0);
    Селектор CS возврата (в eSP+2) должен быть не-пустым, иначе #
                          #GP(0);
  FI;
  Индекс селектора должен быть в границах его таблицы дескрипторов,
          иначе #GP(селектор возврата);
  Байт AR  должен  задавать  кодовый сегмент,  иначе #GP(селектор
          возврата);
  IF не-конформный
  THEN DPL кодового сегмента должен быть = CPL;
  ELSE #GP(селектор возврата);
  FI;
  IF конформный
  THEN DPL  кодового  сегмента  должен   быть   <=   CPL,   иначе
           #GP(селектор возврата);
  Указатель команд должен быть в пределах границ кодового сегмента,
           иначе #GP(0);
  FI;
  IF OperandSize = 32
  THEN
    Загрузка CS:IP из стека;

    Загрузка регистра CS дескриптором нового кодового сегмента;
    Загрузка EFLAGS третьим двойным словом из стека;
    Инкремент eSP на 12;
  ELSE
    Загрузка регистра CS дескриптором нового кодового сегмента;
    Загрузка EFLAGS третьим словом из стека;
    Инкремент eSP на 6;
  FI;

ВОЗВРАТ-НА-ВНЕШНИЙ-УРОВЕНЬ:
  IF OperandSize = 32
  THEN Верхние 20 байтов  в  стеке  должны  быть в пределах границ,
                    иначе #SS(0);
  ELSE Верхние 10 байтов  в  стеке  должны  быть в пределах границ,
                    иначе #SS(0);
  FI;
  Рассмотрим селектор CS возврата и связанный с ним дескриптор:
    Селектор должен быть не-пустым, иначе #GP(0);
    Индекс селектора должен быть в границах его таблицы дескрипторов,
          ELSE #GP(селектор возврата);
    Байт AR  должен  задавать  кодовый сегмент,  иначе #GP(селектор
          возврата);
    IF не-конформный
    THEN DPL кодового сегмента должен быть = RPL селектора CS;
    ELSE #GP(селектор возврата);
    FI;
    IF конформный
    THEN DPL  кодового  сегмента  должен   быть   > CPL,
    ELSE #GP(селектор возврата);
    FI;
    Сегмент должен присутствовать, иначе #NP(селектор возврата);

  Рассмотрим селектор SS возврата и связанный с ним дескриптор:
    Селектор должен быть не-пустым, иначе #GP(0);
    Индекс селектора должен быть в границах его таблицы дескрипторов,
          ELSE #GP(селектор SS);
    RPL селектора должен быть равен RPL селектора CS возврата
          ELSE #GP(селектор SS);
    Байт AR  должен  задавать сегмент данных, доступный для записи,
          иначе #GP(селектор SS);
    DPL сегмента стека должен быть = RPL селектора CS возврата;
    ELSE #GP(селектор SS);
    SS должен присутствовать, иначе #NP(селектор SS);

  Указатель команд должен быть в пределах границ кодового сегмента,
           иначе #GP(0);
  IF OperandSize = 32
  THEN
    Загрузка CS:EIP из стека;
    Загрузка EFLAGS значениями в (eSP+8);
  ELSE
    Загрузка CS:IP из стека;
    Загрузка FLAGS значениями в (eSP+4);
  FI;
  Загрузка SS:eSP из стека;
  Загрузка регистра CS дескриптором CS;
  Загрузка регистра SS дескриптором SS;
  FOR каждого из ES, FS, GS и DS
  DO;
    IF текущее значение регистра недостоверно для внешнего уровня;
    THEN обнуление регистра и очистка флага достоверности;
    FI;
    Чтобы быть    достоверным,    установка    регистра    должна
                 удовлетворять следующим свойствам:
      Индекс селектора должен быть в границах его таблицы
           дескрипторов;
      Байт AR  должен  задавать сегмент данных, доступный для
           записи, или кодовый сегмент, доступный для чтения;
      IF это сегмент данных или не-конформный кодовый сегмент,
      THEN DPL должен быть > CPL, или DPL должен быть < RPL;
  OD;

 Описание
В  режиме  реальных  адресов  команда  IRET  извлекает  из  стека указатель
команд, регистр CS и  флаговый регистр, после чего  возобновляет выполнение
прерванной подпрограммы.
В  защищенном  режиме  действие  команды  IRET  зависит  от установки флага
вложенности задачи (NT) в регистре  флагов. При извлечении из стека  нового
образа  флагов  биты  IOPL  флагового  регистра  изменяются  только при CPL
равном 0.
Если флаг NT очищен, команда IRET возвращается из процедуры прерывания  без
переключения задачи. Код, в который происходит возврат, должен быть  равным
или  менее  привилегированным,  чем  подпрограмма прерывания (как указывают
биты RPL селектора  CS, извлекаемого из  стека). Если код  назначения менее

привилегирован, то команда IRET также извлекает из стека указатель стека  и
SS.
Если  флаг  NT   установлен,  то  команда   IRET  выполняется  в   обратной
последовательности   относительно   команд   CALL   или   INT,    вызвавших
переключение  задачи.  Обновленное  состояние  задачи,  выполняющей команду
IRET,  сохраняется  в  ее  сегменте  состояния  задачи (TSS). При повторном
входе в задачу  впоследствии выполняется код,  который следует за  командой
IRET.

Изменяемые флаги
Изменяются все флаги; регистр флагов извлекается из стека.

Исключения защищенного режима
#GP, #NP или #SS, как указано выше в разделе "Работа команды".

Исключения режима реальных адресов
Прерывание 13, если какая-либо  часть извлекаемого из стека  операнда лежит
за адресом 0FFFFH.

Исключения виртуального режима 8086
Сбой #GP(0), если IOPL меньше 3, что позволяет эмуляцию.


`м`д`05Jcc`* - Переход, если условие перехода удовлетворяется

-----------------------------------------------------------------
|Код       Команда     Число      Описание                      |
|операции              тактовых                                 |
|                      циклов                                   |
|                                                               |
|77 cb     JA rel8     3,1       Переход короткий, если выше    |
|                                (CF = 0 и ZF = 0)              |
|73 cb    JAE rel8     3,1       Переход короткий, если выше    |
|                                или равно (CF = 0)             |
|72 cb     JB rel8     3,1       Переход короткий, если ниже    |
|                                (CF = 1)                       |
|76 cb    JBE rel8     3,1       Переход короткий, если ниже    |
|                                или равно (CF = 1 или ZF = 1)  |
|72 cb     JC rel8     3,1       Переход короткий, если перенос |
|                                (CF = 1)                       |
|E3 cb   JCXZ rel8     8,5       Переход короткий, если регистр |
|                                CX равен 0                     |
|E3 cb  JECXZ rel8     8,5       Переход короткий, если регистр |
|                                ECX равен 0                    |
|74 cb     JE rel8     3,1       Переход короткий, если равно   |
|                                (ZF = 1)                       |
|74 cb     JZ rel8     3,1       Переход короткий, если 0       |
|                                (ZF = 1)                       |
|7F cb     JG rel8     3,1       Переход короткий, если больше  |
|                                (ZF = 0 и SF = OF)             |
|7D cb    JGE rel8     3,1       Переход короткий, если больше  |
|                                или равно (SF = OF)            |
|7C cb     JL rel8     3,1       Переход короткий, если меньше  |
|                                (SF <> OF)                     |
|7E cb    JLE rel8     3,1       Переход короткий, если меньше  |
|                                или равно (ZF=1 или SF <> OF)  |
|76 cb    JNA rel8     3,1       Переход короткий, если не выше |
|                                (CF = 1 и ZF = 1)              |
|72 cb   JNAE rel8     3,1       Переход короткий, если не выше |
|                                или равно (CF = 1)             |
|73 cb    JNB rel8     3,1       Переход короткий, если не ниже |
|                                (CF = 0)                       |
|77 cb   JNBE rel8     3,1       Переход короткий, если не ниже |
|                                или равно (CF=0 и ZF=0)        |
|73 cb    JNC rel8     3,1       Переход короткий, если нет     |
|                                переноса (CF = 0)              |
|75 cb    JNE rel8     3,1       Переход короткий, если не равно|
|                                (ZF = 0)                       |
|7E cb    JNG rel8     3,1       Переход короткий, если не      |
|                                больше (ZF = 1 или SF <> OF)   |
|7C cb   JNGE rel8     3,1       Переход короткий, если не      |
|                                больше или равно (SF <> OF)    |
|7D cb    JNL rel8     3,1       Переход короткий, если не      |
|                                меньше (SF = OF)               |
|7F cb   JNLE rel8     3,1       Переход короткий, если не мень-|
|                                ше или равно (ZF=0 и SF=OF)    |
|71 cb    JNO rel8     3,1       Переход короткий, если нет     |
|                                переполнения (OF=0)            |
|7B cb    JNP rel8     3,1       Переход короткий, если нет кон-|
|                                троля четности (PF = 0)        |
|79 cb    JNS rel8     3,1       Переход короткий, если нет     |
|                                знака (SF = 0)                 |
|75 cb    JNZ rel8     3,1       Переход короткий, если нет нуля|
|                                (ZF = 0)                       |

|70 cb     JO rel8     3,1       Переход короткий, если         |
|                                переполнение (OF = 1)          |
|7A cb     JP rel8     3,1       Переход короткий, если контроль|
|                                четности (PF = 1)              |
|7A cb    JPE rel8     3,1       Переход короткий, если контроль|
|                                на проверку четности (PF = 1)  |
|7B cb    JPO rel8     3,1       Переход короткий, если контроль|
|                                на проверку нечетности (PF = 0)|
|78 cb     JS rel8     3,1       Переход короткий, если знак    |
|                                (SF = 1)                       |
|74 cb     JZ rel8     3,1       Переход короткий, если ноль    |
|                                (ZF = 1)                       |
|0F 87 cw/dw   JA rel16/32  3,1  Переход ближний, если выше     |
|                                (CF = 0 и ZF = 0)              |
|0F 83 cw/dw  JAE rel16/32  3,1  Переход ближний, если выше     |
|                                или равно (CF = 0)             |
|0F 82 cw/dw   JB rel16/32  3,1  Переход ближний, если ниже     |
|                                (CF = 1)                       |
|0F 86 cw/dw  JBE rel16/32  3,1  Переход ближний, если ниже     |
|                                или равно (CF = 1 или ZF = 1)  |
|0F 82 cw/dw   JC rel16/32  3,1  Переход ближний, если перенос  |
|                                (CF = 1)                       |
|0F 84 cw/dw   JE rel16/32  3,1  Переход ближний, если равно    |
|                                (ZF = 1)                       |
|0F 84 cw/dw   JZ rel16/32  3,1  Переход ближний, если 0        |
|                                (ZF = 1)                       |
|0F 8F cw/dw   JG rel16/32  3,1  Переход ближний, если больше   |
|                                (ZF = 0 и SF = OF)             |
|0F 8D cw/dw  JGE rel16/32  3,1  Переход ближний, если больше   |
|                                или равно (SF = OF)            |
|0F 8C cw/dw   JL rel16/32  3,1  Переход ближний, если меньше   |
|                                (SF <> OF)                     |
|0F 8E cw/dw  JLE rel16/32  3,1  Переход ближний, если меньше   |
|                                или равно (ZF=1 или SF <> OF)  |
|0F 86 cw/dw  JNA rel16/32  3,1  Переход ближний, если не выше  |
|                                (CF = 1 и ZF = 1)              |
|0F 82 cw/dw JNAE rel16/32  3,1  Переход короткий, если не выше |
|                                или равно (CF = 1)             |
|0F 83 cw/dw  JNB rel16/32  3,1  Переход ближний, если не ниже  |
|                                (CF = 0)                       |
|0F 87 cw/dw JNBE rel16/32  3,1  Переход ближний, если не ниже  |
|                                или равно (CF=0 и ZF=0)        |
|0F 83 cw/dw  JNC rel16/32  3,1  Переход ближний, если нет      |
|                                переноса (CF = 0)              |
|0F 85 cw/dw  JNE rel16/32  3,1  Переход ближний, если не равно |
|                                (ZF = 0)                       |
|0F 8E cw/dw  JNG rel16/32  3,1  Переход ближний, если не       |
|                                больше (ZF = 1 или SF <> OF)   |
|0F 8C cw/dw JNGE rel16/32  3,1  Переход ближний, если не       |
|                                больше или равно (SF <> OF)    |
|0F 8D cw/dw  JNL rel16/32  3,1  Переход ближний, если не       |
|                                меньше (SF = OF)               |
|0F 8F cw/dw JNLE rel16/32  3,1  Переход ближний, если не мень- |
|                                ше или равно (ZF=0 и SF=OF)    |
|0F 81 cw/dw  JNO rel16/32  3,1  Переход ближний, если нет      |
|                                переполнения (OF=0)            |
|0F 8B cw/dw  JNP rel16/32  3,1  Переход ближний, если нет кон- |
|                                троля четности (PF = 0)        |
|0F 89 cw/dw  JNS rel16/32  3,1  Переход ближний, если нет      |
|                                знака (SF = 0)                 |
|0F 85 cw/dw  JNZ rel16/32  3,1  Переход ближний, если нет нуля |
|                                (ZF = 0)                       |
|0F 80 cw/dw   JO rel16/32  3,1  Переход ближний, если          |
|                                переполнение (OF = 1)          |
|0F 8A cw/dw   JP rel16/32  3,1  Переход ближний, если контроль |
|                                четности (PF = 1)              |
|0F 8A cw/dw  JPE rel16/32  3,1  Переход ближний, если контроль |
|                                на проверку четности (PF = 1)  |
|0F 8B cw/dw  JPO rel16/32  3,1  Переход ближний, если контроль |
|                                на проверку нечетности (PF = 0)|
|0F 88 cw/dw   JS rel16/32  3,1  Переход ближний, если знак     |
|                                (SF = 1)                       |
|0F 84 cw/dw   JZ rel16/32  3,1  Переход ближний, если ноль     |
|                                (ZF = 1)                       |
-----------------------------------------------------------------

Примечание: Первое число тактовых циклов относится к случаю, когда  условие
перехода  выполняется  (переход  происходит);  второе  значение относится к
случаю, когда условие  не выполняется (и  переход не происходит).  rel16/32
указывает,  что  эти  команды  отображаются   двумя  командами  :  одна   с
16-разрядным   относительным   смещением,    а   вторая   с    32-разрядным
относительным смещением, в зависимости от атрибута размера операнда  данной
команды.

Работа команды

IF условие
THEN
  EIP <- EIP + SignExtend(rel8/16/32);
  IF OperandSize = 16
  THEN EIP <- EIP AND 0000FFFFH;
  FI;
FI;


Описание
Команды условного перехода (за  исключением команды JCXZ) проверяют  флаги,
которые  были   установлены  предыдущей   командой.  Условия   для   каждой
мнемонической  формы  команды  даны  в  круглых  скобках выше после каждого
описания. Термины "меньше" и  "больше" используются при сравнении  целых со
знаком; "выше" и "ниже" - для целых без знака.
Если  условие  выполняется,  то  происходит  переход по адресу, задаваемому
операндом.  Использование  данной  команды  наиболее эффективно, когда цель
условного перехода  находится в  текущем кодовом  сегменте и  в пределах от
-128 до +127 байтов относительно первого байта следующей команды.
Цель  перехода  также  может  находиться  в  пределах  от  -32768 до +32767
(атрибут размера сегмента  16) или от  -2**31 до +2**31-1  (атрибут размера
сегмента  32)  относительно  первого  байта  следующей  команды.  Если цель
команды  условного  перехода  находится  в  другом  сегменте,   используйте
команду  с  противоположным  условием  перехода,  которая "обойдет" команду
дальнего безусловного перехода к  другому сегменту. Например, вы  не можете
записать:

     JZ FARLABEL;

     Вместо этого напишите:

     JNZ BEYOND;
     JMP FARLABEL;
BEYOND:

Поскольку может существовать  несколько способов интерпретации  конкретного
состояния флагов, ASM386 обеспечивает  более одной мнемонической формы  для
большинства кодов операции условного  перехода. Например, если вы  сравнили
два символа в  AX и хотите  выполнить переход, если  они равны, используйте
команду JE, или,  если вы выполнили  операцию И для  регистра AX и  маской,
записанной в битовом  поле, и хотите,  чтобы переход происходил  только при
результате, равном  0, используйте  команду JZ,  которая является синонимом
команды JE.
Команда JCXZ отличается  от других команд  условного перехода тем,  что она
проверяет  не  флаги,  а  содержимое  регистров  CX или ECX на равенство 0.
Команда  JCXZ  полезна  в  начале  условного  цикла,  который заканчивается
командой условного перехода к  началу цикла (например, LOOPNE  метка цели).
Команда  JCXZ  предотвращает  вхождение  в  цикл  при  регистре CX или ECX,
равном нулю, что может привести к  выполнению цикла 64К или 32Г раз  вместо
нуля раз.

Изменяемые флаги
Отсутствуют

Исключения защищенного режима
#GP  (0),  если  смещение,  на  которое  задан  переход,  лежит  вне границ
кодового сегмента.

Исключения режима реальных адресов
Отсутствуют

Исключения виртуального режима 8086
Отсутствуют

Примечание
Команда JCXZ  выполняется дольше,  чем последовательность  из двух  команд,
сравнивающая  регистр-счетчик  с  нулем  и  выполняющая  переход  в  случае
равенства.
Все  команды  ветвления  преобразуются  для  выборки  в  16-разрядные коды,
независимо от адреса перехода или возможности кеширования.


`м`д`05JMP`* - Переход

-----------------------------------------------------------------
|Код       Команда     Число      Описание                      |
|операции              тактовых                                 |
|                      циклов                                   |
|EB cb     JMP rel8      3        Переход короткий              |
|E9 cw     JMP rel16     3        Переход ближний, смещение     |
|                                 относительно следующей команды|

|FF /4     JMP r/m16     5/5      Переход ближний косвенный     |
|EA cd     JMP ptr16:16 17,pm=19  Переход межсегментный, 4-бай- |
|                                 товый непосредственный адрес  |
|EA cd     JMP ptr16:16  32       Переход к шлюзу вызова, та же |
|                                 привилегированность           |
|EA cd     JMP ptr16:16  42+TS    Переход через сегмент состоя- |
|                                 ния задачи                    |
|EA cd     JMP ptr16:16  42+TS    Переход через шлюз задачи     |
|FF/5d     JMP m16:16   13,pm=18  Переход r/m16:16 косвенный и  |
|                                 межсегментный                 |
|FF /5     JMP m16:16    3        Переход к шлюзу вызова, та же |
|                                 привилегированность           |
|FF /5     JMP m16:16    41+TS    Переход через сегмент состоя- |
|                                 ния задачи                    |
|FF /5     JMP m16:16    42+TS    Переход через шлюз задачи     |
|E9 cd     JMP rel32     3        Переход ближний, смещение     |
|                                 относительно следующей команды|
|FF /4     JMP r/m32     5/5      Переход ближний косвенный     |
|EA cp     JMP ptr16:32 13,pm=18  Переход межсегментный, 6-бай- |
|                                 товый непосредственный адрес  |
|EA cp     JMP ptr16:32  31       Переход к шлюзу вызова, та же |
|                                 привилегированность           |
|EA cp     JMP ptr16:32  42+TS    Переход через сегмент состоя- |
|                                 ния задачи                    |
|EA cp     JMP ptr16:32  43+TS    Переход через шлюз задачи     |
|FF /5     JMP m16:32   13,pm=18  Переход межсегментный, адрес  |
|                                 в двойном слове r/m           |
|FF /5     JMP m16:32    31       Переход к шлюзу вызова, та же |
|                                 привилегированность           |
|FF /5     JMP m16:32    41+TS    Переход через сегмент состоя- |
|                                 ния задачи                    |
|FF /5     JMP m16:32    42+TS    Переход через шлюз задачи     |
-----------------------------------------------------------------

Примечание: значения ts задаются следующей таблицей:

-----------------------------------------------------------------
                     |          Новая задача
     Старая задача   |-------------------------------------------
                     | к TSS i486 | к TSS 80286 | к TSS VM
-----------------------------------------------------------------
 VM/i486/TSS 80286   |     199    |     180     |     177
-----------------------------------------------------------------

Работа команды

IF команда = относительный переход JMP
  (* т.е. операнд это rel8, rel16 или rel32 *)
THEN
  EIP <- EUP + rel8/16/32;
  IF OperandSize = 16
  THEN EIP <- EIP AND 0000FFFFH;
  FI;
FI;

IF команда = ближний косвенный переход JMP
  (* т.е. операнд это r/m16 или r/m32 *)
THEN
  IF OperandSize = 16
  THEN
    EIP <- [r/m16 AND 0000FFFFH;
  ELSE (* OperandSize = 32 *)
    EIP <- [r/m32;
  FI;
FI;

IF (PE = 0 OR (PE = 1 AND VM = 1))
(* режим реальных адресов или виртуальный режим 8086 *)
  AND команда = дальний JMP
  (* т.е. тип операнда равен m16:16, m16:32, ptr16:16, ptr16:32 *)
THEN GOTO РЕЖИМ-РЕАЛЬНЫХ-АДРЕСОВ-ИЛИ-V86
  IF тип операнда = m16:16 или m16:32
  THEN (* косвенный *)
    IF OperandSize = 16
    THEN
      CS:IP <- [m16:16;
      EIP <- EIP AND 0000FFFFH: (* очистка старших 16 битов *)
    ELSE (* OperanfSize = 32 *)
      CS:EIP <- [m16:32;
    FI;
  FI;
  IF тип операнда = ptr16:16 или ptr16:32
  THEN

    IF OperandSize = 16
    THEN
      CS:IP <- ptr16:16;
      EIP <- EIP AND 0000FFFFH: (* очистка старших 16 битов *)
    ELSE (* OperanfSize = 32 *)
      CS:EIP <- ptrm16:32;
    FI;
  FI;
FI;


IF (PE = 1 AND VM = 0) (* Защищенный режим, но не режим V86 *)
  AND команда = дальний JMP
THEN
  IF тип операнда = m16 или m16:32
  THEN (* Косвенный *)
    Проверить доступ к двойному слову EA;
    #GP(0) или #SS(0) IF нарушение границы;
  FI;
  Селектор назначения не должен быть пустым, ELSE #GP(0);
  Индекс селектора назначения должен быть в пределах
    границ дескрипторной таблицы; ELSE #GP(селектор)
  В зависимости от байта AR дескриптора назначения:
    GOTO      КОНФОРМНЫЙ-КОДОВЫЙ-СЕГМЕНТ;
    GOTO      НЕКОНФОРМНЫЙ-КОДОВЫЙ-СЕГМЕНТ;
    GOTO      ШЛЮЗ-ВЫЗОВА;
    GOTO      ШЛЮЗ-ЗАДАЧИ;
    GOTO      СЕГМЕНТ-СОСТОЯНИЯ-ЗАДАЧИ;
  ELSE #GP(селектор); (* Недопустимый байт AR в дескрипторе *)
FI;


КОНФОРМНЫЙ-КОДОВЫЙ-СЕГМЕНТ:
  DPL дескриптора должен быть <= CPL  ELSE  #GP(селектор);
  Сегмент должен   присутствовать   ELSE  #NP  (селектор);
  Указатель команд должен быть в границах кодового сегмента ELSE
                                                #GP(0);
  IF OperandSize = 16
  THEN  Загрузить CS:EIP из указателя назначения;
  ELSE  Загрузить CS:IP  из указателя назначения;
  FI;
  Загрузить регистр CS новым дескриптором сегмента;

НЕКОНФОРМНЫЙ-КОДОВЫЙ-СЕГМЕНТ:
  RPL селектора назначения должен быть <= CPL ELSE #GP(селектор);
  DPL дескриптора должен быть = CPL  ELSE  #GP(селектор);
  Сегмент должен   присутствовать   ELSE  #NP  (селектор);
  Указатель команд должен быть в границах кодового сегмента ELSE
                                                #GP(0);
  IF OperandSize = 32
  THEN  Загрузить CS:EIP из указателя назначения;
  ELSE  Загрузить CS:IP  из указателя назначения;
  FI;
  Загрузить регистр CS новым дескриптором сегмента;
  Установить поле RPL для CS равным CPL;

ШЛЮЗ-ВЫЗОВА:
  DPL дескриптора должен быть >= CPL  ELSE  #GP(селектор шлюза);
  DPL дескриптора должен быть >= RPL селектора шлюза ELSE
                  #GP(селектор шлюза);
  Шлюз должен присутствовать    ELSE  #NP(селектор шлюза);
  Рассмотрим селектор кодового сегмента в дескрипторе шлюза вызова:
    Селектор не должен быть пустым ELSE #GP(0)
    Селектор должен быть в пределах границ его дескрипторной
      таблицы ELSE #GP(селектор CS)
    Байт AR выбранного дескриптора должен обозначать кодовый
      сегмент ELSE #GP (селектор CS)
    IF не-конформный
    THEN DPL дескриптора кодового сегмента должен быть = CPL
    ELSE #GP(селектор CS);
    FI;
    IF конформный
    THEN DPL дескриптора кодового сегмента должен быть <= CPL;
    ELSE #GP(селектор CS);
    Кодовый сегмент должен присутствовать ELSE #NP(селектор CS);
    Указатель команд должен быть в границах кодового сегмента ELSE
                                                #GP(0);
    IF OperandSize = 32
    THEN  Загрузить CS:EIP из шлюза вызова;
    ELSE  Загрузить CS:IP  из шлюза вызова;
    FI;
  Загрузить регистр CS новым дескриптором кодового сегмента;
  Установить поле RPL для CS равным CPL;

ШЛЮЗ-ЗАДАЧИ:
  DPL дескриптора шлюза должен быть >= CPL ELSE #TS(селектор шлюза)
  DPL дескриптора шлюза должен быть >= RPL селектора шлюза ELSE
            #GP(селектор шлюза)
  Шлюз задачи должен присутствовать ELSE #NP(селектор шлюза)
  Исследовать селектор TSS, заданный в дескрипторе шлюза задачи:
    Он должен задавать бит Глобальный/Локальный как Глобальный
      ELSE #GP(селектор TSS)
    Индекс должен находиться в пределах границы GDT
      ELSE #GP(селектор TSS)
    Байт AR   дескриптора   TSS  должен  задавать  доступный  TSS
              (младшие биты 00001);
      ELSE #GP(селектор TSS)
    Сегмент состояния задачи (TSS) должен присутствовать
      ELSE #NP(селектор TSS)
  ПЕРЕКЛЮЧЕНИЕ-ЗАДАЧ (без вложенности) на TSS
  Указатель команд должен находиться в границе кодового сегмента
      ELSE #GP(0)

СЕГМЕНТ-СОСТОЯНИЯ-ЗАДАЧИ:
  DPL для TSS должен быть >= CPL ELSE #GP(селектор TSS)
  DPL для TSS должен быть >= RPL селектора TSS
     ELSE #GP(селектор TSS)
  Байт AR дескриптора должен задавать доступный TSS (младшие биты
      00001) ELSE #GP(селектор TSS)
  Сегмент состояния задачи (TSS) должен присутствовать
      ELSE #NP(селектор TSS)
  ПЕРЕКЛЮЧЕНИЕ-ЗАДАЧ (без вложенности) на TSS
  Указатель команд  должен находиться в границе кодового сегмента
      ELSE #GP(0);

Описание
Команда JMP передает управление в другую точку потока команд, не  записывая
информации для выполнения возврата.

Ниже описано действие для различных форм команды.
Команды  перехода  с  типом  назначения  r/m16m,  r/m32  и  r/m32 выполняют
ближний переход и не влекут изменения значения сегментного регистра.

Формы команды перехода JMP rel16 и JMP rel32 складывают смещение с  адресом
команды, следующей  за JMP,  чтобы определить  назначение команды.  Форма с
rel16 используется, когда атрибут  размера операнда команды равен  16 битам
(только атрибут  размера сегмента  16); форма  с rel32  используется, когда
атрибут размера  операнда команды  равен 32  битам (только  атрибут размера
сегмента 32). Результат сохраняется  в 32-разрядном регистре EIP.  В случае
rel16 старшие 16 битов регистра EIP очищаются, и таким образом,  получается
смещение, размер которого не превышает 16 битов.

Формы JMP r/m16 и  JMP r/m32 задают регистр  или адрес памяти, из  которого
выбирается  абсолютное  смещение  в  процедуре.  Выбранное  из r/m смещение
равно 32  битам для  атрибута размера  операнда, равного  32 битам (r/m32),
или 16 битам для атрибута размера операнда, равного 16 битам (r/m16).

Формы команды JMP ptr16:16 и ptr16:32 используют четырехили  шести-байтовые
операнды в качестве  длинных указателей на  назначение. Формы JMP  m16:16 и
m16:32 выбирают  дальний указатель  из заданного  адреса памяти  (косвенное
обращение). В режиме реальных  адресов или виртуальном режиме  8086 длинный
указатель  обеспечивает  16  битов  для  регистра  CS  и 16 или 32 бита для
регистра EIP  (в зависимости  от атрибута  размера операнда).  В защищенном
режиме обе формы с длинными указателями проверяют байт прав доступа (AR)  в
дескрипторе,  индексируемом  селекторной   частью  длинного  указателя.   В
зависимости  от  значения  байта  AR  переход  будет  осуществлять  один из
следующих типов передачи управления:
- Переход к кодовому сегменту на том же уровне привилегированности.
- Переключение задачи.

Более  подробная  информация  о  передаче  управления  в  защищенном режиме
находится в главах 6 и 7.

Изменяемые флаги
При переключении задачи изменяются  все флаги; если же  переключение задачи
не происходит, то флаги не изменяются.

Исключения защищенного режима
Для дальних переходов: #GP, #NP, #SS и #TS, как указано выше.
Для ближних прямых переходов: #GP(0), если процедура находится за
пределами границы кодового сегмента; #AC для невыравненной ссылки к  памяти
при текущем уровне привилегированности, равном 3.

Для   ближних   косвенных   переходов:   #GP(0)   в   случае  недопустимого
исполнительного адреса операнда памяти в  сегментах CS, DS, ES, FS  или GS;
#SS(0) в случае недопустимого адреса  в сегменте SS; # GP,  если полученное
косвенное смещение лежит  за границами кодового  сегмента; #PF(код сбоя)  в

случае страничного сбоя; #AC для невыравненной ссылки к памяти при  текущем
уровне привилегированности, равном 3.

Исключения режима реальных адресов
Прерывание  13,  если  какая-либо  часть  операнда  лежит  вне пространства
исполнительных адресов от 0 до 0FFFFH.

Исключения виртуального режима 8086
Те же исключения,  что и для  режима реальных адресов:  #PF (код сбоя)  для
страничных сбоев; #AC для невыравненной ссылки к памяти при текущем  уровне
привилегированности, равном 3.

Примечания
Все  команды  ветвления  преобразуются  для  выборки  в  16-байтовые  коды,
независимо от адреса перехода или возможности кеширования.


`м`д`05LAHF`* - Загрузка флагов в регистр AH

-----------------------------------------------------------------
|Код       Команда  Число      Описание                         |
|операции           тактовых                                    |
|                   циклов                                      |
|                                                               |
|9F        LAHF       3        Загрузка: AH = флаги             |
|                              SF ZF xx AF xx PF xx CF          |
-----------------------------------------------------------------

Работа команды

AH <- SF:ZF:xx:AF:xx:PF:xx:CF;

Описание
Команда LAHF пересылает  младший байт слова  флагов в регистр  AH. Биты, от
MSB  до  LSB,  это  биты  знака,  нуля,  неопределенность, вспомогательный,
неопределенность, контроля четности, неопределенность и переноса.

Изменяемые флаги
Отсутствуют

Исключения защищенного режима
Отсутствуют

Исключения режима реальных адресов
Отсутствуют

Исключения виртуального режима 8086
Отсутствуют


`м`д`05LAR`*  - Загрузка байта прав доступа

-----------------------------------------------------------------
|Код       Команда        Число      Описание                   |
|операции                 тактовых                              |
|                         циклов                                |
|                                                               |
|0F 02 /r  LAR r16,r/m16   11/11   r16 <- r/m16 маскируется FF00|
|0F 02 /r  LAR r32,r/m32   11/11   r32 <- r/m32 маскируется     |
|                                               00FxFF00        |
-----------------------------------------------------------------


Описание
Команда LAR сохраняет отмеченную  форму второго двойного слова  дескриптора
в  качестве  исходного  селектора,  если  селектор  видим на текущем уровне
привилегированности (модифицированном RPL селектора) и содержит  допустимый
тип  дескриптора  в  границах  дескриптора.  Регистр назначения загружается
старшим  двойным  словом  дескриптора,  маскируемого  значением 00FxFF00, и
устанавливается  флаг   ZF.  x   указывает   на   то,  что   четыре   бита,
соответствующие  старшим  четырем  битам  границы,  в значении, загружаемом
командой LAR, неопределены. Если  селектор невидим или имеет  неверный тип,
то флаг ZF очищается.
Если  задан  32-разрядный  размер  операнда,  то  все 32-разрядное значение
целиком  загружается   в  32-разрядный   регистр  назначения.   Если  задан
16-разрядный  размер  операнда,   то  младшие  16   битов  этого   значения
загружаются в 16-разрядный регистр назначения.
Допустимыми для команды  LAR являются все  дескрипторы кодовых сегментов  и
сегментов данных.
Допустимые типы  дескрипторов специальных  сегментов и  шлюзов для  команды
LAR приводятся в следующей таблице:

  Тип     Имя                             Допустимо/недопустимо
-----------------------------------------------------------------
   0      Недопустимо                           Недопустимо
   1      Доступный TSS 80286                   Допустимо
   2      LDT                                   Допустимо
   3      Занятый TSS 80286                     Допустимо
   4      Шлюз вызова 80286                     Допустимо
   5      Шлюз задачи 80286/i486                Допустимо
   6      Шлюз ловушки 80286                    Допустимо
   7      шлюз прерывания 80286                 Допустимо
   8      Недопустимо                           Недопустимо
   9      Доступный TSS i486                    Допустимо
   A      Недопустимо                           Недопустимо
   B      Занятый TSS i486                      Допустимо
   C      Шлюз вызова i486                      Допустимо
   D      Недопустимо                           Недопустимо
   E      Шлюз ловушки i486                     Допустимо
   F      шлюз прерывания i486                  Допустимо
-----------------------------------------------------------------

Изменяемые флаги
Флаг  ZF  установлен,  если  только  селектор  не  является  невидимым  или
недопустимого типа, когда флаг ZF очищается.

Исключения защищенного режима
#GP(0)  в  случае  недопустимого  исполнительного  адреса операнда памяти в
сегментах CS, DS,  ES, FS или  GS; #SS(0) в  случае недопустимого адреса  в
сегменте  SS;   #PF(код  сбоя)   в  случае   страничного  сбоя;   #AC   для
невыравненной  ссылки  к  памяти  при  текущем  уровне привилегированности,
равном 3.

Исключения режима реальных адресов
Прерывание 6; команда LAR в режиме реальных адресов не распознается.

Исключения виртуального режима 8086
Те же исключения, что и в режиме реальных адресов.


`м`д`05LEA`*  - Загрузка исполнительного адреса

-----------------------------------------------------------------
|Код       Команда        Число      Описание                   |
|операции                 тактовых                              |
|                         циклов                                |
|                                                               |
|8D /r     LEA r16,m        1      Записать исполнительный адрес|
|                                  для m в регистр r16          |
|8D /r     LEA r32,m        1      Записать исполнительный адрес|
|                                  для m в регистр r32          |
|8D /r     LEA r16,m        1      Записать исполнительный адрес|
|                                  для m в регистр r16          |
|8D /r     LEA r32,m        1      Записать исполнительный адрес|
|                                  для m в регистр r32          |
-----------------------------------------------------------------

Работа команды

IF OperandSize = 16 AND AddressSize = 16
THEN r16 <- Addr(m);
ELSE
  IF OperandSize = 16 AND AddressSize = 32
  THEN
    r16 <- Усечение_до_16_битов(Addr(m)); (* 32-разрядный адрес *)
  ELSE
    IF OperandSize = 32 AND AddressSize = 16
    THEN
      r32 <- Усечение_до_16_битов(Addr(m));
    ELSE
      IF OperandSize = 32 AND AddressSize = 32
      THEN  r32 <- Addr(m);
      FI:
    FI;
  FI;
FI;

Описание
Команда  LEA  вычисляет  исполнительный  адрес  (часть  его,   определяющую
смещение) и  записывает его  в заданный  регистр. Атрибут  размера операнда
команды (представленный в описании работы команды выше именем  OperandSize)
определяется выбранным  регистром. Атрибут  размера адреса  (представленный
именем  AddressSize)  определяется  атрибутом  USE  сегмента,   содержащего
второй  операнд.  Атрибутиы  размера  адреса  и  размера операнда влияют на
действие, выполняемые командой LEA, следующим образом:

Размер операнда  Размер адреса    Выполняемое действие
-----------------------------------------------------------------
   16               16         Вычисляется 16-разрядный исполнитель-
                               ный адрес и записывается в запроше-
                               нный 16-разрядный регистр назначения.
   16               32         Вычисляется 32-разрядный исполнитель-
                               ный адрес. Младшие 16 битов адреса
                               записываются в запрошенный 16-раз-
                               рядный регистр назначения.
   32               16         Вычисляется 16-разрядный исполнитель-
                               ный адрес. 16-разрядный адрес расши-
                               ряется нулем и записывается в зап-
                               рошенный 32-разрядный регистр назна-
                               чения.
   32               32         Вычисляется 32-разрядный исполнитель-
                               ный адрес и записывается в запроше-
                               нный 32-разрядный регистр назначения.
-----------------------------------------------------------------


Изменяемые флаги
Отсутствуют
Исключения защищенного режима
#UD, если второй операнд является регистром.
Исключения режима реальных адресов
Прерывание 6, если второй операнд является регистром.
Исключения виртуального режима 8086
Те же исключения, что и в режиме реальных адресов.


`м`д`05LEAVE`* - Выход из процедуры высокого уровня

-----------------------------------------------------------------
|Код       Команда        Число      Описание                   |
|операции                 тактовых                              |
|                         циклов                                |
|                                                               |
|C9        LEAVE            5      Установить SP в BP и затем   |
|                                  извлечь BP из стека          |
|C9        LEAVE            5      Установить ESP в EBP и затем |
|                                  извлечь EBP из стека         |
-----------------------------------------------------------------

Работа команды

IF StackAddrSize = 16
THEN
  SP <- BP;
ELSE  (* StackAddrSize = 32 *)
  ESP <- EBP;
FI;
IF OperandSize = 16
THEN
  BP <- Pop();
ELSE (* OperandSize = 32 *)
  EBP <- Pop();
FI;

Описание
Команда  LEAVE  имеет  действие,  противоположное  команде  ENTER.  Копируя
указатель  кадра  в  указатель  стека,  команда  LEAVE  освобождает область
стека,  используемую  процедурой  для  своих  локальных  переменных. Старый
указатель кадра извлекается из стека  в регистр BP или EBP,  восстанавливая
кадр стека вызывающей процедуры.  Последующая команда RET nn  удаляет любые
аргументы, помещенные в стек при входе в процедуру.

Изменяемые флаги
Отсутствуют

Исключения защищенного режима
#SS(0), если регистр  BP не указывает  на адрес памяти  в границах текущего
сегмента стека.

Исключения режима реальных адресов
Прерывание 13, если какая-либо  часть извлекаемого из стека  операнда лежит
за адресом 0FFFFH.

Исключения виртуального режима 8086
Те же исключения, что и в режиме реальных адресов.


`м`д`05LGDT/LIDT`* - Загрузка регистра таблицы дескрипторов
`05         `*       глобальной/прерываний

-----------------------------------------------------------------
|Код       Команда        Число      Описание                   |
|операции                 тактовых                              |
|                         циклов                                |
|0F 01 /2  LGDT m16&32     11      Загрузка m в GDTR            |
|0F 01 /3  LIDT m16&32     11      Загрузка m в IDTR            |
-----------------------------------------------------------------

Работа команды
IF команда = LIDT
THEN
  If OperandSize = 16
  THEN IDTR.граница:база <- m16:24 (* Загружается 24 бита базы *)
  ELSE IDTR.граница:базв <- m16:32
  FI;
ELSE (* Команда = LGDT *)
  If OperandSize = 16
  THEN GDTR.граница:база <- m16:24 (* Загружается 24 бита базы *)
  ELSE GDTR.граница:базв <- m16:32
  FI;
FI;

Описание
Команды LGDT и LIDT загружают значения линейного базового адреса и  границы
из  шести-байтового  операнда  данных  в  памяти  в  регистры  GDTR и IDTR,
соответственно. Если  с командой  LGDT или  LIDT используется  16-разрядный
операнд,  то  регистр  загружается  16-разрядной  границей  и  24-разрядной
базой,  а  старшие   восемь  битов  шести-байтового   операнда  данных   не
используются.  Если  используется  32-разрядный  операнд,  то   загружаются
16-разрядная   граница   и   32-разрядная   база;   старшие   восемь  битов
шести-байтового операнда используются как старшие адресные биты базы.
Команды  SGDT   и  SIDT   всегда  выполеняют   запись  во   все  48   битов
шести-байтного операнда данных. В случае процессора 80286 после  выполнения
команд SGDT и SIDT старшие восемь битов неопределены. В случае  процессоров
386 DX или i486 старшие  восемь битов помещаются в восьми  старших адресных
битах,  как  для  16-разрядных,  так  и  для  32-разрядных  операндов. Если
команда LGDT или  LIDT используется с  16-разрядным операндом для  загрузки
регистра,  записанного  командами  SGDT  или  SIDT, то старшие восемь битов
хранятся в виде нулей.
Команды  LGDT  и  LIDT  используются  в  системном программном обеспечении;
прикладным  программам  они  не  нужны.  Это единственные команды, напрямую
загружающие линейный адрес (а не адрес относительно сегмента) в  защищенном
режиме.   Изменяемые  флаги   Отсутствуют  Исключения  защищенного   режима
#GP(0),  если  текущий  уровень  привилегированности  не равен 0; #UD, если
исходный  операнд  является  регистром;   #GP(0)  в  случае   недопустимого
исполнительного адреса операнда памяти в  сегментах CS, DS, ES, FS  или GS;
#SS(0) в случае недопустимого адреса в сегменте SS; #PF(код сбоя) в  случае
страничного сбоя;  Исключения режима  реальных адресов  Прерывание 13, если
какая-либо часть операнда лежит вне пространства исполнительных адресов  от
0  до  0FFFFH.  Прерывание  6,  если  исходный  операнд является регистром;
Примечание:  Эти  команды  допустимы  в  режиме  реальных  адресов,   чтобы
позволить  инициализацию  при  включении  питания  для  защищенного режима.
Исключения виртуального  режима 8086  Те же  исключения, что  и для  режима
реальных адресов: #PF (код сбоя) для страничных сбоев.


`м`д`05LGS/LSS/LDS/LES/LFS`* - Загрузка полного указателя

-----------------------------------------------------------------
|Код       Команда        Число      Описание                   |
|операции                 тактовых                              |
|                         циклов                                |
|C5 /r    LDS r16,m16:16   6/12    Загрузка в DS:r16 указателя  |
|                                  памяти                       |
|C5 /r    LDS r32,m16:32   6/12    Загрузка в DS:r32 указателя  |
|                                  памяти                       |
|0F B2 /r LSS r16,m16:16   6/12    Загрузка в SS:r16 указателя  |
|                                  памяти                       |
|0F B2 /r LSS r32,m16:32   6/12    Загрузка в SS:r32 указателя  |
|                                  памяти                       |
|C4 /r    LES r16,m16:16   6/12    Загрузка в ES:r16 указателя  |
|                                  памяти                       |
|C4 /r    LES r32,m16:32   6/12    Загрузка в ES:r32 указателя  |
|                                  памяти                       |
|0F B4 /r LFS r16,m16:16   6/12    Загрузка в FS:r16 указателя  |
|                                  памяти                       |
|0F B4 /r LFS r32,m16:32   6/12    Загрузка в FS:r32 указателя  |
|                                  памяти                       |
|0F B5 /r LGS r16,m16:16   6/12    Загрузка в GS:r16 указателя  |
|                                  памяти                       |
|0F B5 /r LGS r32,m16:32   6/12    Загрузка в GS:r32 указателя  |
|                                  памяти                       |
-----------------------------------------------------------------

Работа команды

CASE команда OF
  LSS: Sreg это SS;  (* Загрузить регистр SS *)
  LDS: Sreg это DS;  (* Загрузить регистр SD *)
  LES: Sreg это ES;  (* Загрузить регистр ES *)
  LFS: Sreg это FS;  (* Загрузить регистр FS *)
  LGS: Sreg это GS;  (* Загрузить регистр GS *)
ESAC;
IF (OperandSize = 16)
THEN
  r16 <- [Исполнительный адрес]; (* 16-разрядная пересылка *)
  Sreg <- [Исполнительный адрес + 2]; (* 16-разрядная пересыдка *)
  (* В защищенном режиме это загрузка  дескриптора  в  сегментный
     регистр *)
ELSE (* OperandSize = 32 *)
  r32 <- [Исполнительный адрес]; (* 32-разрядная пересылка *)
  Sreg <- [Исполнительный адрес + 4]; (* 16-разрядная пересыдка *)
  (* В защищенном режиме это загрузка  дескриптора  в  сегментный
     регистр *)
FI;


Описание
Команды  LGS,  LSS,  LDS,  LES  и  LFS  читают из памяти полный указатель и
записывают  его  в  выбранную   пару  сегментный  регистр:регистр.   Полный
указатель загружает 16 битов  в сегментный регистр SS,  DS, ES, FS или  GS.
Другой регистр загружает  32 бита, если  атрибут размера операнда  равен 32
бита, или 16 битов,  если этот атрибут равен  16. Этот загружаемый 16-  или
32-разрядный регистр определяется заданным операндом r16 или r32.
Когда  одному  из  сегментных  регистров  сделано  назначение, в сегментный
регистр также загружается дескриптор. Данные для этого регистра берутся  из
элемента дескрипторной таблицы, соответствующего выбранному селектору.
В регистры DS, ES, FS или GS может быть загружен пустой селектор  (значения
0000 - 0003),  не вызывая исключения  защиты. (Любые последующие  ссылки на
сегмент,  соответствующий  сегментный  регистр  которого  загружен   пустым
селектором, для адресации памяти  вызовут особую ситуацию #GP(0).  Ссылка к
памяти для такого сегмента фактически не происходит).

Ниже приводится листинг проверок и действий в защищенном режиме,
выполняемых при загрузке сегментного регистра:

IF загружается SS:
  IF селектор пустой THEN #GP(0); FI;
  Индекс селектора  должен  быть  в  границах  его  дескрипторной
    таблицы  ELSE #GP(селектор);
  RPL селектора должен быть равен CPL ELSE #GP(селектор);
  Байт AR должен обозначать сегмент данных, доступный для записи
     ELSE #GP(селектор);
  DPL в байте AR должен быть равен CPL ELSE #GP(селектор);
  Сегмент должен   быть   помечен   как    Присутствующий    ELSE
      #SS(селектор);
  Загрузка SS селектором;
  Загрузка SS дескриптором;

IF DS, ES, FS или GS загружен не-пустым селектором:
  Индекс селектора  должен  быть  в  границах  его  дескрипторной
    таблицы  ELSE #GP(селектор);
  Байт AR должен обозначать сегмент данных  или  кода,  доступный
    для чтения ELSE #GP(селектор);
  IF сегмент данных или не-конформный кодовый сегмент
  THEN и RPL, и CPL должны быть меньше или равны DPL байта AR;
  ELSE #GP(селектор);
  Сегмент должен   быть   помечен   как    Присутствующий    ELSE
      #NP(селектор);
  Загрузка сегментного регистра селектором и битами RPL;
  Загрузка сегментного регистра дескриптором;
IF DS, ES, FS или GS загружен пустым селектором:
  Загрузка сегментного регистра селектором;
  Очистка бита Достоверности в дескрипторе;


Изменяемые флаги
Отсутствуют

Исключения защищенного режима
#GP(0)  в  случае  недопустимого  исполнительного  адреса операнда памяти в
сегментах CS, DS,  ES, FS или  GS; #SS(0) в  случае недопустимого адреса  в
сегменте SS; второй операнд должен  быть операндом памяти, а не  регистром;
#GP(0)  при  загрузке  в  SS  пустого  селектора;  #PF(код  сбоя)  в случае
страничного сбоя; #AC для невыравненной ссылки к памяти при текущем  уровне
привилегированности, равном 3.

Исключения режима реальных адресов
Второй операнд  должен быть  операндом памяти,  а не  регистром; Прерывание
13, если  какая-либо часть  операнда лежит  вне пространства исполнительных
адресов от 0 до 0FFFFH.

Примечание:  Эти  команды  допустимы  в  режиме  реальных  адресов,   чтобы
позволить инициализацию при включении питания для защищенного режима.

Исключения виртуального режима 8086
Те же исключения,  что и для  режима реальных адресов:  #PF (код сбоя)  для
страничных сбоев; #AC для невыравненной ссылки к памяти при текущем  уровне
привилегированности, равном 3.


`м`д`05LLDT`* - Загрузка локальной таблицы дескрипторов

-----------------------------------------------------------------
|Код       Команда        Число      Описание                   |
|операции                 тактовых                              |
|                         циклов                                |
|                                                               |
|0F 00 /2  LLDT r/m16      11/11   Загрузка селектора r/m16     |
|                                  в LDTR                       |
-----------------------------------------------------------------

Работа команды

LDTR <- SRC;

Описание
Команда  LLDT  загружает  регистр  локальной  дескрипторной таблицы (LDTR).
Операнд-слово (операнд  памяти или  регистр) команды  LLDT должен содержать
селектор  в  глобальной  дескрипторной  таблице  (GDT).  Элемент GDT должен
представлять  собой  локальную  дескрипторную  таблицу.  В этом случае LDTR
загружается этим элементом. На регистры DS, ES, SS, FS, GS и CS команда  не
влияет. Поле LDT в сегменте состояния задачи не изменяется.
Операнд-селектор может  быть равен  0; в  этом случае  LDTR помечается  как
неДостоверный.  Все  ссылки  к  дескриптору  (за  исключением   выполняемых
командами LAR, VERR, VERW или LSL) вызывают особую ситуацию #GP.
Команда LLDT  используется программным  обеспечением операционной  системы;
прикладные программы ее не используют.

Изменяемые флаги
Отсутствуют

Исключения защищенного режима
#GP(0),  если  текущий   уровень  привилегированности  не   равен  0;   #GP
(селектор), если операнд-селектор не указывает на глобальную  дескрипторную
таблицу,  или  если   указанный  элемент  в   GDT  не  является   локальной
дескрипторной  таблицей  (LDT);  #NP(селектор),  если  дескриптор  LDT   не
Присутствует;  #GP(0)   в  случае   недопустимого  исполнительного   адреса
операнда  памяти  в  сегментах  CS,  DS,  ES,  FS  или  GS; #SS(0) в случае
недопустимого  адреса  в  сегменте  SS;  #PF(код сбоя) в случае страничного
сбоя;

Исключения режима реальных адресов
Прерывание 6; команда LLDT в режиме реальных адресов не распознается.

Исключения виртуального режима 8086
Те же исключения, что и  для режима реальных адресов (поскольку  команда не
распознается, она не выполняется и не ведет к ссылке к памяти).

Примечание
Атрибут размера операнда на эту команду не влияет.


`м`д`05LMSW`* - Загрузка слова состояния машины

-----------------------------------------------------------------
|Код       Команда        Число      Описание                   |
|операции                 тактовых                              |
|                         циклов                                |
|                                                               |
|0F 01 /6  LMSW r/m16      13/13   Загрузка r/m16 в слово       |
|                                  состояния машины             |
-----------------------------------------------------------------

Работа команды

MSW (слово состояния машины) <- r/m16 (* в слово состояния машины
                                         записывается 16 битов *)

Описание
Команда  LMSW  загружает  слово  состояния  машины  (часть регистра CR0) из
исходного операнда.  Эта команда  может использоваться  для переключения  к
защищенному режиму: в этом случае за ним должен следовать  внутрисегментный
переход,  очищающий  очередь  команд.  Команда  LMSW  не выполняет обратное
переключение к режиму реальных адресов.
Команда LMSW  используется только  в системном  программном обеспечении.  В
прикладных программах она не используется.

Изменяемые флаги
Отсутствуют

Исключения защищенного режима
#GP(0), если  текущий уровень  привилегированности не  равен 0;  #GP (0)  в
случае  недопустимого  исполнительного  адреса  операнда памяти в сегментах
CS, DS, ES, FS или GS; #SS(0) в случае недопустимого адреса в сегменте  SS;
#PF(код сбоя) в случае страничного сбоя;

Исключения режима реальных адресов
Прерывание  13,  если  какая-либо  часть  операнда  лежит  вне пространства
исполнительных адресов от 0 до 0FFFFH.

Исключения виртуального режима 8086
Те же исключения,  что и для  режима реальных адресов:  #PF (код сбоя)  для
страничных сбоев.

Примечание
Атрибут  размера  операнда  на  эту  команду  не  влияет.  Данная   команда
обеспечивает совместимость  с процессором  80286; программы  для процессора
i486 должны вместо нее использовать команду MOV CR0, ... . Команда LMSW  не
влияет на биты PG или ET, и она не может служить для очистки бита PE.


`м`д`05LOCK`* - Префикс возбуждения сигнала LOCK#

-----------------------------------------------------------------
|Код       Команда        Число      Описание                   |
|операции                 тактовых                              |
|                         циклов                                |
|                                                               |
|F0        LOCK               1    Возбуждение сигнала LOCK#    |
|                                  для следующей команды        |
-----------------------------------------------------------------

Описание
Префикс LOCK вызывает  возбуждение сигнала LOCK#  процессора i486 на  время
выполнения  следующей  за  ним  команды.  В  случае многопроцессорной среды
данный сигнал может  обеспечивать исключительное использование  процессором
i486  любой  разделяемой  области  памяти,  пока  сигнал  LOCK#  возбужден.
Последовательность  чтения-модификации-записи,   обычно  используемая   для
реализации  операций  тестирования-и-установки  процессора  i486,  включает
команду BTS.
Префикс LOCK работает только в сочетании со следующими командами:
     BTS, BTR, BTC                       mem, reg/imm
     XCHG                                reg, mem
     XCHG                                mem, reg
     ADD, OR, ADC, SBB, AND, SUB, XOR    mem, reg/imm
     NOT, NEG, INC, DEC                  mem

При использовании  префикса LOCK  с командами,  не входящими  в приведенный
выше перечень, генерируется ловушка неопределенного кода операции.
Команда LOCK всегда возбуждает сигнал LOCK#, независимо от присутствия  или
отсутствия префикса LOCK.
Выравнивание поля  памяти не  влияет на  целостность префикса  LOCK. Захват
памяти происходит и для произвольных, невыравненных полей памяти.

Изменяемые флаги
Отсутствуют

Исключения защищенного режима
#UD, если префикс LOCK используется  с командами, не перечисленными выше  в
разделе  "Описание";  прочие  исключения  могут генерироваться последующими
(монопольными, или с захватом) командами.

Исключения режима реальных адресов
Прерывание   6,   если   префикс   LOCK   используется   с   командами,  не
перечисленными  выше   в  разделе   "Описание";  прочие   исключения  могут
генерироваться последующими (монопольными, или с захватом) командами.

Исключения виртуального режима 8086
#UD, если префикс LOCK используется  с командами, не перечисленными выше  в
разделе  "Описание";  прочие  исключения  могут генерироваться последующими
(монопольными, или с захватом) командами.

`м`д`05LODS/LODSB/LODSW/LODSD`*
                - Загрузка строкового операнда

-----------------------------------------------------------------
|Код       Команда     Число      Описание                      |
|операции              тактовых                                 |
|                      циклов                                   |
|                                                               |
|AC        LODS m8       5        Загрузка байта                |
|                                 [(E)SI] в AL                  |
-----------------------------------------------------------------

Работа команды

IF
AddrSize = 16
THEN использовать SI для индекса-источника
ELSE (* AddressSize = 32 *)
  использовать ESI для индекса-источника;
FI;
IF команда байтового типа
THEN
  AL <- [индекс-источника]; (* Загрузка байта *)
  IF DF = 0 THEN IncDec <- 1 ELSE IncDec <- -1; FI;
ELSE
  IF OperandSize = 16
  THEN
    AX <- [индекс-источника]; (* Загрузка слова *)
    IF DF = 0 THEN IncDec <- 2 ELSE IncDec <- -2; FI;
  ELSE (* OperandSize = 32 *)
    EAX <- [индекс-источника]; (* Загрузка двойного слова *)
    IF DF = 0 THEN IncDec <- 4 ELSE IncDec <- -4; FI;
  FI;
FI;
индекс-источника <- индекс-источника + IncDec


Описание

Команда LODS загружает  регистр AL, AX  или EAX байтом,  словом или двойным
словом памяти  из адреса,  на который  указываеи регистр индекса-источника.
После   выполнения   пересылки   регистр   индекса-источника  автоматически
продвигается.  Если  флаг  DF  равен   0  (была  выполнена  команда   CLD),
происходит  инкремент  индекса  источника;  Если  флаг  DF  равен  1  (была
выполнена команда STD),  происходит декремент индекса  источника. Инкремент
или декремент выполняется на 1 при  загрузке байта, 2 при загрузке слова  и
4 при загрузке двойного слова.
Если  атрибут  размера  адреса  команды  равен  16  битам,  то  в  качестве
индекса-источника  используется  регистр  SI;  в  противном  случае атрибут
размера адреса равен 32 битам,  и используется регистр ESI. Адрес  исходных
данных определяется  исключительно содержимым  регистра SI  или ESI.  Перед
выполнением  команды  LODS  в  регистр  SI  должно  быть  загружено  верное
значение индекса. Команды LODSB, LODSW и LODSD являются синонимами  команды
LODS для работы с байтом, словом и двойным словом, соответственно.
Команде LODS может  предшествовать префикс REP;  однако, команда LODS  чаще
используется  в  конструкции  цикла  LOOP,  поскольку  далее  должна обычно
следовать обработка данных, пересланных в регистры EAX, AX или AL.

Изменяемые флаги
Отсутствуют

Исключения защищенного режима

#GP(0)  в  случае  недопустимого  исполнительного  адреса операнда памяти в
сегментах CS, DS,  ES, FS или  GS; #SS(0) в  случае недопустимого адреса  в
сегменте  SS;   #PF(код  сбоя)   в  случае   страничного  сбоя;   #AC   для
невыравненной  ссылки  к  памяти  при  текущем  уровне привилегированности,
равном 3.

Исключения режима реальных адресов
Прерывание  13,  если  какая-либо  часть  операнда  лежит  вне пространства
исполнительных адресов от 0 до 0FFFFH.

Исключения виртуального режима 8086
Те же исключения,  что и для  режима реальных адресов:  #PF (код сбоя)  для
страничных сбоев; #AC для невыравненной ссылки к памяти при текущем  уровне
привилегированности, равном 3.

`м`д`05LOOP/LOOP`*условие
        - Управление циклом при помощи счетчика CX

-----------------------------------------------------------------
|Код       Команда     Число      Описание                      |
|операции              тактовых                                 |
|                      циклов                                   |
|                                                               |
|E2 cb     LOOP rel8    2,6       DEC счетчика, короткий переход|
|                                 если счетчик <> 0             |
|E1 cb    LOOPE rel8    9,6       DEC счетчика, короткий переход|
|                                 если счетчик <> 0 и ZF = 1    |
|E1 cb    LOOPZ rel8    9,6       DEC счетчика, короткий переход|
|                                 если счетчик <> 0 и ZF = 1    |
|E0 cb    LOOPNE rel8   9,6       DEC счетчика, короткий переход|
|                                 если счетчик <> 0 и ZF = 0    |
|E0 cb    LOOPNZ rel8   9,6       DEC счетчика, короткий переход|
|                                 если счетчик <> 0 и ZF = 0    |
-----------------------------------------------------------------

Работа команды

IF AddrSize = 16 THEN CountReg это CX ELSE CountReg это ECX; FI;
CountReg <- CountReg - 1;

IF команда <> LOOP
THEN
  IF (команда = LOOPE) OR (команда = LOOPZ)
  THEN BranchCond <- (ZF = 1) AND (CountReg <> 0);
  FI;
  IF (команда = LOOPNE) OR (команда = LOOPNZ)
  THEN BranchCond <- (ZF = 0) AND (CountReg <> 0);
  FI;
FI;

IF BranchCond         (* Условие перехода *)
THEN
  IF OperandSize = 16
  THEN
    IP <- IP + SignExtend(rel8);
  ELSE (* OperandSize = 32 *)
    EIP <- EIP + SignExtend(rel8);
  FI;
FI;


Описание
Команда  LOOP  декрементирует  счетный  регистр  без  изменения  любого  из
флагов.  Затем  для  используемой  формы  команды LOOP проверяются условия.
Если  условия  удовлетворяются,  то  выполняется  короткий переход к метке,
заданной как  операнд команды  LOOP. Если  атрибут размера  адреса равен 16
битам,  то  в  качестве   регистра-счетчика  используется  регистр  CX;   в
противном  случае  используется  регистр  ECX.  Операнд команды LOOP должен
находиться в диапазоне от 128 (десятичное) байтов до начала команды до  127
байтов после начала команды.
Команды LOOP  обеспечивают управление  итерациями и  объединяют организацию
индексирования  цикла  с  условным  переходом.  Используйте  команду  LOOP,
загружая  число  итераций  без  знака  в  счетный  регистр  и затем помещая
команду  LOOP  в  конце  последовательности  команд,  подлежащих  итерации.
Назначение команды LOOP это метка, указывающая на начало итерации.

Изменяемые флаги
Отсутствуют

Исключения защищенного режима
#GP(0),  если  смещение  перехода  находится  ведет  за  границы   текущего
кодового сегмента.

Исключения режима реальных адресов
Отсутствуют

Исключения виртуального режима 8086
Отсутствуют

Примечание
Безусловная  команда  LOOP  выполняется  дольше,  чем последовательность из
двух  команд,  одна  из  которых  выполняет  декремент счетного регистра, а
вторая - переход, если счетчик не равен нулю.
Все  команды  ветвления  преобразуются  для  выборки  в  16-разрядные коды,
независимо от адреса перехода или возможности кеширования.

`м`д`05LSL`*  - Загрузка границы сегмента

-----------------------------------------------------------------
|Код       Команда        Число      Описание                   |
|операции                 тактовых                              |
|                         циклов                                |
|                                                               |
|0F 03 /r  LSL r16,r/m16   10/10   Загрузка: r16 <- граница сег-|
|                                  мента, селектор r/m16 (гра-  |
|                                  нулирование в байтах)        |
|0F 03 /r  LSL r32,r/m32   10/10   Загрузка: r32 <- граница сег-|
|                                  мента, селектор r/m32 (гра-  |
|                                  нулирование в байтах)        |
|0F 03 /r  LSL r16,r/m16   10/10   Загрузка: r16 <- граница сег-|
|                                  мента, селектор r/m16 (гра-  |
|                                  нулирование в страницах)     |
|0F 03 /r  LSL r32,r/m32   10/10   Загрузка: r32 <- граница сег-|
|                                  мента, селектор r/m32 (гра-  |
|                                  нулирование в страницах)     |
-----------------------------------------------------------------


Описание
Команда  LSL   загружает  регистр   незашифрованной  границей   сегмента  и
устанавливает  флаг  ZF,  при  условии,  что  селектор  источника  видим на
текущем уровне привилегированности и  на уровне RPL дескрипторной  таблицы,
а дескриптор  имеет тип,  приемлемый для  команды LSL.  В противном  случае
флаг ZF  очищается, а  регистр назначения  остается без  изменений. Граница
сегмента загружается значением,  гранулированным в байтах.  Если дескриптор
имеет  границу   сегмента,  гранулированную   в  страницах,   команда   LSL
транслирует его в байты, прежде  чем загрузить в регистр назначения  (сдвиг
влево на  12 20-разрядной  "сырой" границы  из дескриптора,  а затем  OR со
значением 00000FFFH).
32-разрядные  формы   команды  LSL   записывают  в   16-разрядный   регистр
назначения 32-разрядную границу, гранулированную в байтах.
Дескрипторы сегментов кода и данных допустимы для команды LSL.
Допустимые типы  дескрипторов специальных  сегментов и  шлюзов для  команды
LSL приводятся в следующей таблице:

-----------------------------------------------------------------
  Тип     Имя                             Допустимо/недопустимо
-----------------------------------------------------------------
   0      Недопустимо                           Недопустимо
   1      Доступный TSS 80286                   Допустимо
   2      LDT                                   Допустимо
   3      Занятый TSS 80286                     Допустимо
   4      Шлюз вызова 80286                     Недопустимо
   5      Шлюз задачи 80286/i486                Недопустимо
   6      Шлюз ловушки 80286                    Недопустимо
   7      Шлюз прерывания 80286                 Недопустимо
   8      Недопустимо                           Допустимо
   9      Доступный TSS i486                    Допустимо
   A      Недопустимо                           Недопустимо
   B      Занятый TSS i486                      Допустимо
   C      Шлюз вызова i486                      Недопустимо
   D      Недопустимо                           Недопустимо
   E      Шлюз ловушки i486                     Недопустимо
   F      шлюз прерывания i486                  Недопустимо
-----------------------------------------------------------------


Изменяемые флаги
Флаг  ZF  установлен,  если  только  селектор  не  является  невидимым  или
недопустимого типа, когда флаг ZF очищается.

Исключения защищенного режима
#GP(0)  в  случае  недопустимого  исполнительного  адреса операнда памяти в
сегментах CS, DS,  ES, FS или  GS; #SS(0) в  случае недопустимого адреса  в
сегменте  SS;   #PF(код  сбоя)   в  случае   страничного  сбоя;   #AC   для
невыравненной  ссылки  к  памяти  при  текущем  уровне привилегированности,
равном 3.

Исключения режима реальных адресов
Прерывание 6; команда LSL в режиме реальных адресов не распознается.

Исключения виртуального режима 8086
Те же исключения,  что и в  режиме реальных адресов.  #AC для невыравненной
ссылки к памяти при текущем уровне привилегированности, равном 3.

`м`д`05LTR`* - Загрузка регистра задачи

-----------------------------------------------------------------
|Код       Команда        Число      Описание                   |
|операции                 тактовых                              |
|                         циклов                                |
|                                                               |
|0F 00 /3  LTR r/m16       20/20   Загрузка слова EA в регистр  |
|                                  задачи                       |
-----------------------------------------------------------------

 Описание
Команда  LTR  загружает  регистр  задачи  из  исходного регистра или адреса
памяти,  заданного  операндом.  Загруженный  TSS  помечается  как  Занятый.
Переключения задачи не происходит.
Команда  LTR  используется  только  программным  обеспечением  операционной
системы; прикладными программами она не используется.

Изменяемые флаги
Отсутствуют

Исключения защищенного режима
#GP(0)  в  случае  недопустимого  исполнительного  адреса операнда памяти в
сегментах CS, DS,  ES, FS или  GS; #SS(0) в  случае недопустимого адреса  в
сегменте SS; #GP(0), если  текущий уровень привилегированности не  равен 0;
#GP(селектор), если  объект, названный  в селекторе  источника, не является
TSS   или   уже   Занят;   #NP(селектор),   если   TSS   помечен   как  "не
Присутствующий"; # PF(код сбоя) в случае страничного сбоя;

Исключения режима реальных адресов
Прерывание 6; команда LTR в режиме реальных адресов не распознается.

Исключения виртуального режима 8086
Те же исключения, что и в режиме реальных адресов.

Примечание
Атрибут размера операнда на эту команду не влияет.


`м`д`05MOV`* - Пересылка данных

|Код       Команда        Число      Описание                   |
|операции                 тактовых                              |
|                         циклов                                |
|                                                               |
|88 /r     MOV r/m8,r8      1      Пересылка байтового регистра |
|                                  в байт r/m                   |
|89 /r     MOV r/m16,r16    1      Пересылка регистра - слова   |
|                                  в слово r/m                  |
|89 /r     MOV r/m32,r32    1      Пересылка регистра - двойного|
|                                  слова в двойное слово r/m    |
|8A /r     MOV r8,r/m8      1      Пересылка байта r/m          |
|                                  в байтовый регистр           |
|8B /r     MOV r16,r/m16    1      Пересылка слова r/m          |
|                                  в регистр - слово            |
|8B /r     MOV r32,r/m32    1      Пересылка двойного слова r/m |
|                                  в регистр - двойное слово    |
|8C /r     MOV r/m16,Sreg   3/3    Пересылка сегментного        |
|                                  регистра в слово r/m         |
|8E /r     MOV Sreg,r/m16   3/9    Пересылка слова r/m          |
|                                  в сегментный регистр         |
|A0        MOV AL,moffs8    1      Пересылка байта в            |
|                                  (сегмент:смещение) в AL      |
|A1        MOV AX,moffs16   1      Пересылка слова в            |
|                                  (сегмент:смещение) в AX      |
|A1        MOV EAX,moffs32  1      Пересылка двойного слова в   |
|                                  (сегмент:смещение) в EAX     |
|A2        MOV moffs8, AL   1      Пересылка AL  в              |
|                                  (сегмент:смещение)           |
|A3        MOV moffs16,AX   1      Пересылка AX  в              |
|                                  (сегмент:смещение)           |
|A3        MOV moffs32,EAX  1      Пересылка EAX в              |
|                                  (сегмент:смещение)           |
|B0 + rb   MOV reg8,imm8    1      Пересылка непосредственного  |
|                                  байта в регистр              |
|B8 + rw   MOV reg16,imm16  1      Пересылка непосредственного  |
|                                  слова в регистр              |
|B8 + rd   MOV reg32,imm32  1      Пересылка непосредственного  |
|                                  двойного слова в регистр     |
|C6        MOV r/m8,imm8    1      Пересылка непосредственного  |
|                                  байта в байт r/m             |
|C7        MOV r/m16,imm16  1      Пересылка непосредственного  |

|                                  слова в слово r/m            |
|C7        MOV r/m32,imm32  1      Пересылка непосредственного  |
|                                  двойного слова в             |
|                                  двойное  слово в r/m         |

Примечания:  moffs8,  moffs16  и  moffs32  состоят  из  простого   смещения
относительно базы сегмента.  8, 16 и  32 обозначают размер  данных. Атрибут
размера адреса команды определяет размер смещения, 16 или 32 бита.

Работа команды
DEST <- SRC;

Описание
Команда MOV копирует второй операнд в первый.

Если операнд назначения это  сегментный регистр (DS, ES,  SS и т.д.), то  в
регистр  также  загружаются  данные  из  дескриптора.  Данные  для регистра
берутся  из  элемента  дескрипторной  таблицы,  соответствующего селектору.
Пустой селектор (значения  0000-0003) может быть  загружен в регистры  DS и
ES,  не  вызывая  исключения;  однако,  использование  регистров  DS или ES
вызовет особую ситуацию #GP(0), и ссылка к памяти не произойдет.
Команда MOV  пересылки в  SS запрещает  все прерывания  до конца выполнения
следующей команды (которая чаще всего является командой MOV в ESP).
Загрузка сегментного  регистра в  защищенном режиме  приводит к специальным
проверкам и действиям, как описано в следующем листинге:

IF SS загружен;
THEN
  IF селектор пустой THEN #GP(0);
FI;
  Индекс селектора  должен  быть  в  границах  его  дескрипторной
      таблицы иначе #GP(селектор);
  RPL селектора должен быть равен CPL иначе #GP(селектор);
Байт AR должен обозначать сегмент данных,  доступный для записи
      иначе #GP(селектор);
  DPL в байте AR должен быть равен CPL иначе #GP(селектор);
  Сегмент должен   быть   отмечен   как   Присутствующий  иначе
    #SS(селектор);
  Загрузка SS селектором;
  Загрузка SS дескриптором;
FI;
IF DS, ES, FS или GS загружен не-пустым селектором;
THEN
  Индекс селектора  должен  быть  в  границах  его  дескрипторной
      таблицы иначе #GP(селектор);
  Байт AR должен обозначать сегмент данных или кодовый сегмент,
      доступный для чтения иначе #GP(селектор);
  IF сегмент данных или не-конформный кодовый сегмент
  THEN и RPL, и CPL должны быть меньше или равны DPL в байте AR;
  ELSE #GP(селектор);
  FI;
  Сегмент должен   быть   отмечен   как   Присутствующий  иначе
    #NP(селектор);
  Загрузка сегментного регистра селектором;
  Загрузка сегментного регистра дескриптором;
FI;
IF DS, ES, FS или GS загружен пустым селектором;
THEN
  Загрузка сегментного регистра селектором;
  Очистка бита Достоверности дескриптора;
FI;

Изменяемые флаги
Отсутствуют
Исключения защищенного режима

#GP, #SS и #NP, если загружается сегментный регистр; #GP(0),
если назначением является сегмент, недоступный для записи;
#GP(0) в случае недопустимого исполнительного адреса операнда
памяти в сегментах CS, DS, ES, FS или GS; #SS(0) в случае
недопустимого адреса в сегменте SS; #PF(код сбоя) в случае
страничного сбоя; #AC для невыравненной ссылки к памяти при
текущем уровне привилегированности, равном 3.

Исключения режима реальных адресов

Прерывание 13, если какая-либо часть операнда лежит вне
пространства исполнительных адресов от 0 до 0FFFFH.

Исключения виртуального режима 8086
Те же исключения, что и для режима реальных адресов: #PF (код
сбоя) для страничных сбоев. #AC для невыравненной ссылки к
памяти при текущем уровне привилегированности, равном 3.

`м`д`05MOV`* - Пересылка данных в специальные регистры и из них

|Код       Команда        Число      Описание                   |
|операции                 тактовых                              |
|                         циклов                                |
|                                                               |
|0F 22 /r  MOV CR0,r32      16     Пересылка (регистра) в       |
|                                  управляющий регистр          |
|0F 20 /r  MOV r32,CR0/     4      Пересылка (управляющего реги-|
|              CR1/CR2             стра) в (регистр)            |
|0F 22 /r  MOV CR2/CR3,r32  4      Пересылка (регистра) в       |
|                                  (управляющий регистр)        |
|0F 21 /r  MOV r32,DR0 - 3  10     Пересылка (отладочного реги- |
|                                  стра) в (регистр)            |
|0F 21 /r  MOV r32,DR6/DR7  10     Пересылка (отладочного реги- |
|                                  стра) в (регистр)            |
|0F 23 /r  MOV DR0 - 3,r32  11     Пересылка (регистра) в       |
|                                  (отладочный регистр)         |
|0F 23 /r  MOV DR6/DR7,r32  11     Пересылка (регистра) в       |
|                                  (отладочный регистр)         |
|0F 24 /r  MOV r32,TR4/TR5/ 4      Пересылка (тестового реги-   |
|              TR6/TR7             стра) в (регистр)            |
|0F 26 /r  MOV TR4/TR5/TR6/        Пересылка (регистра)         |
|              TR7,r32             в (тестовый регистр)         |
|0F 24 /r  MOV r32,TR3      4      Пересылка (тестового реги-   |
|                                  стра3) в (регистр)           |
|0F 26 /r  MOV TR3,r32      6      Пересылка (регистра)         |
|                                  в (тестовый  регистр3)       |

Работа команды
DEST <- SRC;

Описание
Показанные  выше  формы  команды  MOV  сохраняют  или  загружают  следующие
специальные регистры в/из регистров общего назначения:

     - Управляющие регистры CR0, CR2 и CR3

     - Отладочные регистры DR0, DR1, DR2, DR3, DR6 и DR7

     - Тестовые регистры TR3, TR4, TR5, TR6 и TR7

С этими командами всегда используются 32-разрядные операнды, независимо  от
атрибута размера операнда.

Изменяемые флаги
Флаги OF, SF, ZF, AF, PF и CF неопределены.

Исключения защищенного режима
#GP, если текущий уровень привилегированности не равен 0.

Исключения режима реальных адресов
Отсутствуют

Исключения виртуального режима 8086
#GP(0) при попытке выполнения команды.

Примечания
Команды  должны  выполняться  на  уровне  привилегированности  0  в  режиме
реальных адресов; в противном случае возникает исключение защиты.
Поле reg  в байте  ModR/M задает,  какой из  специальных регистров в каждой
категории участвует.  Два бита  поля mod  всегда равны  11. Поле r/m задает
участвующий регистр общего назначения.
Неопределенным  или  зарезервированным  битам  всегда должны быть присвоены
состояния, в которых они находились при предыдущем считывании.


`м`д`05MOVS/MOVSB/MOVSW/MOVSD`*
                - Пересылка данных из строки в строку

|Код       Команда        Число      Описание                   |
|операции                 тактовых                              |
|                         циклов                                |
|                                                               |
|A4        MOVS m8,m8       7      Пересылка байта              |
|                                  [(E)SI] в ES:[(E)DI]         |
|A5        MOVS m16,m16     7      Пересылка слова              |
|                                  [(E)SI] в ES:[(E)DI]         |
|A5        MOVS m32,m32     7      Пересылка двойного слова     |
|                                  [(E)SI] в ES:[(E)DI]         |
|A4        MOVSB            7      Пересылка байта              |
|                                  DS:[(E)SI] в ES:[(E)DI]      |

|A5        MOVSW            7      Пересылка слова              |
|                                  DS:[(E)SI] в ES:[(E)DI]      |
|A5        MOVSD            7      Пересылка двойного слова     |
|                                  DS:[(E)SI] в ES:[(E)DI]      |

Работа команды

IF (команда = MOVSD) OR (команда имеет операнды -двойные слова)
THEN OperandSize <- 32;
ELSE OperandSize <- 16;
IF AddressSize = 16
THEN использовать    SI    как    индекс-источника   и   DI   как
         индекс-назначения;
ELSE (* AddressSize = 32 *)
  использовать   ESI    как    индекс-источника   и   EDI   как
         индекс-назначения;
FI;
IF байтовый тип команды
THEN
  [индекс-назначения] <- [индекс-источника];(* Назначение байта *)
  IF DF = 0 THEN IncDec <- 1 ELSE IncDec <- -1; FI;
ELSE
  IF OperandSize = 16
  THEN
    [индекс-назначения] <- [индекс-источника];(*Назначение слова*)
    IF DF = 0 THEN IncDec <- 2 ELSE IncDec <- -2; FI;
  ELSE
    [индекс-назначения] <- [индекс-источника];(*Назначение
                                                двойного слова*)
    IF DF = 0 THEN IncDec <- 4 ELSE IncDec <- -4; FI;
  FI;
FI;
индекс-источника <- индекс-источника + IncDec;
индекс-назначения <- индекс-назначения + IncDec;

Описание

Команда MOVS копирует байт или слово из [(E)SI] в байт или слово
в ES:[(E)DI]. Операнд назначения должен адресоваться из регистра
ES: переопределение сегмента для операнда назначения невозможно.
Переопределение сегмента может быть использовано для
операнда-источника (исходного операнда): по умолчанию
принимается регистр DS.

Адрес  операндов   источника  и   назначения  определяется    исключительно
содержимым  регистров  (E)SI  и  (E)DI.  Перед  выполнением команды MOVS вы
должны  загрузить  в  регистры  (E)SI  и (E)DI правильные значения. Команды
MOVS, MOVSW и MOVSD являются синонимами команды MOVS для работы с  байтами,
словами и двойными словами, соответственно.
После  пересылки  данных  происходит  автоматическое  продвижение регистров
(E)SI  и  (E)DI.  Если  флаг  DF  равен  0 (была выполнена команда CLD), то
выполняется инкремент регистров;  если же флаг  DF равен 1  (была выполнена
команда    STD),    то    выполняется    декремент    регистров.   Регистры
инкрементируются  или   декрементируются  на   единицу,  если   выполнялась
пересылка байта, на 2, если выполнялась пересылка слова, и на 4 -  двойного
слова.
Команде  MOVS  может  предшествовать  префикс  REP  для  пересылки сразу CX
байтов или слов. Подробности об этом см. в описании префикса REP.

Изменяемые флаги
Отсутствуют
Исключения защищенного режима

#GP(0), если назначением является  сегмент, недоступный для записи;  #GP(0)
в случае недопустимого исполнительного  адреса операнда памяти в  сегментах
CS, DS, ES, FS или GS; #SS(0) в случае недопустимого адреса в сегменте  SS;
#PF(код сбоя)  в случае  страничного сбоя;  #AC для  невыравненной ссылки к
памяти при текущем уровне привилегированности, равном 3.

Исключения режима реальных адресов
Прерывание  13,  если  какая-либо  часть  операнда  лежит  вне пространства
исполнительных адресов от 0 до 0FFFFH.

Исключения виртуального режима 8086
Те же исключения,  что и для  режима реальных адресов:  #PF (код сбоя)  для
страничных сбоев. #AC для невыравненной ссылки к памяти при текущем  уровне
привилегированности, равном 3.

`м`д`05MOVSX`* - Пересылка с расширением знаком

|Код       Команда        Число      Описание                   |
|операции                 тактовых                              |
|                         циклов                                |
|                                                               |
|0F BE /r  MOVSX r16,r/m8   3/3    Пересылка байта в слово      |
|                                  с расширением знаком         |
|0F BE /r  MOVSX r32,r/m8   3/3    Пересылка байта в двойное    |
|                                  слово с расширением знаком   |
|0F BF /r  MOVSX r32,r/m16  3/3    Пересылка слова в двойное    |
|                                  слово с расширением знаком   |

Работа команды
DEST <- SignExtend(SRC);

Описание
Команда MOVSX  считывает содержимое  исполнительного адреса  или регистра в
байте или слове, расширяет это  значение знаком в соответствии с  атрибутом
размера операнда команды (16 или 32 бита) и записывает результат в  регистр
назначения.

Изменяемые флаги
Отсутствуют

Исключения защищенного режима
#GP(0)  в  случае  недопустимого  исполнительного  адреса операнда памяти в
сегментах CS, DS,  ES, FS или  GS; #SS(0) в  случае недопустимого адреса  в
сегменте  SS;   #PF(код  сбоя)   в  случае   страничного  сбоя;   #AC   для
невыравненной  ссылки  к  памяти  при  текущем  уровне привилегированности,
равном 3.

Исключения режима реальных адресов
Прерывание  13,  если  какая-либо  часть  операнда  лежит  вне пространства
исполнительных адресов от 0 до 0FFFFH.

Исключения виртуального режима 8086
Те же исключения,  что и для  режима реальных адресов:  #PF (код сбоя)  для
страничных сбоев. #AC для невыравненной ссылки к памяти при текущем  уровне
привилегированности, равном 3.


`м`д`05MOVZX`* - Пересылка с расширением нулем

|Код       Команда        Число      Описание                   |
|операции                 тактовых                              |
|                         циклов                                |
|                                                               |
|0F B6 /r  MOVZX r16,r/m8   3/3    Пересылка байта в слово      |
|                                  с расширением нулем          |
|0F B6 /r  MOVZX r32,r/m8   3/3    Пересылка байта в двойное    |
|                                  слово с расширением нулем    |
|0F B7 /r  MOVZX r32,r/m16  3/3    Пересылка слова в двойное    |
|                                  слово с расширением нулем    |

Работа команды
DEST <- ZeroExtend(SRC);

Описание
Команда MOVZX  считывает содержимое  исполнительного адреса  или регистра в
байте или слове,  расширяет это значение  нулем в соответствии  с атрибутом
размера операнда команды (16 или 32 бита) и записывает результат в  регистр
назначения.


Изменяемые флаги
Отсутствуют

Исключения защищенного режима
#GP(0)  в  случае  недопустимого  исполнительного  адреса операнда памяти в
сегментах CS, DS,  ES, FS или  GS; #SS(0) в  случае недопустимого адреса  в
сегменте  SS;   #PF(код  сбоя)   в  случае   страничного  сбоя;   #AC   для
невыравненной  ссылки  к  памяти  при  текущем  уровне привилегированности,
равном 3.

Исключения режима реальных адресов
Прерывание  13,  если  какая-либо  часть  операнда  лежит  вне пространства
исполнительных адресов от 0 до 0FFFFH.

Исключения виртуального режима 8086
Те же исключения,  что и для  режима реальных адресов:  #PF (код сбоя)  для
страничных сбоев. #AC для невыравненной ссылки к памяти при текущем  уровне
привилегированности, равном 3.

`м`д`05MUL`* - Умножение без знака AL или AX

|Код       Команда  Число      Описание                         |
|операции           тактовых                                    |
|                   циклов                                      |
|                                                               |
|F6 /4   MUL AL,r/m8   13/18,13/18  Умножение без знака         |
|                                   (AX <- AL * байт r/m)       |
|F7 /4   MUL AX,r/m16  13/26,13/26  Умножение без знака         |
|                                   (DX:AX <- AX * слово r/m)   |
|F7 /4   MUL EAX,r/m32 13/42,13/42  Умножение без знака         |
|                                   (EDX:EAX <- EAX *           |
|                                   двойное слово r/m)          |

Примечания: Процессор i486 использует алгоритм умножения типа  "early-out".
Фактическое число  тактовых циклов  зависит от  позиции наиболее  значащего
бита  в   оптимизируемом  множителе.   Оптимизация  выполняется   как   для
положительных,  так  и  для  отрицательных  значений.  Вследствие   данного
алгоритма  даются  минимальные  и  максимальные количества тактовых циклов.
Для вычисления  фактического числа  тактовых циклов  используется следующая
формула:

Фактическое число тактовых циклов = если m <> 0 то max(наименьшее целое
число, большее (log |m|)) + 6 циклов. 2 Фактическое число тактовых циклов
= если m = 0 то 9 циклов.

(где m это множитель)

Работа команды

IF операция байтового размера
THEN AX <- AL * r/m8
ELSE (* Операция размером в слово или двойное слово *)
  IF OperandSize = 16
  THEN DX:AX <- AX * r/m16
  ELSE (* OperandSize = 32 *)
    EDX:EAX <- EAX * r/m32
  FI;
FI;

Описание
Команда IMUL выполняет умножение без знака. Ее действие зависит от  размера
операндов следующим образом:

- Операнд размером в байт  умножается на значение AL; результат  помещается
в регистр  AX. Если  значение AH  равно 0,  то флаги  CF и  OF очищаются; в
противном случае они установлены.
- Операнд размером в слово умножается на значение AX; результат  помещается
в  пару  регистров  DX:AX.  Регистр  DX  содержит при этом старшие 16 битов
произведения. Если  значение DX  равно 0,  то флаги  CF и  OF очищаются;  в
противном случае они установлены.
- Операнд размером  в двойное слово  умножается на значение  EAX; результат
помещается в пару регистров EDX:EAX. Регистр EDX содержит при этом  старшие
32  бита  произведения.  Если  значение  EDX  равно  0,  то  флаги  CF и OF
очищаются; в противном случае они установлены.

Изменяемые флаги
Если старшая половина  результата равна 0,  то флаги OF  и CF очищаются;  в
противном случае они установлены; флаги SF, ZF, AF, PF и CF неопределены.

Исключения защищенного режима
#GP(0)  в  случае  недопустимого  исполнительного  адреса операнда памяти в
сегментах CS, DS,  ES, FS или  GS; #SS(0) в  случае недопустимого адреса  в
сегменте  SS;   #PF(код  сбоя)   в  случае   страничного  сбоя;   #AC   для
невыравненной  ссылки  к  памяти  при  текущем  уровне привилегированности,
равном 3.

Исключения режима реальных адресов
Прерывание  13,  если  какая-либо  часть  операнда  лежит  вне пространства
исполнительных адресов от 0 до 0FFFFH.

Исключения виртуального режима 8086
Те же исключения,  что и для  режима реальных адресов:  #PF (код сбоя)  для
страничных сбоев; #AC для невыравненной ссылки к памяти при текущем  уровне
привилегированности, равном 3.

`м`д`05NEG`* - Отрицание с дополнением до двух

|Код       Команда        Число      Описание                   |
|операции                 тактовых                              |
|                         циклов                                |
|                                                               |
|F6 /3     NEG r/m8        1/3     Отрицание с дополнением до   |
|                                  двух байта r/m               |
|F7 /3     NEG r/m16       1/3     Отрицание с дополнением до   |
|                                  двух слова r/m               |
|F7 /3     NEG r/m32       1/3     Отрицание с дополнением до   |
|                                  двух двойного слова r/m      |

Работа команды

IF r/m = 0 THEN CF <- 0 ELSE CF <- 1; FI;
r/m <- - r/m

Описание
Команда NEG замещает значение регистра или операнда памяти  соответствующим
дополнением до  двух. Операнд  вычитается из  нуля, а  результат помещается
обратно в операнд.

Флаг CF установлен, если операнд не равен нулю, когда флаг CF очищается.

Изменяемые флаги
Флаг CF установлен,  если операнд не  равен нулю, когда  флаг CF очищается;
флаги OF, SF, ZF и PF устанавливаются в соответствии с результатом.

Исключения защищенного режима
#GP(0), если назначением является  сегмент, недоступный для записи;  #GP(0)
в случае недопустимого исполнительного  адреса операнда памяти в  сегментах
CS, DS, ES, FS или GS; #SS(0) в случае недопустимого адреса в сегменте  SS;
#PF(код сбоя)  в случае  страничного сбоя;  #AC для  невыравненной ссылки к
памяти при текущем уровне привилегированности, равном 3.

Исключения режима реальных адресов
Прерывание  13,  если  какая-либо  часть  операнда  лежит  вне пространства
исполнительных адресов от 0 до 0FFFFH.

Исключения виртуального режима 8086
Те же исключения,  что и для  режима реальных адресов:  #PF (код сбоя)  для
страничных сбоев. #AC для невыравненной ссылки к памяти при текущем  уровне
привилегированности, равном 3.


`м`д`05NOP`* - Нет операции

|Код       Команда        Число      Описание                   |
|операции                 тактовых                              |
|                         циклов                                |
|                                                               |
|90        NOP             1       Нет операции                 |

Описание
Команда NOP  не выполняет  никакой операции.  Команда NOP  это однобайтовая
команда, которая занимает место в памяти, но не влияет на контекст  машины,
за исключением регистра (E)IP.
Команда  NOP  представляет  собой  мнемонический  алиас  для  команды  XCHG
(E)AX,(E)AX.

Изменяемые флаги
Отсутствуют

Исключения защищенного режима
Отсутствуют

Исключения режима реальных адресов
Отсутствуют

Исключения виртуального режима 8086
Отсутствуют

`м`д`05NOT`* - Отрицание с дополнением до одного (поразрядное дополнение)

|Код       Команда        Число      Описание                   |
|операции                 тактовых                              |
|                         циклов                                |
|                                                               |
|F6 /2     NOT r/m8        1/3     Изменение на противоположное |
|                                  значения каждого бита в      |
|                                  байте r/m                    |
|F7 /2     NOT r/m16       1/3     Изменение на противоположное |
|                                  значения каждого бита в      |
|                                  слове r/m                    |
|F7 /2     NOT r/m32       1/3     Изменение на противоположное |
|                                  значения каждого бита в      |
|                                  двойном слове r/m            |

Работа команды
r/m <- NOT r/m;

Описание
Команда NOT инвертирует операнд: каждая 1 становится 0, и наоборот.

Изменяемые флаги
Отсутствуют

Исключения защищенного режима
#GP(0), если назначением является  сегмент, недоступный для записи;  #GP(0)
в случае недопустимого исполнительного  адреса операнда памяти в  сегментах
CS, DS, ES, FS или GS; #SS(0) в случае недопустимого адреса в сегменте  SS;
#PF(код сбоя)  в случае  страничного сбоя;  #AC для  невыравненной ссылки к
памяти при текущем уровне привилегированности, равном 3.

Исключения режима реальных адресов
Прерывание  13,  если  какая-либо  часть  операнда  лежит  вне пространства
исполнительных адресов от 0 до 0FFFFH.

Исключения виртуального режима 8086
Те же исключения,  что и для  режима реальных адресов:  #PF (код сбоя)  для
страничных сбоев. #AC для невыравненной ссылки к памяти при текущем  уровне
привилегированности, равном 3.


`м`д`05OR`* - Логическое исключающее ИЛИ

|Код       Команда     Число      Описание                     |
|операции              тактовых                                |
|                      циклов                                  |
|                                                              |
|0C ib     OR AL,imm8     1   Операция логического ИЛИ   непос-|
|                             редственного байта и AL          |
|0D iw     OR AX,imm16    1   Операция логического ИЛИ   непос-|
|                             редственного слова и AX          |
|0D id     OR EAX,imm32   1   Операция логического ИЛИ   непос-|
|                             редственного двойного слова и EAX|
|80 /1 ib  OR r/m8,imm8   1/3 Операция логического ИЛИ   непос-|
|                             редственного байта и байта в r/m |
|81 /1 iw  OR r/m16,imm16 1/3 Операция логического ИЛИ   непос-|
|                             редственного слова и слова в r/m |
|81 /1 id  OR r/m32,imm32 1/3 Операция логического ИЛИ   непос-|
|                             редственного двойного слова и    |
|                             двойного слова в r/m             |
|83 /1 ib  OR r/m16,imm8  1/3 Операция логического ИЛИ   непос-|
|                             редственного расширенного знаком |
|                             байта и слова в r/m              |
|83 /1 ib  OR r/m32,imm8  1/3 Операция логического ИЛИ   непос-|
|                             редственного расширенного знаком |
|                             слова и двойного слова в r/m     |
|08 /r     OR r/m8,r8     1/3 Операция логического ИЛИ         |
|                             байтового регистра и байта в r/m |
|09 /r     OR r/m16,r16   1/3 Операция логического ИЛИ         |
|                             регистра-слова и слова в r/m     |
|09 /r     OR r/m32,r32   1/3 Операция логического ИЛИ         |
|                             регистра-двойного слова и        |
|                             двойного слова в r/m             |
|0A /r     OR r8,r/m8     1/2 Операция логического ИЛИ   байта |
|                             в r/m и байтового регистра       |
|OB /r     OR r16,r/m16   1/2 Операция логического ИЛИ   слова |
|                             в r/m и регистра-слова           |
|OB /r     OR r32,r/m32   1/2 Операция логического ИЛИ         |
|                             двойного слова в r/m и регистра- |
|                             двойного слова                   |

Работа команды

DEST <- DEST OR  SRC;
CF <- 0;
OF <- 0;

Описание
Команда  OR  вычисляет  исключающее  ИЛИ  для  ее двух операндов и помещает
результат  в  первый  операнд.  Каждый  бит  результата  равен  0, если оба
соответствующих бита операнда  равны 0; в  противном случае бит  результата
равен 1.

Изменяемые флаги
Флаги CF и OF очищаются ; флаги PF, SF и ZF устанавливаются в  соответствии
с результатом; флаг AF неопределен.

Исключения защищенного режима
#GP(0), если результат должен помещаться в сегмент, для которого  запрещена
запись;  #GP(0)  в  случае  недопустимого  исполнительного  адреса операнда
памяти в сегментах  CS, DS, ES,  FS или GS;  #SS(0) в случае  недопустимого
адреса в  сегменте SS;  #PF(код сбоя)  в случае  страничного сбоя;  #AC для
невыравненной  ссылки  к  памяти  при  текущем  уровне привилегированности,
равном 3.

Исключения режима реальных адресов
Прерывание  13,  если  какая-либо  часть  операнда  лежит  вне пространства
исполнительных адресов от 0 до 0FFFFH.

Исключения виртуального режима 8086
Те же исключения,  что и для  режима реальных адресов:  #PF (код сбоя)  для
страничных сбоев; #AC для невыравненной ссылки к памяти при текущем  уровне
привилегированности, равном 3.


`м`д`05OUT`* - Вывод в порт

|Код       Команда  Число      Описание                         |
|операции           тактовых                                    |
|                   циклов                                      |
|                                                               |
|E6 ib   OUT imm8,AL  16,pm=11*/    Вывод байта AL в непосредст-|
|                     31**,vm=29    венно заданный номер порта  |
|E7 ib   OUT imm8,AX  16,pm=11 */   Вывод слова AX в непосредст-|
|                     31**,vm=29    венно заданный номер порта  |
|E7 ib  OUT imm8,EAX  16,pm=11*/    Вывод двойного слова EAX в  |
|                     31**,vm=29    непосредственно заданный    |
|                                   номер порта в               |
|EE      OUT DX,AL    16,pm=11*/    Вывод байта AL в порт,      |
|                     31**,vm=29    номер которого задан в DX   |
|EF      OUT DX,AX    16,pm=11*/    Вывод слова AX в порт,      |
|                     31**,vm=29    номер которого задан в DX   |
|EF     OUT DX,EAX    16,pm=11*/    Вывод двойного слова EAX в  |
|                     31**,vm=29    порт,номер которого задан DX|
     Примечания: * если CPL <= IOPL
                ** если CPL > IOPL

Работа команды

IF (PE = 1) AND ((VM = 1) OR (CPL > IOPL))
THEN (* Виртуальный режим 8086 или защищенный  режим  при  CPL  >
        IOPL *)
  IF NOT I-O-Permission(SRC, width(SRC))
  THEN #GP(0);
  FI;
FI;
[DEST] <- SRC; (*используемое адресное пространство ввода/вывода*)

Описание
Команда IN пересылает байт или  слово данных из заданного вторым  операндом
регистра (AL,  AX или  EAX) в  выходной порт,  номер которого  задан первым
операндом. Доступ к любому порту от 0 до 65535 выполняется путем  помещения
номера порта  в регистр  DX и  использования команды  OUT с  регистром DX в
качестве   первого   операнда.   Если   команда   содержит    идентификатор
восьми-битового порта, то значение расширяется нулем до 16 битов.

Изменяемые флаги
Отсутствуют

Исключения защищенного режима
#GP(0),   если   текущий    уровень   привилегированности   больше    (т.е.
привилегированность меньше) уровня привилегированности ввода/вывода  (IOPL)
или  если  любой  из  соответствующих  битов  разрешения ввода/вывода в TSS
равен 1.

Исключения режима реальных адресов
Отсутствуют

Исключения виртуального режима 8086
Сбой #GP(0), если любой из соответствующих битов разрешения ввода/вывода  в
TSS равен 1.


`м`д`05OUTS/OUTSB/OUTSW/OUTSD`*  - Вывод строки в порт

|Код       Команда  Число      Описание                         |
|операции           тактовых                                    |
|                   циклов                                      |
|                                                               |
|6E     OUTS DX,r/m8  17,pm=10*/    Вывод байта [(E)SI] в порт, |
|                     32**,vm=30    заданный в DX               |
|6F     OUTS DX,r/m16 17,pm=10*/    Вывод слова [(E)SI] в порт, |
|                     32**,vm=30    заданный в DX               |
|6F     OUTS DX,r/m32 17,pm=10*/    Вывод двойного слова [(E)SI]|
|                     32**,vm=30    в порт, заданный в DX       |
|6E     OUTSB         17,pm=10*/  Вывод байта DS:[(E)SI] в порт,|
|                     32**,vm=30    заданный в DX               |
|6F     OUTSW         17,pm=10*/  Вывод слова DS:[(E)SI] в порт,|
|                     32**,vm=30    заданный в DX               |
|6F     OUTSD         17,pm=10*/  Вывод двойн. слова DS:[(E)SI] |
|                     32**,vm=30    в порт, заданный в DX       |

     Примечания: * если CPL <= IOPL
                ** если CPL > IOPL

Работа команды

IF AddressSize = 16
THEN использование SI как индекса-источника;
ELSE (* AddressSize = 32 *)
     использование ESI как индекса-источника;
FI;

IF (PE = 1) AND ((VM = 1) OR (CPL > IOPL))
THEN (* Виртуальный режим 8086 или защищенный  режим  при  CPL  >
        IOPL *)
  IF NOT I-O-Permission(DEST, width(DEST))
  THEN #GP(0);
  FI;
FI;
IF команда байтового типа
THEN
  [DX] <-[индекс-источника];  (* Запись байта в адресное
      пространство ввода/вывода согласно DX *)
  IF DF = 0 THEN IncDec <- 1 ELSE IncDec <- -1; FI;
FI;
IF OperandSize = 16
THEN
  [DX] <- [индекс-источника];  (* Запись слова в адресное
      пространство ввода/вывода согласно DX *)
  IF DF = 0 THEN IncDec <- 2 ELSE IncDec <- -2; FI;
FI;
IF OperandSize = 32
THEN
  [DX] <- [индекс-источника] <- [DX];  (* Запись двойного слова
      в адресное пространство ввода/вывода согласно DX *)
  IF DF = 0 THEN IncDec <- 4 ELSE IncDec <- -4; FI;
FI;
индекс-источника <- индекс-источника + IncDec;

Описание
Команда OUTS пересылает данные из  байта, слова или двойного слова  памяти,
заданного регистром индекса-источника  в порт вывода,  адресуемый регистром
DX. Если атрибут  размера адреса для  данной команды равен  16 битам, то  в
качестве регистра  индекса-источника используется  регистр SI;  в противном
случае,  когда   атрибут  размера   адреса  равен   32  битам,    регистром
индекса-источника является ESI.
Команда OUTS не позволяет задавать номер порта непосредственным  значением.
Порт  должен  адресоваться  значением  в  регистре  DX.  Перед  выполнением
команды OUTS в DX должно быть загружено правильное значение.
Адрес источника данных определяется содержимым регистра индекса  источника.
Перед  выполнением  команды  OUTS  в  регистр индекса источника должно быть
загружено правильное значение индекса.
После  выполнения  пересылки  регистр  индекса  источника   соответственным
образом автоматически продвигается.  Если флаг DF  равен 0 (была  выполнена
команда CLD), то происходит инкремент  региста; Если флаг DF равен  1 (была
выполнена  команда  STD),  то  происходит  его  декремент.  Инкремент   или
декремент регистра равен  1 при выводе  байта, 2 при  выводе слова и  4 при
выводе двойного слова.

Команды OUTSB,  OUTSW и  OUTSD -  это синонимы  команды OUTS,  работающие с
байтом,  словом  и  двойным  словом,  соответственно.  Команде  OUTS  может
предшествовать префикс REP  для вывода блока,  равного CX байтов  или слов.
Эта операция описана для команды REP.

Изменяемые флаги
Отсутствуют

Исключения защищенного режима
#GP(0),  если  текущий  уровень  привилегированности численно больше уровня
привилегированности ввода/вывода (IOPL)  или если любой  из соответствующих
битов  разрешения  ввода/вывода  в  TSS  равен  1.  исполнительного  адреса
операнда  памяти  в  сегментах  CS,  DS,  ES,  FS  или  GS; #SS(0) в случае
недопустимого адреса  в сегменте  SS; #  PF(код сбоя)  в случае страничного
сбоя;  #AC   для  невыравненной   ссылки  к   памяти  при   текущем  уровне
привилегированности, равном 3.

Исключения режима реальных адресов
Прерывание  13,  если  какая-либо  часть  операнда  лежит  вне пространства
исполнительных адресов от 0 до 0FFFFH.

Исключения виртуального режима 8086
Сбой #GP(0), если любой из соответствующих битов разрешения ввода/вывода  в
TSS равен  1. #PF  (код сбоя)  для страничных  сбоев; #AC для невыравненной
ссылки к памяти при текущем уровне привилегированности, равном 3.


`м`д`05POP`* - Извлечение слова из стека

|Код       Команда     Число      Описание                      |
|операции              тактовых                                 |
|                      циклов                                   |
|                                                               |
|8F /0     POP m16      6        Извлечение вершины стека и     |
|                                помещение ее в слово памяти    |
|8F /0     POP m32      6        Извлечение вершины стека и     |
|                                помещение ее в двойное слово   |
|                                памяти                         |
|58+ rw    POP r16      4        Извлечение вершины стека и     |
|                                помещение ее в слово - регистр |
|58+ rd    POP r32      4        Извлечение вершины стека и     |
|                                помещение ее в двойное слово - |
|                                регистр                        |
|1F        POP DS       3        Извлечение вершины стека и     |
|                                помещение ее в регистр DS      |
|07        POP ES       3        Извлечение вершины стека и     |
|                                помещение ее в регистр ES      |
|17        POP SS       3        Извлечение вершины стека и     |
|                                помещение ее в регистр SS      |
|0F A1     POP FS       3        Извлечение вершины стека и     |
|                                помещение ее в регистр FS      |
|0F A9     POP GS       3        Извлечение вершины стека и     |
|                                помещение ее в регистр GS      |

Работа команды

IF StackAddrSize = 16
THEN
  IF OperandSize = 16
  THEN
    DEST <- (SS:SP); (* Копирование слова *)
    SP <- SP + 2;
  ELSE (* OperandSize = 32 *)
    DEST <- (SS:SP); (* Копирование двойного слова *)
    SP <- SP + 4;
  FI;

ELSE (* StackAddrSize = 32 *)
  IF OperandSize = 16
  THEN
    DEST <- (SS:ESP); (* Копирование слова *)
    ESP <- ESP + 2;
  ELSE (* OperandSize = 32 *)
    DEST <- (SS:ESP); (* Копирование двойного слова *)
    ESP <- ESP + 4;
  FI;
FI;

Описание
Команда  POP  заменяет  текущее  содержимое  операнда  памяти, регистра или
сегментного  регистра  словом,  снятым  с  вершины  стека i486, адресуемого
SS:SP  (при  атрибуте  размера  адреса  16  битов) или SS:ESP (при атрибуте
размера  адреса  32  бита).  Указатель  стека  SP получает приращение 2 при

размере операнда 16 битов или 4  при размере операнда 32 бита. После  этого
указатель устанавливается на новую вершину стека.
Команда POP CS не является командой процессора i486. Извлечение из стека  в
регистр CS осуществляется командой RET.
Если операнд  назначения это  сегментный регистр  (DS, ES,  FS или  SS), то
извлекаемое  из  стека  значение  должно  являться селектором. В защищенном
режиме  загрузка  селектора  инициирует  автоматическую загрузку информации
дескриптора, связанной  с данным  селектором, в  скрытую часть  сегментного
регистра:  загрузка  также  инициирует  контроль  достоверности  информации
селектора и дескриптора.
Пустое значение (0000-0003)  может быть извлечен  в регистр DS,  ES, FS или
GS, не вызывая исключения защиты. Попытка сослаться на сегмент,  сегментный
регистр которого был загружен пустым значением, вызовет исключение  #GP(0).
Ссылок к памяти не происходит. Сегмент при этом сохраняет пустое значение.
Команда  POP  SS   запрещает  все  прерывания,   включая  и   немаскируемые
прерывания,  до   конца  выполнения   следующей  команды.   Это   позволяет
последовательное выполнение команд POP SS и POP eSP без опасности иметь  во
время прерывания  неверное состояние  стека. Однако,  использование команды
LSS для загрузки регистров SS и eSP предпочтительнее.
Загрузка   сегментного   регистра   в   защищенном   режиме  сопровождaется
специальными проверками и действиями, как показано в следующем листинге:

IF загружается SS:
  IF селектор пустой THEN #GP(0);
    Индекс селектора должен быть в границах его таблицы дескрипторов,
          ELSE #GP(селектор);
    RPL селектора должен быть равен CPL ELSE #GP(селектор);
    Байт AR  должен  задавать сегмент данных, доступный для записи,
          ELSE #GP(селектор);
    DPL в байте AR должен быть равен CPL ELSE #GP(селектор);
    Сегмент должен   быть   помечен   как   Присутствующий   ELSE
          #NP(селектор);
    Загрузка регистра SS селектором;
    Загрузка регистра SS дескриптором;

IF DS, ES, FS или GS загружается не-пустым селектором:
  Байт AR  должен  задавать сегмент данных или кодовый сегмент,
     доступный для записи чтения, ELSE #GP(селектор);
  IF сегмент данных или не-конформный сегмент кода
  THEN RPL и CPL должны быть меньше или равны DPL в байте AR;
  ELSE #GP(селектор);
  FI;
  Сегмент должен   быть   помечен   как   Присутствующий   ELSE
          #NP(селектор);
  Загрузка сегментного регистра селектором;
  Загрузка сегментного регистра дескриптором;

IF DS, ES, FS или GS загружается пустым селектором:
  Загрузка сегментного регистра селектором;
  Очистка бита Достоверности в невидимой части регистра

Изменяемые флаги
Отсутствуют

Исключения защищенного режима
#GP, #SS и #NP, если  загружается сегментный регистр; #SS(0), если  текущая
вершина  стека  не  находится  в  границах стекового сегмента; #GP(0), если
назначением  является  сегмент,  недоступный  для  записи;  #GP(0) в случае
недопустимого исполнительного  адреса операнда  памяти в  сегментах CS, DS,
ES, FS или GS; #SS(0) в случае недопустимого адреса в сегменте SS;  #PF(код
сбоя) в случае страничного сбоя; #AC для невыравненной ссылки к памяти  при
текущем уровне привилегированности, равном 3.

Исключения режима реальных адресов
Прерывание  13,  если  какая-либо  часть  операнда  лежит  вне пространства
исполнительных адресов от 0 до 0FFFFH.

Исключения виртуального режима 8086
Те же исключения,  что и для  режима реальных адресов:  #PF (код сбоя)  для
страничных сбоев. #AC для невыравненной ссылки к памяти при текущем  уровне
привилегированности, равном 3.

Примечание
Разрешены  последовательности   парных  команд   PUSH/POP,  не    требующие
дополнительного тактового цикла между ними.

`м`д`05POPA/POPAD`* - Извлечение из стека всех
                      регистров общего назначения

|Код       Команда     Число      Описание                      |
|операции              тактовых                                 |
|                      циклов                                   |
|                                                               |
|61        POPA         9        Извлечение из стека  DI,  SI,  |
|                                 BP,  BX,  DX,  CX  и  AX      |
|61        POPAD        9        Извлечение из стека EDI, ESI,  |
|                                EBP, EBX, EDX, ECX  и EAX      |

Работа команды

IF OperandSize = 16 (* Команда = POPA *)
THEN
  DI <-  Pop();
  SI <-  POP();
  BP <-  Pop();
  теряется <-  Pop();  (* Пропуск SP *)
  BX <-  Pop();
  DX <-  Pop();
  CX <-  Pop();
  AX <-  Pop();
ELSE (* OperandSize = 32, команда = POPAD *)
  EDI <-  Pop();
  ESI <-  POP();
  EBP <-  Pop();
  теряется <-  Pop();  (* Пропуск ESP *)
  EBX <-  Pop();
  EDX <-  Pop();
  ECX <-  Pop();
  EAX <-  Pop();
FI;

 Описание
Команда  POPA  извлекает  из  стека  восемь  16-битовых  регистров   общего
назначения. Однако, значение SP  вместо загрузки регистра SP  уничтожается.
Команда POPA реверсирует действие предыдущей команды PUSHA,  восстанавливая
значения регистров общего назначения,  которые они имели перед  выполнением
команды PUSHA. Первый извлекаемый регистр - это DI.
Команда  POPAD  извлекает  из  стека  восемь  32-битовых  регистров  общего
назначения.   Однако,   значение   ESP   вместо   загрузки   регистра   ESP
уничтожается.  Команда  POPAD   реверсирует  действие  предыдущей   команды
PUSHAD, восстанавливая  значения регистров  общего назначения,  которые они
имели перед выполнением  команды PUSHAD. Первый  извлекаемый регистр -  это
EDI.

Изменяемые флаги
Отсутствуют

Исключения защищенного режима
#SS(0), если  начальный или  конечный адрес  стека не  находится в пределах
стекового сегмента; #PF(код сбоя) в случае страничного сбоя;

Исключения режима реальных адресов
Прерывание  13,  если  какая-либо  часть  операнда  лежит  вне пространства
исполнительных адресов от 0 до 0FFFFH.

Исключения виртуального режима 8086
Те же исключения,  что и для  режима реальных адресов:  #PF (код сбоя)  для
страничных сбоев.


`м`д`05POPF/POPFD`* - Извлечение из стека регистров
                             FLAGS или ERFLAGS

|Код       Команда     Число      Описание                      |
|операции              тактовых                                 |
|                      циклов                                   |
|                                                               |
|9D        POPF         9,pm=6   Извлечение вершины стека в     |
|                                FLAGS                          |
|9D        POPFD        9,pm=6   Извлечение вершины стека в     |
|                                EFLAGS                         |

Работа команды
Флаги <- Pop();

Описание
Команда POPA  снимает с  вершины стека  слово или  двойное слово и помещает
его во  флаговый регистр.  Если атрибут  размера операнда  команды равен 16
битам, из стека  извлекается слово, и  его содержимое помещается  в регистр
FLAGS.  Если  атрибут  размера  операнда  команды  равен  32 бита, из стека
извлекается двойное слово, и его содержимое помещается в регистр EFLAGS.
Информация о регистрах FLAGS  и EFLAGS находится в  главах 2 и 4.  Отметим,
что биты 16 и  17 регистра EFLAGS, называемые  VM и RF, соответственно,  не
зависят от работы команды POPF и POPFD.
Уровень  привилегированности  ввода/вывода  может  быть  изменен только при
выполнении  на  уровне  привилегированности  0.  Флаг прерывания изменяется
только   при   выполнении   на   уровне,   как   минимум   равном    уровню
привилегированности  ввода/вывода.  (Режим  реальных  адресов  эквивалентен
уровню  привилегированности   0).  Если   команда  POPF   выполняется   при
недостаточном  уровне  привилегированности,  исключение  не  возникает,  но
привилегированные биты не изменяются.

Изменяемые флаги
Все флаги, за исключением флагов VM и RF.

Исключения защищенного режима
#SS(0), если вершина стека не находится в пределах стекового сегмента.

Исключения режима реальных адресов
Прерывание  13,  если  какая-либо  часть  операнда  лежит  вне пространства
исполнительных адресов от 0 до 0FFFFH.

Исключения виртуального режима 8086
Сбой  #GP(0),  если  уровень  привилегированности  меньше  3, что позволяет
эмуляцию.


`м`д`05PUSH`* - помещение операнда в стек

|Код       Команда     Число      Описание                      |
|операции              тактовых                                 |
|                      циклов                                   |
|                                                               |
|FF /6     PUSH m16     4        Помещение в стек               |
|                                слова памяти                   |
|FF /6     PUSH m32     4        Помещение в стек               |
|                                двойного слова памяти          |
|50+ /r    PUSH r16     1        Помещение в стек               |
|                                слова - регистра               |
|50+ /r    PUSH r32     1        Помещение в стек               |
|                                двойного слова - регистра      |
|6A        PUSH imm8    1        Помещение в стек               |
|                                непосредственного байта        |
|68        PUSH imm16   1        Помещение в стек               |
|                                непосредственного слова        |
|68        PUSH imm32   1        Помещение в стек               |
|                               непосредственного двойного слова|
|0E        PUSH CS      3        Помещение в стек CS            |
|16        PUSH SS      3        Помещение в стек SS            |
|1E        PUSH DS      3        Помещение в стек DS            |
|06        PUSH ES      3        Помещение в стек ES            |
|0F A0     PUSH FS      3        Помещение в стек FS            |
|0F A8     PUSH GS      3        Помещение в стек GS            |

Работа команды

IF StackAddrSize = 16
THEN
  IF OperandSize = 16 THEN
    SP <- SP - 2;
    (SS:SP) <- (источник);  (* Назначение слова *)
  ELSE
    SP <- SP - 4;
    (SS:SP) <- (источник);  (* Назначение двойного слова *)
  FI;

ELSE (* StackAddrSize = 32 *)
  IF OperandSize = 16
  THEN
    ESP <- ESP - 2;
    (SS:ESP) <- (источник);  (* Назначение слова *)
  ELSE
    ESP <- ESP - 4;
    (SS:ESP) <- (источник);  (* Назначение двойного слова *)
  FI;

Описание
Команда  PUSH  декрементирует  указатель  стека  на 2, если атрибут размера
операнда  команды  равен  16  битам;  в противном случае она декрементирует
указатель стека на 4. Затем  команда PUSH помещает операнд в  новую вершину
стека, на которую указывает указатель стека.
Команда  PUSH  ESP  помещает  в  стек  значение  регистра  ESP, в том виде,
который он имел до выполнения команды. В этом состоит отличие от 8086,  где
команда PUSH SP помещает в стек новое значение (декрементированное на 2).

Изменяемые флаги
Отсутствуют

Исключения защищенного режима
#SS(0), если  новое значение  регистра SP  или ESP  не находится в границах
стекового сегмента;  #GP(0) в  случае недопустимого  исполнительного адреса
операнда  памяти  в  сегментах  CS,  DS,  ES,  FS  или  GS; #SS(0) в случае
недопустимого адреса  в сегменте  SS; #  PF(код сбоя)  в случае страничного
сбоя;  #AC   для  невыравненной   ссылки  к   памяти  при   текущем  уровне
привилегированности, равном 3.

Исключения режима реальных адресов
Отсутствуют: если регистр SP или  ESP равен 1, процессор переходит  в режим
закрытия из-за недостаточного размера памяти стека.

Исключения виртуального режима 8086
Те же исключения,  что и для  режима реальных адресов:  #PF (код сбоя)  для
страничных сбоев. #AC для невыравненной ссылки к памяти при текущем  уровне
привилегированности, равном 3.

Примечание
При  использовании  операнда  памяти  команда  PUSH выполняется дольше, чем
последовательность двух команд, пересылающая операнд через регистр.
Разрешены  последовательности   парных  команд   PUSH/POP,  не    требующие
дополнительного тактового цикла между ними.


`м`д`05PUSHA/PUSHAD`* -
        - Помещение в стек всех регистров общего назначения

|Код       Команда     Число      Описание                      |
|операции              тактовых                                 |
|                      циклов                                   |
|                                                               |
|60        PUSHA        11       Помещение в стек  AX,  CX,  DX,|
|                                 BX, исходного  SP, BP, SI и DI|
|60        PUSHAD       11       Помещение в стек EAX, ECX, EDX,|
|                               EBX, исходного ESP,EBP,ESI и EDI|

Работа команды

IF OperandSize = 16 (* Команда = PUSHA *)
THEN
  Врем <- (SP);
  Push(AX);
  Push(CX);
  Push(DX);
  Push(BX);
  Push(Врем);
  Push(BP);
  Push(SI);
  Push(DI);
ELSE (* OperandSize = 32, команда = PUSHAD *)
  Врем <- (ESP);
  Push(EAX);
  Push(ECX);
  Push(EDX);
  Push(EBX);
  Push(Врем);
  Push(EBP);
  Push(ESI);
  Push(EDI);
FI;


Описание
Команды PUSHA  и PUSHAD  помещают в  стек i486  16- или 32-битовые регистры
общего назначения.  Команда PUSHA  декрементирует указатель  стека (SP)  на
16,  что  соответствует  восьми  помещаемым  значениям  размером  в  слово.
Команда  PUSHAD   декрементирует  указатель   стека  (ESP)   на  32,    что
соответствует  восьми  помещаемым  значениям  размером  в  двойное   слово.
Поскольку регистры помещаются  в стек в  данном порядке, в  новом стеке они
появятся в  обратном порядке.  Последним в  стек помещается  регистр DI или
EDI.

Изменяемые флаги
Отсутствуют

Исключения защищенного режима
#SS(0), если  начальный или  конечный адрес  стека не  находится в пределах
стекового сегмента; #PF(код сбоя) в случае страничного сбоя;

Исключения режима реальных адресов
Перед выполнением  команды PUSHA  или PUSHAD  процессор 386  DX переходит в
режим закрытия при равенстве регистра SP  или ESP 1, 3 или 5;  если регистр
SP или ESP равен 7, 9, 11, 13 или 15, то происходит исключение 13.

Прерывание  13,  если  какая-либо  часть  операнда  лежит  вне пространства
исполнительных адресов от 0 до 0FFFFH.

Исключения виртуального режима 8086
Те же исключения,  что и для  режима реальных адресов:  #PF (код сбоя)  для
страничных сбоев.


`м`д`05PUSHF/PUSHFD`* - Помещение в стек флаговых регистров

|Код       Команда     Число      Описание                      |
|операции              тактовых                                 |
|                      циклов                                   |
|                                                               |
|9C        PUSHF        4,pm=3   Помещение в стек FLAGS         |
|9C        PUSHFD       4,pm=3   Помещение в стек EFLAGS        |

Работа команды

IF OperandSize = 32
THEN push(EFLAGS);
ELSE push(FLAGS);
FI;


Описание
Команда PUSHF декрементирует указатель стека на 2 и копирует регистр  FLAGS
в новую вершину стека; команда PUSHFD декрементирует указатель стека на  4,
и в  новую вершину  стека копируется  регистр EFLAGS,  на которую указывает
SS:ESP. Информацию о регистре EFLAGS см. в главах 2 и 4.

Изменяемые флаги
Отсутствуют

Исключения защищенного режима
#SS(0), если новое значение регистра ESP не находится в пределах  стекового
сегмента.

Исключения режима реальных адресов
Отсутствуют:  процессор  переходит  в  режим  закрытия из-за недостаточного
размера памяти стека.

Исключения виртуального режима 8086
Сбой  #GP(0),  если  уровень  привилегированности  меньше  3, что позволяет
эмуляцию.


`м`д`05RCL/RCR/ROL/ROR`* - Циклический сдвиг

|Код       Команда     Число      Описание                      |
|операции              тактовых                                 |
|                      циклов                                   |
|                                                               |
|D0 /2     RCL r/m8,1  3/4       Циклический сдвиг 9 битов      |
|                                (CF, байт r/m) влево 1  раз    |
|D2 /2     RCL r/m8,   8-30/9-31 Циклический сдвиг 9 битов      |
|              CL                (CF, байт r/m) влево CL раз    |
|C0 /2 ib  RCL r/m8,   8-30/9-31 Циклический сдвиг 9 битов      |
|              imm8              (CF, байт r/m) влево imm8 раз  |
|D1 /2     RCL r/m16,1 3/4       Циклический сдвиг 17 битов     |
|                                (CF,слово r/m) влево 1  раз    |
|D3 /2     RCL r/m16,  8-30/9-31 Циклический сдвиг 17 битов     |
|              CL                (CF,слово r/m) влево CL раз    |
|C1 /2 ib  RCL r/m16,  8-30/9-31 Циклический сдвиг 17 битов     |
|              imm8              (CF,слово r/m) влево imm8 раз  |
|D1 /2     RCL r/m32,1 3/4       Циклический сдвиг 33 битов     |
|                          (CF,двойное слово r/m) влево 1  раз  |
|D3 /2     RCL r/m32,  8-30/9-31 Циклический сдвиг 33 битов     |
|              CL          (CF,двойное слово r/m) влево CL раз  |
|C1 /2 ib  RCL r/m32,  8-30/9-31 Циклический сдвиг 33 битов     |
|              imm8        (CF,двойное слово r/m) влево imm8 раз|

|D0 /3     RCR r/m8,1  3/4       Циклический сдвиг 9 битов      |
|                                (CF, байт r/m) вправо 1  раз   |
|D2 /3     RCR r/m8,   8-30/9-31 Циклический сдвиг 9 битов      |
|              CL                (CF, байт r/m) вправо CL раз   |
|C0 /3 ib  RCR r/m8,   8-30/9-31 Циклический сдвиг 9 битов      |
|              imm8              (CF, байт r/m) вправо imm8 раз |
|D1 /3     RCR r/m16,1 3/4       Циклический сдвиг 17 битов     |
|                                (CF,слово r/m) вправо 1  раз   |
|D3 /3     RCR r/m16,  8-30/9-31 Циклический сдвиг 17 битов     |
|              CL                (CF,слово r/m) вправо CL раз   |
|C1 /3 ib  RCR r/m16,  8-30/9-31 Циклический сдвиг 17 битов     |
|              imm8              (CF,слово r/m) вправо imm8 раз |
|D1 /3     RCR r/m32,1 3/4       Циклический сдвиг 33 битов     |
|                          (CF,двойное слово r/m) вправо 1  раз |
|D3 /3     RCR r/m32,  8-30/9-31 Циклический сдвиг 33 битов     |
|              CL          (CF,двойное слово r/m) вправо CL раз |
|C1 /3 ib  RCR r/m32,  8-30/9-31 Циклический сдвиг 33 битов     |
|              imm8        (CF,двойное слово r/m)вправо imm8 раз|
|D0 /0     ROL r/m8,1  3/4       Циклический сдвиг 8 битов      |
|                                (    байт r/m) влево 1  раз    |
|D2 /0     ROL r/m8,   3/4       Циклический сдвиг 8 битов      |
|              CL                (    байт r/m) влево CL раз    |
|C0 /0 ib  ROL r/m8,   3/4       Циклический сдвиг 8 битов      |
|              imm8              (    байт r/m) влево imm8 раз  |
|D1 /0     ROL r/m16,1 3/4       Циклический сдвиг 16 битов     |
|                                (   слово r/m) влево 1  раз    |
|D3 /0     ROL r/m16,  3/4       Циклический сдвиг 16 битов     |
|              CL                (   слово r/m) влево CL раз    |
|C1 /0 ib  ROL r/m16,  3/4       Циклический сдвиг 16 битов     |
|              imm8              (   слово r/m) влево imm8 раз  |
|D1 /0     ROL r/m32,1 3/4       Циклический сдвиг 32 битов     |
|                             (двойное слово r/m) влево 1  раз  |
|D3 /0     ROL r/m32,  3/4       Циклический сдвиг 32 битов     |
|              CL             (двойное слово r/m) влево CL раз  |
|C1 /0 ib  ROL r/m32,  2/4       Циклический сдвиг 32 битов     |
|              imm8           (двойное слово r/m) влево imm8 раз|
|D0 /1     ROR r/m8,1  3/4       Циклический сдвиг 8 битов      |
|                                (    байт r/m) вправо 1  раз   |
|D2 /1     ROR r/m8,   3/4       Циклический сдвиг 8 битов      |
|              CL                (    байт r/m) вправо CL раз   |
|C0 /1 ib  ROR r/m8,   3/4       Циклический сдвиг 8 битов      |
|              imm8              (    байт r/m) вправо imm8 раз |
|D1 /1     ROR r/m16,1 3/4       Циклический сдвиг 16 битов     |
|                                (   слово r/m) вправо 1  раз   |
|D3 /1     ROR r/m16,  3/4       Циклический сдвиг 16 битов     |
|              CL                (   слово r/m) вправо CL раз   |
|C1 /1 ib  ROR r/m16,  3/4       Циклический сдвиг 16 битов     |
|              imm8              (   слово r/m) вправо imm8 раз |
|D1 /1     ROR r/m32,1 3/4       Циклический сдвиг 32 битов     |
|                             (двойное слово r/m) вправо 1  раз |
|D3 /1     ROR r/m32,  3/4       Циклический сдвиг 32 битов     |
|              CL             (двойное слово r/m) вправо CL раз |
|C1 /1 ib  ROR r/m32,  2/4       Циклический сдвиг 32 битов     |
|              imm8           (двойное слово r/m)вправо imm8 раз|

Работа команды
(* ROL - циклический сдвиг влево *)
врем <- счетчик;
WHILE(врем <> 0)
DO
  времcf <- старший бит (r/m);
  r/m <- r/m * 2 + (времcf);
  врем <- врем - 1;
OD;
IF счетчик = 1
THEN
  IF старший бит r/m <> CF
  THEN OF <- 1;
  ELSE OF <- 0;
  FI;
ELSE OF <- неопределено;
FI;

(* ROR - циклический сдвиг вправо *)
врем <- счетчик;
WHILE(врем <> 0)
DO
  времcf <- младший бит (r/m);
  r/m <- r/m / 2 + (времcf * 2 ** width(r/m));
  врем <- врем - 1;
OD;
IF счетчик = 1
THEN

  IF (старший бит r/m) <> (бит, соседний со старшим битом r/m)
  THEN OF <- 1;
  ELSE OF <- 0;
  FI;
ELSE OF <- неопределено;
FI;

Описание
Каждая команда циклического сдвига сдвигает биты данного операнда  регистра
или памяти. Команда циклического сдвига  влево сдвигают все биты в  верхнем
направлении,  за  исключением  самого  верхнего  бита,  который переходит в
нижнюю позицию.  Команды циклического  сдвига выполняют  обратное действие:
биты сдвигаются  в нижнем  направлении, пока  самый нижний  бит не окажется
сверху.
В  случае  команд  RCL  и  RCR  флаг  CF является частью сдвигаемых данных.
Команда RCL сдвигает флаг CF в  нижний бит, а верхний бит сдвигает  во флаг
CF; команда RCR сдвигает  флаг CF в верхний  бит, а нижний бит  сдвигает во
флаг  CF.  Для  команд  ROL  и  ROR  исходное значение флага CF не является
частью результата, но  флаг CF получает  копию бита, который  был сдвинут с
одного конца на другой.
Сдвиг  повторяется   число  раз,   задаваемое  вторым   операндом,  который
представляет  собой   либо  непосредственное   значение,  либо   содержимое
регистра  CL.  Для  уменьшения  максимального  времени  выполнения  команды
процессор  i486  не  позволяет  число  циклических  сдвигов  более  31. При
попытке  сделать  счетчик  сдвигов  более  31  используются только нижние 5
битов.  8086  не  маскирует  счетчик  сдвигов.  В  виртуальном  режиме 8086
процессор i486 не маскирует счетчик сдвигов.
Флаг  OF  определен  только  для  однократных  форм команды (второй операнд
равен  1).  В  остальных  случаях  он не определен. Для сдвигов/циклических
сдвигов влево  для бита  CF после  сдвига выполняется  операция XOR с битом
результата  старшего  порядка.  Для  сдвигов/циклических сдвигов вправо для
двух  битов  старшего  порядка  результата  выполняется  операция  XOR  для
получения флага OF.

Изменяемые флаги
Флаг  OF  изменяется  только  в  случае  циклических  сдвигов на 1 бит; для
сдвигов на несколько битов флаг  OF неопределен; флаг CF содержит  значение
бита,  который  был  в  него  помещен  сдвигом;  флаги  SF,  ZF, AF и PF не
изменяются.

Исключения защищенного режима
#GP(0), если назначением является  сегмент, недоступный для записи;  #GP(0)
в случае недопустимого исполнительного  адреса операнда памяти в  сегментах
CS, DS, ES, FS или GS; #SS(0) в случае недопустимого адреса в сегменте  SS;
#PF(код сбоя)  в случае  страничного сбоя;  #AC для  невыравненной ссылки к
памяти при текущем уровне привилегированности, равном 3.

Исключения режима реальных адресов
Прерывание  13,  если  какая-либо  часть  операнда  лежит  вне пространства
исполнительных адресов от 0 до 0FFFFH.

Исключения виртуального режима 8086
Те же исключения,  что и для  режима реальных адресов:  #PF (код сбоя)  для
страничных сбоев. #AC для невыравненной ссылки к памяти при текущем  уровне
привилегированности, равном 3.


`м`д`05REP/REPE/REPZ/REPNE/REPNZ`*
        - Повторение следующей строковой команды

|Код       Команда     Число      Описание                      |
|операции              тактовых                                 |
|                      циклов                                   |
|                                                               |
|F3 6C     REP INS     16+8(E)CX,        Ввод (E)CX байтов из   |
|           r/m8,DX    pm=10+8(E)CX *1/  порта DX в ES:[(E)DI]  |
|                      30+8(E)CX *2,                            |
|                      VM=29+8(E)CX                             |
|F3 6D     REP INS     16+8(E)CX,        Ввод (E)CX слов   из   |
|          r/m16,DX    pm=10+8(E)CX *1/  порта DX в ES:[(E)DI]  |
|                      30+8(E)CX *2,                            |
|                      VM=29+8(E)CX                             |
|F3 6D     REP INS     16+8(E)CX,        Ввод (E)CX двойных слов|
|          r/m32,DX    pm=10+8(E)CX *1/ из порта DX в ES:[(E)DI]|
|                      30+8(E)CX *2,                            |
|                      VM=29+8(E)CX                             |
|F3 A4     REP MOVS    5 *3, 13 *4,      Пересылка (E)CX байтов |
|          m8,m8       12+3(E)CX *5      из [(E)SI] в ES:[(E)DI]|
|F3 A5     REP MOVS    5 *3, 13 *4,      Пересылка (E)CX слов   |
|          m16,m16     12+3(E)CX *5      из [(E)SI] в ES:[(E)DI]|
|F3 A5     REP MOVS    5 *3, 13 *4,      Пересылка (E)CX двойных|
|          m32,m32     12+3(E)CX *5      слов                   |
|                                        из [(E)SI] в ES:[(E)DI]|

|F3 6E     REP OUTS    17+5(E)CX,       Вывод (E)CX байтов из   |
|          DX,r/m8     pm=11+5(E)CX *1/ [(E)SI] в порт DX       |
|                      31+5(E)CX *2,                            |
|                      VM=30+5(E)CX                             |
|F3 6F     REP OUTS    17+5(E)CX,       Вывод (E)CX слов   из   |
|          DX,r/m16    pm=11+5(E)CX *1/ [(E)SI] в порт DX       |
|                      31+5(E)CX *2,                            |
|                      VM=30+5(E)CX                             |
|F3 6F     REP INS     17+5(E)CX,       Вывод (E)CX двойных слов|
|          DX,r/m32    pm=11+5(E)CX *1/ из [(E)SI] в порт DX    |
|                      31+5(E)CX *2,                            |
|                      VM=30+5(E)CX                             |
|F2 AC     REP LODS    5 *3,             Загрузка  (E)CX байтов |
|          m8          7 +4(E)CX *6      из [(E)SI] в AL        |
|F2 AD     REP LODS    5 *3,             Загрузка  (E)CX слов   |
|          m16         7 +4(E)CX *6      из [(E)SI] в AX        |
|F2 AD     REP LODS    5 *3,             Загрузка  (E)CX двойных|
|          m32         7 +4(E)CX *6      слов                   |
|                                        из [(E)SI] в EAX       |
|F3 AA     REP STOS    5 *3,             Заполнение(E)CX байтов |
|          m8          7 +4(E)CX *6      в ES:[(E)DI] из AL     |
|F3 AB     REP STOS    5 *3,             Заполнение(E)CX слов   |
|          m16         7 +4(E)CX *6      в ES:[(E)DI] из AX     |
|F3 AB     REP STOS    5 *3,             Заполнение(E)CX двойных|
|          m32         7 +4(E)CX *6      слов                   |
|                                        в ES:[(E)DI] из EAX    |
|F3 A6    REPE CMPS    5 *3,             Поиск несовпадающих    |
|          m8,M8       7 +7(E)CX *6      байтов                 |
|                                        в ES:[(E)DI] и [(E)SI] |
|F3 A7    REPE CMPS    5 *3,             Поиск несовпадающих    |
|          m16,m16     7 +7(E)CX *6      слов                   |
|                                        в ES:[(E)DI] и [(E)SI] |
|F3 A7    REPE CMPS    5 *3,             Поиск несовпадающих    |
|          m32,m32     7 +7(E)CX *6      двойных слов           |
|                                        в ES:[(E)DI] и [(E)SI] |
|F3 AE    REPE SCAS    5 *3,             Поиск не равных     AL |
|          m8          7 +5(E)CX *6      байтов, начиная с      |
|                                          ES:[(E)DI]           |
|F3 AF    REPE SCAS    5 *3,             Поиск не равных     AX |
|          m16         7 +5(E)CX *6      слов  , начиная с      |
|                                          ES:[(E)DI]           |
|F3 AF    REPE SCAS    5 *3,             Поиск не равных     EAX|
|          m32         7 +5(E)CX *6      двойных слов, начиная с|
|                                          ES:[(E)DI]           |
|F2 A6   REPNE CMPS    5 *3,             Поиск   совпадающих    |
|          m8,M8       7 +7(E)CX *6      байтов                 |
|                                        в ES:[(E)DI] и [(E)SI] |
|F2 A7   REPNE CMPS    5 *3,             Поиск   совпадающих    |
|          m16,m16     7 +7(E)CX *6      слов                   |
|                                        в ES:[(E)DI] и [(E)SI] |
|F2 A7   REPNE CMPS    5 *3,             Поиск   совпадающих    |
|          m32,m32     7 +7(E)CX *6      двойных слов           |
|                                        в ES:[(E)DI] и [(E)SI] |
|F2 AE   REPNE SCAS    5 *3,             Поиск    равных     AL |
|          m8          7 +5(E)CX *6      байтов, начиная с      |
|                                          ES:[(E)DI]           |
|F2 AF   REPNE SCAS    5 *3,             Поиск    равных     AX |
|          m16         7 +5(E)CX *6      слов  , начиная с      |
|                                          ES:[(E)DI]           |
|F2 AF   REPNE SCAS    5 *3,             Поиск    равных     EAX|
|          m32         7 +5(E)CX *6      двойных слов, начиная с|
|                                          ES:[(E)DI]           |

Примечания:  *1  если CPL <= IOPL
             *2  если CPL > IOPL
             *3  (E)CX = 0
             *4  (E)CX = 1
             *5  (E)CX > 1
             *6  (E)CX > 0

Работа команды

IF AddressSize = 16
THEN в качестве CountReg используется CX;
ELSE (* AddressSize = 32 *) в качестве CountReg используется ECX;
FI;
WHILE CountReg <> 0
DO
  обслуживание подвешенных прерываний (если они есть);
  выполнение примитивной строковой команды;
  CountReg <- CountReg - 1;
  IF примитивная операция это CMPB,CMPW,SCAB или SCAW
  THEN

    IF (команда REP/REPE/REPZ) AND (ZF=1)
    THEN выход из цикла WHILE
    ELSE
      IF (команда REPNZ или REPNE) AND (ZF=0)
      THEN выход из цикла WHILE;
      FI;
    FI;
  FI;
OD;


Описание
Префиксы  REP,  REPE  (повторять  пока  равно)  и  REPNE (повторять пока не
равно)  применяются   в  строковых   операциях.  Каждый   префикс  вызывает
повторение следующей за ним строковой команды столько раз, сколько  указано
счетным  регистром  или  (для  префиксов  REPE  и REPNE) пока не перестанет
удовлетворяться условие, указанное флагом ZF.
Синонимическими формами  префиксов REPE  и REPNE  являются префиксы  REPZ и
REPNZ, соответственно.
Префиксы REP  одновременно применяются  только к  одной строковой  команде.
Для  повторения   блока  команд   используйте  команду   LOOP  или   другую
конструкцию цикла.

Точное описание действий при каждой итерации следущее:
1.   Если   атрибут   размера   адреса   равен   16   битам,   в   качестве
регистра-счетчика используется CX; Если же атрибут размера адреса равен  32
битам, в качестве регистра-счетчика используется ECX;
2. Проверяется регистр CX. Если он равен 0, происходит выход из итерации  и
переход к следующей команде.
3. Уведомление о любых подвешенных прерываниях.
4. Однократное выполнение строковой операции.
5. Декремент регистра CX или ECX на единицу; флаги не модифицируются.
6. Если  строковая команда  это SCAS  или CMPS,  проверяется флаг  ZF. Если
условие  повтоения  не  выполняется,  то  происходит  выход  из  итерации и
переход к  следующей команде.  Выход из  итерации происходит,  если префикс
это REPE, а  флаг ZF равен  0 (последнее сравнение  показало не-равенство),
либо  если  префикс  это  REPNE,  а  флаг  ZF  равен 1 (последнее сравнение
показало равенство).
7. Возврат к шагу 1 для следующей итерации.
Выход из  повторяющихся команд  CMPS и  SCAS возможен,  когда либо  счетчик
отсчитал нужное число раз, либо флаг ZF показал, что условие повторения  не
выполняется.  Эти  два  случая  можно  различить,  используя для этого либо
команду JCXZ, либо условные переходы, проверяющие флаг ZF (команды JZ,  JNZ
и JNE).

Изменяемые флаги
Флаг ZF  изменяется конструкциями  REP CMPS  и REP  SCAS, как  было описано
выше.

Исключения защищенного режима
Отсутствуют

Исключения режима реальных адресов
Отсутствуют

Исключения виртуального режима 8086
Отсутствуют

Примечание
Не  все  порты  ввода/вывода  способны  поддерживать  скорость,  с  которой
выполняются команды REP INS и REP OUTS.

При использовании с не-строковой командой префикс повторения игнорируется.


`м`д`05RET`* - Возврат из процедуры

|Код       Команда     Число      Описание                      |
|операции              тактовых                                 |
|                      циклов                                   |
|                                                               |
|C3         RET        5         Возврат (ближний) в            |
|                                вызывающую процедуру           |
|CB         RET        13,pm=18  Возврат (дальний) в            |
|                                вызывающую процедуру,          |
|                                та же привилегированность      |
|CB         RET        13,pm=33  Возврат (дальний)              |
|                                меньшая привилегированность,   |
|                                стеки переключения задач       |
|C2 iw      RET imm16  5         Возврат (дальний),             |
|                                извлечение из стека imm16      |
|                                байтов параметров              |

|CA iw      RET imm16  14,pm=17  Возврат (дальний),             |
|                                та же привилегированность,     |
|                                извлечение из стека imm16      |
|                                байтов                         |
|CA iw      RET imm16  14,pm=33  Возврат (дальний),             |
|                                меньшая привилегированность,   |
|                                извлечение из стека imm16      |
|                                байтов                         |

Работа команды

IF команда = ближний RET
THEN
  IF OperandSize = 16
  THEN
    IP <- Pop();
    EIP <- EIP AND 0000FFFFH;
  ELSE (* OperandSize = 32 *)
    EIP <- Pop();
  FI;
  IF в команде задан непосредственный операнд
    THEN eSP <- eSP + imm16; FI;
FI;

IF (PE = 0 OR (PE = 1 AND VM = 1))
   (* режим реальных адресов или виртуальный режим 8086 *)
   AND команда = дальний RET
  THEN
    IF OperandSize = 16
    THEN
      IP <- Pop();
      EIP <- EIP AND 0000FFFFH;
      CS <- Pop(); (* Извлечение из стека 16 битов *)
    ELSE (* OperandSize = 32 *)
      EIP <- Pop();
      CS <- Pop(); (* извлечение из стека 32 битов, 16 битов
                      теряются *)
    FI;
    IF в команде задан непосредственный операнд
       THEN eSP <- eSP + imm16; FI;
FI;

IF (PE = 1 AND VM = 0)
   (* Защищенный режим, не виртуальный режим 8086 *)
   AND команда = дальний RET
  THEN
    IF OperandSize = 16
    THEN  третье слово в стеке должно находиться в границах стека
           иначе #SS(0);
    ELSE  второе слово в стеке должно находиться в границах стека
           иначе #SS(0);
    FI;
    RPL селектора возврата должен быть >= CPL
         ELSE #GP(селектор возврата);
    IF RPL селектора возврата = CPL
    THEN GOTO ТОТ-ЖЕ-УРОВЕНЬ;
    ELSE GOTO ВНЕШНИЙ-УРОВЕНЬ-ПРИВИЛЕГИРОВАННОСТИ;
    FI;
FI;

ТОТ-ЖЕ-УРОВЕНЬ:
  Селектор возврата должен быть не-пустым ELSE  #GP(0)
  Индекс селектора должен быть в границах его таблицы дескрипторов,
      ELSE  #GP(селектор);
  Байт AR дескриптора должен  задавать  кодовый сегмент,
      ELSE #GP(селектор);
  IF не-конформный
  THEN  DPL кодового сегмента должен быть равен CPL;
  ELSE #GP(селектор);
  FI;
  IF конформный
  THEN  DPL кодового сегмента должен быть <= CPL;
      ELSE #GP(селектор);
  FI;
  Кодовый сегмент должен Присутствовать ELSE #NP(селектор);
  Верхнее слово в стеке должно быть в границах стека ELSE #SS(0);
  IP должен быть в границах кодового сегмента ELSE #GP(0);
  IF OperandSize = 32
  THEN
    Загрузка CS:EIP из стека
    Загрузка регистра CS дескриптором
    Инкремент eSP  на  4 плюс непосредственное значение смещения,
              если оно существует

  FI;

ВНЕШНИЙ-УРОВЕНЬ-ПРИВИЛЕГИРОВАННОСТИ:
  IF OperandSize = 32
  THEN Верхние  (16+непосредственное  значение)  байтов  в  стеке
     должны быть в пределах границ стека, иначе #SS(0);
  ELSE Верхние  (8+непосредственное  значение)  байтов  в   стеке
     должны быть в пределах границ стека, иначе #SS(0);
  FI;
  Рассмотрим селектор CS возврата и связанный с ним дескриптор:
    Селектор должен быть не-пустым, иначе #GP(0);
    Индекс селектора должен быть в границах его таблицы дескрипторов,
          ELSE #GP(селектор);
    Байт AR дескриптора должен  задавать  кодовый сегмент,
          ELSE  #GP(селектор);
    IF не-конформный
    THEN DPL  кодового  сегмента  должен  быть  =  RPL  селектора
          возврата; ELSE #GP(селектор);
    FI;
    IF конформный
    THEN DPL  кодового  сегмента  должен   быть <= RPL селектора
        возврата, ELSE #GP(селектор);
    FI;
    Сегмент должен присутствовать, иначе #NP(селектор);

  Рассмотрим селектор SS возврата и связанный с ним дескриптор:
    Селектор должен быть не-пустым, иначе #GP(0);
    Индекс селектора должен быть в границах его таблицы дескрипторов,
          ELSE #GP(селектор);
    RPL селектора должен быть равен RPL селектора CS возврата
          ELSE #GP(селектор);
    Байт AR дескриптора  должен  задавать сегмент данных, доступный
       для записи, ELSE #GP(селектор);
    DPL дескриптора должен быть = RPL селектора CS возврата;
        ELSE #GP(селектор);
    Сегмент должен присутствовать, иначе #NP(селектор);
    Указатель команд должен быть в пределах границ кодового сегмента,
        ELSE #GP(0);
    Установка CPL равным RPL селектора CS возврата;
    IF OperandMode = 32
    THEN
      Загрузка CS:EIP из стека;
      Установка RPL CS равным CPL;
      Инкремент eSP на 8 плюс непосредственное значение смещения,
         если оно существует;
      Загрузка SS:eSP из стека;
    ELSE  (* OperandMode *)
      Загрузка CS:IP из стека;
      Установка RPL CS равным CPL;
      Инкремент eSP на 4 плюс непосредственное значение смещения,
         если оно существует;
      Загрузка SS:eSP из стека;
    FI;
    Загрузка регистра CS дескриптором CS возврата;
    Загрузка регистра SS дескриптором SS возврата;
    FOR каждого из ES, FS, GS и DS
    DO;
      IF текущее  значение  регистра  недостоверно  для  внешнего
           уровня, регистр устанавливается пустым
           (селектор <- AR <- 0);
      Чтобы быть   достоверным,   установка    регистра    должна
           удовлетворять следующим свойствам:
        Индекс селектора должен быть в границах его таблицы
           дескрипторов;
        Байт AR дескриптора  должен  задавать  сегмент  данных  или
           кодовый сегмент, доступный для чтения;
        IF это сегмент данных или не-конформный кодовый сегмент,
          THEN DPL должен быть >= CPL, или DPL должен быть >= RPL;
        FI;
  OD;


Описание
Команда RET  передает управление  на адрес  возврата, находящийся  в стеке.
Адрес  обычно  помещается  в  стек  командой  CALL, а возврат выполняется к
команде, расположенной после команды CALL.
Необязательный  числовой  параметр  команды  RET  определяет  число  байтов
(operandMode  =  16)  или  слов  (OperandMode  =  32),  которые должны быть
освобождены после извлечения из стека адреса возврата. Эти элементы  обычно
используются как входные параметры вызываемой процедуры).
Для  внутрисегментного  (ближнего)  возврата  адрес  в  стеке  это смещение
сегмента, извлекаемое из стека и помещаемое в указатель команд. Регистр  CS
не изменяется.  Для межсегментного  (дальнего) возврата  адрес в  стеке это

длинный  указатель.  Сначала  из  стека  извлекается  смещение,  а  за  ним
селектор.
В реальном режиме регистры CS  и IP загружаются прямо. В  защищенном режиме
межсегментный   возврат   заставляет   процессор   проверить    дескриптор,
адресуемый  селектором  возврата.  Байт  AR  дескриптора  должен обозначать
кодовый сегмент, равный или  менее привилегированный (с большим  или равным
числовым  номером  уровня  привилегированности),  нежели  текущий   уровень
привилегированности.  Возврат   на  меньший   уровень   привилегированности
вызывает  перезагрузку   стека  из   значения,  записанного   после   блока
параметров.
Во  время  меж-уровневой  передачи  управления  команда  RET может очистить
регистры DS, ES, FS и GS. Если эти регистры относятся к сегментам,  которые
не  могут  быть  использованы  на  новом  уровне  привилегированности,  они
очищаются,  чтобы  предупредить  неразрешенный   доступ  с  нового   уровня
привилегированности.

Изменяемые флаги
Отсутствуют

Исключения защищенного режима
#GP, #NP или  #SS, как указано  выше в разделе  "Работа команды"; #  PF(код
сбоя) в случае страничного сбоя;

Исключения режима реальных адресов
Прерывание 13, если какая-либо  часть извлекаемого из стека  операнда лежит
за адресом 0FFFFH.

Исключения виртуального режима 8086
Те же исключения,  что и для  режима реальных адресов:  #PF (код сбоя)  для
страничных сбоев.



`м`д`05SAHF`* - Запись AH во флаги

|Код       Команда     Число      Описание                      |
|операции              тактовых                                 |
|                      циклов                                   |
|                                                               |
|9E        SAHF         2        Запись AH во флаги             |
|                                SF ZF xx AF xx PF xx CF        |

Работа команды

SF:ZF:xx:AF:xx:PF:xx:CF <- AH;

Описание
Команда SAHF загружает  флаги SF, ZF,  AF, PF и  CF значениями из  регистра
AH, битами 7,6,4,2 и 0, соответственно.

Изменяемые флаги
Флаги SF, ZF, AF, PF и CF загружаются значениями из регистра AH.

Исключения защищенного режима
Отсутствуют

Исключения режима реальных адресов
Отсутствуют

Исключения виртуального режима 8086
Отсутствуют


`м`д`05SAL/SAR/SHL/SHR`* - Команды сдвига

|Код       Команда     Число      Описание                      |
|операции              тактовых                                 |
|                      циклов                                   |
|                                                               |
|D0 /4     SAL r/m8,1     3/4    Умножение на 2 один раз        |
|                                байта r/m                      |
|D2 /4     SAL r/m8,CL    3/4    Умножение на 2 CL раз          |
|                                байта r/m                      |
|C0 /4 ib  SAL r/m8,imm8  2/4    Умножение на 2 imm8 раз        |
|                                байта r/m                      |
|D1 /4     SAL r/m16,1    3/4    Умножение на 2 один раз        |
|                                слова r/m                      |
|D3 /4     SAL r/m16,CL   3/4    Умножение на 2 CL раз          |
|                                слова r/m                      |
|C1 /4 ib  SAL r/m16,imm8 2/4    Умножение на 2 imm8 раз        |
|                                слова r/m                      |
|D1 /4     SAL r/m32,1    3/4    Умножение на 2 один раз        |
|                                двойного слова r/m             |

|D3 /4     SAL r/m32,CL   3/4    Умножение на 2 CL раз          |
|                                двойного слова r/m             |
|C1 /4 ib  SAL r/m32,imm8 2/4    Умножение на 2 imm8 раз        |
|                                двойного слова r/m             |
|                                                 1             |
|D0 /7     SAR r/m8,1     3/4    Деление со знаком на 2 один раз|
|                                байта r/m                      |
|                                                 1             |
|D2 /7     SAR r/m8,CL    3/4    Деление со знаком на 2 CL раз  |
|                                байта r/m                      |
|                                                 1             |
|C0 /7 ib  SAR r/m8,imm8  2/4    Деление со знаком на 2 imm8 раз|
|                                байта r/m                      |
|                                                 1             |
|D1 /7     SAR r/m16,1    3/4    Деление со знаком на 2 один раз|
|                                слова r/m                      |
|                                                 1             |
|D3 /7     SAR r/m16,CL   3/4    Деление со знаком на 2 CL раз  |
|                                слова r/m                      |
|                                                 1             |
|C1 /7 ib  SAR r/m16,imm8 2/4    Деление со знаком на 2 imm8 раз|
|                                слова r/m                      |
|                                                 1             |
|D1 /7     SAR r/m32,1    3/4    Деление со знаком на 2 один раз|
|                                двойного слова r/m             |
|                                                 1             |
|D3 /7     SAR r/m32,CL   3/4    Деление со знаком на 2 CL раз  |
|                                двойного слова r/m             |
|                                                 1             |
|C1 /7 ib  SAR r/m32,imm8 2/4    Деление со знаком на 2 imm8 раз|
|                                двойного слова r/m             |
|D0 /4     SHL r/m8,1     3/4    Умножение на 2 один раз        |
|                                байта r/m                      |
|D2 /4     SHL r/m8,CL    3/4    Умножение на 2 CL раз          |
|                                байта r/m                      |
|C0 /4 ib  SHL r/m8,imm8  2/4    Умножение на 2 imm8 раз        |
|                                байта r/m                      |
|D1 /4     SHL r/m16,1    3/4    Умножение на 2 один раз        |
|                                слова r/m                      |
|D3 /4     SHL r/m16,CL   3/4    Умножение на 2 CL раз          |
|                                слова r/m                      |
|C1 /4 ib  SHL r/m16,imm8 2/4    Умножение на 2 imm8 раз        |
|                                слова r/m                      |
|D1 /4     SHL r/m32,1    3/4    Умножение на 2 один раз        |
|                                двойного слова r/m             |
|D3 /4     SHL r/m32,CL   3/4    Умножение на 2 CL раз          |
|                                двойного слова r/m             |
|C1 /4 ib  SHL r/m32,imm8 2/4    Умножение на 2 imm8 раз        |
|                                двойного слова r/m             |
|D0 /5     SHR r/m8,1     3/4    Деление без знака на 2 один раз|
|                                байта r/m                      |
|D2 /5     SHR r/m8,CL    3/4    Деление без знака на 2 CL раз  |
|                                байта r/m                      |
|C0 /5 ib  SHR r/m8,imm8  2/4    Деление без знака на 2 imm8 раз|
|                                байта r/m                      |
|D1 /5     SHR r/m16,1    3/4    Деление без знака на 2 один раз|
|                                слова r/m                      |
|D3 /5     SHR r/m16,CL   3/4    Деление без знака на 2 CL раз  |
|                                слова r/m                      |
|C1 /5 ib  SHR r/m16,imm8 2/4    Деление без знака на 2 imm8 раз|
|                                слова r/m                      |
|D1 /5     SHR r/m32,1    3/4    Деление без знака на 2 один раз|
|                                двойного слова r/m             |
|D3 /5     SHR r/m32,CL   3/4    Деление без знака на 2 CL раз  |
|                                двойного слова r/m             |
|C1 /5 ib  SHR r/m32,imm8 2/4    Деление без знака на 2 imm8 раз|
|                                двойного слова r/m             |
Деление не аналогично IDIV;  округление направлено в сторону  отрицательной
бесконечности.

Работа команды
(* Счетчик - это второй параметр *)
(врем) <- счетчик;
WHILE (врем <> 0)
DO
  IF команда SAL или SHL
  THEN CF <- старший бит r/m;
  FI;
  IF команда SAR или SHR
  THEN CF <- младший бит r/m;
  FI;
  IF команда SAL или SHL
  THEN r/m <- r/m * 2;

  FI;
  IF команда SAR
  THEN r/m <- r/m / 2 (* Деление со знаком, округление в сторону
                         отрицательной неопределенности *);
  FI;
  IF команда SHR
  THEN r/m <- r/m / 2 (* Деление без знака *);
  FI;
  врем <- врем - 1;
OD;
(* Определение переполнения для различных команд *)
IF счетчик = 1
THEN
  IF команда SAL или SHL
  THEN OF <- старший бит r/m <> (CF);
  FI;
  IF команда SAR
  THEN OF <- 0;
  FI;
  IF команда SHR
  THEN OF <- старший бит операнда;
  FI;
ELSE OF <- неопределен;
FI;

Описание
Команда SAL (или ее синоним SHL) сдвигает биты операнда в верхнюю  сторону.
Старший бит сдвигается во флаг CF, а младший бит очищается.
Команды  SAR  и  SHR  сдвигают  биты  операнда  вниз.  Младший бит операнда
сдвигается во  флаг CF.  Действие этих  команд эквивалентно  делению на  2.
Команда  SAR  выполняет   деление  со  знаком   с  округлением  в   сторону
отрицательной неопределенности  (в отличие  от команды  IDIV); старший  бит
остается без изменений.  Команда SHR выполняет  деление без знака;  старший
бит очищается.
Сдвиг   повторяется   число   раз,   заданное   вторым  операндом,  который
представляет  собой   либо  непосредственное   значение,  либо   содержимое
регистра  CL.  Для  уменьшения  максимального  времени выполнения процессор
i486 не позволяет  значения счетчика сдвигов,  превышающие 31. При  попытке
выполнить сдвиг  более чем  31 раз  используются только  младшие пять битов
счетчика сдвигов. (8086 использует как счетчик числа сдвигов все 8 битов).
Флаг  OF  изменяется  только  при  использовании  форм  команд, выполняющих
единичный  сдвиг.  Для  сдвига  влево  флаг  OF очищается, если старший бит
ответа тот  же, что  и результирующее  значение флага  CF (т.е. два старших
бита исходного операнда были одинаковы); флаг OF устанавливается, если  они
различны.  В  случае  команды  SAR  флаг  OF  очищается  для всех единичных
сдвигов. Команда SHR устанавливает  флаг OF равным старшему  биту исходного
операнда.

Изменяемые флаги
Флаг  OF  изменяется  для  единичных  сдвигов;  флаг  OF  для множественных
сдвигов не определен; флаги CF, ZF, PF и SF устанавливаются в  соответствии
с результатом.

Исключения защищенного режима
#GP(0), если назначением является  сегмент, недоступный для записи;  #GP(0)
в случае недопустимого исполнительного  адреса операнда памяти в  сегментах
CS, DS, ES, FS или GS; #SS(0) в случае недопустимого адреса в сегменте  SS;
#PF(код сбоя)  в случае  страничного сбоя;  #AC для  невыравненной ссылки к
памяти при текущем уровне привилегированности, равном 3.

Исключения режима реальных адресов
Прерывание  13,  если  какая-либо  часть  операнда  лежит  вне пространства
исполнительных адресов от 0 до 0FFFFH.

Исключения виртуального режима 8086
Те же исключения,  что и для  режима реальных адресов:  #PF (код сбоя)  для
страничных сбоев. #AC для невыравненной ссылки к памяти при текущем  уровне
привилегированности, равном 3.


`м`д`05SBB`* - Целочисленное вычитание с заемом

|Код       Команда     Число      Описание                      |
|операции              тактовых                                 |
|                      циклов                                   |
|                                                               |
|1C ib     SBB AL,imm8      1    Вычитание с заемом непосредст- |
|                                венного байта из AL            |
|1D iw     SBB AX,imm16     1    Вычитание с заемом непосредст- |
|                                венного слова из AX            |
|1D id     SBB EAX,imm32    1    Вычитание с заемом непосредст- |
|                                венного двойного слова из EAX  |
|80 /3 ib  SBB r/m8,imm8    1/3  Вычитание с заемом непосредст- |
|                                венного байта из байта r/m     |

|81 /3 iw  SBB r/m16,imm16  1/3  Вычитание с заемом непосредст- |
|                                венного слова из слова r/m     |
|81 /3 id  SBB r/m32,imm32  1/3  Вычитание с заемом непосредст- |
|                                венного двойного слова из      |
|                                двойного слова r/m             |
|83 /3 ib  SBB r/m16,imm8   1/3  Вычитание с заемом непосредст- |
|                                венного расширенного знаком    |
|                                байта из слова r/m             |
|83 /3 ib  SBB r/m32,imm8   1/3  Вычитание с заемом непосредст- |
|                                венного расширенного знаком    |
|                                байта из двойного слова r/m    |
|18 /r     SBB r/m8,r8      1/3  Вычитание с заемом байтового   |
|                                регистра из байта r/m          |
|19 /r     SBB r/m16,r16    1/3  Вычитание с заемом регистра -  |
|                                слова из слова r/m             |
|19 /r     SBB r/m32,r32    1/3  Вычитание с заемом регистра -  |
|                                двойного слова из              |
|                                двойного слова r/m             |
|1A /r     SBB r8,r/m8      1/2  Вычитание с заемом из байтового|
|                                регистра байта r/m             |
|1B /r     SBB r16,r/m16    1/2  Вычитание с заемом из регистра-|
|                                слова слова r/m                |
|1B /r     SBB r32,r/m32    1/2  Вычитание с заемом из регистра-|
|                                двойного слова                 |
|                                двойного слова r/m             |

Работа команды

IF SRC это байт, а DEST это слово или двойное слово
THEN DEST <- DEST - (SignExtend(SRC) + CF)
ELSE DEST <- DEST - (SRC + CF);


Описание
Команда  SBB  складывает  второй  операнд  (SRC)  с  флагом  CF  и вычитает
результат  из  первого  операнда  (DEST). Результат вычитания присваивается
первому операнду (DEST), и флаги устанавливаются соответствующим образом.
При вычитании  из операнда-слова  непосредственного байтового  значения это
непосредственное значение сначала расширяется знаком.

Изменяемые флаги
Флаги OF, SF, ZF, AF, PF и CF устанавливаются в соответствии с результатом.

Исключения защищенного режима
#GP(0), если назначением является  сегмент, недоступный для записи;  #GP(0)
в случае недопустимого исполнительного  адреса операнда памяти в  сегментах
CS, DS, ES, FS или GS; #SS(0) в случае недопустимого адреса в сегменте  SS;
#PF(код сбоя)  в случае  страничного сбоя;  #AC для  невыравненной ссылки к
памяти при текущем уровне привилегированности, равном 3.

Исключения режима реальных адресов
Прерывание  13,  если  какая-либо  часть  операнда  лежит  вне пространства
исполнительных адресов от 0 до 0FFFFH.

Исключения виртуального режима 8086
Те же исключения,  что и для  режима реальных адресов:  #PF (код сбоя)  для
страничных сбоев. #AC для невыравненной ссылки к памяти при текущем  уровне
привилегированности, равном 3.


`м`д`05SCAS/SCASB/SCASW/SCASD`*
                - Сравнение строковых данных

|Код       Команда     Число      Описание                      |
|операции              тактовых                                 |
|                      циклов                                   |
|                                                               |
|AE        SCAS m8          6    Сравнение байтов AL-ES:[DI],   |
|                                обновление (E)DI               |
|AF        SCAS m16         6    Сравнение слов   AX-ES:[DI],   |
|                                обновление (E)DI               |
|AF        SCAS m32         6    Сравнение двойных слов         |
|                                EAX-ES:[DI], обновление (E)DI  |
|AE        SCASB            6    Сравнение байтов AL-ES:[DI],   |
|                                обновление (E)DI               |
|AF        SCASW            6    Сравнение слов   AX-ES:[DI],   |
|                                обновление (E)DI               |
|AF        SCASD            6    Сравнение двойных слов         |
|                                EAX-ES:[DI], обновление (E)DI  |

Работа команды

IF AddressSize = 16
THEN использование DI в качестве индекса-назначения;
ELSE (* AddressSize = 32 *) использование EDI в качестве индекса-
        назначения;
FI;
IF байтовый тип команды
THEN
  AL - [индекс-назначения]; (* Сравнение байта в AL и назначения
                               *)
  IF DF = 0 THEN IncDec <- 1 ELSE IncDec <- -1; FI;
ELSE
  IF OperandSize = 16
  THEN
    AX - [индекс-назначения]; (* Сравнение слова в AL
                                  и назначения *)
    IF DF = 0 THEN IncDec <- 2 ELSE IncDec <- -2; FI;
  ELSE (* OperandSize = 32 *)
    EAX - [индекс-назначения]; (* Сравнение двойного слова в EAX
                                   и назначения *)
    IF DF = 0 THEN IncDec <- 4 ELSE IncDec <- -4; FI;
  FI;
FI;
индекс-назначения = индекс-назначения + IncDec;


Описание
Команда  SCAS  вычитает  байт   или  слово  памяти,  задаваемое   регистром
назначения,  из  регистров  AL,   AX  или  EAX.  Результат   отбрасывается;
происходит  только  установка  флагов.   Операнд  должен  адресоваться   из
регистра ES; переопределение сегмента не допускается.
Если атрибут  размера адреса  команды равен  16 битам,  в качестве регистра
назначения  используется  регистр  DI;  в  противном случае атрибут размера
адреса равен 16 битам, и используется регистр EDI.
Адрес  сравниваемых  данных  памяти  определяется  исключительно содержимым
регистра  назначения,  а  не  операндом  команды SCAS. Операнд удостоверяет
адресуемость  сегмента  ES  и  определяет  тип  данных.  Перед  выполнением
команды SCAS  следует загрузить  в регистр  DI или  EDI правильное значение
индекса.
После  того,  как  сравнение  выполнено,  регистр  назначения автоматически
обновляется. Если флаг  направления равен 0  (была выполнена команда  CLD),
происходит инкремент  регистра назначения;  если флаг  направления равен  1
(была  выполнена  команда  STD),  происходит декремент регистра назначения.
При сравнении байтов  инкремент или декремент  равен 1; при  сравнении слов
инкремент или декремент равен 2;  При сравнении двойных слов инкремент  или
декремент равен 4.
Команды SCASB, SCASW и SCASD являются синонимами команды SCAS,  работающими
с  байтом,  словом   и  двойным  словом,   соответственно,  не   требующими
операндов. Их проще программировать,  но они не обеспечивают  проверки типа
или сегмента.
Команде  SCAS  может  предшествовать  префикс  REPE  или REPNE для поиска в
блоке CX или ECX байтов или слов. Подробности см. в описании команды REP.

Изменяемые флаги
Флаги  OF,  SF,  ZF,  AF,  PF   и  CF  устанавливаются  в  соответствии   с
результатом.

Исключения защищенного режима
#GP(0)  в  случае  недопустимого  исполнительного  адреса операнда памяти в
сегментах CS, DS,  ES, FS или  GS; #SS(0) в  случае недопустимого адреса  в
сегменте  SS;   #PF(код  сбоя)   в  случае   страничного  сбоя;   #AC   для
невыравненной  ссылки  к  памяти  при  текущем  уровне привилегированности,
равном 3.

Исключения режима реальных адресов
Прерывание  13,  если  какая-либо  часть  операнда  лежит  вне пространства
исполнительных адресов от 0 до 0FFFFH.

Исключения виртуального режима 8086
Те же исключения,  что и для  режима реальных адресов:  #PF (код сбоя)  для
страничных сбоев. #AC для невыравненной ссылки к памяти при текущем  уровне
привилегированности, равном 3.

`м`д`05SETcc`* - Установка байта по условию

|Код       Команда     Число      Описание                      |
|операции              тактовых                                 |
|                      циклов                                   |
|                                                               |
|0F 97    SETA r/m8    4/3       Установка байта, если выше     |
|                                (CF = 0 и ZF = 0)              |
|0F 93    SETAE r/m8   4/3       Установка байта, если выше     |
|                                или равно (CF = 0)             |
|0F 92    SETB r/m8    4/3       Установка байта, если ниже     |
|                                (CF = 1)                       |
|0F 96    SETBE r/m8   4/3       Установка байта, если ниже     |
|                                или равно (CF = 1 или ZF = 1)  |
|0F 92    SETC r/m8    4/3       Установка байта, если перенос  |
|                                (CF = 1)                       |
|0F 94    SETE r/m8    4/3       Установка байта, если равно    |
|                                (ZF = 1)                       |
|0F 9F    SETG r/m8    4/3       Установка байта, если больше   |
|                                (ZF = 0 или SF = OF)           |
|0F 9D    SETGE r/m8   4/3       Установка байта, если больше   |
|                                или равно (SF = OF)            |
|0F 9C    SETL r/m8    4/3       Установка байта, если меньше   |
|                                (SF <> OF)                     |
|0F 9E    SETLE r/m8   4/3       Установка байта, если меньше   |
|                                или равно (ZF=1 или SF <> OF)  |
|0F 96    SETNA r/m8   4/3       Установка байта, если не выше  |
|                                (CF = 1)                       |
|0F 92    SETNAE r/m8  4/3       Установка байта, если не выше  |
|                                или равно (CF = 1)             |
|0F 93    SETNB r/m8   4/3       Установка байта, если не ниже  |
|                                (CF = 0)                       |
|0F 97    SETNBE r/m8  4/3       Установка байта, если не ниже  |
|                                или равно (CF=0 и ZF=0)        |
|0F 93    SETNC r/m8   4/3       Установка байта, если нет      |
|                                переноса (CF = 0)              |
|0F 95    SETNE r/m8   4/3       Установка байта, если не равно |
|                                (ZF = 0)                       |
|0F 9E    SETNG r/m8   4/3       Установка байта, если не       |
|                                больше (ZF = 1 или SF <> OF)   |
|0F 9C    SETNGE r/m8  4/3       Установка байта, если не       |
|                                больше или равно (SF <> OF)    |
|0F 9D    SETNL r/m8   4/3       Установка байта, если не       |
|                                меньше (SF = OF)               |
|0F 9F    SETNLE r/m8  4/3       Установка байта, если не мень- |
|                                ше или равно (ZF=0 и SF=OF)    |
|0F 91    SETNO r/m8   4/3       Установка байта, если нет      |
|                                переполнения (OF=0)            |
|0F 9B    SETNP r/m8   4/3       Установка байта, если нет кон- |
|                                троля четности (PF = 0)        |
|0F 99    SETNS r/m8   4/3       Установка байта, если нет      |
|                                знака (SF = 0)                 |
|0F 95    SETNZ r/m8   4/3       Установка байта, если нет нуля |
|                                (ZF = 0)                       |
|0F 90    SETO r/m8    4/3       Установка байта, если          |
|                                переполнение (OF = 1)          |
|0F 9A    SETP r/m8    4/3       Установка байта, если контроль |
|                                четности (PF = 1)              |
|0F 9A    SETPE r/m8   4/3       Установка байта, если контроль |
|                                на проверку четности (PF = 1)  |
|0F 9B    SETPO r/m8   4/3       Установка байта, если контроль |
|                                на проверку нечетности (PF = 0)|
|0F 98    SETS r/m8    4/3       Установка байта, если знак     |
|                                (SF = 1)                       |
|0F 94    SETZ r/m8    4/3       Установка байта, если ноль     |
|                                (ZF = 1)                       |

Работа команды
IF условие THEN r/m8 <- 1 ELSE r/m8 <- 0; FI;

Описание
Команда SETcc сохраняет байт  в приемнике, заданном исполнительным  адресом
или регистром, если условие  удовлетворяется, либо записывает туда  0, если
условие не удовлетворяется.

Изменяемые флаги
Отсутствуют

Исключения защищенного режима
#GP(0), если назначением является  сегмент, недоступный для записи;  #GP(0)
в случае недопустимого исполнительного  адреса операнда памяти в  сегментах
CS, DS, ES, FS или GS; #SS(0) в случае недопустимого адреса в сегменте  SS;
#PF(код сбоя)  в случае  страничного сбоя;  #AC для  невыравненной ссылки к
памяти при текущем уровне привилегированности, равном 3.

Исключения режима реальных адресов
Прерывание  13,  если  какая-либо  часть  операнда  лежит  вне пространства
исполнительных адресов от 0 до 0FFFFH.

Исключения виртуального режима 8086
Те же исключения,  что и для  режима реальных адресов:  #PF (код сбоя)  для
страничных сбоев. #AC для невыравненной ссылки к памяти при текущем  уровне
привилегированности, равном 3.


`м`д`05SGDT/SIDT`*
 - Сохранение регистра таблицы дескрипторов  глобальной/прерываний

|Код       Команда     Число      Описание                      |
|операции              тактовых                                 |
|                      циклов                                   |
|                                                               |
|0F 01 /0  SGDT m      10        Сохранение GDTR в m            |
|0F 01 /1  SIDT m      10        Сохранение IDTR в m            |

Работа команды
DEST <- 48-битовое содержимое базы/границы регистра;

Описание
Команды SGDT  и SIDT  копируют содержимое  регистов дескрипторных  таблиц в
шесть байтов  памяти, задаваемых  операндом. Поле  границы (LIMIT) регистра
присваивается  первому  слову  по  исполнительному  адресу.  Если   атрибут
размера  операнда  команды  равен  32  битам,  то  следующищим  трем байтам
присваивается  поле  базы  (BASE)  регистра,  а  четвертый байт заполняется
нулем.  В  противном  случае  атрибут  размера  операнда  равен 16 битам, и
следующим четырем байтам присваивается 32-разрядное поле базы регистра.
Команды  SGDT   и  SIDT   используются  только   операционным   программным
обеспечением, в прикладных программах они не используются.

Изменяемые флаги
Отсутствуют

Исключения защищенного режима
Прерывание  6,  если  операндом  назначения  является регистр; #GP(0), если
назначением  является  сегмент,  недоступный  для  записи;  #GP(0) в случае
недопустимого исполнительного  адреса операнда  памяти в  сегментах CS, DS,
ES, FS или GS; #SS(0) в случае недопустимого адреса в сегменте SS;  #PF(код
сбоя) в случае страничного сбоя; #AC для невыравненной ссылки к памяти  при
текущем уровне привилегированности, равном 3.

Исключения режима реальных адресов
Прерывание 6,  если операндом  назначения является  регистр; Прерывание 13,
если  какая-либо  часть  операнда  лежит  вне  пространства  исполнительных
адресов от 0 до 0FFFFH.

Исключения виртуального режима 8086
Те же исключения,  что и для  режима реальных адресов:  #PF (код сбоя)  для
страничных сбоев. #AC для невыравненной ссылки к памяти при текущем  уровне
привилегированности, равном 3.

Замечание по совместимости
16-разрядные формы команд SGDT и SIDT совместимы с процессором 80286,  если
не выполняются ссылки  к значению в  старших восьми битах.  Процессор 80286
записывает в эти старшие биты единицы, тогда как процессоры 386 DX и  i486,
если  атрибут  размера  операнда  равен  16  битам,  записывают  туда  0. В
Справочном  руководстве  программиста  по  iAPX  286  эти  биты  заданы как
устанавливаемые командами SGDT и SIDT в неопределенное состояние.


`м`д`05SHLD`* - Сдвиг влево двойной точности

|Код       Команда     Число      Описание                      |
|операции              тактовых                                 |
|                      циклов                                   |
|                                                               |
|0F A4  SHLD r/m16,r16,imm8  2/3 r/m16 принимает результат SHL  |
|                                для r/m16, конкатенированного  |
|                                с r16                          |
|0F A4  SHLD r/m32,r32,imm8  2/3 r/m32 принимает результат SHL  |
|                                для r/m32, конкатенированного  |
|                                с r32                          |
|0F A5  SHLD r/m16,r16,CL    3/4 r/m16 принимает результат SHL  |
|                                для r/m16, конкатенированного  |
|                                с r16                          |
|0F A5  SHLD r/m32,r32,CL    3/4 r/m32 принимает результат SHL  |
|                                для r/m32, конкатенированного  |
|                                с r32                          |

Работа команды

(* счетчик - это  целое  без  знака,  соответствующее  последнему
операнду команды,  либо  непосредственно  заданному  байту,  либо
байту в регистре CL *)
ShiftAmt <- счетчик MOD 32;
inBits <- регистр; (* Разрешены перекрывающиеся операнды *)
IF ShiftAmt = 0
THEN нет операции (* no operation *)
ELSE
  IF ShiftAmt >= OperandSize
  THEN (* Неверные параметры *)
    r/m <- не определен;
    CF, OF, SF, ZF, AF, PF <- не определены;
  ELSE (* Выполнение сдвига *)
    CF <- BIT[База, OperandSize - ShiftAmt];
      (* Последний бит, сдвинутый на выходе из операнда *)
    FOR i <- OperandSize - 1 DOWNTO ShiftAmt
    DO
      BIT[База, i] <- BIT[База, i - ShiftAmt];
    OD;
    FOR i <- ShiftAmt - 1 DOWNTO 0
    DO
      BIT[База, i] <- BIT[inBits, i - ShiftAmt + OperandSize];
    OD;
    Установка SF, ZF, PF   (r/m);
    (* SF,ZF и PF устанавливаются согласно значению результата *)
    AF <- не определен.
  FI;
FI;


Описание
Команда SHLD  выполняет сдвиг  влево первого  операнда, определяемого полем
r/m, на число битов, задаваемое операндом - счетчиком. Второй операнд  (r16
или r32) обеспечивает  биты, в которые  происходит сдвиг справа  (начиная с
0).  Результат  записывается  обратно  в  операнд  r/m.  Регистр   остается
неизмененным.
Операнд -  счетчик задается  либо непосредственным  байтом, либо содержимым
регистра CL. Эти операнды берутся по  модулю 32, задавая число от 0  до 31,
на  которое  происходит  сдвиг.  Поскольку  сдвигаемые  биты обеспечиваются
заданными  регистрами,  эту  операцию  полезно  использовать  для   сдвигов
операндов  повышенной  точности  (64  бита  и  более).  Флаги  SF,  ZF и PF
устанавливаются в  соответствии с  результатом. Флаг  CF устанавливаются  в
значение последнего  бита, удаленного  сдвигом из  операнда. Флаги  OF и AF
неопределены.

Изменяемые флаги
Флаги SF,  ZF и  PF устанавливаются  в соответствии  с результатом; флаг CF
устанавливаются  в   значение  последнего   бита,  удаленного   сдвигом  из
операнда; после сдвига на одну  позицию бита флаг OF устанавливается,  если
произошло изменение знака,  в противном случае  он очищается; после  сдвига
более  чем  на   одну  битовую  позицию   флаг  OF  неопределен;   флаг  AF
неопределен, за исключением  случая, когда счетчик  сдвига был равен  нулю,
что не влияет на состояния флагов.

Исключения защищенного режима
#GP(0), если назначением является  сегмент, недоступный для записи;  #GP(0)
в случае недопустимого исполнительного  адреса операнда памяти в  сегментах
CS, DS, ES, FS или GS; #SS(0) в случае недопустимого адреса в сегменте  SS;
#PF(код сбоя)  в случае  страничного сбоя;  #AC для  невыравненной ссылки к
памяти при текущем уровне привилегированности, равном 3.
Прерывание  13,  если  какая-либо  часть  операнда  лежит  вне пространства
исполнительных адресов от 0 до 0FFFFH.

Исключения виртуального режима 8086
Те же исключения,  что и для  режима реальных адресов:  #PF (код сбоя)  для
страничных сбоев. #AC для невыравненной ссылки к памяти при текущем  уровне
привилегированности, равном 3.


`м`д`05SHRD`* - Сдвиг вправо двойной точности

|Код       Команда     Число      Описание                      |
|операции              тактовых                                 |
|                      циклов                                   |
|                                                               |
|0F AC  SHRD r/m16,r16,imm8  2/3 r/m16 принимает результат SRL  |
|                                для r/m16, конкатенированного  |
|                                с r16                          |
|0F AC  SHRD r/m32,r32,imm8  2/3 r/m32 принимает результат SHR  |
|                                для r/m32, конкатенированного  |
|                                с r32                          |

|0F AD  SHRD r/m16,r16,CL    3/4 r/m16 принимает результат SHR  |
|                                для r/m16, конкатенированного  |
|                                с r16                          |
|0F AD  SHRD r/m32,r32,CL    3/4 r/m32 принимает результат SHR  |
|                                для r/m32, конкатенированного  |
|                                с r32                          |


Работа команды

(* счетчик - это  целое  без  знака,  соответствующее  последнему
операнду команды,  либо  непосредственно  заданному  байту,  либо
байту в регистре CL *)
ShiftAmt <- счетчик MOD 32;
inBits <- регистр; (* Разрешены перекрывающиеся операнды *)
IF ShiftAmt = 0
THEN нет операции (* no operation *)
ELSE
  IF ShiftAmt >= OperandSize
  THEN (* Неверные параметры *)
    r/m <- не определен;
    CF, OF, SF, ZF, AF, PF <- не определены;
  ELSE (* Выполнение сдвига *)
    CF <- BIT[r/m, ShiftAmt - 1];
      (* Последний бит, сдвинутый на выходе из операнда *)
    FOR i <- 0 TO OperandSize - 1 - ShiftAmt
    DO
      BIT[r/m, i] <- BIT[r/m, i - ShiftAmt];
    OD;
    FOR i <- OperandSize - ShiftAmt TO OperandSize - 1
    DO
      BIT[r/m, i] <- BIT[inBits, i + ShiftAmt - OperandSize];
    OD;
    Установка SF, ZF, PF   (r/m);
    (* SF,ZF и PF устанавливаются согласно значению результата *)
    AF <- не определен.
  FI;
FI;

Описание
Команда SHRD выполняет сдвиг  вправо первого операнда, определяемого  полем
r/m, на число битов, задаваемое операндом - счетчиком. Второй операнд  (r16
или r32)  обеспечивает биты,  в которые  происходит сдвиг  слева (начиная с
31).  Результат  записывается  обратно  в  операнд  r/m.  Регистр  остается
неизмененным.
Операнд -  счетчик задается  либо непосредственным  байтом, либо содержимым
регистра CL. Эти операнды берутся по  модулю 32, задавая число от 0  до 31,
на  которое  происходит  сдвиг.  Поскольку  сдвигаемые  биты обеспечиваются
заданными  регистрами,  эту  операцию  полезно  использовать  для   сдвигов
операндов  повышенной  точности  (64  бита  и  более).  Флаги  SF,  ZF и PF
устанавливаются в  соответствии с  результатом. Флаг  CF устанавливаются  в
значение последнего  бита, удаленного  сдвигом из  операнда. Флаги  OF и AF
неопределены.

Изменяемые флаги
Флаги SF,  ZF и  PF устанавливаются  в соответствии  с результатом; флаг CF
устанавливаются  в   значение  последнего   бита,  удаленного   сдвигом  из
операнда; после сдвига на одну  позицию бита флаг OF устанавливается,  если
произошло изменение знака,  в противном случае  он очищается; после  сдвига
более  чем  на   одну  битовую  позицию   флаг  OF  неопределен;   флаг  AF
неопределен, за исключением  случая, когда счетчик  сдвига был равен  нулю,
что не влияет на состояния флагов.

Исключения защищенного режима
#GP(0), если назначением является  сегмент, недоступный для записи;  #GP(0)
в случае недопустимого исполнительного  адреса операнда памяти в  сегментах
CS, DS, ES, FS или GS; #SS(0) в случае недопустимого адреса в сегменте  SS;
#PF(код сбоя)  в случае  страничного сбоя;  #AC для  невыравненной ссылки к
памяти при текущем уровне привилегированности, равном 3.

Исключения режима реальных адресов
Прерывание  13,  если  какая-либо  часть  операнда  лежит  вне пространства
исполнительных адресов от 0 до 0FFFFH.

Исключения виртуального режима 8086
Те же исключения,  что и для  режима реальных адресов:  #PF (код сбоя)  для
страничных сбоев. #AC для невыравненной ссылки к памяти при текущем  уровне
привилегированности, равном 3.

`м`д`05SLDT`* - Сохранение регистра локальной таблицы дескрипторов

|Код       Команда     Число      Описание                      |
|операции              тактовых                                 |
|                      циклов                                   |
|                                                               |
|0F 00 /0  SLDT r/m16  2/3       Сохранение LDTR в слове,       |
|                                заданном исполнительным адресом|


Работа команды
r/m16 <- LDTR;

Описание
Команда SLDT  сохраняет регистр  локальной дескрипторной  таблицы (LDTR)  в
двух-байтовом регистре  или адресе  памяти, на  который указывает  операнд,
задающий исполнительный адрес. Этот регистр содержит селектор,  указывающий
на глобальную дескрипторную таблицу.
Команда SLDT используется  только операционным программным  обеспечением, в
прикладных программах она не используется.

Изменяемые флаги
Отсутствуют

Исключения защищенного режима
#GP(0), если назначением является  сегмент, недоступный для записи;  #GP(0)
в случае недопустимого исполнительного  адреса операнда памяти в  сегментах
CS, DS, ES, FS или GS; #SS(0) в случае недопустимого адреса в сегменте  SS;
#PF(код сбоя)  в случае  страничного сбоя;  #AC для  невыравненной ссылки к
памяти при текущем уровне привилегированности, равном 3.

Исключения режима реальных адресов
Прерывание 6, команда SLDT в режиме реальных адресов не распознается.

Исключения виртуального режима 8086
Те же исключения,  что и для  режима реальных адресов:  #PF (код сбоя)  для
страничных сбоев. #AC для невыравненной ссылки к памяти при текущем  уровне
привилегированности, равном 3.

Примечание
Атрибут размера операнда на работу команды не влияет.


`м`д`05SMSW`* - Сохранение слова состояния машины

|Код       Команда     Число      Описание                      |
|операции              тактовых                                 |
|                      циклов                                   |
|                                                               |
|0F 01 /4  SMSW r/m16   2/3      Сохранение слова состояния     |
|                                машины в слове, заданном       |
|                                исполнительным адресом         |

Работа команды
r/m16 <- MSW; (* Слово состояния машины *)

Описание
Команда  SMSW  сохраняет  слово  состояния  машины  (часть  регистра CR0) в
двух-байтовом регистре  или адресе  памяти, на  который указывает  операнд,
задающий исполнительный адрес.

Изменяемые флаги
Отсутствуют

Исключения защищенного режима
#GP(0), если назначением является  сегмент, недоступный для записи;  #GP(0)
в случае недопустимого исполнительного  адреса операнда памяти в  сегментах
CS, DS, ES, FS или GS; #SS(0) в случае недопустимого адреса в сегменте  SS;
#PF(код сбоя)  в случае  страничного сбоя;  #AC для  невыравненной ссылки к
памяти при текущем уровне привилегированности, равном 3.

Исключения режима реальных адресов
Прерывание  13,  если  какая-либо  часть  операнда  лежит  вне пространства
исполнительных адресов от 0 до 0FFFFH.

Исключения виртуального режима 8086
Те же исключения,  что и для  режима реальных адресов:  #PF (код сбоя)  для
страничных сбоев. #AC для невыравненной ссылки к памяти при текущем  уровне
привилегированности, равном 3.

Примечание
Команда  обеспечивает  совместимость  с  процессором  80286;  программы для
процессора i486 должны использовать команду MOV ..., CR0.

`м`д`05STC`* - Установка флага переноса

|Код       Команда     Число      Описание                      |
|операции              тактовых                                 |
|                      циклов                                   |
|                                                               |
|F9        STC          2        Установка флага переноса       |


Работа команды
CF <- 1;
Описание
Команда STC устанавливает флаг CF.
Изменяемые флаги
Устанавливается флаг CF.
Исключения защищенного режима
Отсутствуют
Исключения режима реальных адресов
Отсутствуют
Исключения виртуального режима 8086
Отсутствуют


`м`д`05STD`* - Установка флага направления

-----------------------------------------------------------------
|Код       Команда     Число      Описание                      |
|операции              тактовых                                 |
|                      циклов                                   |
|                                                               |
|FD        STD          2        Установка флага направления,   |
|                                что соответствует декременту   |
|                                (E)SI или (E)DI                |
-----------------------------------------------------------------

Работа команды
DF <- 1;

Описание
Команда  STD  устанавливает  флаг  направления  DF,  в  результате чего все
последующие  строковые   операции  будут   выполнять  декремент   индексных
регистров, (E)SI или (E)DI, с которыми они работают.

Изменяемые флаги
Устанавливается флаг DF.

Исключения защищенного режима
Отсутствуют

Исключения режима реальных адресов
Отсутствуют

Исключения виртуального режима 8086
Отсутствуют


`м`д`05STI`* - Установка флага прерывания

-----------------------------------------------------------------
|Код       Команда     Число      Описание                      |
|операции              тактовых                                 |
|                      циклов                                   |
|                                                               |
|F13       STI          5        Установка флага прерывания:    |
|                                прерывания разрешены, начиная  |
|                                с конца следующей команды      |
-----------------------------------------------------------------

Работа команды
IF <- 1;
Описание
Команда  STI  устанавливает  флаг  IF.  После  выполнения следующей команды
процессор  может  реагировать  на  внешние  прерывания,  если эта следующая
команда  оставляет  флаг  IF  в  состоянии,  разрешающем  прерывания.  Если
внешние прерывания запрещены, и  вы после команды RET  использовали команду
RET (например,  в конце  подпрограммы), то  команда RET  будет выполнена до
того, как  начнут распознаваться  внешние прерывания.  Также, если  внешние
прерывания запрещены, а вы использовали  команду STI и за ней  команду CLI,
то  внешние  прерывания  не  будут  распознаваться,  поскольку  команда CLI
очищает флаг IF во время своего выполнения.

Изменяемые флаги
Устанавливается флаг IF.

Исключения защищенного режима
#GP,  если  текущий  уровень  привилегированности  больше  (имеет   меньшую
привилегированность), чем уровень привилегированности ввода/вывода (IOPL).

Исключения режима реальных адресов
Отсутствуют

Исключения виртуального режима 8086
Отсутствуют


`м`д`05STOS/STOSB/STOSW/STOSD`*
                - Сохранение строковых данных

-----------------------------------------------------------------
|Код       Команда     Число      Описание                      |
|операции              тактовых                                 |
|                      циклов                                   |
|                                                               |
|AA        STOS m8          5    Сохранение AL в байте          |
|                                ES:[(E)DI], обновление (E)DI   |
|AB        STOS m16         5    Сохранение AX в слове          |
|                                ES:[(E)DI], обновление (E)DI   |
|AB        STOS m32         5    Сохранение EAX в двойном слове |
|                                ES:[(E)DI], обновление (E)DI   |
|AA        STOSB            5    Сохранение AL в байте          |
|                                ES:[(E)DI], обновление (E)DI   |
|AB        STOSW            5    Сохранение AX в слове          |
|                                ES:[(E)DI], обновление (E)DI   |
|AB        STOD             5    Сохранение EAX в двойном слове |
|                                ES:[(E)DI], обновление (E)DI   |
-----------------------------------------------------------------

Работа команды

IF AddressSize = 16
THEN использование ES:DI в качестве DestReg
ELSE (*  AddressSize  =  32  *)  использование  ES:EDI в качестве
                                DestReg;
FI;
IF байтовый тип команды
THEN
  (ES:DestReg) <- AL;
  IF DF = 0
  THEN DestReg <- DestReg + 1;
  ELSE DestReg <- DestReg - 1;
  FI;
ELSE IF OperandSize = 16
  THEN
    (ES:DestReg) <- AX;
    IF DF = 0
    THEN DestReg <- DestReg + 2;
    ELSE DestReg <- DestReg - 2;
    FI;
  ELSE (* OperandSize = 32 *)
    (ES:DestReg) <- EAX;
    IF DF = 0
    THEN DestReg <- DestReg + 4;
    ELSE DestReg <- DestReg - 4;
    FI;
  FI;
FI;


Описание
Команда  STOS  пересылает  содержимое  регистра  AL,  AX или EAX в байт или
слово  памяти,  заданное  регистром  назначения  относительно  сегмента ES.
Регистром назначения  является регистр  DI для  атрибута размера  адреса 16
битов, или EDI для атрибута размера адреса 32 бита.
Операнд  назначения  должен  адресоваться  из  регистра ES; переопределение
сегмента не допускается.
Адрес назначения  определяется содержимым  регистра назначения,  а не  явно
заданным  операндом  команды  STOS.  Этот  операнд  используется только для
удостоверения адресуемости  сегмента ES  и определения  типа данных.  Перед
выполнением команды STOS следует загрузить в регистр DI или EDI  правильное
значение индекса.
После того, как пересылка выполнена, регистр DI автоматически  обновляется.
Если  флаг  направления  равен  0  (была выполнена команда CLD), происходит
инкремент  регистра  назначения;  если  флаг  направления  равен  1   (была
выполнена  команда  STD),  происходит  декремент  регистра  назначения. При
сохранении  байтов  инкремент  или  декремент  равен 1; при сохранении слов
инкремент или декремент равен 2; при сохранении двойных слов инкремент  или
декремент равен 4.

Команды STOSB, STOSW и STOSD являются синонимами команды STOS,  работающими
с  байтом,  словом   и  двойным  словом,   соответственно,  не   требующими
операндов. Их проще программировать,  но они не обеспечивают  проверки типа
или сегмента.
Команде STOS  может предшествовать  префикс REPE  или REPNE  для заполнения
блока  из  CX  или  ECX  байтов,  слов  или двойных слов. Подробности см. в
описании команды REP.

Изменяемые флаги
Отсутствуют

Исключения защищенного режима
#GP(0), если назначением является  сегмент, недоступный для записи;  #GP(0)
в случае недопустимого исполнительного  адреса операнда памяти в  сегментах
CS, DS, ES, FS или GS; #SS(0) в случае недопустимого адреса в сегменте  SS;
#PF(код сбоя)  в случае  страничного сбоя;  #AC для  невыравненной ссылки к
памяти при текущем уровне привилегированности, равном 3.

Исключения режима реальных адресов
Прерывание  13,  если  какая-либо  часть  операнда  лежит  вне пространства
исполнительных адресов от 0 до 0FFFFH.

Исключения виртуального режима 8086
Те же исключения,  что и для  режима реальных адресов:  #PF (код сбоя)  для
страничных сбоев. #AC для невыравненной ссылки к памяти при текущем  уровне
привилегированности, равном 3.


`м`д`05STR`* - Сохранение регистра задачи

-----------------------------------------------------------------
|Код       Команда     Число      Описание                      |
|операции              тактовых                                 |
|                      циклов                                   |
|                                                               |
|0F 00 /1  STR r/m16     2/3     Сохранение регистра задачи в   |
|                                слове, заданным исполнительным |
|                                адресом                        |
-----------------------------------------------------------------

Работа команды
r/m <- регистр задачи;

Описание
Содержимое регистра  задачи копируется  в двух-байтовый  регистр или  адрес
памяти, заданный операндом с исполнительным адресом.
Команда  STR  используется  только  операционным  программным обеспечением.
Прикладные программы ее не используют.

Изменяемые флаги
Отсутствуют

Исключения защищенного режима
#GP(0), если назначением является  сегмент, недоступный для записи;  #GP(0)
в случае недопустимого исполнительного  адреса операнда памяти в  сегментах
CS, DS, ES, FS или GS; #SS(0) в случае недопустимого адреса в сегменте  SS;
#PF(код сбоя)  в случае  страничного сбоя;  #AC для  невыравненной ссылки к
памяти при текущем уровне привилегированности, равном 3.

Исключения режима реальных адресов
Прерывание 6; команда STR в режиме реальных адресов не распознается.

Исключения виртуального режима 8086
Те же исключения, что и для режима реальных адресов.

Примечания
Атрибут размера операнда на действие этой команды не влияет.


`м`д`05SUB`* - Целочисленное вычитание

-----------------------------------------------------------------
|Код       Команда     Число      Описание                      |
|операции              тактовых                                 |
|                      циклов                                   |
|                                                               |
|2C ib     SUB AL,imm8     1     Вычитание непосредственного    |
|                                байта из AL                    |
|2D iw     SUB AX,imm16    1     Вычитание непосредственного    |
|                                слова из AX                    |
|2D id     SUB EAX,imm32   1     Вычитание непосредственного    |
|                                двойного слова из EAX          |

|80 /5 ib  SUB r/m8,imm8   1/3   Вычитание непосредственного    |
|                                байта из байта r/m             |
|81 /5 iw  SUB r/m16,imm16 1/3   Вычитание непосредственного    |
|                                слова из слова r/m             |
|81 /5 id  SUB r/m32,imm32 1/3   Вычитание непосредственного    |
|                                двойного слова из              |
|                                двойного слова r/m             |
|83 /5 ib  SUB r/m16,imm8  1/3   Вычитание непосредственного    |
|                                расширенного знаком байта      |
|                                из слова r/m                   |
|83 /5 ib  SUB r/m32,imm8  1/3   Вычитание непосредственного    |
|                                расширенного знаком байта      |
|                                из двойного слова r/m          |
|28 /r     SUB r/m8,r8     1/3   Вычитание регистра -           |
|                                байта из байта r/m             |
|29 /r     SUB r/m16,r16   1/3   Вычитание регистра -           |
|                                слова из слова r/m             |
|29 /r     SUB r/m32,r32   1/3   Вычитание регистра -           |
|                                двойного слова из              |
|                                двойного слова r/m             |
|2A /r     SUB r8,r/m8     1/2   Вычитание регистра -           |
|                                байта из байта r/m             |
|2B /r     SUB r16,r/m16   1/2   Вычитание регистра -           |
|                                слова из слова r/m             |
|2B /r     SUB r32,r/m32   1/2   Вычитание регистра -           |
|                                двойного слова из              |
|                                двойного слова r/m             |
-----------------------------------------------------------------

Работа команды

IF SRC это байт, а DEST это слово или двойное слово
THEN DEST = DEST - SignExtend(SRC);
ELSE DEST <- DEST - SRC;
FI;


Описание
Команда  SUB  вычитает  второй  операнд  (SRC)  из  первого (DEST). Первому
операнду  присваивается  результат   вычитания,  а  флаги   устанавливаются
соответствующим образом.
При вычмитании  из операнда  - слова  непосредственного байтового  значения
последнее расширяется знаком до размера операнда назначения.

Изменяемые флаги
Флаги OF, SF, ZF, AF, PF и CF устанавливаются в соответствии с результатом.

Исключения защищенного режима
#GP(0), если назначением является  сегмент, недоступный для записи;  #GP(0)
в случае недопустимого исполнительного  адреса операнда памяти в  сегментах
CS, DS, ES, FS или GS; #SS(0) в случае недопустимого адреса в сегменте  SS;
#PF(код сбоя)  в случае  страничного сбоя;  #AC для  невыравненной ссылки к
памяти при текущем уровне привилегированности, равном 3.

Исключения режима реальных адресов
Прерывание  13,  если  какая-либо  часть  операнда  лежит  вне пространства
исполнительных адресов от 0 до 0FFFFH.

Исключения виртуального режима 8086
Те же исключения,  что и для  режима реальных адресов:  #PF (код сбоя)  для
страничных сбоев. #AC для невыравненной ссылки к памяти при текущем  уровне
привилегированности, равном 3.


`м`д`05TEST`* - Логическое сравнение

-----------------------------------------------------------------
|Код       Команда     Число      Описание                      |
|операции              тактовых                                 |
|                      циклов                                   |
|                                                               |
|A8 ib    TEST AL,imm8     1     AND  для  непосредственного    |
|                                байта и  AL                    |
|A9 iw    TEST AX,imm16    1     AND  для  непосредственного    |
|                                слова и  AX                    |
|A9 id    TEST EAX,imm32   1     AND  для  непосредственного    |
|                                двойного слова  и EAX          |
|F6 /0 ib TEST r/m8,imm8   1/2   AND  для  непосредственного    |
|                                байта и  байта r/m             |
|F7 /0 iw TEST r/m16,imm16 1/2   AND  для  непосредственного    |
|                                слова и  слова r/m             |

|F7 /0 id TEST r/m32,imm32 1/2   AND  для  непосредственного    |
|                                двойного слова и               |
|                                двойного слова r/m             |
|84 /r    TEST r/m8,r8     1/2   AND  для  регистра -           |
|                                байта и  байта r/m             |
|85 /r    TEST r/m16,r16   1/2   AND  для  регистра -           |
|                                слова и  слова r/m             |
|85 /r    TEST r/m32,r32   1/2   AND  для  регистра -           |
|                                двойного слова и               |
|                                двойного слова r/m             |
-----------------------------------------------------------------

Работа команды

DEST := LeftSRC AND RightSRC;
CF <- 0;
OF <- 0;

 Описание
Команда TEST вычисляет поразрядное логическое И (AND) для двух заданных  ей
операндов. Каждый  бит результата  равен 1,  если оба  соответствующих бита
операндов равны 1; в противном случае этот бит равен 0. Результат  операции
теряется, а модифицируются только флаги.

Изменяемые флаги
Флаги OF и CF очищаются; флаги  SF, ZF и PF устанавливаются в  соответствии
с результатом.

Исключения защищенного режима
#GP(0)  в  случае  недопустимого  исполнительного  адреса операнда памяти в
сегментах CS, DS,  ES, FS или  GS; #SS(0) в  случае недопустимого адреса  в
сегменте  SS;   #PF(код  сбоя)   в  случае   страничного  сбоя;   #AC   для
невыравненной  ссылки  к  памяти  при  текущем  уровне привилегированности,
равном 3.

Исключения режима реальных адресов
Прерывание  13,  если  какая-либо  часть  операнда  лежит  вне пространства
исполнительных адресов от 0 до 0FFFFH.

Исключения виртуального режима 8086
Те же исключения,  что и для  режима реальных адресов:  #PF (код сбоя)  для
страничных сбоев. #AC для невыравненной ссылки к памяти при текущем  уровне
привилегированности, равном 3.


`м`д`05VERR, VERW`*
     -Верификация доступности чтения или записи сегмента

-----------------------------------------------------------------
|Код       Команда     Число      Описание                      |
|операции              тактовых                                 |
|                      циклов                                   |
|                                                               |
|0F 00 /4  VERR r/m16   11/11    Установка ZF=1, если сегмент   |
|                                доступен для чтения,           |
|                                селектор в r/m16               |
|0F 00 /5  VERW r/m16   11/11    Установка ZF=1, если сегмент   |
|                                доступен для записи,           |
|                                селектор в r/m16               |
-----------------------------------------------------------------

Работа команды

IF сегмент с селектором в (r/m) доступен для
   текущего уровня защиты
   AND ((сегмент доступен для чтения согласно VERR) OR
        (сегмент доступен для записи согласно VERW))
THEN ZF <- 1;
ELSE ZF <- 0;
FI;

 Описание
Двух-байтовый  регистр  или  операнд  памяти  команд  VERR  и VERW содержит
значение селектора.  Команды VERR  и VERW  определяют доступность сегмента,
указанного  селектором,  с  текущего  уровня  привилегированности, а также,
доступен  ли  он  для  чтения  (VERR),  или для записи (VERW). Если сегмент
доступен, то устанавливается флаг ZF;  если сегмент недоступен, то флаг  ZF
очищается.  Для  установки  флага   ZF  должны  удовлетворяться   следующие
условия:

- Селектор должен обозначать дескриптор в пределах границ таблицы (GDT  или
LDT): селектор должен быть "определен".

- Селектор  должен обозначать  дескриптор сегмента  кода или  данных (а  не
дескриптор сегмента состояния задачи, LDT или шлюза).
- Для  команды VERR  сегмент должен  быть доступен  для чтения. Для команды
VERW сегмент должен быть сементом данных, доступным для чтения.
- Если кодовый сегмент доступен  для чтения и является конформным,  уровень
привилегированности дескриптора  (DPL) для  команды VERR  может иметь любое
значение.  В  противном  случае  DPL  должен  быть  больше  или  равен (это
соответствует меньшей или  равной привилегированности) как  текущего уровня
привилегированности, так и RPL селектора.

Выполняется  такая  же  проверка  достоверности,  как  если  бы сегмент был
загружен в  регистр DS,  ES, FS  или GS,  и был  выполнен указанный  доступ
(чтения или  записи). Флаг  ZF принимает  результат проверки достоверности.
Значение  селектора  не  может  давать  в  результате  исключение   защиты,
позволяя программному обеспечению предупреждать возможные проблемы  доступа
к сегменту.

Изменяемые флаги
Флаг ZF  устанавливается, если  сегмент доступен,  и очищается  в противном
случае.

Исключения защищенного режима
Сбои,  генерируемые  неверной   адресацией  операнда  памяти,   содержащего
селектор; селектор не загружается в какой-либо сегментный регистр, а  сбои,
относящиеся к операнду селектора, не генерируются.
#GP(0)  в  случае  недопустимого  исполнительного  адреса операнда памяти в
сегментах CS, DS,  ES, FS или  GS; #SS(0) в  случае недопустимого адреса  в
сегменте  SS;   #PF(код  сбоя)   в  случае   страничного  сбоя;   #AC   для
невыравненной  ссылки  к  памяти  при  текущем  уровне привилегированности,
равном 3.

Исключения режима реальных адресов
Прерывание  6;  команды   VERR  и  VERW   в  режиме  реальных   адресов  не
распознаются.

Исключения виртуального режима 8086
Те же исключения, что и для режима реальных адресов: #AC для  невыравненной
ссылки к памяти при текущем уровне привилегированности, равном 3.


`м`д`05WAIT`* - Ожидание

-----------------------------------------------------------------
|Код       Команда     Число      Описание                      |
|операции              тактовых                                 |
|                      циклов                                   |
|                                                               |
|9B        WAIT         1-3      Заставляет процессор проверить |
|                                наличие числовых исключений    |
-----------------------------------------------------------------


Описание
Команда   WAIT   заставляет   процессор   проверить   наличие   подвешенных
немаскируемых числовых исключений, прежде чем перейти к следующей команде.

Изменяемые флаги
Отсутствуют

Исключения защищенного режима
#NM, если MP и TS в CR0 установлены.

Исключения режима реальных адресов
Прерывание 7, если MP и TS в CR0 установлены.

Исключения виртуального режима 8086
#NM, если MP и TS в CR0 установлены.

Примечания
Помещение   команды   WAIT   после   команды   ESC   гарантируют,  что  все
немаскируемые исключения  операций с  плавающей точкой,  которые могут быть
сгенерированы командами,  будут обработаны  до того,  как процессор  сможет
моддифицировать результаты этих команд.

FWAIT это альтернативная мнемоническая форма команды WAIT.
Информация об использовании команды WAIT  (FWAIT) приводится в главе 18,  в
разделе "Параллельная обработка".

`м`д`05WBINVD`* - Обратная запись и аннулирование кеша

-----------------------------------------------------------------
|Код       Команда     Число      Описание                      |
|операции              тактовых                                 |
|                      циклов                                   |
|                                                               |
|0F 09     WBINVD       5        Обратная запись и аннулирование|
|                                всего кеша                     |
-----------------------------------------------------------------

Работа команды
Очистка внутреннего  кеша Сигнал  внешнему кешу  о необходимости  выполнить
обратную запись Сигнал внешнему кешу о необходимости очистки

Описание
Очищается   внутренний   кеш,   и   генерируется   специальный  цикл  шины,
указывающий,  что  внешний  кеш  должен  выполнить запись его содержимого в
главную оперативную память. Далее  следует еще один специальный  цикл шины,
указывающий внешнему кешу на то, что внешний кеш должен быть очищен.

Изменяемые флаги
Отсутствуют

Исключения защищенного режима
Отсутствуют

Исключения режима реальных адресов
Отсутствуют

Исключения виртуального режима 8086
Отсутствуют

Примечания
Команда зависима от реализации; ее работа может по-разному  реализовываться
будущими процессорами Intel.
Ответственность за исполнение сигналов  обратной записи и очистки  внешнего
кеша лежит на соответствующем аппаратном обеспечении.
Процессорами   386   эта   команда   не   поддерживается.   Информация   об
использовании  этой  команды  совместимо  с  процессорами 386 см. в разделе
3.11. Запрет кеширования описан в разделе 12.2.


`м`д`05XADD`* - Обмен местами и сложение

-----------------------------------------------------------------
|Код       Команда     Число      Описание                      |
|операции              тактовых                                 |
|                      циклов                                   |
|                                                               |
|0F C0 /r  XADD r/m8,r8   3/4    Обмен местами регистра - байта |
|                                и байта r/m; загрузка суммы    |
|                                в байт r/m                     |
|0F C1 /r  XADD r/m16,r16 3/4    Обмен местами регистра - слова |
|                                и слова r/m; загрузка суммы    |
|                                в слово r/m                    |
|0F C1 /r  XADD r/m32,r32 3/4    Обмен местами регистра -       |
|                                двойного слова и двойного слова|
|                                r/m; загрузка суммы в          |
|                                двойное слово r/m              |
-----------------------------------------------------------------

Работа команды

врем <- DEST
DEST <- врем + SRC
SRC <- врем

 Описание
Команда XADD загружает DEST и SRC, а затем загружает сумму DEST с  исходным
значением SRC в DEST.

Изменяемые флаги
Флаги CF, PF, AF, SF,  ZF и OF получают такие  же значения, как и в  случае
команды ADD.

Исключения защищенного режима
#GP(0), если назначением является  сегмент, недоступный для записи;  #GP(0)
в случае недопустимого исполнительного  адреса операнда памяти в  сегментах
CS, DS, ES, FS или GS; #SS(0) в случае недопустимого адреса в сегменте  SS;
#PF(код сбоя)  в случае  страничного сбоя;  #AC для  невыравненной ссылки к
памяти при текущем уровне привилегированности, равном 3.

Исключения режима реальных адресов
Прерывание  13,  если  какая-либо  часть  операнда  лежит  вне пространства
исполнительных адресов от 0 до 0FFFFH.

Исключения виртуального режима 8086
Те же исключения,  что и для  режима реальных адресов:  #PF (код сбоя)  для
страничных сбоев. #AC для невыравненной ссылки к памяти при текущем  уровне
привилегированности, равном 3.

Примечания
Данная команда  может быть  использована с  префиксом LOCK.  Микропроцессор
386  DX  не  реализует  эту  команду.  При  использовании команды вы должны
обеспечить эквивалентный код,  также работающий и  на процессоре 386  DX. О
том, как во время выполнения определить, является ли процессор  процессором
i486, написано в разделе 3.11.


`м`д`05XCHG`* - Обмен местами регистра/памяти и регистра

-----------------------------------------------------------------
|Код       Команда     Число      Описание                      |
|операции              тактовых                                 |
|                      циклов                                   |
|                                                               |
|90 +r     XCHG AX,r16     3     Обмен местами регистра - слова |
|                                и AX                           |
|90 +r     XCHG r16,AX     3     Обмен местами регистра - слова |
|                                и AX                           |
|90 + r    XCHG EAX,r32    3     Обмен местами регистра -       |
|                                двойного слова и EAX           |
|90 + r    XCHG r32,EAX    3     Обмен местами регистра -       |
|                                двойного слова и EAX           |
|86 /r     XCHG r/m8,r8    3/5   Обмен местами регистра - байта |
|                                и байта по исполнительному     |
|                                адресу                         |
|86 /r     XCHG r8,r/m8    3/5   Обмен местами регистра - байта |
|                                и байта по исполнительному     |
|                                адресу                         |
|87 /r     XCHG r/m16,r16  3/5   Обмен местами регистра - слова |
|                                и слова по исполнительному     |
|                                адресу                         |
|87 /r     XCHG r16,r/m16  3/5   Обмен местами регистра - слова |
|                                и слова по исполнительному     |
|                                адресу                         |
|87 /r     XCHG r/m32,r32  3/5   Обмен местами регистра -       |
|                                двойного слова и двойного слова|
|                                по исполнительному адресу      |
|87 /r     XCHG r32,r/m32  3/5   Обмен местами регистра -       |
|                                двойного слова и двойного слова|
|                                по исполнительному адресу      |
-----------------------------------------------------------------

Работа команды

врем <- DEST
DEST <- SRC
SRC <- врем

 Описание
Команда XCHG меняет местами два операнда. Операнды могут следовать в  любой
последовательности. Если в  команде участвует операнд  памяти, то на  время
обмена возбуждается сигнал LOCK#, независимо от присутствия или  отсутствия
префикса LOCK или от значения IOPL.

Изменяемые флаги
Отсутствуют

Исключения защищенного режима
#GP(0), если назначением является  сегмент, недоступный для записи;  #GP(0)
в случае недопустимого исполнительного  адреса операнда памяти в  сегментах
CS, DS, ES, FS или GS; #SS(0) в случае недопустимого адреса в сегменте  SS;
#PF(код сбоя)  в случае  страничного сбоя;  #AC для  невыравненной ссылки к
памяти при текущем уровне привилегированности, равном 3.

Исключения режима реальных адресов
Прерывание  13,  если  какая-либо  часть  операнда  лежит  вне пространства
исполнительных адресов от 0 до 0FFFFH.

Исключения виртуального режима 8086
Те же исключения,  что и для  режима реальных адресов:  #PF (код сбоя)  для
страничных сбоев. #AC для невыравненной ссылки к памяти при текущем  уровне
привилегированности, равном 3.

`м`д`05XLAT/XLATB`* - Ассоциативная трансляция в таблице

-----------------------------------------------------------------
|Код       Команда     Число      Описание                      |
|операции              тактовых                                 |
|                      циклов                                   |
|                                                               |
|D7        XLAT m8         4     Установка AL равным байту      |
|                                памяти DS:[(E)BX+AL без знака] |
|D7        XLATB           4     Установка AL равным байту      |
|                                памяти DS:[(E)BX+AL без знака] |
-----------------------------------------------------------------

Работа команды

IF AddressSize = 16
THEN
  AL <- (BX + ZeroExtend(AL))
ELSE (* AddressSize = 32 *)
  AL <- (EBX + ZeroExtend(AL))
FI;

Описание
Команда XLAT  изменяет регистр  AL с  индекса таблицы  на элемент  таблицы.
Регистр  AL  должен  представлять  собой  индекс  без  знака  для  таблицы,
адресуемой  парой  регистров  DS:BX  (в  случае  атрибута  размера  адреса,
равного 16), или DS:EBX (в случае атрибута размера адреса 32 бита).
Операнд  команды  XLAT  позволяет  переопределение  сегмента.  Команда XLAT
использует  содержимое  регистра  BX  даже  при  его  отличии  от  смещения
операнда.  Смещение  операнда  должно  быть  помещено  в регистр BX или EBX
предыдущей командой.
Форма команды, не  имеющая операнда, XLATB,  может быть использована,  если
таблица для BX или EBX всегда находится в сегменте DS.

Изменяемые флаги
Отсутствуют

Исключения защищенного режима
#GP(0)  в  случае  недопустимого  исполнительного  адреса операнда памяти в
сегментах CS, DS,  ES, FS или  GS; #SS(0) в  случае недопустимого адреса  в
сегменте  SS;   #PF(код  сбоя)   в  случае   страничного  сбоя;   #AC   для
невыравненной  ссылки  к  памяти  при  текущем  уровне привилегированности,
равном 3.

Исключения режима реальных адресов
Прерывание  13,  если  какая-либо  часть  операнда  лежит  вне пространства
исполнительных адресов от 0 до 0FFFFH.

Исключения виртуального режима 8086
Те же исключения,  что и для  режима реальных адресов:  #PF (код сбоя)  для
страничных сбоев. #AC для невыравненной ссылки к памяти при текущем  уровне
привилегированности, равном 3.


`м`д`05XOR`* - Логическое исключающее ИЛИ

-----------------------------------------------------------------
|Код       Команда     Число      Описание                      |
|операции              тактовых                                 |
|                      циклов                                   |
|                                                               |
|34 ib    XOR  AL,imm8     1     XOR  для  непосредственного    |
|                                байта и  AL                    |
|35 iw    XOR  AX,imm16    1     XOR  для  непосредственного    |
|                                слова и  AX                    |
|35 id    XOR  EAX,imm32   1     XOR  для  непосредственного    |
|                                двойного слова  и EAX          |
|80 /6 ib XOR  r/m8,imm8   1/3   XOR  для  непосредственного    |
|                                байта и  байта r/m             |
|81 /6 iw XOR  r/m16,imm16 1/3   XOR  для  непосредственного    |
|                                слова и  слова r/m             |
|81 /6 id XOR  r/m32,imm32 1/3   XOR  для  непосредственного    |
|                                двойного слова и               |
|                                двойного слова r/m             |
|83 /6 ib  XOR r/m16,imm8  1/3   XOR для   непосредственного    |
|                                расширенного знаком байта      |
|                                из слова r/m                   |
|83 /6 ib  XOR r/m32,imm8  1/3   XOR для   непосредственного    |
|                                расширенного знаком байта      |
|                                из двойного слова r/m          |
|30 /r     XOR r/m8,r8     1/3   XOR  для  регистра -           |
|                                байта и  байта r/m             |

|31 /r     XOR r/m16,r16   1/3   XOR  для  регистра -           |
|                                слова и  слова r/m             |
|31 /r     XOR r/m32,r32   1/3   XOR  для  регистра -           |
|                                двойного слова и               |
|                                двойного слова r/m             |
|32 /r     XOR r8,r/m8     1/2   XOR  для  регистра -           |
|                                байта и  байта r/m             |
|33 /r     XOR r16,r/m16   1/2   XOR  для  регистра -           |
|                                слова и  слова r/m             |
|33 /r     XOR r32,r/m32   1/2   XOR  для  регистра -           |
|                                двойного слова и               |
|                                двойного слова r/m             |
-----------------------------------------------------------------

Работа команды

DEST <- LeftSRC XOR RightSRC;
CF <- 0;
OF <- 0;

 Описание
Команда  XOR  вычисляет  исключающее  ИЛИ   (XOR)  для  двух  заданных   ей
операндов.  Каждый  бит  результата  равен  1,  если  соответствующие  биты
операндов различны;  в противном  случае этот  бит равен  0. Ответ замещает
собой первый операнд.

Изменяемые флаги
Флаги OF и CF очищаются; флаги  SF, ZF и PF устанавливаются в  соответствии
с результатом; флаг AF неопределен.

Исключения защищенного режима
#GP(0), если назначением является  сегмент, недоступный для записи;  #GP(0)
в случае недопустимого исполнительного  адреса операнда памяти в  сегментах
CS, DS, ES, FS или GS; #SS(0) в случае недопустимого адреса в сегменте  SS;
#PF(код сбоя)  в случае  страничного сбоя;  #AC для  невыравненной ссылки к
памяти при текущем уровне привилегированности, равном 3.

Исключения режима реальных адресов
Прерывание  13,  если  какая-либо  часть  операнда  лежит  вне пространства
исполнительных адресов от 0 до 0FFFFH.

Исключения виртуального режима 8086
Те же исключения,  что и для  режима реальных адресов:  #PF (код сбоя)  для
страничных сбоев. #AC для невыравненной ссылки к памяти при текущем  уровне
привилегированности, равном 3.

