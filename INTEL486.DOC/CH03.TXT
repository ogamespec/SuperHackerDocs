`м`дГлава 3. Прикладное программирование. `*
---------------------------------------------------------------------------

Эта глава является обзором целочисленных команд, которые программист  может
использовать  при  написании   прикладного  программного  обеспечения   для
процессора i486. Команды  группируются по типам  связанных с ними  функций.
(Дополнительные  прикладные  команды  для  работы  с операндами с плавающей
запятой описаны в Части III).   Команды, не обсуждаемые в этой главе  или в
Части III,  обычно используются  программистами операционных  систем. Такие
команды  системного  уровня  описаны  в  Части  II.  Данное описание команд
приведено для  процессора i486,работающего  в защищенном  режиме. Множество
команд в этом режиме  является 32- разрядным расширением  множества команд,
используемых в  16-разрядных процессорах  семейства Intel.  В режиме прямой
адресации  или  в  виртуальном  режиме  86 процессор i486 имеет архитектуру
самого  быстрого   усовершенствованного  процессора   8086  с   расширенным
множеством  команд.  Смотри  главы  21,22,23,24  и  25  для более подробной
информации  о  выполнении  множества  16-разрядных  команд.  Все   команды,
описанные в  данной главе,  доступны во  всех режимах.   Описание множества
команд в Главе  26 содержит более  подробную информацию обо  всех командах,
включая кодирование, выполняемые действия, воздействие на флаги,  временные
характеристики и исключения, которые могут возникать в процессе  выполнения
команды.


`д`к3.1  Команды пересылки данных.`*

Эти команды обеспечивают  удобные методы пересылки  байтов, слов и  двойных
слов между памятью и регистрами процессора. Они делятся на три типа :

- Команды пересылки данных общего назначения.
- Команды работы со стеком.
- Команды преобразования типов.

`д`к3.1.1  Команды пересылки данных общего назначения.`*

MOV  (Переслать)  пересылает  байт,  слово  или  двойное  слово из операнда
источника  в  операнд  назначения.  Команда  MOV  используется при передаче
данных между следующими элементами :

- из регистра в память;
- из памяти в регистр;
- между регистрами общего назначения;
- непосредственные данные в регистр;
- непосредственные данные в память;

Команда  MOV  не  может  пересылать  данные  из  памяти  в  память  или  из
сегментного регистра  в сегментный  регистр. Пересылка  из памяти  в память
может быть выполнена при  помощи команды пересылки строк  MOVS. Специальная
форма  команды  MOV  разработана  для  обеспечения  пересылки  данных между
регистрами  AL  или  EAX  и  местом  в  памяти,  закодированным  при помощи
32-разрядного  смещения,  заданного  в   команде.  Эта  форма  команды   не
позволяет  выходить   за  границу   сегмента,  и   запрещает  использование
индексных регистров или  масштабирования. Кодирование данной  формы команды
на  один  байт  короче,  чем  кодирование  команды  MOV  общего назначения.
Аналогичное кодирование выполняется для перемещения 8-,16- или  32-разрядов
непосредственно в один из регистров общего назначения.

XCHG  (Перестановка)  переставляет  содержимое  двух операндов. Эта команда
используется вместо трех команд  MOV. Она не требует  временного размещения
в памяти одного из операндов в то время, когда другой загружается.  Команда
XCHG oсобенно полезна при использовании семафоров или аналогичных  структур
данных в  процессе синхронизации.   Команда XCHG  может менять  местами два
байта, два слова или два  двойных слова. Операндами для команды  XCHG могут
служить   два   регистровых   операнда   или   операнд-регистр  и  операнд,
расположенный   в   памяти.   Когда   команда   XCHG   использует  операнд,
расположенный в памяти, она автоматически активизирует сигнал LOCK  (Смотри
Главу 13 для получения более подробной информации о блокировке шин).

`д`к3.1.2  Команды работы со стеком.`*

PUSH  (Поместить)  декрементирует  указатель  стека  (регистр  ESP),  затем
копирует операнд-источник в вершину  стека (см. Рисунок 3-1).  Команда PUSH
часто  используется  для  размещения  в  стеке  параметров  перед   вызовом
процедуры. Внутри процедуры она может быть использована для  резервирования
пространства  в  стеке  под  временные  переменные. Команда PUSH работает с
операндами,  размещенными  в  памяти,  непосредственными  операндами  и   с
регистровыми  операндами  (включая  регистры  сегмента).  Специльная  форма
команды PUSH возможна при размещении в стеке 32-разрядного регистра  общего
назначения. Эта  форма кодируется  на один  байт короче,  чем команда общей
формы.

┌─────────────────────────────────────────────────────────────┐
│                                                             │
│  ПЕРЕД РАЗМЕЩЕНИЕМ ДВОЙНОГО   ПОСЛЕ РАЗМЕЩЕНИЯ ДВОЙНОГО     │
│          СЛОВА                         СЛОВА                │
│                                                             │
│   31                   0        31                    0     │
│   ┌────────────────────┐        ┌─────────────────────┐     │
│   ├────────────────────┤        ├─────────────────────┤     │
│   ├────────────────────┤        ├─────────────────────┤     │
│   │                    │ESP    ├─────────────────────┤     │
│   ├────────────────────┤        │    ДВОЙНОЕ СЛОВО    │ESP │
│   ├────────────────────┤        ├─────────────────────┤     │
│   ├────────────────────┤        ├─────────────────────┤     │
│   ├────────────────────┤        ├─────────────────────┤     │
│   ├────────────────────┤        ├─────────────────────┤     │
│   └────────────────────┘        └─────────────────────┘     │
│                                                             │
└─────────────────────────────────────────────────────────────┘

                   Рисунок 3-1. Команда PUSH.

PUSHA  (Разместить/поместить  все  регистры)  сохраняет  содержимое  восьми
регистров  общего  назначения  в  стеке  (см.  Рисунок  3-2).  Эта  команда
упрощает вызовы  процедур путем  сокращения числа  команд, необходимых  для
сохранения  содержимого  регистров  общего  назначения. Процессор размещает
регистры общего  назначения в  стеке в  следующем порядке  : EAX, ECX, EDX,
EBX, начальное значение  регистра ESP перед  тем, как был  размещен регистр
EAX,  EBP,  ESI  И  EDI.  Результат выполнения команды PUSHA противоположен
действию команды POPA.

POP (Восстановить (данные)  из стека) передает  слово или двойное  слово из
текущей  вершины  стека  (на   которую  указывает  регистр  ESP)   операнду
назначения и затем  увеличивает значение регистра  ESP, чтобы тот  указывал
на новую вершину стека. Смотри  Рисунок 3 -3. POP перемещает  информацию из
стека  в  регистр  общего  назначения,  регистр  сегмента или в память. Для
передачи двойного слова из  стека в регистр общего  назначения используется
специальная форма команды POP. Эта форма кодируется кодом, который на  один
байт короче, чем кодирование общей формы команды.

┌─────────────────────────────────────────────────────────────┐
│                                                             │
│  ПЕРЕД ВЫПОЛНЕНИЕМ КОМАНДЫ    ПОСЛЕ ВЫПОЛНЕНИЯ КОМАНДЫ      │
│          PUSHA                         PUSHA                │
│                                                             │
│   31                   0        31                    0     │
│   ┌────────────────────┐        ┌─────────────────────┐     │
│   ├────────────────────┤        ├─────────────────────┤     │                     │     │
│   ├────────────────────┤        ├─────────────────────┤     │
│   │                    │ESP    ├─────────────────────┤     │
│   ├────────────────────┤        │        EAX          │     │
│   │                    │        ├─────────────────────┤     │
│   ├────────────────────┤        │        ECX          │     │
│   │                    │        ├─────────────────────┤     │
│   ├────────────────────┤        │        EDX          │     │
│   │                    │        ├─────────────────────┤     │
│   ├────────────────────┤        │        EBX          │     │
│   │                    │        ├─────────────────────┤     │
│   ├────────────────────┤        │ СТАРОЕ ЗНАЧЕНИЕ ESP │     │
│   │                    │        ├─────────────────────┤     │
│   ├────────────────────┤        │        EBP          │     │
│   │                    │        ├─────────────────────┤     │
│   ├────────────────────┤        │        ESI          │     │
│   │                    │        ├─────────────────────┤     │
│   ├────────────────────┤        │        EDI          │ESP │
│   ├────────────────────┤        ├─────────────────────┤     │
│   ├────────────────────┤        ├─────────────────────┤     │
│   └────────────────────┘        └─────────────────────┘     │
│                                                             │
└─────────────────────────────────────────────────────────────┘

                  Рисунок 3-2. Команда PUSHА.

┌─────────────────────────────────────────────────────────────┐
│                                                             │
│    ПЕРЕД ВОССТАНОВЛЕНИЕМ       ПОСЛЕ ВОССТАНОВЛЕНИЯ         │
│       ДВОЙНОГО  СЛОВА             ДВОЙНОГО  СЛОВА           │
│                                                             │
│   31                    0      31                   0       │
│   ┌─────────────────────┐      ┌────────────────────┐       │
│   ├─────────────────────┤      ├────────────────────┤       │
│   ├─────────────────────┤      ├────────────────────┤       │
│   ├─────────────────────┤      │                    │ESP   │
│   │    ДВОЙНОЕ СЛОВО    │ESP  ├────────────────────┤       │
│   ├─────────────────────┤      ├────────────────────┤       │
│   ├─────────────────────┤      ├────────────────────┤       │
│   ├─────────────────────┤      ├────────────────────┤       │
│   ├─────────────────────┤      ├────────────────────┤       │
│   └─────────────────────┘      └────────────────────┘       │
│                                                             │
└─────────────────────────────────────────────────────────────┘

                   Рисунок 3-3. Команда POP.

POPA  (Восстановить  (из  стека)  все  регистры)  восстанавливает  из стека
данные,  сохраненные  в  нем  при  помощи  команды PUSHA, в регистры общего
назначения,   за   исключением   регистра   ESP.   Значение   регистра  ESP
восстанавливается после  выполнения чтения  стека (Восстановления).  Смотри
Рисунок 3-4.

┌─────────────────────────────────────────────────────────────┐
│                                                             │
│  ПЕРЕД ВЫПОЛНЕНИЕМ КОМАНДЫ      ПОСЛЕ ВЫПОЛНЕНИЯ КОМАНДЫ    │
│          POPA                           POPA                │
│                                                             │
│   31                    0      31                   0       │
│   ┌─────────────────────┐      ┌────────────────────┐       │
│   ├─────────────────────┤      ├────────────────────┤       │                     │     │
│   ├─────────────────────┤      ├────────────────────┤       │
│   ├─────────────────────┤      │                    │ESP   │
│   │        EAX          │      ├────────────────────┤       │
│   ├─────────────────────┤      │                    │       │
│   │        ECX          │      ├────────────────────┤       │
│   ├─────────────────────┤      │                    │       │
│   │        EDX          │      ├────────────────────┤       │
│   ├─────────────────────┤      │                    │       │
│   │        EBX          │      ├────────────────────┤       │
│   ├─────────────────────┤      │                    │       │
│   │ СТАРОЕ ЗНАЧЕНИЕ ESP │      ├────────────────────┤       │
│   ├─────────────────────┤      │                    │       │
│   │        EBP          │      ├────────────────────┤       │
│   ├─────────────────────┤      │                    │       │
│   │        ESI          │      ├────────────────────┤       │
│   ├─────────────────────┤      │                    │       │
│   │        EDI          │ESP  ├────────────────────┤       │
│   ├─────────────────────┤      ├────────────────────┤       │
│   ├─────────────────────┤      ├────────────────────┤       │
│   └─────────────────────┘      └────────────────────┘       │
│                                                             │
└─────────────────────────────────────────────────────────────┘

                   Рисунок 3-4. Команда POPA.


`д`к3.1.3  Команды преобразования типов.`*

Команды  преобразования  типа  преобразуют  байты  в слова, слова в двойные
слова и двойные слова в 64-разрядные значения (так называемые  учетверенные
слова). Эти команды  особенно полезны при  преобразовании целых со  знаком,
поскольку  они   автоматически  заполняют   дополнительные  биты   большего
элемента значениями знакового бита меньшего элемента. Это приводит к  целым
того же знака и той же величины, только в более длинном формате. Такой  тип
преобразования,  показанный  на  Рисунке  3-5,  называется распространением
знака.

Имеется два вида команд преобразования типа :
- Команды CWD, CBW и CWDE, которые работают только с данными в регистре EAX.
-  Команды  MOVSX  и  MOVZX,  которые  позволяют  одному  из операндов быть
регистром  общего  назначения,  оставляя  другому операнду возможность быть
ячейкой памяти или регистром.  CWD (Преобразовать слово в двойное слово)  и
CDQ  (Преобразовать   двойное  слово   в  учетверенное   слово)   удваивают
размерность операнда-источника. Команда CWD копирует знак (бит 15) слова  в
регистре AX в каждый  бит регистра DX. Команда  CDQ копирует знак (бит  31)
двойного слова в регистре EAX в каждый бит регистра EDX. Команда CWD  может
быть использована для получения делимого в формате двойного слова из  слова

перед началом  деления слова,  и команда  CDQ может  быть использована  для
получения делимого в  формате учетверенного слова  из двойного слова  перед
началом деления двойного слова.

┌─────────────────────────────────────────────────────────────────┐
│                                                                 │
│                                15                              0│
│                                ┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐│
│  ДО РАСШИРЕНИЯ ЗНАКА           │S│N│N│N│N│N│N│N│N│N│N│N│N│N│N│N││
│                                └─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘│
│                                                                 │
│                                                                 │
│31                                                              0│
│┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐│
││S│S│S│S│S│S│S│S│S│S│S│S│S│S│S│S│S│N│N│N│N│N│N│N│N│N│N│N│N│N│N│N││
│└─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘│
│  ПОСЛЕ РАСШИРЕНИЯ ЗНАКА                                         │
└─────────────────────────────────────────────────────────────────┘

              Рисунок 3-5. Распространение знака.


CBW (Преобразовать байт в слово) копирует знак (бит 7) байта в регистре  AL
в каждый бит регистра AX.

CWDE  (Преобразовать  слово  в  двойное  слово с расширением) копирует знак
(бит 15) слова в регистре AX в каждый бит регистра EAX.

MOVSX (Переслать с  распространением знака) расширяет  8-разрядное значение
до  16-разрядного  значения  или  8-разрядное  или 16-разрядное значение до
32-разрядного значения,  используя значение  знакового бита  для заполнения
пустых позиций.

MOVZX (Переслать  с расширением  нулями) расширяет  8-разрядное значение до
16-разрядного  значения  или  8-разрядное  или  16-разрядное  значение   до
32-разрядного значения, очищая (заполняя нулями) пустые позиции.


`д`к3.2  Команды двоичной арифметики. `*

Арифметические  команды  процессора  i486  работают  с  числовыми  данными,
кодированными  в  двоичном  виде.  Операции  включают  сложение, вычитание,
умножение  и  деление,  а  также  инкрементирование  и   декрементирование,
сравнение и изменение  знака (инвертирование). Поддерживаются  как двоичные
целые со  знаком, так  и двоичные  без знака.  Команды двоичной  арифметики
могут использоваться также в  качестве этапов в арифметических  вычислениях
с  десятичными  целыми.  Операнды-источники  могут  быть  непосредственными
значениями, регистрами  общего назначения  или данными  в памяти.  Операнды
назначения могут быть регистрами общего назначения или ячейками памяти  (за
исключением ситуации, когда  операнд-источник содержится в  ячейке памяти).
Основные арифметические команды имеют специальный формат для случая,  когда
операндом-источником  является  непосредственное   значение,  а   операндом
назначения является  регистр AL  или EAX.  Эти форматы  имеют длину на один
байт короче, чем арифметические команды общего вида.
Арифметические  команды  обновляют  значения  флагов  ZF,  CF,  SF  и   OF,
отражающих  вид  полученного  результата.  Вид  команды,  используемый  для
проверки  флагов,  зависит  от  того,  как  интерпретируются  данные  - как
имеющие  знак  или  как  не  имеющие  знака.  Флаг  CF содержит информацию,
относящуюся  к  целым  без  знака;  флаги  SF  и  OF  содержат  информацию,
относящуюся к целым со знаком. Флаг ZF содержит информацию, касающуюся  как
целых  со  знаком,  так  и  целых  без  знака:  флаг ZF получает значение 1
(устанавливается), когда все биты результата очищаются (становятся  равными
0).
Арифметические  команды  работают  с  8-,  16-,  или 32-разрядными данными.
Флаги   обновляются   в   зависимости   от   размеров  операций.  Например,
8-разрядная  команда  ADD  устанавливает  флаг  CF  равным  1,  если  сумма
операндов превышает 255 (десятичное).
Если используется целое без знака,  CF флаг может быть проверен  после этих
арифметических операций для того, чтобы определить, когда операция  требует
переноса или  заема единицы  разряда для  того, чтобы  перейти к следующему
этапу операции.  Флаг CF  устанавливается в  1, если  появляется перенос (в
командах  сложения  ADD,  ADC,  AAA  и  DAA)  или  заем единицы (в командах
вычитания SUB, SBB, AAS, DAS, CMP и NEG).
Команды  INC  и  DEC  не   изменяют  состояния  флага  CF.  Это   позволяет
использовать команды для обновления счетчиков, используемых для  управления
циклами  без  изменения  имеющегося  состояния  арифметических результатов.
Чтобы  определить  арифметическое   состояние  счетчика,  можно   проверить
состояние  флага  ZF  (для  обнаружения  окончания  цикла) или использовать
команды ADD и SUB для обновления значения, хранящегося в счетчике.
Флаги SF  и OF  поддерживают целочисленную  арифметику со  знаком. Флаг  SF
имеет  значение  знакового  бита  результата.  Старшим значащим битом (MSB)
значения целого со знаком является  бит, следующий за знаковым битом  - бит

6 байта, бит 14 слова, или  бит 30 двойного слова. Флаг OF  устанавливается
равным 1 в одном из двух случаев :

- Был  порожден перенос  из MSB  в знаковый  бит, но  никакого переноса  из
знакового бита не  было выполнено (команды  сложения ADD, ADC,  INC, AAA, и
DAA).   Другими   словами,   результат   был   больше,   чем   максимальное
положительное  число,   которое  может   быть  представленно   в   двоичном
дополнительном коде.

- Был порожден  перенос из знакового  бита в MSB,  но никакого переноса  из
знакового бита  не было  выполнено (команды  вычитания SUB,  SBB, DEC, AAS,
DAS,  CMP  и  NEG).  Другими   словами,  результат  оказался  меньше,   чем
наименьшее отрицательное число, которое может быть представлено в  двоичном
дополнительном коде.

Эти флаги статуса проверяются  обоими типами условных команд:  Jcc (переход
по условию cc) или SETcc (установка байта по условию).


`д`к3.2.1  Команды сложения и вычитания. `*

ADD   (Сложение    целых)   заменяет    операнд   назначения    на    сумму
операнда-источника и операнда назначения. Команда оказывает воздействие  на
флаги OF, SF, ZF, AF, PF и CF.

ADC  (Сложение  целых  с  переносом)  заменяет  операнд назначения на сумму
операнда-источника и операнда назначения  плюс 1, если флаг  CF установлен.
Если флаг CF сброшен, команда ADC  выполняет те же действия, что и  команда
ADD.  Команда  ADC  используется  для  поддержки  переноса,  когда сложение
выполняется на одном из  этапов, например, когда используется  32-разрядная
команда  ADD  для  сложения   двух  учетверенных  слов-операндов.   Команда
оказывает воздействие на флаги OF, SF, ZF, AF, PF, и CF.

INC  (Инкременирование)  добавляет  1  к  операнду  назначения. Команда INC
сохраняет значение  флага CF.  Это позволяет  использовать команду  INC для
обновления счетчиков  циклов без  оказания воздействия  на флаги состояния,
изменяющиеся  под  воздействием  арифметических  операций, используемых при
управлении циклом. Флаг ZF может быть использован для обнаружения  ситуации
возникновения  переноса.  Использование  команды  ADD  с   непосредственным
значением 1 в  качестве операнда выполняет  увеличение с обновлением  флага
CF.  Можно  использовать  однобайтную  форму  этой команды, когда операндом
является регистр общего назначения. Команда оказывает воздействие на  флаги
OF, SF, ZF, AF, и PF.

SUB (Вычитание  целых) вычитает  операнд-источник из  операнда назначения и
заменяет  значение  операнда  назначения  на  полученный  результат.   Если
возникает  заем  единицы,  устанавливается  значение  флага  CF. Операндами
могут быть  байты, слова  и двойные  слова со  знаком и  без него.  Команда
оказывает воздействие на флаги OF, SF, ZF, AF, PF и CF.

SBB  (Вычитание  целых  с  заемом)  вычитает  операнд-источник  из операнда
назначения,  заменяя  значение  приемника  на  результат вычитания минус 1,
если установлен флаг CF. Если флаг  CF очищен, команда SBB выполняет ту  же
операцию, что и команда SUB.  Команда SUB используется для поддержки  заема
разряда, когда выполняется  вычитание чисел как  один из этапов,  например,
когда  используется   32-разрядная  команда   SUB  для   вычитания   одного
учетверенного слова из другого. Команда оказывает воздействие на флаги  OF,
SF, ZF, AF, PF и CF.

DEC  (Декременирование)  вычитает  1  из  операнда  назначения. Команда DEC
сохраняет состояние флага  CF. Это позволяет  использовать команду DEC  для
обновления  счетчиков   циклов  без   воздействия  на   состояние   флагов,
изменяемых  под  воздействием  арифметических  операций,  используемых  для
управления циклом. Использование  команды SUB с  непосредственным значением
1  в  качестве  операнда  выполняет  уменьшение, которое обновляет значение
флага  CF.  Допустима  однобайтная  форма  этой  команды,  когда  операндом
является регистр общего назначения. Команда оказывает воздействие на  флаги
OF, SF, ZF, AF, и PF.


`д`к3.2.2  Команды сравнения и изменения знака.  `*

CMP (Сравнить) вычитает источник из приемника. Команда обновляет флаги  OF,
SF,  ZF,  AF,  CF,  но  не  изменяет значения операнда-источника и операнда
назначения. Последующие команды Jcc и SETcc могут проверять флаги.

NEG (Инвертировать) вычитает  целое со знаком  из нуля. Результатом  работы
команды NEG  является изменение  знака операнда  в двоичном  дополнительном
коде при сохраняении его  значения. Команда оказывает воздействие  на флаги
OF, SF, ZF, AF, PF и CF.

`д`к3.2.3  Команды умножения.`*

Процессор  i486  разделяет  умножение  операндов  со знаком и операндов без
знака. Команда  MUL работает  с целыми  без знака,  в то  время как команда
IMUL работает как с целыми со знаком, так и с целыми без знака.

MUL   (Умножение   целых   без   знака)   выполняет   умножение  без  знака
операнда-источника  и  регистра  AL,  AX  или EAX. Если источником является
байт,  процессор  умножает  его  на  значение,  хранящееся  в регистре AL и
возвращает результат  удвоенной длины  в регистры  AH и  AL. Если  исходный
операнд является словом, процессор  умножает его на значение,  хранящееся в
регистре AX  и возвращает  результат удвоенной  длины в  регистры DX  и AX.
Если операнд-источник  является двойным  словом, процессор  умножает его на
значение,  хранящееся  в  регистре  EAX  и  возвращает  результат  в   виде
учетверенного слова в регистры EDX  и EAX. Команда MUL устанавливает  флаги
CF и  OF, если  старшая половина  результата отлична  от нуля;  в противном
случае флаги очищаются. Состояние флагов SF, ZF, AF и PF не определено.

IMUL (Умножение целых  со знаком) выполняет  операцию умножения со  знаком.
Команда IMUL имеет три формы :

1. Форма с одним операндом.  Операнд может быть словом, байтом  или двойным
словом,  расположенным  в  памяти  или  в  регистре  общего назначения. Эта
команда использует  регистры EAX  и EDX  как операнды  по умолчанию  тем же
образом, что и команда MUL.

2.  Форма  с  двумя  операндами.  Одним  из  исходных операндов должен быть
регистр общего назначения, другим  операндом может быть как  регистр общего
назначения, так  и ячейка  памяти. Результат  заменяет содержимое  регистра
общего назначения.

3. Форма  с тремя  операндами :  два операнда  являются источниками, третий
операнд  является  приемником.   Одним  из  операндов-источников   является
непосредственное значение, указанное в  команде; вторым может быть  регистр
общего  назначения  или  ячейка  памяти.  Результат  сохраняется в регистре
общего  назначения.  Непосредственный  операнд  является  целым со знаком в
двоично-дополнительном  коде.   Если  непосредственный   операнд   является
байтом, процессор автоматически расширяет его со знаком до размера  второго
операнда, прежде чем выполнить умножение.

Во многих отношениях вышеприведенные три формы похожи :

- Длина результата равняется удвоенной длине операндов.

- Флаги CF и OF устанавливаются, когда значащие биты переносятся в  старшую
половину  результата.  Флаги  CF  и  OF  очищаются,  когда  старшая   часть
результата является продолжением знака младшей части результата.  Состояние
флагов SF, ZF, AF и PF не определено.

Тем не  менее, форматы  2 и  3 отличаются,  так как  разультат усекается до
длины операндов, прежде чем он он будет сохранен в регистре назначения.  По
причине  такого  усечения   необходимо  проверить  флаг   OF,  чтобы   быть
уверенным, что ни  один из значащих  битов не потерян.  (Чтобы ознакомиться
со способами проверки флага OF, смотри команды JO, INTO и PUSHF).
Форматы 2 и 3 команды IMUL  также могут быть использованы с операндами  без
знака, так  как вне  зависимости от  того, являются  ли операнды  целыми со
знаком или без знака, младшая половина результата остается одной и той  же.
Однако  флаги  CF  и  OF  не  могут  быть  использованы,  для  того   чтобы
определить, отличается ли правая часть результата от 0.



`д`к3.2.4  Команды деления `*

Процессор  i486  подразделяет  команды   деления  на  операции  деления   с
операндами  со  знаком  и  с  операндами  без знака. Команда DIV работает с
целыми без  знака, в  то время  как команда  IDIV работает  как с целыми со
знаком, так и с целыми  без знака. В обоих случаях  генерируется исключение
ошибки  деления,  если  делитель  равен  0  или  частное слишком велико для
регистров AL, AX и EAX.

DIV (Деление целых без  знака) выполняет беззнаковое деление  регистров AL,
AX и  EAX на  операнд-источник. Делимое  (аккумулятор) по  длине в два раза
больше, чем  делитель (операнд-  источник); частное  и остаток  имеют ту же
длину, что и делитель, как показано в Таблице 3-1.
Нецелочисленные  результаты  усекаются  в  направлении  0.  Остаток  всегда
меньше,  чем  делитель.  Для  деления  байтов  без знака наибольшим частным
может  быть  число  255.  Для  деления  слов  без  знака наибольшее частное
равняется  62535.  Для  деления  двойных  слов  наибольшее  частное   равно
2**32-1. Состояние флагов OF, SF, ZF, AF, PF и CF не определено.

               Таблица 3-1. Ореранды команд деления

┌──────────────────┬─────────────┬──────────────┬─────────────┐
│ Размер  операнда │   Делимое   │   Частное    │   Остаток   │
│  (Делитель)      │             │              │             │
├──────────────────┼─────────────┼──────────────┼─────────────┤
│   Байт           │ Регистр AX  │ Регистр AL   │ Регистр AH  │
│   Слово          │ DX и AX     │ Регистр AX   │ Регистр DX  │
│   Двойное слово  │ EDX и EAX   │ Регистр EAX  │ Регистр EDX │
└──────────────────┴─────────────┴──────────────┴─────────────┘

IDIV (Деление  целых со  знаком) выполняет  деление со  знаком сумматора на
операнд-источник. Команда  IDIV использует  те же  регистры, что  и команда
DIV.

Для деления байтов со знаком максимальное положительное  частное  равняется
 +127, минимальное  отрицательное частное  равняется -128. Для деления слов
со знаком максимальное положительное частное равняется +32767,  минимальное
отрицательное частное равняется -32768. Для деления двойных слов со  знаком
максимальное   положительное   частное   равняется   +2**32-1,  минимальное
отрицательное   частное   равняется   -2**31.   Нецелочисленные  результаты
усекаются в направлении 0. Остаток всегда имеет тот же знак, что и  частное
и меньше, чем делитель в выражении.  Состояние флагов OF, SF, ZF, AF,  PF и
CF не определено.


`д`к3.3  Команды десятичной арифметики`*

Десятичные  арифметические  вычисления  выполняются  путем   комбинирования
команд двоичной арифметики  (уже описанных в  предыдущем разделе) и  команд
десятичной арифметики. Команды десятичной арифметики используются одним  из
следуюших способов :

-  Преобразуют   результаты  ранее   выполненных  двоичных   арифметических
операций,  чтобы   получить  допустимые   упакованные  или    неупакованные
десятичные результаты.

-   Преобразуют   входные   данные   для   подпоследовательности   двоичных
арифметических операций таким  образом, чтобы операции  выдавали допустимые
упакованные или неупакованные  десятичные результаты. Эти  команды работают
только с регистрами AL или AH. Большинство использует флаг AL.


`д`к3.3.1  Команды коррекции упакованного BCD   `*

DAA (Десятичная коррекция  после сложения) корректирует  результат сложения
двух допустимых  упакованных десятичных  операндов в  регистре AL.  Команда
DAA должна  следовать за  сложением двух  пар упакованных  десятичных чисел
(одна  цифра  в  каждой  половине  байта)  для  получения  пары   правильно
упакованных   десятичных   цифр   в    качестве   результатов.   Флаг    CF
устанавливается  в  случае  возникновения  переноса.  Изменяется   значение
флагов SF, ZF, AF, PF и CF. Состояние флага OF не определено.

DAS  (Десятичная   коррекция  после   вычитания)  корректирует    результат
вычитания двух  значащих упакованных  десятичных операндов  в регистре  AL.
Команда DAS всегда  должна следовать за  вычитанием одной пары  упакованных
десятичных чисел (одна  цифра в каждой  половине байта) из  другой пары для
получения   пары   правильно   упакованных   десятичных   цифр  в  качестве
результата.  Флаг  CF  устанавливается,  если возникает необходимость заема
разрядной  единицы.  Изменяется  значение  флагов  SF,  ZF,  AF,  PF  и CF.
Состояние флага OF не определено.


`д`к3.3.2  Команды коррекции неупакованного BCD`*

AAA (ASCII-коррекция  после сложения)  изменяет содержимое  регистра AL  на
допустимое  неупакованное  десятичное  число  и  очищает  старшие  4  бита.
Команда AAA  должна следовать  за сложением  двух неупакованных  десятичных
операндов в регистре AL.  Устанавливается флаг CF и  увеличивается значение
регистра AH в случае возникновения переноса. Изменяется значение флагов  AF
и CF. Состояние флагов OF, SF, ZF и PF не определено.

AAS (ASCII-коррекция  после вычитания)  изменяет содержимое  регистра AL на
значащее неупакованное десятичное число  и очищает старшие 4  бита. Команда
AAS  должна  следовать  за  вычитанием  одного  неупакованного  десятичного
операнда из другого  в регистре AL.  Устанавливается флаг CF  и уменьшается
значение  регистра  AH,  если  необходим  заем разряда. Изменяются значения
флагов AF и CF. Состояние флагов OF, SF, ZF и PF не определено.

AAM  (ASCII-коррекция  после  умножения)  корректирует  результат умножения
двух значащих неупакованных десятичных чисел. Команда AAM должна  следовать
за умножением  двух десятичных  чисел, чтобы  получить значащий  десятичный
результат. Старшая  цифра расположена  слева в  регистре AH,  младшая цифра

расположена  в  регистре  AL.  Изменяются  значения  флагов  SF,  ZF  и PF.
Состояние флагов AF, OF и CF не определено.

AAD (ASCII-коррекция перед делением) модифицирует делимое в регистрах AH  и
AL, чтобы  подготовиться к  делению двух  значащих неупакованных десятичных
операндов так, чтобы  частное от деления  было бы допустимым  неупакованным
десятичным числом. Регистр AH должен  содержать старшую цифру и регистр  AL
должен содержать младшую цифру.  Эта команда округляет значение  и помещает
результат  в  регистр  AL.   Регистр  AH  очищается.  Изменяются   значения
регистров SF, ZF и PF. Состояное регистров AF, OF и CF не определено.


`д`к3.4  Логические команды. `*

Логические  команды  имеют  два   операнда.  Операнд-источник  может   быть
непосредственным  значением,  регистром   общего  назначения  или   ячейкой
памяти. Операнды  назначения могут  быть регистрами  общего назначения  или
ячейками памяти (за исключением  ситуации, когда источник является  ячейкой
памяти). Логические команды изменяют состояние флагов. Возможно  применение
кратких  форм  команд,  если  непосредственное  значение операнда-источника
применяется  к  операнду  назначения  в   регистрах  AL  или  EAX.   Группы
логических операций включают в себя :

- Команды булевых операций.
- Команды проверки и модификации битов.
- Команды сканирования битов.
- Команды сдвига и циклического сдвига.
- Установка значения байта по условию.


`д`к3.4.1  Команды булевых операций. `*

Логические операции выполняются командами AND, OR, XOR и NOT.

NOT (Отрицание) инвертирует  биты в указанном  операнде в форме  дополнения
до  единицы.  Команда  NOT  является  унарной операцией, которая использует
один операнд в регистре или в ячейке памяти. NOT не влияет на флаги.

Команды  AND,  OR  и  XOR  выполняют стандартные логические операции "and",
"or"  и  "исключающее  or".   Эти  команды  могут  использовать   следующие
комбинации операндов :

- Два регистровых операнда.
- Операнд - регистр общего назначения и операнд - ячейка памяти.
- Операнд  - непосредственное  значение и  либо регистр  общего назначения,
либо операнд - ячейка памяти.

Команды  AND,  OR  и  XOR  очищают   флаги  OF  и  CF,  оставляя  флаг   AF
неопределенным и обновляя флаги SF, ZF И PF.


`д`к3.4.2  Команды проверки и модификации битов.`*

Эта  группа  команд  работает  с  одним  битом,  который может находиться в
памяти или  в регистре  общего назначения.  Положение бита  задается в виде
смещения  относительно  младшего  бита  операнда.  Значение  смещения может
задаваться в  виде непосредственного  значения или  содержаться в  регистре
общего назначения.
Описываемые команды вначале присваивают значение выбранного бита флагу  CF.
Затем выбранному  биту присваивается  новое значение,  которое определяется
каждой  конкретной  операцией.  Состояние  флагов  OF,  SF,  ZF, AF и PF не
определено.  Значения,  помещаемые  в   выбранный  бит  данными   командами
приведены в Таблице 3-2.


`д`к3.4.3  Команды сканирования битов`*

Эти  команды  сканируют  слово  или  двойное слово в поисках установленного
бита и заносят  в регистр номер  первого установленного бита  (целое число,
определяющее позицию найденного бита). Сканируемая строка может  находиться
как в регистре, так и в памяти.  Если все слово равно нулю, т.е. в  нем нет
единичных битов, устанавливается флаг  ZF. Если единичный бит  найден, флаг
ZF  очищается.  Если   единичных  битов  не   найдено,  значение   регистра
назначения  не  определено.  Состояние  флагов  OF,  SF,  ZF,  PF  и  CF не
определено.
BSF (Сканирование битов вперед)  просматривает биты от младшего  к старшему
(от бита 0 до старшего бита).
BSR (Сканирование битов в обратном порядке) просматривает биты от  старшего
к младшему (от самого старшего бита к биту 0).

      Таблица 3-2. Команды проверки и модификации битов.

┌────────────────────────────┬────────────────┬────────────────┐
│         Команда            │    Значение    │    Значение    │
│                            │    флага CF    │выбранного бита │
├────────────────────────────┼────────────────┼────────────────┤
│ BT (проверка бита)         │  Флаг CF      │  Не оказывает  │
│                            │ Выбранный бит  │     влияния    │
│ BTS (проверка и            │     --"--      │Выбранный бит1 │
│      установка бита)       │                │                │
│ BTR (проверка и            │     --"--      │Выбранный бит0 │
│      сброс бита)           │                │                │
│ BTC (проверка и задание    │     --"--      │Выбранный бит  │
│ противоположного значения) │                │-(Выбранный бит)│
└────────────────────────────┴────────────────┴────────────────┘


`д`к3.4.4  Команды смещения (сдвига) и циклического сдвига`*

Команды сдвига  и циклического  сдвига переставляют  биты внутри  операнда.
Эти команды подразделяются на три класса :

- Команды сдвига.
- Команды двойного сдвига.
- Команды циклического сдвига.


`д`к3.4.4.1  Команды сдвига `*

Команды сдвига выполняют арифметический  или логический сдвиг над  байтами,
словами  или  двойными  словами.   Арифметический  сдвиг  вправо   копирует
знаковый  бит  в  пустую  позицию  старшего  бита  операнда, в то время как
логический сдвиг  вправо, сдвинув  операнд вправо,  очищает пустые позиции.
Арифметический сдвиг является самым быстрым способом выполнения  простейших
вычислений. Например,  арифметический сдвиг  вправо на  один бит  выполняет
деление  целого  на  два.  Логический  сдвиг  делит  целое  без  знака  или
положительное целое, но отрицательное целое со знаком теряет свой  знаковый
бит.

Команды арифметического и логического сдвига вправо, SAR и SHR,  отличаются
друг от друга только своей интерпретацией позиций битов, освобождаемых  при
смещении  содержимого  операндов.  Обратите  внимание,  что  нет различий в
командах логического и арифметического сдвига влево. Два символьных  имени,
SAL и SHL, поддерживаются языком ассемблера для обозначения одной команды.

Счетчик указывает число битовых позиций, на которое надо сдвинуть  операнд.
Биты  могут  быть  сдвинуты  максимум  на  31 позицию. Команды сдвига могут
задавать счетчик сдвига  любым из трех  способов. Одна форма  команд сдвига
всегда выполняет сдвиг на один бит. Вторая форма задает счетчик сдвига  как
непосредственное  значение.  Третья  форма  задает  счетчик  как  значение,
содержащееся в регистре CL. Последняя форма позволяет задавать счетчик  как
результат  вычислений.  Используются  только  пять младших битов (разрядов)
регистра CL.

Когда количество позиций сдвига  равно нулю, никакие флаги  не подвергаются
изменениям.  В  противном  случае  флаг  CF заполяется значением последнего
бита, вытесненного за границы операнда. В командах сдвига на один бит  флаг
OF  устанавливается  равным  единице,  если  значение  самого старшего бита
(знакового бита) изменяется  в процессе операции.  В противном случае  флаг
OF очищается (присваивается значение ноль). После сдвига более чем на  одну
позицию  значение  флага  OF  не  определено.  При сдвиге на одну или более
позиций изменяются значения флагов  SF, ZF, PF и  CF, и состояние флага  AF
не определено.

SAL (Арифметический  сдвиг влево)  сдвигает байт,  слово или  двойное слово
операнда  назначения  влево  на  одну  позицию  или  на  количество  битов,
заданное  в  операнде-счетчике  (непосредственное  значение  или значение в
регистре CL). Пустые биты очищаются. Смотри Рисунок 3-6.

SHL  (Логический  сдвиг  влево)  другое  наименование команды SAL. Название
поддерживается в языке ассемблера.

SHR  (Логический  сдвиг  вправо)  сдвигает  байт,  слово  или двойное слово
операнда  назначения  вправо  на  одну  позицию  или  на  количество битов,
заданное  в  операнде-счетчике  (непосредственное  значение  или значение в
регистре CL). Пустые биты очищаются. Смотри Рисунок 3-7.

SAR (Арифметический сдвиг  вправо) сдвигает байт,  слово или двойное  слово
операнда  назначения  вправо  на  одну  позицию  или  на  количество битов,
заданное  в  операнде-счетчике  (непосредственное  значение  или значение в
регистре  CL).  Знак  операнда  сохраняется  путем  очистки  пустых позиций
битов,  если  операнд  положительный,  или  установки значений пустых битов
(равным единице), если операнд отрицательный. Смотри Рисунок 3-8.

┌─────────────────────────────────────────────────────────────┐
│                                                             │
│ Начальное состояние :                                       │
│                                                             │
│    CF                        ОПЕРАНД                        │
│   ┌─┐           ┌────────────────────────────────┐          │
│   │x│           │10001000100010001000100010001111│          │
│   └─┘           └────────────────────────────────┘          │
│                                                             │
│ После выполнения 1-разрядной (1-битовой) команды SHL/SAL :  │
│                                                             │
│    CF                        ОПЕРАНД                        │
│   ┌─┐           ┌────────────────────────────────┐          │
│   │1│           │00010001000100010001000100011110│ <─ 0     │
│   └─┘           └────────────────────────────────┘          │
│                                                             │
│ После выполнения 10-разрядной (10-битовой) команды SHL/SAL :│
│                                                             │
│    CF                        ОПЕРАНД                        │
│   ┌─┐           ┌────────────────────────────────┐          │
│   │0│           │00100010001000100011110000000000│ <─ 0     │
│   └─┘           └────────────────────────────────┘          │
│                                                             │
└─────────────────────────────────────────────────────────────┘

                Рисунок 3-6. Команда SHL/SAL.


┌─────────────────────────────────────────────────────────────┐
│                                                             │
│ Начальное состояние :                                       │
│                                                             │
│                           ОПЕРАНД                    CF     │
│              ┌────────────────────────────────┐     ┌─┐     │
│              │10001000100010001000100010001111│     │x│     │
│              └────────────────────────────────┘     └─┘     │
│                                                             │
│ После выполнения 1-разрядной (1-битовой) команды SHR :      │
│                                                             │
│                           ОПЕРАНД                    CF     │
│              ┌────────────────────────────────┐     ┌─┐     │
│     0 ──>    │01000100010001000100010001000111│ ─-> │1│     │
│              └────────────────────────────────┘     └─┘     │
│                                                             │
│ После выполнения 10-разрядной (10-битовой) команды SHR :    │
│                                                             │
│                           ОПЕРАНД                    CF     │
│              ┌────────────────────────────────┐     ┌─┐     │
│     0 ──>    │00000000001000100010001000100010│ ──> │0│     │
│              └────────────────────────────────┘     └─┘     │
│                                                             │
└─────────────────────────────────────────────────────────────┘

                Рисунок 3-7. Команда SHR.

┌─────────────────────────────────────────────────────────────┐
│                                                             │
│ Начальное состояние (положительный операнд) :               │
│                                                             │
│                         ОПЕРАНД                    CF       │
│            ┌────────────────────────────────┐     ┌─┐       │
│            │01000100010001000100010001000111│     │x│       │
│            └────────────────────────────────┘     └─┘       │
│                                                             │
│ После выполнения 1-разрядной (1-битовой) команды SАR :      │
│                                                             │
│                         ОПЕРАНД                    CF       │
│            ┌────────────────────────────────┐     ┌─┐       │
│         ┌─>│00100010001000100010001000100011│ ─-> │1│       │
│         │  └┬───────────────────────────────┘     └─┘       │
│         └───┘                                               │
│                                                             │
│ Начальное состояние (отрицательный операнд) :               │
│                                                             │
│                         ОПЕРАНД                    CF       │
│            ┌────────────────────────────────┐     ┌─┐       │
│            │11000100010001000100010001000111│     │x│       │
│            └────────────────────────────────┘     └─┘       │
│                                                             │
│ После выполнения 1-разрядной (1-битовой) команды SАR :      │
│                                                             │
│                         ОПЕРАНД                    CF       │
│            ┌────────────────────────────────┐     ┌─┐       │
│         ┌─>│11100010001000100010001000100011│ ─-> │1│       │
│         │  └┬───────────────────────────────┘     └─┘       │
│         └───┘                                               │
│                                                             │
└─────────────────────────────────────────────────────────────┘

                Рисунок 3-8. Команда SАR.


Насмотря на то, что эта  команда может быть использована для  деления целых
на целое, являющееся  степенью двойки, результат  деления не будет  тем же,
что  при  выполнении  команды  IDIV.  Частное  при  выполнении команды IDIV
округляется  в  сторону  нуля,  в  то  время  как  "частное" при выполнении
команды  SAR  округляется  в  сторону  отрицательной бесконечности. Разница
проявляется только  для отрицательных  чисел. Например,  когда используется
команда IDIV для деления -9 на 4, результатом будет -2 с остатком -1.  Если
использовать команду  SAR для  сдвига -9  вправо на  два бита,  результатом
будет -3.  "Остатком" такого  вида деления  будет -13;  однако команда  SAR
сохраняет только бит старшего разряда остатка (во флаге CF).


`д`к3.4.4.2 Команды двойного сдвига.`*

Эти  команды  обеспечивают  основные  операции,  необходимые для выполнения
действий над  длинными невыровненными  битовыми строками.  Команды двойного
сдвига выполняются как  над словами, так  и над двойными  словами следующим
образом :

-  Берутся  два  операнда  длиной  в  слово и получается результат длиной в
слово (32-разрядный сдвиг).
-  Берутся  два  операнда  длиной  в  двойное  слово и получается результат
длиной в двойное слово (64-разрядный сдвиг).

Из двух операндов, операнд-источник должен  быть регистром, в то время  как
операнд  назначения  может  быть  как  регистром,  так  и  ячейкой  памяти.
Количество  битов,  на  которое  выполняется  сдвиг,  может  быть  задано в
регистре  CL  или   непосредственно  значением  байта   в  команде.   Биты,
вытесненные  за  границу  операнда-источника,   заполняют  пустые  биты   в
операнде назначения, который  тоже сдвигается. Сохраняется  значение только
операнда назначения.
 Когда выполняется сдвиг на ноль позиций, ни один из флагов не подвергается
изменениям. В противном случае, флагу CF присваивается значение  последнего
бита, вытесненного  из операнда  назначения, и изменяются  значения  флагов
SF,  ZF  и  PF.  При  сдвиге  на  один  разряд флаг  OF  получает  значение
"единица",  если  знак  операнда  изменяется, в  противном  случае флаг  OF
очищается.  При  сдвигах  более  чем   на один бит  состояние  флага AF  не
определено.

SHLD  (Двойной  сдвиг  влево)  сдвигает  биты  операнда  назначения  влево,
заполняя пустые  биты значениями  битов, вытесняемых  из операнда-источника
(см.  Рисунок   3-9).  Результат   запоминается  в   операнде   назначения.
Операнд-источник не изменяется.

SHRD  (Двойной  сдвиг  вправо)  сдвигает  биты  операнда назначения вправо,
заполняя пустые  биты значениями  битов, вытесняемых  из операнда-источника
(цм.  Рисунок   3-10).  Результат   запоминается  в   операнде  назначения.
Операнд-источник не изменяется.

┌─────────────────────────────────────────────────────────────┐
│                 31                                     0    │
│  ┌──┐           ┌──────────────────────────────────────┐    │
│  │CF│ ──────── │  Приемник (память или регистр)       │─┐ │
│  └──┘           └──────────────────────────────────────┘  │ │
│                                                           │ │
│          ┌────────────────────────────────────────────────┘ │
│          │      31                                     0    │
│          │      ┌──────────────────────────────────────┐    │
│          └──────│           Источник (регистр)         │    │
│                 └──────────────────────────────────────┘    │
│                                                             │
└─────────────────────────────────────────────────────────────┘

                 Рисунок 3-9. Команда SHLD.


┌─────────────────────────────────────────────────────────────┐
│     31                                     0                │
│     ┌──────────────────────────────────────┐                │
│     │           Источник (регистр)         │────┐           │
│     └──────────────────────────────────────┘    │           │
│┌────────────────────────────────────────────────┘           │
││                                                            │
││    31                                     0                │
││    ┌──────────────────────────────────────┐         ┌──┐   │
│└───>│  Приемник (память или регистр)       │────────>│CF│   │
│     └──────────────────────────────────────┘         └──┘   │
│                                                             │
└─────────────────────────────────────────────────────────────┘

                 Рисунок 3-10. Команда SHRD.


`д`к3.4.4.3  Koманды циклического сдвига.`*

Команды циклического  сдвига выполняют  циклическое перемещение  разрядов в
байтах,  словах  и  двойных  словах.  Биты,  вытесненные  с  одного   конца
операнда, заносятся в  него с другого  конца. В отличие  от команд смещения
никакие биты не очищаются в процессе циклического сдвига.
Команды циклического сдвига используют только флаги CF и OF. Флаг CF  может
работать  в  качестве  расширения  операнда  в  двух  командах циклического
сдвига,  позволяющих  биту  стать  обособленным  и  затем  быть проверенным
командами  условного  перехода  (JC  или  JNC).  Флаг  CF  всегда  содержит
значение  последнего  бита,  вытесненного  за  пределы  операнда в процессе
циклического сдвига,  даже если  команда не  использует флаг  CF в качестве
расширения операнда. Состояние флагов SF, ZF, AF и PF не изменяется.
При циклическом сдвиге на один  бит флаг OF устанавливается, если  операция
изменяет  самый  старший  бит  (знаковый  бит)  операнда  назначения.  Если
сохраняется исходное значение знака, флаг OF очищается. После  циклического
сдвига более чем на один бит значение флага OF не определено.

ROL (Циклический сдвиг влево)  циклически сдвигает байт, слово  или двойное
слово  операнда  назначения  влево  на  один  бит  или на количество битов,
заданное  в  операнде-счетчике  (непосредственное  значение  или  значение,
содержащееся в регистре CL).  Для каждого разряда бит,  который вытесняется
с левого конца операнда, возвращается в правый конец. Смотри Рисунок 3-11.
ROR (Циклический сдвиг вправо) циклически сдвигает байт, слово или  двойное
слово  операнда  назначения  вправо  на  один  бит или на количество битов,
заданное  в  операнде-счетчике  (непосредственное  значение  или  значение,
содержащееся в регистре CL).  Для каждого разряда бит,  который вытесняется
с правого конца операнда, возвращается в левый конец. Смотри Рисунок 3-12.

RCL  (Циклический  сдвиг  влево  через  перенос)  циклически сдвигает байт,
слово  или  двойное  слово  операнда  назначения  влево  на один бит или на
количество битов, заданное  в операнде-счетчике (непосредственное  значение
или значение, содержащееся в регистре CL).
Эта  команда  отличается  от  ROL  тем,  что она интерпретирует флаг CF как
однобитовое  расширение  операнда  назначения  со стороны старших разрядов.
Для  каждого  разряда  бит,  который  вытесняется  с левого конца операнда,
перемещается  во  флаг  CF.  В  тоже  время  бит, содержащийся во флаге CF,
вводится с правой стороны. Смотри Рисунок 3-13.

RCR  (Циклический  сдвиг  вправо  через  перенос) циклически сдвигает байт,
слово  или  двойное  слово  операнда  назначения  вправо на один бит или на
количество битов, заданное  в операнде-счетчике (непосредственное  значение
или значение, содержащееся в регистре CL).

Эта  команда  отличается  от  ROR  тем,  что она интерпретирует флаг CF как
однобитовое  расширение  операнда  назначения  со стороны младших разрядов.
Для  каждого  разряда  бит,  который  вытесняется с правого конца операнда,
перемещается  во  флаг  CF.  В  тоже  время  бит, содержащийся во флаге CF,
вводится с левой стороны. Смотри Рисунок 3-14.

┌─────────────────────────────────────────────────────────────┐
│               31                                       0    │
│ ┌──┐          ┌────────────────────────────────────────┐    │
│ │CF│───┬─────│    Приемник (память или регистр)       │─┐ │
│ └──┘    │     └────────────────────────────────────────┘  │ │
│         │                                                 │ │
│         └─────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────┘

            Рисунок 3-11. Команда ROL.


┌─────────────────────────────────────────────────────────────┐
│       31                                       0            │
│       ┌────────────────────────────────────────┐       ┌──┐ │
│ ┌────>│    Приемник (память или регистр)       │──┬───>│CF│ │
│ │     └────────────────────────────────────────┘  │    └──┘ │
│ │                                                 │         │
│ └─────────────────────────────────────────────────┘         │
└─────────────────────────────────────────────────────────────┘

            Рисунок 3-12. Команда ROR.


┌─────────────────────────────────────────────────────────────┐
│ ┌─────────────────────────────────────────────────────────┐ │
│ │                                                         │ │
│ │             31                                       0  │ │
│ │      ┌──┐   ┌────────────────────────────────────────┐  │ │
│ └──────│CF│──│    Приемник (память или регистр)       │─┘ │
│        └──┘   └────────────────────────────────────────┘    │
└─────────────────────────────────────────────────────────────┘

            Рисунок 3-13. Команда RCL.


┌─────────────────────────────────────────────────────────────┐
│ ┌────────────────────────────────────────────────────────┐  │
│ │                                                        │  │
│ │     31                                       0         │  │
│ │     ┌────────────────────────────────────────┐   ┌──┐  │  │
│ └────>│    Приемник (память или регистр)       │──>│CF│──┘  │
│       └────────────────────────────────────────┘   └──┘     │
└─────────────────────────────────────────────────────────────┘

            Рисунок 3-14. Команда RCR.


`д`к3.4.4.4  Быстрый "bit blt" с использованием команд двойного сдвига`*

Одним из назначений команд двойного сдвига является реализация  перемещения
строки  битов,   с  произвольным   рассогласованием  битовых   строк.   Это
называется "bit blt" (BIT BLock Transfer - пересылка блока битов).  Простым
примером  является  перемещение  строки  битов  с  произвольного смещения в
памяти в выровненную по двойным словам строку байт. Слева направо в  строке
пересылается  32  бита  за  один  раз,  если в цикле пересылки используется
двойное смещение.

   MOV   ESI,ScrAddr
   MOV   EDI,DestAddr
   MOV   EBX,WordCnt
   MOV   CL,RelOffset       ; относительное смещение Dest-Src
   MOV   EDI,[ESI]          ; загрузить первое слово источника
   ADD   ESI,4              ; увеличить адрес источника
BltLoop:
   LODS                     ; новая часть в убывающем порядке
                            ; в EAX
   SHLD  EDX,EAX,CL         ; переписать содержимое EDX на
                            ; выровненную вставку
   XCHG  EDX,EAX            ; поменять местами старшее и младшее
                            ; слово
   STOC                     ; записать очередную выровненную
                            ; часть данных
   DEC   EBX                ; уменьшить счетчик цикла
   JNZ   BltLoop

Это простой  цикл, позволяющий  данным быть  перемещенными по  32-разрядным
частям с  наивысшей возможной  скоростью. Без  двойного смещения  наилучшим
результатом, который  может быть  получен, является  16-разрядная пересылка
за цикл с использованием 32-разрядного смещения, и заменой команды XCHG  на
команду  ROR  по  16  бит  для  замены  местами старшего и младшего слова в
регистрах.  Более  общий  цикл,  чем  приведен  выше,  потребует некоторого
маскирования первого перемещаемого двойного слова (перед основным  циклом),
последнего перемещаемого двойного слова  (после основного цикла), но  будет
пересылать те же 32 бита за один цикл, что и программа, приведенная выше.


`д`к3.4.4.5  Быстрая вставка и исключение битовых строк.`*

Команды двойного смещения также делают возможным :

- Быструю вставку битовой строки из регистра в произвольное  местоположение
бита  в  большей  битовой  строке  в  памяти,  без нарушения битов по обеим
сторонам от вставляемых битов.
-   Быстрое   исключение   битовой   строки   в   регистр  с  произвольного
местоположения в большей  битовой строке в  памяти, без нарушения  битов по
обеим сторонам от исключаемых битов.

Следующие  примеры  программ  иллюстрируют  вставку  и исключение битов при
различных условиях :

1. Вставка битовой строки в память (когда битовая строка длиной от 1 до  25
бит, т.е. вставить 4 байта или меньше) :

; Вставить выровненную по правому краю битовую строку из регистра
; в битовую строку в памяти.
;
; Допущения :
; 1. Основание массива строки выровнено по двойным словам.
; 2. Длина битовой строки задана непосредственно значением и
;    битовое смещение содержится в регистре.
;
; Регистр ESI содержит выровненную по правому краю битовую
; строку, которую надо вставить.
; Регистр EDI содержит битовое смещение начальной позиции
; подстроки.
; Также используются регистры EAX и ECX.
;
MOV   ECX,EDI             ; сохранить исходное смещение
SHR   EDI,3               ; разделить смещение на 8 (адрес байта)
AND   CL,7H               ; получить три младших бита смещения
MOV   EAX,[EDI]strg_base  ; переместить строку длиной в двойное
                          ; слово в EAX
RDR   EAX,CL              ; правое выравнивание поля старых
                          ; битов
SHRD  EAX,ESI,длина       ; получили новые биты
ROL   EAX,длина           ; правое выравнивание поля новых битов
ROL   EAX,CL              ; доставить в конечную позицию
MOV   [EDI]strg_base,EAX  ; заменить двойное слово в памяти

2. Вставка битовой строки в память (когда битовая строка длиной от 1 до  31
битa, т.е. вставить 5 байт или меньше) :

; Вставить выровненную по правому краю битовую строку из регистра
; в битовую строку в памяти.
;
; Допущения :
; 1. База массива строки выровнена по двойным словам.
; 2. Длина битовой строки задана непосредственно значением и
;    битовое смещение содержится в регистре.
;
; Регистр ESI содержит выровненную по правому краю битовую
; строку, которую надо вставить.
; Регистр EDI содержит битовое смещение начальной позиции
; подстроки.
; Также используются регистры EAX, EBX, ECX и EDI.
;
MOV   ECX,EDI             ; временно сохранить смещение
SHR   EDI,5               ; разделить смещение на 32 (двойное
                          ; слово)
SHL   EDI,2               ; умножить на 4 (адрес байта)
AND   CL,1FH              ; получить пять младших битов смещения
MOV   EAX,[EDI]strg_base  ; переместить младшую строку длиной в
                          ; двойное слово в EAX
MOV   EDX,[EDI]strg_base+4  ; переместить оставшуюся строку
                          ; длиной в двойное слово в EDX
MOV   EBX,EAX             ; временное сохранение части строки
SHRD  EAX,EDX,CL          ; смещение на заданное число бит
                          ; внутри двойного слова

SHRD  EAX,EBX,CL          ; смещение на заданное число бит
                          ; внутри двойного слова
SHRD  EAX,ESI,длина       ; получили новые биты
ROL   EAX,длина           ; правое выравнивание поля новых битов
MOV   EBX,EAX             ; временное сохранение строки
SHLD  EAX,EDX,CL          ; смещение на заданное число бит
                          ; внутри слова
SHLD  EDX,EDX,CL          ; смещение на заданное число бит
                          ; внутри слова
MOV   [EDI]strg_base,EAX  ; заменить двойное слово в памяти
MOV   [EDI]strg_base+4,EDX  ; заменить двойное слово в памяти

3. Вставка битовой  строки в память  (когда битовая строка  длиной 32 битa,
т.е. вставить 4 или 5 байт) :

;  Вставить  выровненную  по  правому  краю  битовую  строку  из
;  регистра в битовую строку в памяти.
;
;  Допущения :
; 1. База массива строки выровнена по двойным словам.
; 2. Длина  битовой  строки  32  бита  и  битовое   смещение
;  содержится в регистре.
;

; Регистр ESI содержит 32-битовую строку, которую надо вставить.
; Регистр EDI содержит битовое смещение начальной позиции
; подстроки.
; Также используются регистры EAX, EBX, ECX и EDI.
;
MOV   EDX,EDI             ; сохранить исходное смещение
SHR   EDI,5               ; разделить смещение на 32 (двойное
                          ; слово)
SHL   EDI,2               ; умножить на 4 (адрес байта)
AND   CL,1FH              ; изолировать пять младших битов
                          ; смещения
MOV   EAX,[EDI]strg_base  ; переместить младшую строку длиной в
                          ; двойное слово в EAX
MOV   EDX,[EDI]strg_base+4  ; переместить оставшуюся строку
                          ; длиной в двойное слово в EDX
MOV   EBX,EAX             ; временное сохранение части строки
SHRD  EAX,EDX             ; смещение на заданное число бит
                          ; внутри двойного слова
SHRD  EDX,EBX             ; смещение на заданное число бит
                          ; внутри двойного слова
MOV   EAX,ESI             ; переместить 32-разрядное поле в
                          ; положение
MOV   EBX,EAX             ; временное сохранение части строки
SHLD  EAX,EDX             ; смещение на заданное число бит
                          ; внутри слова
SHLD  EDX,EBX             ; смещение на заданное число бит
                          ; внутри слова
MOV   [EDI]strg_base,EAX  ; заменить двойное слово в памяти
MOV   [EDI]strg_base+4,EDX  ; заменить двойное слово в памяти

4. Изъятие битовой строки  из памяти (когда битовая  строка длиной от 1  до
25 бит, т.е. изъять 4 байта или меньше) :

; Изъять выровненную по правому краю битовую строку в регистр
; из битовой строки в память.
;
; Допущения :
; 1. База массива строки выровнена по двойным словам.
; 2. Длина битовой строки задана непосредственно значением и
;    битовое смещение содержится в регистре.
;
; Регистр EAX содержит выровненную по правому краю дополненную
; нулями битовую строку, которую надо изъять.
; Регистр EDI содержит битовое смещение начальной позиции
; подстроки.
; Также используются регистры EDI и ECX.
;
MOV   ECX,EDI             ; временное сохранение смещения
SHR   EDI,3               ; разделить смещение на 8 (адрес байта)
AND   CL,7H               ; получить три младших бита смещения
MOV   EAX,[EDI]strg_base  ; переместить строку длиной в двойное
                          ; слово в EAX
SHR   EAX,CL              ; смещение на заданное количество
                          ; битов внутри двойного слова
AND   EAX,маска           ; изъять битовое поле в EAX

5. Изъятие битовой строки  из памяти (когда битовая  строка длиной от 1  до
32 бит, т.е. изъять 5 байт или меньше) :

; Изъять выровненную по правому краю битовую строку в регистр
; из битовой строки в памяти.
;
; Допущения :
; 1. База массива строки выровнена по двойным словам.
; 2. Длина битовой строки задана непосредственно значением и
;    битовое смещение содержится в регистре.
;
; Регистр EAX содержит выровненную по правому краю дополненную
; нулями битовую строку, которую надо изъять.
; Регистр EDI содержит битовое смещение начальной позиции
; подстроки.
; Также используются регистры EAX, EBX и ECX.
;
MOV   ECX,EDI             ; временно сохранить смещение
SHR   EDI,5               ; разделить смещение на 32 (двойное
                          ; слово)
SHL   EDI,2               ; умножить на 4 (адрес байта)
AND   CL,1FH              ; получить пять младших битов смещения
MOV   EAX,[EDI]strg_base  ; переместить младшую строку длиной в
                          ; двойное слово в EAX
MOV   EDX,[EDI]strg_base+4  ; переместить оставшуюся строку
                          ; длиной в двойное слово в EDX
SHRD  EAX,EDX,CL          ; смещение на заданное число бит
                          ; внутри двойного слова
SHRD  EAX,EDX,CL          ; смещение на заданное число бит
                          ; внутри двойного слова
AND   EAX,маска           ; изъять битовое поле в EAX


`д`к3.4.5  Команды установки байта по условию  `*

Эта группа команд  устанавливает значение байта  равным нулю или  единице в
зависимости от  любого из  16 условий,  определяемых флагами  статуса. Байт
может  находиться  как  в  регистре,  так  и в памяти. Эти команды особенно
полезны  для  поддержки  Булевских  выражений  в  языках   программирования
высокого уровня, таких, как Паскаль.
Некоторые языки представляют  логическую единицу как  целое, в котором  все
биты  установлены.  Это  может  быть  сделано  при  помощи  команды SETcc с
взаимно  исключающими  условиями  и  последующим  уменьшением результата на
единицу.

SETcc (Установить  значение байта  в зависимости  от условия  cc) загружает
значение 1  в байт,  если условие  cc истинно,  в противном  случае очищает
байт. Смотри Приложение D для определения всех возможных условий.


`д`к3.4.6  Команда проверки  `*

TEST (Проверить)  выполняет логическое  "and" для  двух операндов,  очищает
флаги OF и CF, оставляя  флаг AF неопределенным и обновляя  значения флагов
SF,  ZF  и  PF.  Флаги  могут  быть  проверены  командами условной передачи
управления или  командами установки  значения байта  по условию. Операндами
служат байты, слова или двойные слова.
Разница между командами TEST и AND  заключается в том, что команда TEST  не
изменяет значение операнда  назначения. Разница между  командами TEST и  BT
заключается в  том, что  TEST может  проверять значения  множества битов за
одну операцию, в то время как команда BT проверяет один бит.


`д`к3.5  Команды передачи управления `*

Процессор  i486  поддерживает  команды  как  условной,  так  и  безусловной
передачи управления  для контроля  за ходом  выполнения программы.  Команды
условной передачи  управления выполняются  только для  некоторых комбинаций
состояния  флагов.  Команды  безусловной  передачи  управления  выполняются
всегда.


`д`к3.5.1  Команды безусловной передачи управления.`*

Команды  JMP,  CALL,  RET,  INT  и  IRET  передают  выполнение  адресату  в
программном сегменте.  Адресат может  находиться как  в том  же программном
сегменте (близкая передача), так  и в другом программном  сегменте (дальняя
передача). Форматы команд, которые  передают управление в другие  сегменты,
обсуждаются  в  следующем  разделе  данной  главы.  Если модель организации
памяти,  используемая  в  некоторой  прикладной  программе,  не   позволяет
программисту   видеть   другие   сегменты,   дальняя   передача  управления
использоваться не должна.

`д`к3.5.1.1  Команда перехода  `*

JMP  (Переход)  безусловно  передает   управление  адресату.  Команда   JMP
является однонаправленной  командой передачи  управления; она  не сохраняет
адрес возврата в стеке.

Команда JMP передает  управление из текущей  процедуры в другую  процедуру.
Адрес процедуры  указывается непосредственно  в команде,  в регистре  или в
ячейке памяти. Местоположение адреса определяет, интерпретируется ли  адрес
как относительный адрес или как абсолютный адрес.

Относительный   адрес.    Относительный   переход    использует    смещение
(непосредственная константа, используемая  при вычислении адреса)  заданное
в команде.  Смещение имеет  знак и  длину (байт  или двойное  слово). Адрес
назначения  формируется  путем  сложения  смещения  и адреса, хранящегося в
регистре EIP. После этого в  регистре EIP будет содержаться адрес  команды,
которая должна выполняться после команды перехода.

Абсолютный адрес. Абсолютный переход используется с 32-разрядным  смещением
одним из следующих способов :

1.  Программа  может  выполнять  переход   по  адресу  в  регистре   общего
назначения.  Это  32-разрядное   значение  копируется  в   регистр  EIP   и
выполнение продолжается.

2.  Адресат  назначения  может  быть  переменной  в  памяти,  указанной   с
использованием сдандартного режима адресации. Операнд копируется в  регистр
EIP и выполнение продолжается.


`д`к3.5.1.2  Команды вызова процедур`*

CALL  (Вызов  процедуры)  передает  управление  и  сохраняет адрес команды,
следующей  за  командой  CALL,  для  дальнейшего использования командой RET
(Возврат). CALL сохраняет текущее содержимое регистра EIP в стеке.  Команда
RET  в  вызванной  процедуре  использует  этот  адрес  в стеке для передачи
управления назад в вызывающую программу.

Команды CALL и JMP имеют абсолютный и относительный форматы.

Косвенная  команда  CALL  указывает  абсолютный  адрес  одним  из следующих
способов :

1.  Программа  может  выполнить  переход   по  адресу  в  регистре   общего
назначения. 32-разрядное значение копируется в регистр EIP, адрес  возврата
сохраняется в стеке и выполнение продолжается.

2.  Адресат  назначения  может  быть  переменной  в  памяти,  указанной   с
использованием стандартного режима адресации. Операнд копируется в  регистр
EIP, адрес возврата сохраняется в стеке и выполнение продолжается.


`д`к3.5.1.3  Команды возврата и возврата-из-прерывания `*

RET  (Возврат  из  процедуры)  завершает  выполнение  процедуры  и передает
управление  команде,  следующей  за  командой  CALL, которая вызвала данную
процедуру.  Команда  RET  восстанавливает  содержимое регистра EIP, которое
было сохранено в стеке при вызове процедуры.

Команда RET имеет необязательный операнд непосредственного значения.  Когда
операнд имеется,  эта константа  прибавляется к  содержимому регистра  ESP,
что  имеет  эффект  удаления  всех  параметров,  сохраненных  в стеке перед
вызовом процедуры.

IRET (Возврат  из прерывания)  возвращает управление  прерванной процедуре.
Команда  IRET  отличается  от  команды  RET  тем,  что  она восстанавливает
содержимое   регистра   EFLAGS   из   стека.   Содержимое  регистра  EFLAGS
запоминается в стеке при возникновении прерывания.


`д`к3.5.2  Команды условной передачи управления`*

Команды условной передачи управления являются переходами, которые  передают
управление,  если  состояния   регистра  EFLAGS  удоволетворяет   условиям,
заданным в команде.


`д`к3.5.2.1  Команды условного перехода. `*

В Таблице  3-3 приведена  мнемоника команд  перехода. Команды,  приведенные
парами,  являются  альтернативными  именами  одной  и  той же команды. Язык
ассемблера поддерживает эти имена для большей ясности листингов программ.

Разрешена форма  команды условного  перехода, которая  использует смещение,
суммируемое  с  содержимым  регистра  EIP,  если  указанное  условие верно.
Смещение может  быть байтом  или двойным  словом. Смещение  имеет знак; оно
может быть использовано для перехода вперед и назад.

┌──────────────────────────────────────────────────────────────┐
│             Условные переходы без знака                      │
├───────────┬─────────────────┬────────────────────────────────┤
│ Мнемоника │  Статус флагов  │           Описание             │
├───────────┼─────────────────┼────────────────────────────────┤
│ JA/JNBE   │ (CF or ZF) = 0  │ выше/не ниже не равно          │
│ JAE/JNB   │ CF = 0          │ выше или равно/не ниже         │
│ JB/JNAE   │ CF = 1          │ ниже/не выше не равно          │
│ JBE/JNA   │ (CF or ZF) = 1  │ ниже или равно/не выше         │
│ JC        │ CF = 1          │ перенос                        │
│ JE/JZ     │ ZF = 1          │ равно/ноль                     │
│ JNC       │ CF = 0          │ нет переноса                   │
│ JNE/JNZ   │ ZF = 0          │ не равно/не ноль               │
│ JNP/JPO   │ PF = 0          │ нет четности/нечетное          │
│ JP/JPE    │ PF = 1          │ четность/четное                │
├───────────┴─────────────────┴────────────────────────────────┤
│             Условные переходы со знаком                      │
├───────────┬─────────────────┬────────────────────────────────┤
│ JG/JNLE   │((SF xor OF)     │ больше/не меньше не равно      │
│           │  or ZF) = 0     │ больше или равно/не меньше     │
│ JGE/JNL   │ (SF xor OF) = 0 │ меньше/не больше не равно      │
│ JL/JNGE   │ (SF xor OF) = 1 │ меньше или равно/не больше     │
│ JLE/JNG   │((SF xor OF)     │ нет переполнения               │
│           │  or ZF) = 1     │ нет знака (неотрицательное)    │
│ JNO       │ OF = 0          │ переполнение                   │
│ JNS       │ SF = 1          │ знак (отрицательное)           │
│ JO        │ OF = 1          │                                │
│ JS        │ SF = 1          │                                │
└───────────┴─────────────────┴────────────────────────────────┘

         Таблица 3-3. Команды условного перехода.


`д`к3.5.2.2  Команды управления циклом`*

Команды управления  циклом являются  командами условного  перехода, которые
используют значение, помещенное  в регистр ECX,  в качестве счетчика  числа
выполнений тела  цикла. Все  команды управления  циклом уменьшают  значение
регистра ECX при каждом выполнении цикла и завершают работу при  достижении
значения ноль. Четыре  из пяти команд  управления циклом воспринимают  флаг
ZF  в  качестве  условия  завершения  цикла до момента достижения счетчиком
цикла значения ноль.

LOOP (Цикл до тех пор, пока  ECX не равен нулю) является командой  условной
передачи  управления,  которая  уменьшает  содержимое  регистра  ECX  перед
проверкой условия  завершения цикла.  Если содержимое  регистра ECX отлично
от нуля, программа  передает управление по  адресу, указанному в  команде в
качестве адреса назначения (приемника). Команда LOOP приводит к  выполнению
части программы,  которое повторяется  до тех  пор, пока  счетчик не станет
равным  нулю.  Когда  достигается  значение  нуля,  выполнение   передается
команде,  следующей  непосредственно  за   командой  LOOP.  Если   значение
регистра ECX равняется нулю  перед первым выполнением цикла,  счетчик цикла
умеьшается  на  1,  регистру  присваивается  значение  0FFFFFFFFH  и   цикл
выполняется 2**32 раза.

LOOPE (Цикл  до тех  пор, пока  равенство) и  LOOPZ (Цикл  до тех пор, пока
ноль) являются  синонимами одной  и той  же команды.  Эти команды  являются
командами  условного  перехода,  которые  уменьшают содержимое регистра ECX
перед проверкой  условия завершения  цикла. Если  значение регистра  ECX не
равно нулю и установлен флаг  ZF, программа передает управление по  адресу,
указанному  в  качестве  операнда  назначения  в  команде. Когда достигнуто
значение нуля или флаг ZF очищен, выполнение передается команде,  следующей
непосредственно за командой LOOPE/ LOOPZ.

LOOPNE (Цикл до тех пор, пока неравенство) и LOOPNZ (Цикл до тех пор,  пока
не ноль) являются синонимами одной  и той же команды. Эти  команды являются
командами  условного  перехода,  которые  уменьшают содержимое регистра ECX
перед проверкой  условия завершения  цикла. Если  значение регистра  ECX не
равно  нулю  и  очищен  флаг  ZF,  программа передает управление по адресу,
указанному  в  качестве  операнда  назначения  в  команде. Когда достигнуто
значение  нуля  или  флаг  ZF  установлен,  выполнение  передается команде,
следующей непосредственно за командой LOOPNE /LOOPNZ.


`д`к3.5.2.3.  Выполнение цикла или повтор ноль раз`*

JECXZ (Переход,  если ECX  равен нулю)  переходит по  адресу, указанному  в

команде  в  качестве  операнда  назначения,  если в регистре ECX содержится
значение ноль.  Команда JECXZ  используется совместно  с командой  LOOP и с
командами сканирования строки  и сравнения. Так  как эти команды  уменьшают
значение  регистра  ECX  перед  проверкой  на  ноль, цикл будет выполняться
2**32  раза,  если  обращение  к  циклу  произошло,  когда  в  регистре ECX
содержалось значение ноль. Команда JECXZ используется для создания  циклов,
которые пропускаются  без выполнения,  если начальное  значение равно нулю.
Команда  JECXZ  в  начале  цикла  может  быть  использована для перехода за
пределы цикла, если значение  счетчика цикла равняется нулю.  Когда команда
используется  вместе  с  повторяющимся  командами  сканирования  строки   и
сравнения, JECXZ  может определить  условие окончания  цикла до  достижения
счетчиком  значения  нуля  или  до  выполнения  условий  сканирования   или
сравнения.


`д`к3.5.3  Программные прерывания. `*

Команды  INT,  INTO  и  BOUND  позволяют программисту осуществлять передачу
управления программе обработки прерываний или исключениям.

INTn  (Программное  прерывание)  вызывает  программу  обработки,  указанную
вектором прерываний, заданным в  команде. Команда INT может  задавать любые
типы прерываний.  Эта команда  используется для  поддержки множества  типов
программных  прерываний   или  для   проверки  работы   сервисных  программ
обработки прерываний. Сервисные программы обработки прерываний  завершаются
командой  IRET,  которая  передает  управление  к  команде,  следующей   за
командой INT.

INTO (Прерывание по  переполнению) вызывает программу  обработки исключений
по  переполнению,  если  установлен  флаг  OF.  Если  данный  флаг  очищен,
выполнение   продолжается   без   вызова   программы   обработки.  Флаг  OF
устанавливается арифметическими и логическими командами и командами  работы
со   строками.   Команда   INTO   поддерживает   использование  программных
прерываний  для  обработки  ошибочных  ситуаций,  таких, как арифметическое
переполнение.

BOUND  (Обнаружить  выход  значения   за  допустимые  границы)   сравнивает
значение со знаком,  хранящееся в регистре  общего назначения, с  верхним и
нижним  пределами.  Программа  обработки  исключений  по контролю выхода за
допустимые  границы  вызывается,  если  значение,  содержащееся в регистре,
меньше чем  нижняя граница,  или больше  чем верхняя  граница. Эта  команда
поддерживает использование  программных прерываний  для контроля  выхода за
допустимые границы, таких как  проверка индекса массива, чтобы  убедиться в
том, что он попадает в диапазон границ, заданный для массива.

Команда BOUND имеет два  операнда. Первый операнд указывает  регистр общего
назначения, который необходимо проверить. Второй операнд указывает  базовый
адрес  двух  слов  или  двух  двойных  слов,  расположенных  по соседству в
памяти.  Нижней  границей  является  слово  или  двойное  слово  с  младшим
адресом, верхняя граница имеет  старший адрес. Команда BOUND  предполагает,
что верхнее граничное  значение и нижнее  граничное значение расположены  в
смежных  ячейках   памяти.  Верхняя   и  нижняя   граница  не   могут  быть
операндами-регистрами; если же они таковыми являются, возникает  исключение
по неверному коду операции.

Верхняя  и  нижняя  границы  массива  могут  располагаться в памяти даже до
самого  массива.  Это  позволяет  задавать  границы  массива как постоянное
смещение  относительно  начала  массива.  Так  как адрес массива уже должен
находиться  в  регистре,  такая  практика позволяет избежать дополнительных
циклов шины для получения эффективной адресации границ массива.


`д`к3.6  Команды работы со строками  `*

Команды  работы  со  строками  работают  с  большими  структурами  данных в
памяти,  такими,  как  алфавитно-цифровые  строки  символов.  Смотри  также
раздел, посвященный Вводу/Выводу, для получения более подробной  информации
относительно  команд  Ввода/Вывода  строк  (иногда  их  называют   блочными
командами Ввода/Вывода).
Работа со строками может выполняться посредством команд работы со  строками
(которые выполняют только  одну итерацию для  каждой операции) совместно  с
другими возможностями команд  процессора, такими, как  префиксы повторения.
Команды работы со строками :

MOVS - Переслать строку.
CMPS - Сравнить строки.
SCAS - Сканировать строку.
LODS - Загрузить строку.
STOC - Запомнить строку.

После выполнения  команды работы  со строкой,  регистры строки-источника  и
строки-приемника  указывают  на  следуюшие  элементы  в  этих  строках. Эти
регистры  автоматически   увеличивают  или   уменьшают  свои   значения  на

количество байт,  занятых каждым  элементом строки.  Элементом строки может
быть байт, слово или двойное слово. Строчными регистрами являются :

ESI - Регистр индекса источника.
EDI - Регистр индекса приемника.

Операции  работы  со  строками  могут  начинаться  со  старших  адресов   и
выполняться  по  направлению  к  младшим  адресам,  или  могут начинаться с
младших  адресов   и  выполняться   по  направлению   к  старшим   адресам.
Направление выполнения управляется флагом :

DF - Флаг направления.

Если  флаг  DF  очищен,  регистры  увеличиваются.  Если  флаг   установлен,
регистры уменьшаются. Следующие команды устанавливают и очищают флаг :

STD - Команда установки флага направления.
CLD - Команда очистки флага направления.

Для того, чтобы  выполнить операции более  чем над одним  элементом строки,
должны использоваться префиксы повторения, такие как:

REP - Повторять до тех пор, пока регистр ECX не равен нулю.

REPE/REPZ  -  Повторять  до  тех  пор,  пока  регистр  ECX  не равен нулю и
установлен флаг ZF.

REPNE/REPNZ - Повторять до тех пор,  пока регистр ECX не равен нулю  и флаг
ZF очищен.

Исключения  и  прерывания,  которые  могут  возникать в процессе выполнения
команд  работы  со  строками,  сохраняют  регистры в таком состоянии, чтобы
команда  работы  со  строкой  могла  быть  повторена.  Регистры источника и
приемника указывают на следующие  элементы строк, регистр EIP  указывает на
команду работы со  строкой и регистр  ECX содержит значение,  сохраненное в
нем  со  времени  последней  успешной  итерации.  Все,  что  необходимо для
повторного запуска операции -  это обработать прерывание или  зафиксировать
источник исключения, затем выполнить команду IRET.


`д`к3.6.1 Префиксы повторения. `*

Префиксы  повторения  REP  (Повторять,  пока  ECX не равен нулю), REPE/REPZ
(Повторять  пока  равно/ноль)  и  REPNE/REPNZ  (Повторять  пока не равно/не
ноль) задают повторяющееся выполнение команд работы со строками. Эта  форма
итераций позволяет операциям работы  со строками работать быстрее,  чем это
возможно при организации программных циклов.
Когда  у  команды  работы  со  строкой имеется префикс повторения, операция
выполняется  до  тех  пор,  пока  одно  из  условий окончания, определяемое
префиксом, не будет выполнено.
Для каждого повторения команды работа со строкой может быть  приостановлена
прерыванием  или  исключением.  После  того,  как прерывание или исключение
было обработано, операция работы над  строкой может быть продолжена с  того
места,  на  котором  она  была  приостановлена.  Этот  механизм   позволяет
выполнять  длинные  операции  над  строками  без  влияния  на время отклика
системы на прерывание.
Все  три   префикса,  приведенные   в  Таблице   3-4,  принуждают   команду
выполняться до тех пор, пока  значение регистра ECX не уменьшится  до нуля,
если  ни  одно  из  других  условия  окончания  работы  не будет выполнено.
Префиксы  повторения  отличаются  друг  от  друга  по  своим дополнительным
условиям  окончания  работы.  Префикс  REP  не имеет дополнительных условий
окончания. Префиксы  REPE/REPZ и  REPNE/REPNZ используются  исключительно с
командами  SCAS  (Сканировать  строку)  и  CMPS  (Сравнить строки). Префикс
REPE/REPZ  заканчивает  работу,  если  флаг  ZF очищен. Префикс REPNE/REPNZ
заканчивает  работу,  если   флаг  ZF  установлен.   Флаг  ZF  не   требует
предварительной  инициализации  перед   выполнением  повторяющихся   команд
работы  со  строками,  так  как  и  SCAS  и  CMPS воздействуют на флаг ZF в
соответствие с результатами сравнения, которое они выполнили.

┌─────────────────┬─────────────────────┬─────────────────────┐
│ Префикс повтора │ Условие окончания 1 │ Условие окончания 2 │
├─────────────────┼─────────────────────┼─────────────────────┤
│  REP            │    ECX = 0          │    отсутствует      │
│  REPE/REPZ      │    ECX = 0          │    ZF = 0           │
│  REPNE/REPNZ    │    ECX = 0          │    ZF = 1           │
└─────────────────┴─────────────────────┴─────────────────────┘
                 Таблица 3-4. Команды повтора.

`д`к3.6.2  Флаги управления индексированием и направлением `*

Хотя   регистры   общего   назначения   в   большинстве  случаев  полностью
взаимозаменяемы,  команды  работы  со  строками  требуют использования двух
специальных регистров.  Строки источнока  и приемника  находятся в  памяти,
адресуемой   регистрами   ESI   и    EDI.   Регистр   ESI   указывает    на
операнд-источник.  По   умолчанию,  регистр   ESI  используется   вместе  с
сегментным  регистром  DS.  Префикс  замены сегмента позволяет использовать
регистр ESI вместе с сегментными регистрами CS, SS, ES, FS или GS.  Регистр
EDI  указывает  на  операнд  назначения.  Он использует сегмент, на который
который указывает сегментный регистр  ES; замена этого сегмента  запрещена.
Использование  двух   различных  сегментных   регистров  в   одной  команде
позволяет работать со строками, расположенными в различных сегментах.
Когда в командах  работы со строками  используются регистры ESI  и EDI, они
автоматически  увеличиваются   или  уменьшаются   после  каждой   итерации.
Действия  над  строками  можно  начинать  выполнять  со  старших адресов по
направлению  к  младшим  адресам,  или  они  могут  выполняться,  начиная с
младших  адресов  по  направлению  к  старшим адресам. Направление операций
управляется флагом DF. Если флаг очищен, значения регистров  увеличиваются.
Если флаг  установлен, значения  регистров уменьшаются.  Команды STD  и CLD
устанавливают и  очищают этот  флаг. Программисты  всегда должны  поместить
нужное  значение  во  флаг  DF,  прежде  чем использовать команды работы со
строками.

`д`к3.6.3  Команды  работы  со  строками`*

MOVS   (Переслать    строку)  перемещает   элемент   строки,     адресуемый
регистром   ESI   в   позицию,  адрес  которой  указан   в   регистре  EDI.
Команда MOVEB перемещает байты, команда  MOVEW перемещает слова  и  команда
MOVED   перемещает  двойные  слова.   Команда  MOVE,  когда  она  дополнена
префиксом  REP, работает как пересылка блоков  из памяти  в   память.   Для
выполнения   этой    операции   программа должна  инициализировать регистры
ECX, ESI и  EDI. Регистр ECX  указывает количество элементов    в    блоке.
CMPS     (Сравнение     строк)  вычитает      элемент  строки-приемника  из
элемента строки-источника   и обновляет   флаги AF,   SF, PF,  CF и  OF. Ни
один  из   элементов  не  будет  записан  обратно  в память.  Если элементы
строки   равны, устанавлиавется  флаг ZF;   в противном   случае этот  флаг
очищается.   CMPSB   сравнивает  байты,   CMPSW  сравнивает  слова  и CMPSD
сравнивает  двойные  слова.   SCAS (Сканировать  строку)  вычитает  элемент
строки-приемника  из  регистра EAX,  AX  или  AL  (в  зависимости от  длины
операнда) и  обновляет флаги AF, SF,  ZF, PF  и OF.  Строка и  регистры  не
изменяются.  Если  значения равны,  устанавливается  флаг  ZF; в  противном
случае   флаг   очищается.   Команда   SCASB   сканирует   байты,   команда
SCASW сканирует слова  и команда SCASD  сканирует  двойные  слова.    Когда
префиксы REPE/REPZ   или REPNE/REPNZ   модифицируют   команду   SCAS    или
CMPS, сформированный при  этом цикл заканчивается  либо по счетчику  цикла,
либо  по тому воздействию,  которое  команды  SCAS  или  CMPS оказывают  на
флаг ZF.  LODS  (Загрузить   строку)  помещает  элемент   строки-источника,
на который  указывает адрес  в регистре  ESI, в  регистр EAX  для строк  из
двойных слов,  в  регистр AX  для  строк  из слов   или в  регистр  AL  для
строк из байтов. Эта команда используется обычно внутри  цикла, где  другие
команды  обрабатывают  каждый  элемент  строки   по  мере  его  появления в
регистре.   STOS (Запомнить  строку) помещает  элемент   строки из регистра
EAX, AX или AL в строку,   на которую указывает адрес в регистре   EDI. Эта
команда  обычно  используется   в  цикле,  где   она  записывает   в память
результат обработки   элемента строки,  считанного из   памяти при   помощи
команды  LODS.   Команда    REP'STOS  является   самым  быстрым    способом
инициализации большого блока  памяти.


`д`к3.7  Команды для  языков  с  блочной  структурой`*

Эти   команды   обеспечивают     поддержку  машинно-ориентированным  языком
языков с  блочной структурой, таких, как   Cи или Паскаль. Они  включают  в
себя   команды ENTER  и   LEAVE, которые  упрощают вход   в   процедуру   и
выход   из    нее   в  созданном    компилятором  коде.  Они   поддерживают
структуру   указателей  (пойнтеров)   и   локальных  переменных  в   стеке,
называемую  кадром стека.  ENTER (Вход  в процедуру)  создает  кадр  стека,
совместимый с контекстными правилами языков  с блочной структурой.  В  этих
языках   процедура   имеет доступ   к   своим   собственным   переменным  и
некоторому  количеству  других переменных,  определенных  где-либо  еще   в
программе.  Контекстом   процедуры  называется   множество  переменных,   к
которым  процедура  имеет  доступ.  Правила   контекста различны для разных
языков; они могут  основываться  на   вложенности  процедур,   на   делении
программы  на отдельно    скомпилированные   файлы    или   на    некоторых
других  схемах подразделения на модули.  Команда ENTER имеет два  операнда.
Первый   операнд  указывает  на   количество  байт,  которое  должно   быть
зарезервированно в  стеке для динамического хранения данных в процедуре,  в
которую будет  осуществлен вход. Динамическим хранением называется  память,
отведенная для   переменных, создаваемых  в   тот момент,   когда процедура
вызвана,  известных    также,  как  автоматические    переменные.    Второй
параметр   является  лексическим  уровнем  вложенности   (от   0   до   31)

процедуры.   Уровень  вложенности  -  это  глубина  процедуры   в  иерархии
блочно-структурированной   программы.     Лексический  уровень   не   имеет
никакого   отношения   ни   к   уровню   привилегированности  защиты,  ни к
уровню привилегированности Ввода/Вывода.  Лексический  уровень  вложенности
определяет  число  указателей   кадров  стека,  которые   надо  скопировать
в   новый кадр   стека из   предыдущего кадра.   Указателем на  кадр  стека
является   двойное   слово,   используемое   для   доступа   к   переменным
процедуры.    Множество    указателей    на    кадры  стека,   используемых
процедурой для  доступа    к  переменным    других  процедур,    называется
отображением (данных).  Первое   двойное  слово   в  отображении   является
указателем   на предыдущий   кадр   стек.   Этот   указатель   используется
командой  LEAVЕ  для аннулирования   результата  действий   команды   ENTER
путем    отмены  текущего   кадра  стека.    Пример   :  ENTER   2048,3   .
Зарезервировать  2Кбайт   динамической  памяти   в   стеке   и   установить
указатели   на  два  предыдущих  кадра  стека  в  кадре  стека   для   этой
процедуры.    После того,   как команда   ENTER создаст  отображение    для
процедуры,   она    размещает    динамические  (автоматические)   локальные
переменные  для  данной   процедуры  путем уменьшения содержимого  регистра
ESP   на  количество   байт,  заданное   в  первом   параметре.  Это  новое
значение  регистра  ESP  служит  в  качестве  начального  значения верхушки
стека для  всех операций  PUSH и  POP   внутри процедуры.   Для того, чтобы
позволить процедуре   адресовать   (обращаться)   к   своему   отображению,
команда  ENTER  предоставляет   регистру     EBP   указывать     на  первое
двойное  слово    в отображении.  Так  как стеки  увеличиваются вниз,   это
действительно  двойное  слово  с   самым  старшим   адресом в  отображении.
Команды   работы с   данными, которые  указывают регистр  EBP   в  качестве
базового регистра,  автоматически адресуют позиции  внутри сегмента   стека
вместо  сегмента  данных.    Команда ENTER может  быть  использована  двумя
способами:  вложенным и не  вложенным.   Если  лексический  уровень   равен
0,   используется   не  вложенная  форма.  Не  вложенная   форма  сохраняет
содержимое  регистра  EBP   в  стеке,  копирует  содержимое  регистра   ESP
в  регистр  EBP  и  вычитает  первый  операнд из содержимого регистра  ESP,
для   того,  чтобы  разместить  динамическую   память.   Не вложенная форма
отличается  от   вложенной  тем,  что  не  копируются  никакие указатели на
кадры  стека.   Вложенная  форма  команды  ENTER   появляется  тогда, когда
второй параметр   (лексический уровень)  не   равен нулю.    Рисунок   3-15
показывает  определения    форматов   команды    ENTER.  STORAGE    -   это
количество   байт   динамической    памяти   для    размещения    локальных
переменных,  и   LEVEL  -  это  лексический  уровень  вложенности.  Главная
процедура (в  которую   вложены все   остальные   процедуры)   работает  на
самом  старшем  лексическом  уровне,  уровне   1.   Следующая    процедура,
которую   она  вызывает,  работает  на  более  глубоком лексическом уровне,
уровне 2. Процедура  уровня 2  может  получать доступ к переменным  главной
процедуры,  которые  находятся  в   зафиксированном  положении,   указанном
компилятором.  В   случае  уровня   1  команда    ENTER резервирует  только
запрошенную динамическую  память в  стеке, так  как нет никаких  предыдущих
отображений, которые следовало бы скопировать.

┌──────────────────────────────────────────────────────────────┐
│                                                              │
│                           Сохранить EBP                      │
│                           Установить временное значение      │
│                              FRAME_PTR равным ESP            │
│                           IF LEVEL = 0, то                   │
│                              Повторять (LEVEL - 1) раз       │
│                                  EBP := EBP -4               │
│                                Сохранить в стеке двойное     │
│                          слово, на которое указывает EBP     │
│                              Конец повтора                   │
│                              Восстановить FRAME_PTR          │
│                           END IF                             │
│                           EBP := FRAME_PTR                   │
│                           ESP := ESP - STORAGE               │
│                                                              │
└──────────────────────────────────────────────────────────────┘

        Рисунок 3-15. Определение формата команды ENTER.


Процедура, которая  вызывает другую  процедуру на  более низком лексическом
уровне,  дает   вызванной  процедуре   возможность  доступа   к  переменным
вызвавшей  ее  процедуры.  Команда  ENTER  обеспечивает  этот  доступ путем
размещения указателя на кадр стека вызывающей процедуры в отображении.
Процедура, которая вызывает другую процедуру на том же лексическом  уровне,
не  дает  возможности  доступа  к  своим  переменным. В этом случае команда
ENTER копирует  только ту  часть отображения  вызывающей процедуры, которая
относится к  предыдущим вложенным  процедурам, работающим  на более высоких
лексических уровнях. Новый кадр  стека не содержит указателя  для адресации
кадра стека вызвавшей процедуры.
Команда ENTER интерпретирует реентерабельную процедуру как вызов  процедуры
на  том  же  лексическом  уровне.  В  этом случае каждая следующая итерация
реентерабельной  процедуры  может  адресоваться  только к своим собственным

переменным   и   переменным   процедур,   внутри   которых   она   вложена.
Реентерабельная  процедура   всегда  может   адресовать  свои   собственные
переменные; ей не требуется для этого указателей на кадры стека  предыдущих
итераций.
Путем  копирования  только  указателей  на  кадры  стека  процедур на более
высоких лексических  уровнях команда  ENTER добивается  того, что процедуры
получают доступ только к  переменным более высоких лексических  уровней, но
не к переменным параллельных лексических уровней (смотри Рисунок 3-16).


┌─────────────────────────────────────────────────────────────┐
│                                                             │
│                                                             │
│   ┌─────────────────────────────────────────────────────┐   │
│   │          ГЛАВНАЯ ПРОГРАММА (УРОВЕНЬ 1)              │   │
│   │  ┌───────────────────────────────────────────────┐  │   │
│   │  │           ПРОЦЕДУРА А (УРОВЕНЬ 2)             │  │   │
│   │  │ ┌───────────────────────────────────────────┐ │  │   │
│   │  │ │         ПРОЦЕДУРА B (УРОВЕНЬ 3)           │ │  │   │
│   │  │ └───────────────────────────────────────────┘ │  │   │
│   │  │                                               │  │   │
│   │  │ ┌───────────────────────────────────────────┐ │  │   │
│   │  │ │         ПРОЦЕДУРА C (УРОВЕНЬ 3)           │ │  │   │
│   │  │ │ ┌─────────────────────────────────────┐   │ │  │   │
│   │  │ │ │       ПРОЦЕДУРА D (УРОВЕНЬ 4)       │   │ │  │   │
│   │  │ │ └─────────────────────────────────────┘   │ │  │   │
│   │  │ │                                           │ │  │   │
│   │  │ └───────────────────────────────────────────┘ │  │   │
│   │  │                                               │  │   │
│   │  └───────────────────────────────────────────────┘  │   │
│   │                                                     │   │
│   │                                                     │   │
│   └─────────────────────────────────────────────────────┘   │
│                                                             │
│                                                             │
└─────────────────────────────────────────────────────────────┘

               Рисунок 3-16. Вложенные процедуры.

Языки программирования с блочной структурой могут использовать  лексический
уровень вложенности, определенный  командой ENTER, для  управления доступом
к переменным  вложенных процедур.  На рисунке,  например, если  ПРОЦЕДУРА A
вызывает ПРОЦЕДУРУ B, которая, в свою очередь, вызывает ПРОЦЕДУРУ C,  тогда
ПРОЦЕДУРА C получит  доступ к переменным  ГЛАВНОЙ ПРОГРАММЫ и  ПРОЦЕДУРЫ A,
но не к переменным ПРОЦЕДУРЫ C, так  как они расположены ма одном и том  же
лексическом  уровне.  Следующее  определение  описывает доступ к переменным
для вложенных процедур на Рисунок 3-16 :

1. ГЛАВНАЯ ПРОГРАММА имеет переменные на фиксированных позициях.

2.  ПРОЦЕДУРА  A  может  получать   доступ  к  переменным  только   ГЛАВНОЙ
ПРОГРАММЫ.

3. ПРОЦЕДУРА  B может  получить доступ  только к  переменным ПРОЦЕДУРЫ  A и
ГЛАВНОЙ  ПРОГРАММЫ.  ПРОЦЕДУРА  B  не  может  получить  доступ к переменным
ПРОЦЕДУРЫ C или ПРОЦЕДУРЫ D.

4. ПРОЦЕДУРА  C может  получить доступ  только к  переменным ПРОЦЕДУРЫ  A и
ГЛАВНОЙ  ПРОГРАММЫ.  ПРОЦЕДУРА  C  не  может  получить  доступ к переменным
ПРОЦЕДУРЫ B или ПРОЦЕДУРЫ D.

5. ПРОЦЕДУРА D может получить доступ к переменным ПРОЦЕДУРЫ C, ПРОЦЕДУРЫ  A
и ГЛАВНОЙ  ПРОЦЕДУРЫ. ПРОЦЕДУРА  D не  может получить  доступ к  переменным
ПРОЦЕДУРЫ B.

На следующей  диаграмме команда  ENTER в  начале ГЛАВНОЙ  программы создает
три  двойных  слова  динамической  памяти  для  ГЛАВНОЙ  программы,  но  не
копирует никаких указателей из  других кадров стека (смотри  Рисунок 3-17).
Первое  двойное  слово  в  отображении  содержит  копию последнего значения
регистра EBP перед  тем, как была  выполнена команда ENTER.  Второе двойное
слово (которое,  так как  стек растет  вниз, хранится  по младшему  адресу)
содержит  копию  содержимого  регистра  EBP  следом  за выполнением команды
ENTER. После  того, как  команда была  выполнена, регистр  EBP указывает на
первое  двойное  слово,  сохраненное  в  стеке,  и регистр ESP указывает на
последнее двойное слово в кадре стека.

┌─────────────────────────────────────────────────────────────┐
│                                                             │
│                                                             │
│                       ┌────────────────────────────┐        │
│                       ├────────────────────────────┤        │
│                       ├────────────────────────────┤        │
│                   ┌───│         СТАРОЕ EBP         │──EBP  │
│      ОТОБРАЖЕНИЕ  │   ├────────────────────────────┤        │
│                   └───│  EBP из ГЛАВНОЙ программы  │        │
│                       ├────────────────────────────┤        │
│                   ┌───│                            │        │
│      ДИНАМИЧЕСКАЯ │   ├────────────────────────────┤        │
│      ПАМЯТЬ       │   ├────────────────────────────┤        │
│                   └───│                            │──ESP  │
│                       ├────────────────────────────┤        │
│                       ├────────────────────────────┤        │
│                       └────────────────────────────┘        │
│                                                             │
│                                                             │
└─────────────────────────────────────────────────────────────┘
   Рисунок 3-17. Стек данных после запуска ГЛАВНОЙ программы.


Когда ГЛАВНАЯ программа вызывает  ПРОЦЕДУРУ А, команда ENTER  создает новое
отображение  (смотри  Рисунок  3-18).  Первое  двойное  слово  -  последнее
значение, содержавшееся  в регистре  EBP ГЛАВНОЙ  программы. Второе двойное
слово - указатель  на кадр стека  ГЛАВНОЙ программы, который  скопирован из
второго двойного слова отображения в ГЛАВНОЙ программе. Это слово в  данной
ситуации  является  другой  копией  последнего  значения,  содержавшегося в
регистре  EBP  в  ГЛАВНОЙ  программе.  ПРОЦЕДУРА  А может получить доступ к
переменным  ГЛАВНОЙ  программы,  так  как  ГЛАВНАЯ  программа  находится на
уровне 1.  Более того,  базовый адрес  динамической памяти,  используемой в
ГЛАВНОЙ  программе,  является  текущим  адресом  в регистре EBP плюс четыре
байта дополнительно  для сохраненного  содержимого регистра  EBP в  ГЛАВНОЙ
программе. Все динамические переменные  для ГЛАВНОЙ программы находятся  на
фиксированном положительном смещении относительно этого значения.

┌─────────────────────────────────────────────────────────────┐
│                                                             │
│                                                             │
│                       ┌────────────────────────────┐        │
│                       ├────────────────────────────┤        │
│                       ├────────────────────────────┤        │
│                       │         СТАРОЕ EBP         │        │
│                       ├────────────────────────────┤        │
│                       │  EBP из ГЛАВНОЙ программы  │        │
│                       ├────────────────────────────┤        │
│                       ├────────────────────────────┤        │
│                       ├────────────────────────────┤        │
│                       ├────────────────────────────┤        │
│                   ┌───│  EBP из ГЛАВНОЙ программы  │──EBP  │
│                   │   ├────────────────────────────┤        │
│      ОТОБРАЖЕНИЕ  │   │  EBP из ГЛАВНОЙ программы  │        │
│                   │   ├────────────────────────────┤        │
│                   └───│  EBP из ПРОЦЕДУРЫ А        │        │
│                       ├────────────────────────────┤        │
│                   ┌───│                            │        │
│      ДИНАМИЧЕСКАЯ │   ├────────────────────────────┤        │
│      ПАМЯТЬ       │   ├────────────────────────────┤        │
│                   └───│                            │──ESP  │
│                       ├────────────────────────────┤        │
│                       ├────────────────────────────┤        │
│                       └────────────────────────────┘        │
│                                                             │
│                                                             │
└─────────────────────────────────────────────────────────────┘
      Рисунок 3-18. Стек данных после запуска ПРОЦЕДУРЫ А


Когда  ПРОЦЕДУРА  А  вызывает  ПРОЦЕДУРУ  B,  команда  ENTER  создает новое
отображение  (смотри  Рисунок  3-19).  Первое  двойное слово содержит копию
последнего значения  регистра EBP  в ПРОЦЕДУРЕ  А. Второе  и третье двойные
слова  являются  копиями  двух  указателей  на  кадр  стека в отображении в
ПРОЦЕДУРЕ А. ПРОЦЕДУРА B может  получать доступ к переменным ПРОЦЕДУРЫ  А и
ГЛАВНОЙ программы  путем использования  указателей на  кадры стека  в своем
отображении.

┌─────────────────────────────────────────────────────────────┐
│                                                             │
│                                                             │
│                       ┌────────────────────────────┐        │
│                       ├────────────────────────────┤        │
│                       ├────────────────────────────┤        │
│                       │         СТАРОЕ EBP         │        │
│                       ├────────────────────────────┤        │
│                       │  EBP из ГЛАВНОЙ программы  │        │
│                       ├────────────────────────────┤        │
│                       ├────────────────────────────┤        │
│                       ├────────────────────────────┤        │
│                       ├────────────────────────────┤        │
│                       │  EBP из ГЛАВНОЙ программы  │        │
│                       ├────────────────────────────┤        │
│                       │  EBP из ГЛАВНОЙ программы  │        │
│                       ├────────────────────────────┤        │
│                       │  EBP из ПРОЦЕДУРЫ А        │        │
│                       ├────────────────────────────┤        │
│                       ├────────────────────────────┤        │
│                       ├────────────────────────────┤        │
│                       ├────────────────────────────┤        │
│                   ┌───│  EBP из ПРОЦЕДУРЫ А        │──EBP  │
│                   │   ├────────────────────────────┤        │
│                   │   │  EBP из ГЛАВНОЙ программы  │        │
│      ОТОБРАЖЕНИЕ  │   ├────────────────────────────┤        │
│                   │   │  EBP из ПРОЦЕДУРЫ А        │        │
│                   │   ├────────────────────────────┤        │
│                   └───│  EBP из ПРОЦЕДУРЫ B        │        │
│                       ├────────────────────────────┤        │
│                   ┌───│                            │        │
│      ДИНАМИЧЕСКАЯ │   ├────────────────────────────┤        │
│      ПАМЯТЬ       │   ├────────────────────────────┤        │
│                   └───│                            │──ESP  │
│                       ├────────────────────────────┤        │
│                       ├────────────────────────────┤        │
│                       └────────────────────────────┘        │
│                                                             │
│                                                             │
└─────────────────────────────────────────────────────────────┘

      Рисунок 3-19. Стек данных после запуска ПРОЦЕДУРЫ B


Когда  ПРОЦЕДУРА  B  вызывает  ПРОЦЕДУРУ  С,  команда  ENTER  создает новое
отображение для  ПРОЦЕДУРЫ С  (смотри Рисунок  3-20). Первое  двойное слово
содержит копию последнего  значения регистра EBP  в ПРОЦЕДУРЕ B.  Оно будет
использовано командой  LEAVE для  восстановления кадра  стека ПРОЦЕДУРЫ  B.
Второе и третье  двойные слова являются  копиями указателей кадров  стека в
отображении ПРОЦЕДУРЫ А. Если  ПРОЦЕДУРА С находится на  лексическом уровне
следующей  глубины  по  отношению  к  ПРОЦЕДУРЕ  B, четвертое двойное слово
будет  скопировано,  и  оно  будет  указателем  на кадр стека для локальных
переменных ПРОЦЕДУРЫ B.

┌─────────────────────────────────────────────────────────────┐
│                                                             │
│                                                             │
│                       ┌────────────────────────────┐        │
│                       ├────────────────────────────┤        │
│                       ├────────────────────────────┤        │
│                       │         СТАРОЕ EBP         │        │
│                       ├────────────────────────────┤        │
│                       │  EBP из ГЛАВНОЙ программы  │        │
│                       ├────────────────────────────┤        │
│                       ├────────────────────────────┤        │
│                       ├────────────────────────────┤        │
│                       ├────────────────────────────┤        │
│                       │  EBP из ГЛАВНОЙ программы  │        │
│                       ├────────────────────────────┤        │
│                       │  EBP из ГЛАВНОЙ программы  │        │
│                       ├────────────────────────────┤        │
│                       │  EBP из ПРОЦЕДУРЫ А        │        │
│                       ├────────────────────────────┤        │
│                       ├────────────────────────────┤        │
│                       ├────────────────────────────┤        │
│                       ├────────────────────────────┤        │
│                       │  EBP из ПРОЦЕДУРЫ А        │        │
│                       ├────────────────────────────┤        │
│                       │  EBP из ГЛАВНОЙ программы  │        │
│                       ├────────────────────────────┤        │
│                       │  EBP из ПРОЦЕДУРЫ А        │        │
│                       ├────────────────────────────┤        │
│                       │  EBP из ПРОЦЕДУРЫ B        │        │

│                       ├────────────────────────────┤        │
│                       ├────────────────────────────┤        │
│                       ├────────────────────────────┤        │
│                       ├────────────────────────────┤        │
│                   ┌───│  EBP из ПРОЦЕДУРЫ B        │──EBP  │
│                   │   ├────────────────────────────┤        │
│                   │   │  EBP из ГЛАВНОЙ программы  │        │
│      ОТОБРАЖЕНИЕ  │   ├────────────────────────────┤        │
│                   │   │  EBP из ПРОЦЕДУРЫ А        │        │
│                   │   ├────────────────────────────┤        │
│                   └───│  EBP из ПРОЦЕДУРЫ B        │        │
│                       ├────────────────────────────┤        │
│                   ┌───│                            │        │
│      ДИНАМИЧЕСКАЯ │   ├────────────────────────────┤        │
│      ПАМЯТЬ       │   ├────────────────────────────┤        │
│                   └───│                            │──ESP  │
│                       ├────────────────────────────┤        │
│                       ├────────────────────────────┤        │
│                       └────────────────────────────┘        │
│                                                             │
│                                                             │
└─────────────────────────────────────────────────────────────┘
      Рисунок 3-20. Стек данных после запуска ПРОЦЕДУРЫ C

Обратите внимание, что ПРОЦЕДУРА B и  ПРОЦЕДУРА С находятся на одном и  том
же уровне, поэтому  для ПРОЦЕДУРЫ С  не предполагается доступ  к переменным
ПРОЦЕДУРЫ B.  Это не  означает, что  ПРОЦЕДУРА С  полностью изолирована  от
ПРОЦЕДУРЫ  B;  ПРОЦЕДУРА  С  вызывается  ПРОЦЕДУРОЙ B, поэтому указатель на
возвращаемый кадр стека  является указателем на  кадр стека ПРОЦЕДУРЫ  B. В
дополнение к  этому ПРОЦЕДУРА  B может  передавать параметры  в ПРОЦЕДУРЫ С
как через  стек, так  и через  переменные, глобальные  по отношению к обоим
процедурам (т.е. переменные сферы действия обоих процедур).

LEAVE (Выйти из процедуры)  противоположна по действию описанной  перед ней
команде ENTER.  Команда LEAVE  не имеет  операндов. Команда  LEAVE копирует
содержимое  регистра  EBP  в  регистр  ESP  для  того, чтобы освободить все
стековое  пространство,  зарезервированное  для  процедуры.  Затем  команда
LEAVE восстанавливает старое значение  регистра EBP из стека.  Одновременно
восстанавливается  исходное  значение  регистра  ESP. Следующая команда RET
затем может удалить любые аргументы и адреса возврата, сохраненные в  стеке
вызываемой программой для использования в процедуре.


`д`к3.8  Команды управления флагами. `*

Команды управления  флагами изменяют  состояние битов  регистра EFLAGS, как
показано в Таблице 3-5.

┌────────────────────────────────────┬──────────────────────┐
│             Команда                │      Результат       │
├────────────────────────────────────┼──────────────────────┤
│ STC (Установить флаг переноса)     │  CF ── 1            │
│ CLC (Очистить флаг переноса)       │  CF ── 0            │
│ CMC (Дополнить флаг переноса)      │  CF ── - (CF)       │
│ CLD (Очистить флаг направления)    │  DF ── 0            │
│ STD (Установить флаг направления)  │  DF ── 1            │
└────────────────────────────────────┴──────────────────────┘
         Tаблица 3-5. Команды управления флагами.



`д`к3.8.1  Команды управления флагами переноса и управления. `*

Команды  работы  с  флагом   переноса  используются  вместе  с   командами,
аналогичными командам циклического сдвига с переносом RCL и RCR. Они  могут
инициировать  флаг  переноса  CF  в  известное  состояние перед выполнением
команды, которая копирует флаг в операнд.
Команды  управления  флагом  направления  устанавливают  или  очищают  флаг
направления DF, который управляет направлением обработки строки. Если  флаг
DF очищен, процессор увеличивает регистры  индекса строк, ESI и EDI,  после
каждой  итерации  команды  обработки  строки.  Если  флаг  DF   установлен,
процессор уменьшает эти индексные регистры.


`д`к3.8.2  Команды пересылки флага.`*

Хотя и  существуют специальные  команды для  изменения флагов  CF и DF, нет
прямых  методов   изменения  для   остальных  флагов,   ориентированных  на
использование  в  прикладном  программировании.  Команды  пересылки   флага
позволяют  программе  изменять  состояние  других  флагов  с использованием
команд манипуляций с битами, если  только эти флаги были перемещены  в стек
или в регистр AH.

Команды LAHF и SAHF работают с пятью флагами статуса, которые  используются
прежде всего арифметическими и логическими командами.

LAHF (Загрузить регистр AH из флагов) копирует флаги SF, ZF, AF, PF и CF  в
регистр  AH,  биты  7,6,4,2  и  0  соответственно  (смотри  Рисунок  3-21).
Содержимое оставшихся  битов 5,3,  и 1  остается неопределенным. Содержимое
регистра EFLAGS остается неизменным.

SAHF (Сохранить значения регистра AH во флагах) копирует биты 7,6,4,2, и  0
во флаги SF, ZF, AF, PF и CF соответственно (смотри Рисунок 3-21).

Kоманды PUSHF и POPF  не только рекомендуется использовать  для запоминания
значения  флагов  в  памяти,  где  они  могут быть проверены и изменены, но
также рекомендуется использовать  для сохранения состояния  регистра EFLAGS
при выполнении подпрограмм.


┌──────────────────────────────────────────────────────────────┐
│                                                              │
│                     7 6 5 4 3 2 1 0                          │
│                    ┌─┬─┬─┬─┬─┬─┬─┬─┐                         │
│                    │S│Z│0│A│0│P│1│C│                         │
│                    │F│F│ │F│ │F│ │F│                         │
│                    └─┴─┴─┴─┴─┴─┴─┴─┘                         │
│                                                              │
│  БИТОВЫЕ ПОЗИЦИИ ФЛАГОВ ТЕ ЖЕ САМЫЕ, ЧТО И ИХ ПОЗИЦИИ В РЕ-  │
│  ГИСТРЕ EFLAGS ИЛИ В РЕГИСТРЕ AH. БИТОВЫЕ ПОЗИЦИИ, ПОКАЗАН-  │
│  НЫЕ КАК 0 ИЛИ 1, ЯВЛЯЮТСЯ ПОЗИЦИЯМИ, ЗАРЕЗЕРВИРОВАННЫМИ     │
│  КОМПАНИЕЙ INTEL (R). ЭТИ ПОЗИЦИИ ИСПОЛЬЗОВАТЬ ЗАПРЕЩЕНО.    │
│                                                              │
└──────────────────────────────────────────────────────────────┘

         Рисунок 3-21. Младший байт регистра EFLAGS.


PUSHF (Сохранить  флаги) сохраняет  младшее слово  регистра EFLAGS  в стеке
(смотри Рисунок 3-22).  Команда PUSHFD сохраняет  целиком регистр EFLAGS  в
стеке (тем не менее флаг RF читается как очищенный).

POPF  (Восстановить  флаги  из  стека)  восстанавливает  слово  из  стека в
регистр EFLAGS.  При всех  использованиях этой  команды изменяются значения
только  битов  14,11,10,8,7,6,4,2  и  0.  Если  уровень привилегированности
данного программного сегмента равен 0 (самый привилегированный), биты  IOPL
(13 и  12) также  изменяются. Если  уровень привилегий  Ввода/Вывода (IOPL)
равен  0,   то  изменяется   также  флаг   IF  (бит   9).  Команда    POPFD
восстанавливает  двойное  слово  из  стека  в  регистр  EFLAGS, и она может
изменять состояние флага AС (бит 18)  так же, как и всех битов,  изменяемых
по команде POPF.

┌─────────────────────────────────────────────────────────────────┐
│                                                                 │
│                                                  PUSHFD/POPFD   │
│ │<───────────────────────────────────────────────────────────>│ │
│                                                                 │
│                                                    PUSHF/POPF   │
│ │<───────────────────────────────────────────────────────────>│ │
│  31                              15                          0  │
│ ┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐ │
│ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │I│ │ │ │ │ │ │ │ │ │ │ │ │ │
│ │ │ │ │ │ │ │ │ │ │ │ │ │ │A│N│R│ │N│O│O│D│I│T│S│Z│ │A│ │P│ │C│ │
│ │0│0│0│0│0│0│0│0│0│0│0│0│0│C│M│F│0│T│P│F│F│F│F│F│F│0│F│0│F│1│F│ │
│ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │L│ │ │ │ │ │ │ │ │ │ │ │ │ │
│ └─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘ │
│                                                                 │
│ БИТОВЫЕ ПОЗИЦИИ, ПОМЕЧЕННЫЕ 0 ИЛИ 1, ЗАРЕЗЕРВИРОВАНЫ КОМПАНИЕЙ  │
│ INTEL (R). ИСПОЛЬЗОВАНИЕ ПОЗИЦИЙ ЗАПРЕЩЕНО.                     │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘

   Рисунок 3-22. Флаги, используемые командами PUSHF и POPF


`д`к3.9  Числовые команды`*

Процессор  i486  включает  в  себя  аппаратуру  и  команды  для  выполнения
высокоточных  числовых  операций  над  множеством  числовых  типов  данных,
включая  80-разрядное  расширенное  вещественное  и  64-разрядное   длинное
целое. Возможно выполнение  арифметических команд, трансцендентных  команд,
команд  сравнения  и  преобразования  типов  данных.  Также  поддерживаются
значения  часто  используемых  в   вычислениях  констант,  чтобы   повысить
скорость числовых вычислений.
Числовые  команды  встроены  в  поток  команд  процессора i486, поэтому они
выполняются  одним   и  тем   же  устройство,   имеющим  возможности    как

целогочисленного  процессора,   так  и   возможности  процессора   чисел  с
плавающей запятой.  Но в  действительности устройство  работы с  чиселами с
плавающей   запятой   ЦПУ   i486   работает   параллельно  с  целочисленным
устройством, достигая при этом наивысшей производительности.

ЧАСТЬ  III,  Главы  14-18  данного  руководства,  более  подробно описывают
числовые команды.


`д`к3.10  Команды работы с сегментными регистрами`*

Существует несколько различных типов команд, которые используют  сегментные
регистры. Здесь они  сгруппированы все вместе,  так как, если  разработчики
системы выберут  несегментированную модель  организации памяти,  ни одна из
этих  команд  не  будет  использована.   Команды,  которые  имеют  дело   с
сегментными регистрами, таковы :

1. Команды пересылки сегмент-регистр.
MOV SegReg,...
MOV ...,SegReg
PUSH SegReg
POP SegReg

2. Передача управления другому выполнимому сегменту.
JMP дальний
CALL дальний
RET дальний

3. Команды работы с указателями данных.
LDS регистр, 48-разрядный операнд в памяти
LES регистр, 48-разрядный операнд в памяти
LFS регистр, 48-разрядный операнд в памяти
LGS регистр, 48-разрядный операнд в памяти
LSS регистр, 48-разрядный операнд в памяти

4. Обратите внимание на то, что следующие связанные с прерываниями  команды
также  используются  в  несегментированных  системах.  Хотя  они  и   могут
передавать  управление  между  сегментами,  когда используется сегментация,
они понятны прикладному программисту.
INT n
INTO
BOUND
IRET


`д`к3.10.1  Команды пересылки сегмент-регистр.  `*

Формы команд MOV, POP и  PUSH также используются для загрузки  и сохранения
сегментных  регистров.  Эти  формы  работают  как формы с регистрами общего
назначения, за исключением того, что один из операндов является  сегментным
регистром. Команда MOV не может копировать содержимое сегментного  регистра
в другой сегментный регистр.

Команды POP и MOV не могут поместить значение в регистр CS (сегмент  кода);
только  команды  дальней  передачи  управления  оказывают  воздействие   на
регистр  CS.  Когда  приемником   является  регистр  SS  (сегмент   стека),
запрещаются все прерывания до момента выполнения следующей команды.

В  процессоре  386(R)  DX  загрузка  сегментного регистра всегда приводит к
блокировке  циклов  чтения  и  записи  путем  установки  бита  доступа.   В
процессоре i486 блокировка циклов возникает  только в том случае, если  бит
доступа не был установлен ранее.

Не  требуется  никакого  16-разрядного  префикса  размерности  операнда при
передаче данных между сегментным регистром и 32-разрядным регистром  общего
назначения.


`д`к3.10.2  Команды дальней передачи управления. `*

Команды дальней передачи управления передают управление приемнику в  другом
сегменте  путем  замены  содержимого  регистра  CS.  Приемник  задается при
помощи  дальнего  указателя,   который  является  16-разрядным   селектором
сегмента и 32-разрядным смещением внутри сегмента. Дальний указатель  может
быть непосредственным значением или операндом в памяти.

Дальний   CALL.   Внутрисегментная   команда   CALL   помещает    значения,
содержащиеся в регистрах EIP и CS, в стек.

Дальний  RET.   Внутрисегментная  команда   RET  восстанавливает   значения
регистров CS и EIP из стека.

`д`к3.10.3  Команды работы указатель на данные`*

Команды  работы  с  указателями  загружают  дальний  указатель  в  регистры
процессора. Дальний указатель состоит из 16-разрядного селектора  сегмента,
который загружается в сегментный  регистр, и 32-разрядного смещения  внутри
сегмента, которое загружается в регистр общего назначения.

LDS  (Загрузить  указатель,  используя  DS)  копирует  дальний указатель из
операнда-источника  в   регистр  DS   и  в   регистр  общего    назначения.
Операнд-источник обязан  быть операндом,  расположенным в  ячейке памяти, и
операнд назначения должен быть регистром общего назначения.

Пример : LDS ESI, STRING_X

Загружает  в  регистр  DS  селектор  сегмента  для сегмента, адрес которого
задан в STRING_X, и загружает сдвиг внутри сегмента, адресуемого  STRING_X,
в регистр ESI. Задание регистра  ESI в качестве операнда назначения  удобно
при подготовке  к выполнению  операций со  строками, когда  строка-источник
находится не в текущем сегменте.

LES  (Загрузить  указатель,  используя  ES)  имеет  тот же результат, что и
команда  LDS,  за  исключением  того,  что  селектор сегмента загружается в
регистр ES, а не в регистр DS.

Пример : LES EDI, DESTINATION_X

Загружает  в  регистр  ES  селектор  сегмента  для сегмента, адрес которого
задан  в  DESTINATION_X,  и  загружает  сдвиг  внутри сегмента, адресуемого
DESTINATION_X, в регистр EDI. Эта команда является удобным способом  выбора
приемника  для   выполнения  команд   работы  со   строками,  если   нужное
местоположение находится вне текущего сегмента Е-данных.

LFS  (Загрузить  указатель,  используя  FS)  имеет  тот же результат, что и
команда LDS, за исключением того, что значение селектора сегмента  получает
регистр FS, а не регистр DS.

LGS  (Загрузить  указатель,  используя  GS)  имеет  тот же результат, что и
команда LDS, за исключением того, что значение селектора сегмента  получает
регистр GS, а не регистр DS.

LSS  (Загрузить  указатель,  используя  SS)  имеет  тот же результат, что и
команда  LDS,  за  исключением  того,  что  регистр  SS,  а  не регистр DS,
получает значение селектора сегмента.  Эта команда особенно важна,  так как
она позволяет двум  регистрам, идентифицирующим стек  (регистры SS и  ESP),
изменять свои значения за одну непрерываемую операцию. В отличие от  другух
команд,  которые  могут  загружать  значения  в  регистр  SS,  до окончания
выполнения команды  LSS прерывания  не подавляются.  Другие команды, такие,
как  POP  SS,  подавляют  прерывания  для  того,  чтобы позволить следующей
команде загрузить значение в регистр ESP без возникновения прерывания.  Так
как  обоим  регистрам,  и  SS,  и  ESP, могут быть присвоены значения одной
командой  LSS,  нет  необходимости   запрещать  и  затем  вновь   разрешать
появление прерываний.


`д`к3.11  Остальные команды`*

Следующие команды не  попадают ни в  одну из вышеприведенных  категорий, но
тем не менее не теряют своей значимости.

Команды BSWAP, XADD  и CMPXCHG отсутствуют  на микропроцессорах 386  DX или
386 SX. ЦПУ 386 может выполнять аналогичные операции в командах  умножения.
Для того,  чтобы использовать  эти команды,  всегда включайте функционально
эквивалентный  код  для  ЦПУ  386.  Используйте код, приведенный на Рисунок
3-23 для определения, могут ли данные команды быть использованы.

┌────────────────────────────────────────────────────────────────┐
│ $title ("Определяет идентификатор ЦПУ для ЦПУ 386 или i486")   │
│                                                                │
│     name   CPU_ID                                              │
│     public   is386                                             │
│                                                                │
│ code     segment       er public use32                         │
│ ;                                                              │
│ ; Идентифицирует текущий тип ЦПУ, на котором выполняется работа│
│ ; Возвращает значения EAX=0 для ЦПУ i486, или EAX=1 для ЦПУ 386│
│ ; Оставляет неизмененными ESP, EBP, EBH, ESI и EDI             │
│ is386     proc      near                                       │
│     mov    edx,esp           ; сохраняет значение текущего     │
│                              ; указателя стека для             │
│                              ; выравнивания его                │

│     and    esp,not 3         ; выравнивает стек для            │
│                              ; избежания ошибки AC             │
│     pushfd                   ; сохраняет   EFLAGS              │
│     pop    eax               ; получает из стека значение EAX  │
│     mov    ecx, eax          ; сохраняет исходное значение     │
│                              ; EFLAGS                          │
│     xor    eax, 40000H       ; перебрасывает на противоположное│
│                              ; значение бита АС                │
│     push   eax               ; копирует в EFLAGS               │
│     popfd                                                      │
│     pushfd                   ; получает новое значение EFLAGS  │
│     pop    eax               ; помещает в EAX                  │
│     xor    eax, ecx          ; проверяет, если бит АС изменен, │
│                              ; ЕАХ=4000Н, если процессор 386,  │
│                              ; 0, если процессор i486          │
│     shr    eax, 18           ; устанавливает ЕАХ=1, если ЦПУ   │
│                              ; 386, 0, если ЦПУ i486           │
│     and    eax, 1            ; игнорирует все остальные биты   │
│     push   ecx                                                 │
│     popfd                    ; восстанавливает исходное        │
│                              ; значение регистра EFLAGS        │
│     mov    esp, edx          ; восстанавливает исходное        │
│                              ; значение указателя стека        │
│     ret                                                        │
│ is386      endp                                                │
│                                                                │
│ code       ends                                                │
│     end                                                        │
└────────────────────────────────────────────────────────────────┘

         Рисунок 3-23 Код для определения CPU_ID


`д`к3.11.1  Команда вычисления адреса `*

LEA   (Загрузить   эффективный    адрес)   помещает   32-разрядный    сдвиг
операнда-источника в  памяти (а  не его  содержимое) в  операнд назначения.
Операнд-источник должен  находиться в  памяти, и  операнд назначения должен
быть  регистром  общего  назначения.  Эта  команда  особенно  полезна   для
инициализации  регистров  ESI  и  EDI  перед  выполнением  команд работы со
строками или инициализации  регистра EBX перед  командой XLAT. Команда  LEA
может выполнять любое необходимое индексирование или масштабирование.

Пример : LEA EBX, EBCDIC_TABLE

Заставляет процессор поместить адрес начальной позиции таблицы,  помеченной
как EBCDIC_TABLE, в EBX.


`д`к3.11.2  Команда нет-операции`*

NOP  (Нет-операции)   занимает  байт   пространства  кода.   Когда  команда
выполняется,  она  увеличивает  регистр  EIP  так,  чтобы  он  указывал  на
следующую команду, но не имеет более никакого действия.


`д`к3.11.3  Команда трансляции.`*

XLATB (Транслировать)  заменяет содержимое  регистра AL  на байт, считанный
из таблицы  трансляции в  памяти. Содержимое  регистра AL  интерпретируется
как целый  без знака  индекс в  этой таблице,  с использованием содержимого
регистра EBX в качестве базового адреса. Команда XLAT делает то же самое  и
загружает  результат  в  тот  же  регистр,  но она получает байт-операнд из
памяти.  Эта  функция  используется  для  преобразования  кодов символов из
одного алфавита в  другой. Например, код  ASCII мовет быть  использован для
получения своего эквивалента в кодах EBCDIC.


`д`к3.11.4  Команда перестановки байтов.`*

BSWAP (Переставить байты) меняет порядок байтов в 32-разрядном  регистровом
операнде.  Битовые  позиции  7..0  меняются  местами  с позициями 31..24, и
позиции 15..8 меняются местами с позициями 23..16. Эта команда полезна  при
преобразованиях форматов данных "big-endian" и "little-endian".  Выполнение
команды BSWAP два  раза подряд оставляет  значение регистра без  изменений.
Эта  команда  также  ускоряет   выполнение  команд  десятичной   арифметики
посредством  работы  с  четырьмя  разрядами  за  один  раз, как показано на
Рисунок  3-24.  Смотри  введение  в  раздел 3.11 относительно использования
команды BSWAP на процессоре 386.

`д`к3.11.5  Команда заменить-и-сложить`*

XADD  (Заменить  и  сложить)  использует  два  операнда: операнд-источник в
регистре и  операнд назначения  в регистре  или в  памяти. Операнд-источник
заменяется на операнд назначения, и приемник заменяется на сумму  источника
и  приемника.  Флаги  отражают  результат  сложения. Эта команда может быть
объединена с  командой LOCK  в многопроцессорной  системе, чтобы  позволить
множеству  процессоров  выполнять  один  цикл  действий.  Смотри введение в
раздел 3.11 относительно использования команды XADD на процессоре 386.


`д`к3.11.6  Команда сравнить-и-заменить `*

CMPXCHG (Сравнить и заменить) использует три операнда : операнд-источник  в
регистре, операнд назначения  в регистре или  в памяти и  аккумулятор (т.е.
регистр  AL,  AX  или  EAX  в  зависимости  от размерности операндов). Если
значения в приемнике  и в накопителе  равны, операнд назначения  заменяется
на  источник.  В  противном  случае  исходное  значение операнда назначения
загружается в накопитель. Флаги отражают результат, который получается  при
вычитании  операнда  назначения  из  аккумулятора. Флаг ZF устанавливается,
если значения операнда  назначения и накопителя  равны, в противном  случае
флаг очищается.

Команда  CMPXCHG  полезна  при  тестировании  и  модификации семафоров. Она
выполняет проверку, чтобы посмотреть, свободен  ли семафор и есть ли  такая
отметка,  в  противном  случае  команда  получает  идентификатор   текущего
владельца в одной  непрерываемой операции. В  системах с одним  процессором
она  исключает  необходимость  переключения  на  уровень  0  для блокировки
прерываний  для  выполнения  многократных  команд.  Для   многопроцессорных
систем  команда  CMPXVHG  может  быть   объединена  с  командой  LOCK   для
выполнения всех циклов  шины автоматически. Смотри  введение в раздел  3.11
относительно использования команды CMPXCHG на процессоре 386.

┌──────────────────────────────────────────────────────────────┐
│                                                              │
│ $title   ('ASCII сложение/вычитание с использованием BSWAP') │
│                                                              │
│    name        ASCII_arith                                   │
│                                                              │
│ code    segment      er public use32                         │
│ ;                                                            │
│ ; Сложить 4 десятичных цифры в ASCII-строке все вместе       │
│ ; Старшим полубайтом ДОЛЖЕН быть 3                           │
│ ; DS:[ESI] указывает на операнд 1                            │
│ ; DS:[EBX] указывает на операнд 2                            │
│ ; DS:[EDI] указывает на операнд назначения                   │
│ ;                                                            │
│                                                              │
│ add10    proc       near                                     │
│                                                              │
│ ;                                                            │
│ ; Выполняет ASCII сложение с использованием команды BSWAP на │
│ ; процессоре i486                                            │
│ ;                                                            │
│                                                              │
│   mov     eax,[esi]        ; получает младшие четыре цифры   │
│                            ; первого операнда                │
│   bswap   eax              ; преобразует в форму big-endian  │
│   add     eax,96969696H    ; выравнивает для сложения        │
│   mov     ecx,[ebx]        ; получает четыре младшие цифры   │
│                            ; второго операнда                │
│   bswap   ecx              ; преобразует в форму big-endian  │
│   add     eax,ecx          ; выполняет сложение с внутрираз- │
│                            ; рядным переносом                │
│   rcr     ch,1             ; сохраняет флаг переноса         │
│   mov     edx,eax          ; сохраняет значение              │
│   and     eax,0F0F0F0F0H   ; извлекает старший полубайт      │
│   sub     edx,eax          ; заполняет нулями старший        │
│                            ; полубайт каждого байта          │
│   shr     eax,4            ; подготавливает для фиксации     │
│   and     eax,0A0A0A0AH    ; если ненулевой старший полу-    │
│                            ; байт, то сформоровать 10 как    │
│                            ; выравнивающее значение для      │
│                            ; младшего полубайта              │
│   add     eax,edx          ; формируется выровненное значе-  │
│                            ; ние младшего полубайта, старшие │
│                            ; полубайты могут быть 1 из       │
│                            ; выравнивания                    │
│   or      eax,30303030H    ; преобразовать обратно в ASCII   │
│   bswap   eax              ; обратно в форму little-endian   │
│   mov     [edi],eax        ; установить значение приемника   │

│   rcl     ch,1             ; восстановить флаг перенос       │
│   ret                                                        │
│                                                              │
│ add10     endp                                               │
│                                                              │
│ ;                                                            │
│ ; Вычесть 4 десятичных цифры в ASCII-строке все вместе       │
│ ; Старшим полубайтом ДОЛЖЕН быть 3                           │
│ ; DS:[ESI] указывает на операнд 1                            │
│ ; DS:[EBX] указывает на операнд 2   [ESI]-[EBX]              │
│ ; DS:[EDI] указывает на операнд назначения                   │
│ ;                                                            │
│                                                              │
│ sub10    proc     near                                       │
│                                                              │
│ ;                                                            │
│ ; Выполняет ASCII вычитание с использованием команды BSWAP на│
│ ; процессоре i486                                            │
│ ;                                                            │
│                                                              │
│   mov     eax,[esi]        ; получает младшие четыре цифры   │
│                            ; первого операнда                │
│   bswap   eax              ; преобразует в форму big-endian  │
│   mov     ecx,[ebx]        ; получает четыре младшие цифры   │
│                            ; второго операнда                │
│   bswap   ecx              ; преобразует в форму big-endian  │
│   sub     eax,ecx          ; выполняет вычитание с исполь-   │
│                            ; зованием внутриразрядного заема │
│                            ; единицы                         │
│   rcr     ch,1             ; сохраняет флаг переноса         │
│   mov     edx,eax          ; сохраняет значение              │
│   and     eax,0F0F0F0F0H   ; извлекает старший полубайт, F,  │
│                            ; если возникает заем единицы     │
│   sub     edx,eax          ; заполняет нулями старший        │
│                            ; полубайт каждого байта          │
│   shr     eax,4            ; подготавливает для фиксации     │
│   and     eax,0A0A0A0AH    ; если ненулевой старший полу-    │
│                            ; байт, то сформоровать 10 как    │
│                            ; выравнивающее значение для      │
│                            ; младшего полубайта              │
│   add     eax,edx          ; формируется выровненное значе-  │
│                            ; ние младшего полубайта, старшие │
│                            ; полубайты могут быть 1 из       │
│                            ; выравнивания                    │
│   or      eax,30303030H    ; преобразовать обратно в ASCII   │
│   bswap   eax              ; обратно в форму little-endian   │
│   mov     [edi],eax        ; установить значение приемника   │
│   rcl     ch,1             ; восстановить флаг заема единицы │
│   ret                                                        │
│                                                              │
│ sub10     endp                                               │
│                                                              │
│ code      ends                                               │
│   end                                                        │
│                                                              │
└──────────────────────────────────────────────────────────────┘
Рисунок 3-24. ASCII арифметика с использованием команды BSWAP
