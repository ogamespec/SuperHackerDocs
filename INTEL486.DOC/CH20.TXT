`м`дГлава 20.  Примеры вычислительного программирования`*
--------------------------------------------------------------------------

В следующем  разделе приведены  примеры программ  вычислительного характера
для  процессора  i486,  написанные  на  ассемблере  ASM386/486. Эти примеры
иллюстрируют  некоторые  полезные  приемы  для  разработки   вычислительных
программных продуктов и систем на основе процессора i486.


`д`к20.1  Пример условного ветвления`*

Как уже обсуждалось в Главе 15, различные числовые команды воздействуют  на
биты кода  условия слова  состояния модуля  обработки операций  с плавающей
точкой,  хотя  существует  множество  способов  для того, чтобы реализовать
условное  ветвление,  следующее  за  сравнением.  Далее  приведен  основной
подход:

- Выполнить сравнение.
- Сохранить слово состояния.  (Слово состояния модуля обработки  операций с
плавающей точкой можно сохранить прямо в регистре AX.)
- Проверить биты кода условия.
- Перейти по результату.

На Рисунке 20-1 представлен  фрагмент программы, который иллюстрирует,  как
можно  сравнить  два  находящиеся  в  памяти  вещественные  числа  двойного
формата  (подобная  программа  может  быть  использована  с командой FTST).
Числа, которые  сравниваются в  этом фрагменте,  названы A  и B.   Операция
сравнения  требует  загрузки  числа  A  в вершину регистрового стека модуля
обработки операций с  плавающей точкой, а  затем сравнения его  с числом B,
выполняя  при  этом  операцию  восстановления  из  стека.  После чего слово
состояния  записывается  в  регистр  AX.   A  и  B  имеют  четыре возможных
порядка, а биты C3, C2 и C0 кода условия указывают, какой из этих  порядков
установлен. Три бита располагаются  в верхнем байте слова  состояния модуля
обработки операций  с плавающей  точкой так,  чтобы соответствовать  флагам
нуля, четности и переноса (ZF, PF и CF), когда байт записывается во  флаги.
Во фрагменте программы флаги ZF, PF и CF регистра EFLAGS устанавливаются  в
значения битов C3, C2 и  C0 слова состояния, а затем  используется операция
условного  перехода  для  того,   чтобы  проверить  флаги.   Результирующая
программа  очень  компактна  и  записывается  всего  лишь  в  семь  команд.
Команда  FXAM  обновляет  все  четыре  бита  кода  условия. На Рисунке 20-2
показано, как  таблица переходов  может быть  использована для  того, чтобы
определить  характер  просмотренных  величин.  Таблица переходов (FXAM_TBL)
содержит 16 меток, по одной  для каждого возможного кода условия.  Обратите
внимание,  что  четыре  значения  содержат  одно  и тоже - "EMPTY" (пусто).
Первые два значения кода условия соответствуют позиции "EMPTY". Два  другие
значения  в   таблице,  которые   содержат  "EMPTY",   никогда  не    будут
использованы процессором i486 или математическим сопроцессором 387(TM),  но
могут быть использованы при выполнении программы на сопроцессоре 80287.

┌───────────────────────────────────────────────────────────────┐
│        .                                                      │
│  A     DQ     ?                                               │
│  B     DQ     ?                                               │
│        .                                                      │
│        .                                                      │
│        FLD    A   ;  Загружает A в вершину стека FPU          │
│        FCOMP  B   ;  Сравнение A:B, выталкивание A            │
│        FSTSW  AX  ;  Сохраняет результат в регистре AX        │
│  ;                                                            │
│  ; Коды условия содержатся в регистре ЦПУ AX                  │
│  ;     (Результаты сравнения)                                 │
│  ; Загрузка кодов условия во флаги                            │
│  ;                                                            │
│        SAHF                                                   │
│  ;                                                            │
│  ; Использует условные переходы для того, чтобы               │
│  ; определить как упорядочены A и B                           │
│  ;                                                            │
│        JP  A_B_UNORDERED  ; Тестирование бита C2 (PF)         │
│        JB  A_LESS         ; Тестирование бита C0 (CF)         │
│        JE  A_EQUAL        ; Тестирование бита C3 (ZF)         │
│  A_GREATHER:              ; C0 (CF) = 0, C3 (ZF) = 0          │
│        .                                                      │
│        .                                                      │
│  A_EQUAL:                 ; C0 (CF) = 0, C3 (ZF) = 1          │
│        .                                                      │
│        .                                                      │
│  A_LESS:                  ; C0 (CF) = 1, C3 (ZF) = 0          │
│        .                                                      │
│        .                                                      │
│  A_UNORDERED:             ; C2 (PF) = 1                       │
│        .                                                      │
└───────────────────────────────────────────────────────────────┘
       Рисунок 20-1. Условное Ветвление при Сравнении

Фрагмент  программы  выполняет  команду  FXAM  и сохраняет слово состояния.
Затем идет манипуляция битами кода условия для окончательного вывода  числа
в  регистр  AX,  которое  равно  коду  условия,  умноженному на 2. При этом
включается обнуление  неиспользуемых битов  в байте,  который содержит код,
происходит сдвиг бита C3  вправо так, чтобы он  был соседним с битом  C2, и
затем происходит сдвиг кода для  того, чтобы умножить его на  2. Полученное
значение используется как индекс, по  которому выбирается одна из меток  из
таблицы  переходов  FXAM  TBL  (умножение  кода условия требуется из-за 2-х
байтной длины  каждого значения  в таблице).  Команда безусловного перехода
JMP  направляет  процессор  через  таблицу  переходов  к процедуре, которая
содержит  программу  (не  показанную  в  примере)  для  обработки   каждого
возможного результата каманды FXAM.


`д`к20.2  Примеры обработки исключений`*

Существует  множество  подходов  для  написания обработчиков исключительных
ситуаций.  Один   полезный  прием   -  это   сделать  процедуру   обработки
исключчений из трех  частей: "пролога", "тела"  и "эпилога". Эта  процедура
вызывается через прерывание номер 16.

┌───────────────────────────────────────────────────────────────┐
│                                                               │
│    ; Таблица переходов для процедуры проверки                 │
│    ;                                                          │
│    FXAM_TBL    DD POS_UNNORM, POS_NAN, NEG_UNNORM, NEG_NAN,   │
│    &           POS_NORM, POS_INFINITY, NEG_NORM,              │
│    &           NEG_INFINITY, POS_ZERO, EMPTY, NEG_ZERO,       │
│    &           EMPTY, POS_DENORM, EMPTY, NEG_DENORM, EMPTY    │
│         .                                                     │
│         .                                                     │
│    ; Проверить ST и сохранить результат (коды условия)        │
│    ;                                                          │
│         FXAM                                                  │
│         XOR   EAX, EAX   ; Очистить регистр EAX               │
│         FSTSW AX                                              │
│    ;                                                          │
│    ; Вычисление смещения в таблице переходов                  │
│    ;                                                          │
│         AND   AX, 0100011100000000B  ; Очистить все биты      │
│    ;                                   кроме C3, C2-C0        │
│         SHR   EAX, 6   ; Сдвинуть C2-C0 как (000XXX00)        │
│         SAL   AH, 5    ; Установить C3 как  (00X00000)        │
│         OR    AL, AH   ; Слить C3 и C2-C0   (00XXXX00)        │
│         XOR   AH, AH   ; Удалить старую копию C3              │
│    ;                                                          │
│    ; Перейти к процедуре по коду условия                      │
│    ;                                                          │
│         JMP   FXAM_TBL[EAX]                                   │
│    ;                                                          │
│    ; Метки таблицы перехода, по одной для обработки           │
│    ; каждого возможного результата FXAM                       │
│    ;                                                          │
│    POS_UNNORM:                                                │
│        .                                                      │
│    POS_NAN:                                                   │
│        .                                                      │
│    NEG_UNNORM:                                                │
│        .                                                      │
│    NEG_NAN:                                                   │
│        .                                                      │
│    POS_NORM:                                                  │
│        .                                                      │
│    POS_INFINITY:                                              │
│       .                                                       │
│    NEG_NORM:                                                  │
│        .                                                      │
│    NEG_INFINITY:                                              │
│        .                                                      │
│    POS_ZERO:                                                  │
│        .                                                      │
│    EMPTY:                                                     │
│        .                                                      │
│    NEG_ZERO:                                                  │
│        .                                                      │
│    POS_DENORM:                                                │
│        .                                                      │
│    NEG_DENORM:                                                │
│        .                                                      │
│                                                               │
└───────────────────────────────────────────────────────────────┘

       Рисунок 20-2. Условное Ветвление при Операции FXAM

При передаче управления на  процедуру обработки исключения, все  прерывания
запрещаются  аппаратным  способом.  Пролог  выполняет  все функции, которые
должны быть  защищены от  возможного прерывания  более высоким приоритетом.
Обычно это  сохранение регистров  и передача  диагностической информации из
модуля обработки  операций с  плавающй точкой  в память.  Когда критический
процесс будет завершен, пролог  может разрешить прерывания для  того, чтобы
позволить обработчикам прерываний  с более высоким  приоритетом выполниться
раньше обработчика исключения.
Тело  обработчика  исключения  просматривает  диагностическую  информацию и
реагирует на то, что необходимо  с точки зрения программного продукта.  Эта
реакция  может  иметь  диапазон  от  прерывания  выполнения для того, чтобы
выдать  сообщение,  до  попытки  уладить  неполадку и продолжить нормальное
выполнение.
Эпилог,  собственно,   выполняет  действия   обратные  прологу,   возвращая
процессор в  состояние, при  котором можно  было бы  возобновить нормальное
выполнение. Эпилог  не должен  загружать немаскированный  флаг исключения в
модуль обработки  операций с  плавающей точкой  или потребовать  немедленно
другой исключительной ситуации.
На  рисунках  от  Рисунка  20-3  до  Рисунка  20-5 показаны скелетные схемы
исходных кодов  на ассемблере  ASM386/486 трех  обработчиков исключительных
ситуаций. При этом демонстрируется как могут быть написаны пролог и  эпилог
в различных ситуациях,  а на месте,  где должно быть  помещено зависящее от
применения тело обработчика исключения, стоят комментарии.

┌───────────────────────────────────────────────────────────────┐
│                                                               │
│    SAVE_ALL        PROC                                       │
│    ;                                                          │
│    ; Сохранить регистры, занести                              │
│    ; отображение состояния FPU в стек                         │
│    ;                                                          │
│       PUSH  EBP                                               │
│       MOV   EBP, ESP                                          │
│       SUB   ESP, 108                                          │
│    ;                                                          │
│    ; Сохранить полное состояние FPU, разрешить прерывания     │
│    ;                                                          │
│       FNSAVE [EBP-108]                                        │
│       STI                                                     │
│    ;                                                          │
│    ; Далее следует программа обработчика исключений           │
│    ; в зависимости от цели обработки                          │
│    ;                                                          │
│    ; Очистить флаги исключений в слове состояния              │
│    ; (которое находится в памяти)                             │
│    ; Восстановить модифицированное отображение состояния      │
│    ;                                                          │
│       MOV     BYTE PTR [EBP-104], 0H                          │
│       FRSTOR  [EBP-108]                                       │
│    ;                                                          │
│    ; Освободить стек, восстановить регистры                   │
│    ;                                                          │
│       MOVE  ESP, EBP                                          │
│         .                                                     │
│         .                                                     │
│       POP   EBP                                               │
│    ;                                                          │
│    ; Вернуться к прерванным вычислениям                       │
│    ;                                                          │
│       IRET                                                    │
│    SAVE_ALL        ENDP                                       │
│                                                               │
└───────────────────────────────────────────────────────────────┘

 Рисунок 20-3. Обработчик Исключения Полного Состояния


┌───────────────────────────────────────────────────────────────┐
│                                                               │
│    SAVE_ENVIRONMENT  PROC                                     │
│    ;                                                          │
│    ; Сохранить регистры, занести                              │
│    ; окружение FPU в стек                                     │
│    ;                                                          │
│       PUSH  EBP                                               │
│                                                               │
│       MOV   EBP, ESP                                          │
│       SUB   ESP, 28                                           │
│    ;                                                          │
│    ; Сохранить окружение FPU, разрешить прерывания            │
│    ;                                                          │
│       FNSTENV [EBP-28]                                        │
│       STI                                                     │

│    ;                                                          │
│    ; Далее следует программа обработчика исключений           │
│    ; в зависимости от цели обработки                          │
│    ;                                                          │
│    ; Очистить флаги исключений в слове состояния              │
│    ; (которое находится в памяти)                             │
│    ; Восстановить модифицированное отображение окружения      │
│    ;                                                          │
│       MOV     BYTE PTR [EBP-24], 0H                           │
│       FLDENV  [EBP-28]                                        │
│    ;                                                          │
│    ; Освободить стек, восстановить регистры                   │
│    ;                                                          │
│       MOVE  ESP, EBP                                          │
│       POP   EBP                                               │
│    ;                                                          │
│    ; Вернуться к прерванным вычислениям                       │
│    ;                                                          │
│       IRET                                                    │
│    SAVE_ENVIRONMENT  ENDP                                     │
│                                                               │
└───────────────────────────────────────────────────────────────┘
 Рисунок 20-4. Обработчик Исключения Сокращенного Времени Ожидания


Тексты на Рисунках 20-3 и 20-4 очень похожи; их отличие заключается  только
в выборе команд для сохранения и восстановления состояния модуля  обработки
операций  с  плавающей  точкой.   Выбор  здесь  заключается  в   повышенной
диагностической  информации,  предоставляемой  командой  FNSAVE,  и   более
быстрым  выполнением   команды  FNSTENV.   Для  тех   приложений,   которые
чувствительны  к   времени  ожидания   прерывания  или   которым  не   надо
просматривать    содержимое    регистров,    команда    FNSTENV   сокращает
продолжительность "критической зоны", в течение которой процессор не  видит
требования других прерываний.
После  выполнения  тела   обработчика  исключения,  эпилог   приготавливает
процессор для  того, чтобы  продолжить выполнение  от точки  прерывания (то
есть,  команды,   следующей  за   той,  которая   создала   немаскированное
исключение).  Обратите  внимание,  что  флаги  исключения в памяти, которые
загружается в модуль  обработки операций с  плавающей точкой, обращаются  в
нуль  для  перезагрузки  (фактически,   в  этих  примерах  обнуляется   все
отображение слова состояния).
Примеры  на  Рисунках  20-3  и   20-4  предполагают,  что  сам   обработчик
исключения не  будет причиной  другой немаскируемого  исключения. Там,  где
это возможно,  можно применять  общий подход,  показанный на  Рисунке 20-5.
Основной прием  - сохранить  полное состояние  модуля обработки  операций с
плавающей  точкой  и  затем  загрузить  новое  управляющее слово в прологе.
Обращаем  ваше  внимание  на  то,  что  надо  быть  очень  осторожным   при
разработке  обработчиков  исключений  этого  типа  для  того, чтобы уберечь
обработчик от бесконечных обращений.

┌───────────────────────────────────────────────────────────────┐
│                                                               │
│            .                                                  │
│            .                                                  │
│            .                                                  │
│        LOCAL_CONTROL  DW  ?   ; Инициализировано              │
│            .                                                  │
│            .                                                  │
│            .                                                  │
│    REENTRANT       PROC                                       │
│    ;                                                          │
│    ; Сохранить регистры, занести                              │
│    ; отображение состояния FPU в стек                         │
│    ;                                                          │
│       PUSH  EBP                                               │
│         .                                                     │
│         .                                                     │
│         .                                                     │
│       MOV   EBP, ESP                                          │
│       SUB   ESP, 108                                          │
│    ;                                                          │
│    ; Сохранить полное состояние FPU, загрузить новое          │
│    ; управляющее слово, разрешить прерывания                  │
│    ;                                                          │
│       FNSAVE [EBP-108]                                        │
│       FLDCW  LOCAL_CONTROL                                    │
│       STI                                                     │
│         .                                                     │
│         .                                                     │

│         .                                                     │
│    ;                                                          │
│    ; Далее следует программа обработчика исключений           │
│    ; в зависимости от цели обработки                          │
│    ; Генерируемое здесь немаскированное исключение            │
│    ; будет причиной вызова обработчика исключений.            │
│    ; Если необходима локальная память, то можно               │
│    ; расположить данные в стеке.                              │
│         .                                                     │
│         .                                                     │
│         .                                                     │
│    ; Очистить флаги исключений в слове состояния              │
│    ; (которое находится в памяти)                             │
│    ; Восстановить модифицированное отображение состояния      │
│    ;                                                          │
│       MOV     BYTE PTR [EBP-104], 0H                          │
│       FRSTOR  [EBP-108]                                       │
│    ;                                                          │
│    ; Освободить стек, восстановить регистры                   │
│    ;                                                          │
│       MOVE  ESP, EBP                                          │
│         .                                                     │
│         .                                                     │
│       POP   EBP                                               │
│    ;                                                          │
│    ; Вернуться в точку, где произошло прерывание              │
│    ;                                                          │
│       IRET                                                    │
│    REENTRANT       ENDP                                       │
│                                                               │
└───────────────────────────────────────────────────────────────┘

 Рисунок 20-5. Реентерабельный Обработчик Исключений


`д`к20.3  Пример перевода числа с плавающей точкой в символьный вид  `*

Вычислительные  программы  должны  формировать  свои  результаты  для того,
чтобы  они  были  воспринимаемы   и  читаемы  пользователем  программы.   В
большинстве  случаев,  числовые  результаты  выводятся  как строки символов
ASCII для того, чтобы их можно было отпечатать или просмотреть на  дисплее.
Этот  пример  показывает,  как  величина  с  плавающей  точкой  может  быть
переведена  в  десятичную  строку  ASCII  символов.  Функция, показанная на
Рисунке  20-6,  может  быть  вызвана  из  программ  на языках PL/M-386/486,
Pascal386/486, FORTRAN-386/486 или ASM386/486.
При написании программы обращалось  внимание скорее на краткость,  скорость
и точность  выполнения, чем  на максимизацию  числа значащих  цифр. Сделана
попытка  оставить  целые  в  их   собственных  областях  для  того,   чтобы
предотвратить случайные ошибки при переводе чисел.
Используя  числа   в  вещественном   формате  расширенной   точности,   эта
подпрограмма достигает  в наихудшем  случае точности  три единицы  в 16-том
десятичном разряде для нецелелочисленных  величин или целых чисел,  больших
чем 10**(18). Это  двойная точность. Если  число имеет десятичный  порядок,
меньший  чем  100,  точность  составляет  одна  единица в 17-том десятичном
разряде.
Более  высокая  точность  может  быть  достигнута  при  больших затратах на
программирование, увеличении размера программы более низкой эффективности.


`д`к20.3.1  Составляющие части функции  `*

Перевод  чисел  реализуется  тремя  отдельными  модулями.  Главную   работу
выполняем  модуль   FLOATING  TO   ASCII  (Число   с  плавающей   точкой  в
ASCII-строку). Другие  модули представлены  отдельно, потому  что они имеют
более общее назначение.  Один из них,  GET POWER 10  (Взять степень 10-ти),
используется также и подпрограммой перевода чисел из ASCII вида в формат  с
плавающей точкой.  Другой маленький  модуль, TOP  STATUS (Состояние вершины
стека), идентифицирует то, что  находится в вершине числового  регистрового
стека.


`д`к20.3.2  Соглашения по исключениям  `*

Необходимо   предотвратить    функцию   от    генерирования   внутри    нее
исключительных  ситуаций.  Принимаются  любые  числовые  значения, при этом
только возможные исключения занимают стек числовых регистров.
Любое значение,  посланное в  числовой стек,  проверяется на существование,
тип (NaN или бесконечность) и состояние (денормальное, ноль, знак).  Размер
строки тестируется  при минимальном  и максимальном  значении. Если вершина
регистрового стека пуста или размер строки слишком мал, функция  возвращает
код ошибки.
Переполнение  и  отрицательное  переполнение  при  очень  больших или очень
маленьких числах предотврашаются внутри функции.

 Рисунок 20-6. Подпрограмма Перевода Чисел с Плавающей Точкой в ASCII Вид

┌─────────────────────────────────────────────────────────────────────────┐
│                                                                         │
│                                                                         │
│  SOURCE                                                                 │
│                                                                         │
│  +1 $title('Перевод числа с плавающей точкой в ASCII вид')              │
│                                                                         │
│                                                                         │
│       name    floating_to_ascii                                         │
│                                                                         │
│       public  floating_to_ascii                                         │
│       extrn   get_power_10:near, tos_status:near                        │
│  ;                                                                      │
│  ; Эта подпрограмма переводит число с плавающей точкой                  │
│  ; из вершины стека FPU в строку типа ASCII и отделяет                  │
│  ; степень 10, масштабируя значение (в двоичном виде).                  │
│  ; Максимальная длина строки символов регулируется                      │
│  ; параметром, который должен быть больше 1.                            │
│  ; Не-нормальные значения, денормальные значения и псевдо               │
│  ; -нули переводятся корректно. Однако, не-нормальные                   │
│  ; величины и псевдо-нули более не поддерживаются                       │
│  ; процессором i486 (в соответствии со стандартом IEEE) и               │
│  ; внутренне не генерируются. Возвращаемое значение                     │
│  ; указывает сколько двоичных разрядов точности было                    │
│  ; потеряно в не-нормальных или денормальных значениях.                 │
│  ; Также указывается и величина мантиссы псевдо-нуля                    │
│  ; (двоичным порядком). Целые числа меньшие 10**18                      │
│  ; переводятся точно, если принимающая строка ASCII                     │
│  ; символов содержит достаточное количество позиций для                 │
│  ; цифр этих чисел. В противном случае значение                         │
│  ; переводиться в научную нотацию.                                      │
│  ;                                                                      │
│  ; В зависимости от результата подпрограмма выдает                      │
│  ; следующие значения:                                                  │
│  ;                                                                      │
│  ;       0  перевод выполнен, размер строки определен                   │
│  ;       1  недопустимые аргументы                                      │
│  ;       2  точный целочисленный перевод, размер строки                 │
│  ;            определен                                                 │
│  ;       3  неопределенность                                            │
│  ;       4  + NaN (не-число)                                            │
│  ;       5  - NaN                                                       │
│  ;       6  + Бесконечность                                             │
│  ;       7  - Бесконечность                                             │
│  ;       8  встречен псевдо-ноль, размер строки определен               │
│  ;                                                                      │
│  ;    Интерфейс для вызова из PLM-386/486                               │
│  ;                                                                      │
│  ; floating_to_ascii:                                                   │
│  ;   procedure (number, denormal_ptr, string_ptr, size_ptr,             │
│  ;   field_size, power_ptr) word external;                              │
│  ;   declare (denormal_ptr, string_ptr, power_ptr, size_ptr)            │
│  ;   pointer;                                                           │
│  ;   declare field_size word;                                           │
│  ;   string_size based size_ptr word;                                   │
│  ;   declare number real;                                               │
│  ;   declare denormal integer based denormal_ptr;                       │
│  ;                                                                      │
│                                                                         │
│  ; declare power integer based power_ptr;                               │
│  ; end floating_to_ascii;                                               │
│  ;                                                                      │
│  ; Величина с плавающей точкой должна быть на вершине                   │
│  ; стека FPU. Эта подпрограмма требует три свободные                    │
│  ; регистра в стеке и после отработки выталкивает                       │
│  ; передаваемые значения из стека. Полученная строка                    │
│  ; будет иметь начальный символ либо "+", либо "-",                     │
│  ; указывая на знак величины. Затем следуют десятичные                  │
│  ; цифры в ASCII виде. Числовое значение строки типа                    │
│  ; ASCII будет равно (ASCII СТРОКА)*10**ПОРЯДОК. Если                   │
│  ; данное число было нулем, то строка будет содержать                   │
│  ; только знак и один символ 0. Величина размера строки                 │
│  ; (string_size) указывает на полную длину строки символов,             │
│  ; включая символ знака. Строка (0) всегда будет                        │
│  ; содержать знак. Возможно, что размер строки будет                    │
│  ; меньше размера поля. Это бывает при нулях и целых                    │
│  ; числах. Псевдо-ноль выдает особый код возврата. При                  │
│  ; денормальных числах указывается степень двух                         │
│  ; представленного значения. Степень десяти и строка будут              │
│  ; такими же, как если бы величина была бы простым нулем.               │
│  ;                                                                      │

│  ; Эта подпрограмма точно выдает десятичные целые до 18                 │
│  ; цифр. Целые величины имеют десятичный показатель                     │
│  ; степени в строке из нулей. При нецелых величинах                     │
│  ; точность результата заключена в двух последних                       │
│  ; десятичных цифрах (двойная точность). Для                            │
│  ; масштабирования величины в диапазоне, приемлемом для                 │
│  ; данных типа BCD, используются команды возведения в                   │
│  ; степень. Для перевода используется режим округления,                 │
│  ; действующий при входе в подпрограмму.                                │
│  ;                                                                      │
│  ;       Следующие регистры не видны:                                   │
│  ;                                                                      │
│  ;      eax ebx ecx edx esi edi eflags                                  │
│  ;                                                                      │
│  ; Определение стека.                                                   │
│  ;                                                                      │
│  ebp_save       equ     dword ptr [ebp]                                 │
│  es_save        equ     ebp_save + size ebp_save                        │
│  return_ptr     equ     es_save + size es_save                          │
│  power_ptr      equ     return_ptr + size return_ptr                    │
│  field_size     equ     power_ptr + size power_ptr                      │
│  size_ptr       equ     field_size + size size_ptr                      │
│  string_ptr     equ     size_ptr + size size_ptr                        │
│  denormal_ptr   equ     string_ptr + size string_ptr                    │
│                                                                         │
│  parms_size     equ     size power_ptr + size field_size +              │
│  &              size    size_ptr + size string_ptr +                    │
│  &              size    denormal_ptr                                    │
│  ;                                                                      │
│  ; Определение используемых констант.                                   │
│  ;                                                                      │
│  BCD_DIGITS   equ  18  ; Количество цифр в величине типа BCD            │
│  WORD_SIZE    equ  4                                                    │
│  BCD_SIZE     equ  10                                                   │
│  MINUS        equ  1   ; Определение выдаваемых значений                │
│  NAN          equ  4   ; Выбраные здесь точные величины -               │
│  INFINITY     equ  6   ; важны. Они должны соответствовать              │
│  INDEFINITE   equ  3   ; возможным выдаваемым значениям и               │
│  PSEUDO_ZERO  equ  8   ; тестироваться в том же порядке, как            │
│  INVALID      equ  -2  ; показано в этой программе.                     │
│  ZERO         equ  -4                                                   │
│  DENORMAL     equ  -6                                                   │
│  UNNORMAL     equ  -8                                                   │
│  NORMAL       equ  0                                                    │
│  EXACT        equ  2                                                    │
│  ;                                                                      │
│  ;       Определение положения временной области хранения.              │
│  ;                                                                      │
│  power_two    equ  word ptr [ebp - WORD_SIZE]                           │
│  bcd_value    equ  tbyte ptr power_two - BCD_SIZE                       │
│  bcd-byte     equ  byte ptr bcd_value                                   │
│  fraction     equ  bcd_value                                            │
│                                                                         │
│  lokal_size   equ  size power_two + size bcd_value                      │
│  ;                                                                      │
│  ;      Выделить достаточный объем стека для                            │
│  ;      временных результатов.                                          │
│  ;                                                                      │
│  stack  stackseg (lokal_size+6) ; Выделить пространство стека           │
│                                 ; для локальных данных.                 │
│  +1 $eject                                                              │
│                                                                         │
│  code         segment public er                                         │
│               extrn   power_table:qword                                 │
│  ;                                                                      │
│  ;      Константы, используемые этой функцией.                          │
│  ;                                                                      │
│               even               ; Оптимизировать до 16 цифр.           │
│  const10      dw      10         ; Подрегулировать значение для         │
│  ;                               ; слишком больших BCD.                 │
│  ;                                                                      │
│  ;        Перевести биты C3, C2, C1 и C0 в                              │
│  ;        значащие флаги и величины, используя                          │
│  ;        процедуру tos_status.                                         │
│  ;                                                                      │
│  status_table db      UNNORMAL, NAN, UNNORMAL+MINUS,                    │
│  &                    NAN+MINUS, NORMAL, INFINITY,                      │
│  &                    NORMAL+MINUS, INFINITY+MINUS,                     │
│  &                    ZERO, INVALID, ZERO+MINUS, INVALID,               │
│  &                    DENORMAL, INVALID, DENORMAL+MINUS, INVALID        │
│  floting_to_ascii proc                                                  │
│                                                                         │
│         call   tos_status   ; Посмотреть на состояние ST(0)             │

│  ;                                                                      │
│  ;         Взять дескриптор из таблицы                                  │
│  ;                                                                      │
│         movzx      eax, status_table[eax]                               │
│         cmp        al,INVALID             ; ST(0) пуст?                 │
│         jne        not_empty                                            │
│  ;                                                                      │
│  ;        ST(0) - пуст! Возвращает значение состояния.                  │
│  ;                                                                      │
│         ret    parms_size                                               │
│  ;                                                                      │
│  ;        Удалить бесконечность из стека и выйти.                       │
│  ;                                                                      │
│  found_infinity:                                                        │
│         fstp       st(0)       ; Оставить fstp                          │
│         jmp        short exit_proc                                      │
│  ;                                                                      │
│  ;              Длина строки слишком мала!                              │
│  ;              Выдает код недопустимости.                              │
│  ;                                                                      │
│  small_string:                                                          │
│         mov    al,INVALID                                               │
│  exit_proc:                                                             │
│         leave                          ; Восстановить стек              │
│                                                                         │
│         pop    es                                                       │
│         ret    parms_size                                               │
│  ;                                                                      │
│  ;          В ST(0) находится NaN или                                   │
│  ;          неопределенность. Сохранить значение                        │
│  ;          в памяти и просмотреть дробное поле                         │
│  ;          для того, чтобы отличить                                    │
│  ;          неопределенность от обычного NaN.                           │
│  ;                                                                      │
│  NAN_or_indefinite:                                                     │
│         fstp   fraction       ; Для проверки - удалить значение         │
│                               ; из стека.                               │
│         test   al,MINUS       ; Посмотреть бит знака.                   │
│         fwait                 ; Убедиться в выполнении сохранения.      │
│         jz     exit_proc      ; Если положительный знак, то не          │
│                               ; может быть неопределенностью.           │
│                                                                         │
│         mov    ebx,0C0000000H ; Подавить верхние 32 разряда дробной     │
│                               ; части.                                  │
│                                                                         │
│  ;             Сравнить разряды 63-32                                   │
│         sub    ebx,dword ptr fraction + 4                               │
│                                                                         │
│  ;             Разряды 31-0 должны быть нулями                          │
│         or     ebx,dword ptr fraction                                   │
│         jnz    exit_proc                                                │
│                                                                         │
│  ;             Установить выдаваемое значение на                        │
│  ;             неопределенность                                         │
│         mov   al,INDEFINITE                                             │
│         jmp   exit_proc                                                 │
│  ;                                                                      │
│  ;             Выделить место в стеке для локальных переменных          │
│  ;             и установить параметр адресации.                         │
│  ;                                                                      │
│  not_empty:                                                             │
│         push  es            ; Сохранить рабочий регистр                 │
│         enter local_size,0  ; Установить адресацию стека                │
│                                                                         │
│  ;             Проверить, достаточно ли места в строке                  │
│         mov   ecx,field_size                                            │
│         cmp   ecx,2                                                     │
│         jl    small_string                                              │
│                                                                         │
│         dec   ecx           ; Установить символ знака                   │
│                                                                         │
│  ; Посмотреть, может быть строка слишком большая для типа BCD           │
│         cmp   ecx,BCD_DIGITS                                            │
│         jbe   size_ok                                                   │
│                                                                         │
│  ; Иначе установить максимальный размер строки                          │
│         mov   ecx,BCD_DIGITS                                            │
│  size_ok:                                                               │
│         cmp   al,INFINITY   ; Может быть бесконечность?                 │
│                                                                         │
│  ; Возвратить значение состояния для + или - бесконечности              │
│         jge   found_infinity                                            │
│                                                                         │

│         cmp   al,NAN              ; Можеть быть NaN или                 │
│         jge   NAN_or_indefinite   ; неопределенность                    │
│                                                                         │
│  ;                                                                      │
│  ;             Установить выдаваемое значение по умолчанию              │
│  ;             и проверить, нормализовано ли число.                     │
│  ;                                                                      │
│         fabs        ; Использовать только положительные значения        │
│  ;                                                                      │
│  ;      Бит знака в регистре AL содержит истинный знак величины.        │
│  ;                                                                      │
│         xor   edx,edx          ; Подготовить константу 0                │
│         mov   edi,denormal_ptr ; Обнулить счетчик денормальных чисел    │
│         mov   [edi],dx                                                  │
│         mov   ebx,power_ptr    ; Обнулить значение степени десяти       │
│         mov   [ebx],dx                                                  │
│         mov   dl,al                                                     │
│         and   dl,1                                                      │
│         add   dl,EXACT                                                  │
│         cmp   al,ZERO          ; Проверить на ноль                      │
│         jae   convert_integer  ; Перейти программу возведения в         │
│                                ; степень, если значение равно нулю.     │
│                                                                         │
│         fstp  fraction                                                  │
│         fwait                                                           │
│         mov   al,bcd_byte + 7                                           │
│         or    byte ptr bcd_byte +7,80h                                  │
│         fld   fraction                                                  │
│         fxtract                                                         │
│         test  al,80h                                                    │
│         jnz   normal_value                                              │
│                                                                         │
│         fld1                                                            │
│         fsub                                                            │
│         ftst                                                            │
│         fstsw ax                                                        │
│         sahf                                                            │
│         jnz   set_unnormal_count                                        │
│  ;                                                                      │
│  ;                 Найден псевдо-ноль                                   │
│  ;                                                                      │
│         fldlg2                 ; Оценить степень десяти                 │
│         add   dl,PSEUDO_ZERO - EXACT                                    │
│         fmulp st(2),st                                                  │
│         fxch                   ; Взять степеть десяти                   │
│         fistp word ptr [ebx]   ; Установить степень десяти              │
│         jmp   convert_integer                                           │
│                                                                         │
│  set_unnormal_count:                                                    │
│         fxtract                ; Взять исходную дробь,                  │
│                                ; и нормализовать.                       │
│         fxch              ; Взять счетчик не-нормальных чисел           │
│         fchs                                                            │
│         fistp word ptr [edi]   ; Установить счетчик                     │
│                                ; не-нормальных чисел                    │
│                                                                         │
│  ;                                                                      │
│  ; Вычислить десятичную величину вместе с этим числом                   │
│  ; внутри одного порядка.                                               │
│  ;                                                                      │
│  ; Всегда при округлении будет присутствовать ошибка                    │
│  ; из-за потери точности. В результате, мы                              │
│  ; преднамеренно при вычислении порядка не стали                        │
│  ; рассматривать LOG10 от значения дроби. Так как                       │
│  ; дробь всегда больше или равна 1 и меньше двух, то                    │
│  ; LOG10 от этой дроби не изменяет основной точности                    │
│  ; функции. Для того, чтобы получить десятичный                         │
│  ; порядок величины, надо просто умножить степень                       │
│  ; двух на LOG10(2) и округлить результат с                             │
│  ; отсечением до целого.                                                │
│  ;                                                                      │
│  normal_value:                                                          │
│         fstp  fraction    ; Для дальнейшего использования               │
│                           ; сохранить поле дроби.                       │
│         fist  power_twq   ; Сохранить степень двух                      │
│         fldlg2            ; Взять LOG10(2)                              │
│                           ; Теперь можно безопасно использовать         │
│                           ; power_two                                   │
│         fmul              ; Подготовить LOG10 от порядка числа          │
│         fistp word ptr [ebx]   ; Здесь может быть применен любой        │
│                                ; режим округления                       │
│  ;                                                                      │
│  ;            Проверить, чтобы величина числа                           │
│  ;            интерпретировалась как целое.                             │

│  ;                                                                      │
│  ; CX имеет максимально позволенное количество десятичных цифр.         │
│  ;                                                                      │
│         fwait              ; Ожидать допустимой степени десяти          │
│  ;                                                                      │
│  ;             Возвести десять в степень величины значения              │
│  ;                                                                      │
│         movsx si,word ptr [ebx]                                         │
│         sub   esi,ecx         ; Подготовить в AX необходимый            │
│                               ; коэффициент масштабирования.            │
│         ja    adjust_result   ; Перейти, если число не подходит         │
│  ;                                                                      │
│  ; Число между 1 и 10**(field_size - размер поля)                       │
│  ; Проверить на целочисленность                                         │
│  ;                                                                      │
│         fild  power_two         ; Восстановить начальное значение       │
│         sub   dl,NORMAL-EXACT   ; Перевести в точное выдаваемое         │
│                                 ; значение                              │
│         fld   farction                                                  │
│         fscale              ; Подготовить полную величину, в этой       │
│                             ; команде она не портится                   │
│         fst   st(1)         ; Скопировать значение для сравнения        │
│         frndint             ; Проверить на целочисленность              │
│         fcomp               ; Сравнить значения                         │
│         fstsw ax            ; Сохранить состояние                       │
│         sahf                ; C3 = 1, значит это была целое число       │
│                                                                         │
│         jnz   convert_integer                                           │
│                                                                         │
│         fstp  st(0)            ; Удалить нецелочисленное значение       │
│         add   dl,NORMAL-EXACT  ; Восстановить начальнное выдаваемое     │
│                                ; значение                               │
│  ;                                                                      │
│  ; Масштабировать число внутри диапазона,                               │
│  ; позволенного форматом BCD. Операция                                  │
│  ; масштабирования выдает число внутри одного                           │
│  ; десятичного порядка величины наибольшего                             │
│  ; десятичного числа, представимого для данной длины                    │
│  ; строки.                                                              │
│  ;                                                                      │
│  ;     Величина степени десяти для масштабирования                      │
│  ;     находится в регистре SI.                                         │
│  ;                                                                      │
│  adjust_result:                                                         │
│         mov   eax,esi            ; Подготовить для возведения в         │
│                                  ; степень                              │
│         mov   word ptr [ebx],ax  ; Установить начальную величину        │
│                                  ; степени десяти                       │
│         neg   eax                ; Вычесть единицу для каждого порядка  │
│                                  ; величины, на который масштабируется  │
│                                  ; значение.                            │
│         call  get_power_10       ; Коэффициент масштабирования          │
│                                  ; представляется как порядок и дробь.  │
│         fld   fraction           ; Взять дробь                          │
│         fmul                     ; Комбинировать дроби                  │
│         mov   esi,ecx            ; Возвести десять в максимальную       │
│                                  ; степень                              │
│         shl   esi,3              ; Для того, чтобы значение BCD         │
│                                  ; входило в строку                     │
│         fild  power_two          ; Комбинировать степень двух           │
│         faddp st(2),st                                                  │
│         fscale                   ; Подготовить полное значение,         │
│                                  ; порядок остался не тронутым          │
│         fstp  st(1)              ; Удалить порядок                      │
│  ;                                                                      │
│  ; Проверьте установленное значение по таблице                          │
│  ; точных степеней десяти. Суммарные ошибки оценки                      │
│  ; величины и степенной функции могут привести к                        │
│  ; тому, что значение одного порядка величины будет                     │
│  ; либо слишком маленькое, либо слишком большое для                     │
│  ; поля типа BCD. Для устранения этой проблемы                          │
│  ; протестируйте полученное значение - является ли                      │
│  ; оно слишком большим или слишком маленьким. Затем                     │
│  ; отрегулируйте его и значение степени десяти.                         │
│  ;                                                                      │
│  test_power:                                                            │
│  ;                                                                      │
│  ; Сравните с точной степенью. Используйте следующую                    │
│  ; степень при уменьшении CX на единицу.                                │
│  ;                                                                      │
│         fcom  power_table[esi]+type power_table                         │
│         fstsw ax               ; Не надо ждать                          │
│         sahf                   ; Если C3=C0=0, то слишком большое       │
│         jb    test_for-small                                            │

│         fidiv const10          ; Иначе установить значение              │
│         and   dl,not EXACT     ; Удалить флаг того, что число точное    │
│         inc   word ptr [ebx]   ; Установить значение степени десяти     │
│         jmp   short in_range   ; Перевести значение в целое типа BCD    │
│                                                                         │
│  test_for_small:                                                        │
│         fcom  power_table[esi] ; Проверить относительный размер         │
│                                                                         │
│         fstsw ax               ; Не ждать                               │
│         sahf                   ; Если C0 = 0, то ST(0) больше или       │
│                                ; равен нижшей границе                   │
│         jc    in_range         ; Перевести значение в целое типа BCD    │
│         fimul const10          ; Подогнать значение под диапазон        │
│         dec   word ptr [ebx]   ; Подобрать значение степени десяти      │
│  in_range:                                                              │
│         frndint                ; Подготовить целое значение             │
│  ;                                                                      │
│  ; Утверждение: 0 <= TOS <= 999,999,999,999,999,999                     │
│  ; Число TOS будет точно представлено                                   │
│  ; 18-ю цифрами в формате BCD.                                          │
│  ;                                                                      │
│  convert_integer:                                                       │
│         fbstp bcd_value        ; Сохранить число в формате BCD          │
│  ;                                                                      │
│  ; При сохранении формата BCD установить регистры                       │
│  ; для перевода в ASCII вид.                                            │
│  ;                                                                      │
│         mov   esi,BCD_SIZE-2   ; Инициализировать значение              │
│                                ; индекса BCD                            │
│         mov   cx,0f04h         ; Установить счетчик сдвига и маску      │
│         mov   ebx,1            ; Установить начальный размер ASCII      │
│                                ; поля для знака                         │
│         mov   edi,string_ptr   ; Взять адрес начала ASCII строки        │
│         mov   ax,ds            ; Скопировать DS в ES                    │
│         mov   es,ax                                                     │
│         cld                    ; Установить режим автоматического       │
│                                ; добавления единицы                     │
│         mov   al,'+'           ; Очистить поле знака                    │
│         test  dl,MINUS         ; Проверить на отрицательное значение    │
│         jz    positive_result                                           │
│                                                                         │
│         mov   al,'-'                                                    │
│  positive_result:                                                       │
│         stosb                  ; Установить указатель строки на         │
│                                ; последний знак                         │
│         and   dl,not MINUS     ; Выключить бит знака                    │
│         fwait                  ; Ожидать окончания команды fbstp        │
│  ;                                                                      │
│  ; Используемые регистры:                                               │
│  ;                                                                      │
│  ;          AH:          байт со значением типа BCD                     │
│  ;          AL:          значение строки ASCII                          │
│  ;          DX:          возвращаемое значение                          │
│  ;          CH:          маска BCD = 0fh                                │
│  ;          CL:          счетчик сдвига BCD = 4                         │
│  ;          BX:          ширина поля строки ASCII                       │
│  ;          ESI:         индекс поля BCD                                │
│  ;          DI:          указатель поля строки BCD                      │
│  ;          DS, ES:      адрес сегмента строки ASCII                    │
│  ;                                                                      │
│  ;          Удалить начальные нули из числа.                            │
│  ;                                                                      │
│  ;                                                                      │
│  skip_leading_zeroes:                                                   │
│         mov   ah,bcd_byte[esi]    ; Взять байт BCD                      │
│         mov   al,ah               ; Скопировать значение                │
│         shr   al,cl               ; Взять верхнюю по порядку цифру      │
│         and   al,0fh              ; Установить флаг нуля                │
│         jnz   enter_odd           ; Выйти из цикла, если в начале       │
│                                   ; обнаружены не нули                  │
│                                                                         │
│         mov   al,ah               ; Взять снова байт BCD                │
│         and   al,0fh              ; Взять нижнюю по порядку цифру       │
│         jnz   enter-even          ; Выйти из цикла, если обнаружены     │
│                                   ; ненулевые цифры                     │
│                                                                         │
│         dec   esi                 ; Уменьшить индекс BCD                │
│         jns   skip_leading_zeroes                                       │
│  ;                                                                      │
│  ;               Вся мантисса состоит из нулей                          │
│  ;                                                                      │
│         mov   al,'0'              ; Установить начальный ноль           │
│         stosb                                                           │

│         inc   ebx                 ; Увеличить длину строки              │
│         jmp   short exit_with_value                                     │
│  ;                                                                      │
│  ;               Теперь расширяем строку цифрами от                     │
│  ;               0 до 9 по одной цифре на байт                          │
│  ;                                                                      │
│  digit_loop:                                                            │
│         mov   ah,bcd_byte[esi]    ; Взять байт BCD                      │
│         mov   al,ah                                                     │
│         shr   al,cl               ; Взять верхнюю по порядку цифру      │
│  enter_odd:                                                             │
│         add   al,'0'              ; Перевести в ASCII                   │
│         stosb                     ; Занести цифру в строку ASCII        │
│         mov   al,ah               ; Взять нижнюю по порядку цифру       │
│         and   al,0fh                                                    │
│         inc   ebx                 ; Увеличить счетчик размера поля      │
│  enter-even:                                                            │
│         add   al,'0'              ; Перевести в ASCII                   │
│         stosb                     ; Занести цифру в строку ASCII        │
│         inc   ebx                 ; Увеличить счетчик размера поля      │
│         dec   esi                 ; Перейти к следующему байту BCD      │
│         jns   digit_loop                                                │
│  ;                                                                      │
│  ;           Перевод закончен. Установить размер                        │
│  ;           строки и остаток                                           │
│  ;                                                                      │
│  exit_with_value:                                                       │
│         mov   edi,size_ptr                                              │
│         mov   word ptr [edi],bx                                         │
│         mov   eax,edx             ; Установить выдаваемое значение      │
│         jmp   exit_proc                                                 │
│                                                                         │
│  floating_to_ascii       endp                                           │
│                          code          ends                             │
│                                        end                              │
│                                                                         │
│                                                                         │
│  +1 $title(Вычислить значение 10**AX)                                   │
│                                                                         │
│  ; Эта подпрограмма вычисляет значение степени                          │
│  ; 10**EAX. Точный результат выдается для значений в                    │
│  ; диапазоне 0 <= EAX < 19. Все регистры прозрачны                      │
│  ; и значение выдается в TOS как два числа: порядок                     │
│  ; в ST(1) и дробь в ST(0). Величина порядка может                      │
│  ; превышать наибольший порядок числа в расширенном                     │
│  ; вещественном формате. В программе используются                       │
│  ; три стековых регистра.                                               │
│  ;                                                                      │
│         name      get_power_10                                          │
│         public    get_power_10, power_table                             │
│                                                                         │
│  stack  stackseg  8                                                     │
│                                                                         │
│  code  segment public er                                                │
│  ;                                                                      │
│  ;          Использовать точные значения от 1.0 до 1E18.                │
│  ;                                                                      │
│         even               ; Оптимизировать 16-ти битовый доступ        │
│  power_table   dq  1.0,1e1,1e2,1e3                                      │
│                                                                         │
│                dq  1e4,1e5,1e6,1e7                                      │
│                                                                         │
│                dq  1e8,1e9,1e10,1e11                                    │
│                                                                         │
│                dq  1e12,1e13,1e14,1e15                                  │
│                                                                         │
│                dq  1e16,1e17,1e18                                       │
│                                                                         │
│  get_power_10  proc                                                     │
│         cmp   eax,18      ; Проверить диапазон 0 <= AX < 19             │
│         ja    out_of_range                                              │
│                                                                         │
│         fld   power_table[eax*8]  ; Взять точное значение               │
│         fxtract           ; Отделить степень и                          │
│                           ; дробную часть                               │
│         ret               ; Оставить fxtract                            │
│  ;                                                                      │
│  ; Вычислить значение, используя команду возведения                     │
│  ; в степень. Используются следующие соотношения:                       │
│  ;                                                                      │
│  ; 10**X = 2**(log2(10)*X)                                              │
│  ; 2**(I+F) = 2**I * 2**F                                               │
│  ;                                                                      │

│  ; Если ST(1) = I и ST(0) = 2**F, то команда fscale                     │
│  ; выдает 2**(I+F).                                                     │
│  ;                                                                      │
│  out_of_range:                                                          │
│                                                                         │
│         fldl2t                   ; TOS = LOG2(10)                       │
│         enter 4,0                                                       │
│                                                                         │
│  ;            Сохранить значение степени десяти, P                      │
│  ;                                                                      │
│         mov   [ebp-4],eax                                               │
│                                                                         │
│  ;            TOS, X = LOG2(10)*P = LOG2(10**P)                         │
│  ;                                                                      │
│         fimul dword ptr [ebp-4]                                         │
│         fld1                     ; Установить TOS = -1.0                │
│         fchs                                                            │
│         fld   st(1)              ; Скопировать значение степени по      │
│                                  ; основанию два                        │
│         frndint                  ; TOS = I; -бесконечность < I <= X,    │
│                                  ; где I - целое                        │
│                                  ; Режим округления не имеет значения   │
│         fxch  st(2)              ; TOS = X, ST(1) = -1.0                │
│                                  ; ST(2) = I                            │
│         fsub  st,st(2)           ; TOS, F = X-I:                        │
│                                  ; -1.0 < TOS <= 1.0                    │
│                                                                         │
│  ;      Восстановить начальный режим управления точностью               │
│         pop   eax                                                       │
│         f2xm1            ; TOS = 2**(F) - 1.0                           │
│         leave            ; Восстановить стек                            │
│         fsubr            ; Подготовить 2**(F)                           │
│         ret              ; Оставить fsubr                               │
│                                                                         │
│  get_power_10   endp                                                    │
│                                                                         │
│  code           ends                                                    │
│                 end                                                     │
│                                                                         │
│  +1 $title(Определение содержимого регистра TOS)                        │
│  ;                                                                      │
│  ; Эта подпрограмма выдает значение от 0 до 15 в                        │
│  ; регистр EAX в соответствии с содержанием вершины                     │
│  ; стека FPU. Все регистры прозрачны, поэтому ошибки                    │
│  ; исключены. Выдаваемое значение соответствует                         │
│  ; битам C3, C2, C1 и C0 команды FXAM.                                  │
│  ;                                                                      │
│         name           tos_status                                       │
│         public         tos_status                                       │
│                                                                         │
│  stack        stackseg   6                                              │
│                                                                         │
│  code         segment public er                                         │
│                                                                         │
│  tos_status  proc                                                       │
│         fxam             ; Взять состояние регистра TOS                 │
│         fstsw ax         ; Взять текущее состояние                      │
│         mov   al,ah      ; Положить биты 10-8 в биты 2-0                │
│         and   eax,4007h  ; Маскировать биты C3, C2, C1 и C0             │
│         shr   ah,3       ; Положить бит C3 в бит 11                     │
│         or    al,ah      ; Положить бит C3 в бит 3                      │
│         mov   ah,0       ; Очистить возвращаемое значение               │
│         ret                                                             │
│                                                                         │
│  tos_status endp                                                        │
│                                                                         │
│  code       ends                                                        │
│             end                                                         │
│                                                                         │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘


`д`к20.3.3  Специальные команды `*

Функции  оперируют   различными  числовыми   командами,  типами   данных  и
управляют   точностью.   Показанные   команды   являются   командами    для
автоматического перевода  чисел в  BCD вид  (двоично- десятичный  код). При
этом вычисляется  10-ти кратное  значение целочисленной  величины, операции
выполняются   одновременно,   устанавливается   синхронизация   данных    и
используется  ориентированное  округление  в  модуле  обработки  операций с
плавающей точкой.

Без  типа  данных  расширенной   точности  и  встроенной   экспоненциальной
функции,  не  может  быть  достигнута  двойная  точность  этой  функции при
скорости и размере приведенного примера.
Функция базируется на числовом типе данных BCD для перевода из двоичного  с
плавающей   точкой   в   десятичное.   Основная   работа   заключается    в
масштабировании значения  с плавающей  точкой до  приемлемого ограниченного
диапазона значений  типа BCD.  Для то,  чтобы напечатать  результат из 9-ти
цифр, необходимо  точно провести  масштабирование данной  величины в  целое
между 10**(8) и 10**(9). Например, число +0.123456789 требует  коэффициента
масштабирования   порядка   10**(9)   для   того,   чтобы   получить  число
 +123456789.0, которое может храниться в 9-ти цифрах типа  BCD. Коэффициент
масштабирования  должен  быть  точной   степенью  10-ти  для  того,   чтобы
предотвратить изменения цифр при печати.
Эти  подпрограммы   должны  правильно   переводить  все   значения,   точно
представимые в  десятичном виде,  в поле,  заданного размера. Целочисленные
значения,  которые  подходят  под  данный  размер строки, нет необходимости
масштабировать,  а  можно  сразу  сохранять  в  форме  BCD. Нецелочисленные
значения, точно представимые в  десятичном виде в пределах  размера строки,
также  переводятся  точно.  Например,  число  0.125 точно представимо как в
двоичном виде, так и в  десятичном. Для того, чтобы перевести  это значение
с   плавающей   точкой   в   десятичный   вид,   надо  выбрать  коэффициент
масштабирования 1000. В результате  получим число 125. При  масштабировании
величин,  функция  должна  оставлять  след  там,  где  будет  располагаться
десятичная точка в конечном десятичном значении.


`д`к20.3.4  Описание операции`*

Перевод числа с  плавающей точкой в  десятичный ASCII вид  проводится в три
основных  шага:  определение  величины   числа,  масштабирование  его   для
представления в виде BCD и перевод данных типа BCD в десятичную  символьную
ASCII запись.
Определение величины  результата требует  нахождения такого  значения числа
X, при котором наше число было бы  представимо в виде I x 10**(X), где  1.0
є I  < 10.0.  Масштабирование числа  требует его  умножения на  коэффициент
масштабирования  10**(S)  так,  чтобы  результат  был  целым, не содержащим
десятичных цифр  больше, чем  отведено для  этого места  в строке  символов
ASCII.
После   масштабирования,   округления   и   перевода   в   тип   BCD  число
представляется в форме, удобной для  перевода в десятичный ASCII вид  любым
программным обеспечением.
Реализация всех  этих трех  шагов требует  предельного внимания  к деталям.
Для начала  обратите внимание,  что не  каждая величина  с плавающей точкой
имеет  числовое  значение.  Подпрограммой  перевода  могут быть встречены и
такие величины  как бесконечность,  неопределенность или  NaN. Поэтому  эта
подпрограмма должна уметь опознавать  эти величины и однозначно  определять
их.
Также присутствуют особые  случаи числовых значений.  Ненормальные величины
имеют  числовое  значение  и  должны  быть  отличимы  функцией, так как они
указывают  на  то,  что  была  потеряна  точность  в  процессе   проведения
предшествующих вычислений.
Определив,  что  число  имеет   числовое  значение  и  нормализовано   (при
необходимости  установка  соответствующих  флагов  сигнализирует  вызванной
программе, что  это ненормальное  число), можно  масштабировать величину  в
диапазоне типа BCD.


`д`к20.3.5  Масштабирование величин  `*

Для того, чтобы масштабировать  число, необходимо определить его  величину.
Достаточно вычислить величину с точностью  до 1 единицы или при  кратном 10
коэффициенте,  умноженным  на  требуемую  величину.  После  масштабирования
числа проводится проверка для того,  чтобы посмотреть попал ли результат  в
ожидаемый диапазон.  Если нет,  то результат  может быть  исправлен на один
десятичный порядок вверх или вниз от требуемой величины. Подстроечный  тест
после  масштабирования  необходим  для  устранения  неизбежной неточности в
масштабированном значении.
Так  как  оценка  значения  для  коэффициента  масштабирования  должна быть
достаточно  близкой,   то  используется   быстрый  прием   масштабирования.
Величина оценивается  умножением степени  2, которая  представляет из  себя
несмещенный  порядок  числа  с  плавающей  точкой,  соответственно с числом
log(10)  от  2.  Округление  результата  до  целого дает оценку достаточной
точности. Игнорируя дроби, значение  в результате может иметь  максимальную
ошибку 0.32.
Используя  значение  величины  и  размер  числовой  строки, можно вычислить
коэффициент  масштабирования.   В  процедуре   перевода  числа   вычисление
коэффициента масштабирования является  самой неточной операцией.  Для этого
используется соотношение 10**(X) = 2**(X * log(10) 2) и команда F2XM1.
В соответствии с ограничениями  на диапазон значений, разрешенных  командой
F2XM1,  значение  степени  2  разбивается  на  целую  и дробную компоненты.
Соотношение 2**(I + F) = 2**(I) x 2**(F) позволяет использовать  инструкцию
FSCALE  для  того,  чтобы  перекомбинировать  значение  2**(F), вычисленное
командой F2XM1, и часть 2**(I).

`д`к20.3.5.1  Неточность при масштабировании`*

При  вычислении  коэффициента  масштабирования  возникает  неточность из-за
остаточных нулей,  помещенных в  дробной величине  степени 2  при отделении
значимых битов целой  части. Для каждого  целого значимого бита  в значении
степени 2, отделенных от дробных  битов, в дробной части теряется  один бит
точности при заполнении нулями менее значащих битов.
До  14  битов  может  быть  потеряно  в  дробной  части, так как наибольшая
допустимая величина порядка числа  с плавающей точкой составляет  2**(14) -
1. Эти  биты непосредственно  и уменьшают  точность вычисления коэффициента
масштабирования, чем и вызывают уменьшение точности самого значения  числа.
Для  чисел  в  диапазоне  10**(ё30)  максимальное  число  битов   точности,
потерянных при выполнении масштабирования, достигает 8-ми.


`д`к20.3.5.2  Предупреждение переполнений и отрицательных переполнений `*

Дробная часть  числа и  показатель отделены  друг от  друга для того, чтобы
избежать  переполнений   и  отрицательных   переполнений  при    вычислении
масшабированной   величины.   Например,   для   того,   чтобы    произвести
масштабирование  числа  10**(-4932)   до  10**(8),  требуется   коэффициент
масштабирования 10**(4950), который  не может быть  представлен процессором
i486.
Отделив  показатель   и  дробь,   операция  масштабирования   будет  просто
складывать  показатели  отдельно  от  умножения  дробей. Эта арифметическая
операция включает малые целые числа, легко представимые процессором i486.


`д`к20.3.5.3  Окончательная регулировка  `*

Возможно,  что  степенная  функция  Get  Power  10  может  выдать результат
масштабирования  величины   так,  что   получится  число,   имеющее  больше
разрядов, чем может  быть представлено в  строке ASCII символов.  Например,
масштабирование  числа  9.9999999999999999  x  10**(4900)  с  коэффициентом
1.00000000000000010   x   10**(-4883)   дало   бы   в   результате    число
1.00000000000000009    x    10**(18).    И    коэффициент   масштабирования
соответствует  точности  модуля  обработки  операций  с  плавающей точкой и
результат  соответствует  точности  перевода,   но  число  не  может   быть
представлено  в  формате  BCD.  Вот  почему  необходо после масштабирования
провести  тестирование  величины  результата.  Результат можно умножить или
разделить  на   10,  в   зависимости  от   того,  является   ли   результат
соответственно слишком малым или слишком большим.


`д`к20.3.6  Выходной формат  `*

Для  максимальной  гибкости  выходного  формата,  позиция  десятичной точки
указывается  двоичным   целым  числом,   называемым  значением   показателя
степени.  Если  показатель   степени  равен  нулю,   то  десятичная   точка
предполагается справа  от самой  правой цифры.  Показатель степени  больший
нуля показывает,  как много  остаточных нулей  не показывается.  Для каждой
единице ниже нуля десятичная точка в строке сдвигается налево.
Последний  шаг  перевода  числа  -  это  сохранить  результат  в виде BCD и
указать,  где   находится  десятичная   точка.  Строка   типа  BCD    затем
распаковывается   в   десятичную   строку    из   ASCII   символов.    Знак
устанавливается в соответствии со знаком оригинального значения.


`д`к20.4  Примеры тригонометрических вычислений   `*

В этом примере моделируется  кинематика руки робота по  гомогенным матрицам
преобразований  размером  4  x  4,  предложенным  Денавитом  и Хартенбергом
(1,2). Передаточные  и поворотные  отношения между  смежными звеньями  руки
описаны с помощью этих матриц,  используя матричный метод D-H. Для  каждого
звена построена гомогенная матрица  преобразований размером 4 x  4, которая
представляет  координатную  систему  звена  (L(i))  в  соединении  (J(i)) в
соответствии с предыдущей координатной системой (J(i-1),L(i-1)).

─────────────────────────────────────── 1. J.Denavit and R.S.Hartenberg,
"A Kinematic Notation for Lower-Pair Mechanisms Based on Matrices." J.
Applied Mechanics, June 1955, pp. 215-221

2. C.S.George Lee, "Robert Arm Kinematics, Dinamics, and Control." IEEE
Computer, Dec. 1982.

Следующие  четыре  геометрические  величины  полностью  описывают  движение
любой пары соединение/звено (J(i),L(i)), как показано на Рисунке 20-7.

тета(i)  =  Угол  между  осью  x(i)  и  осью x(i-1) при повороте вокруг оси
z(i-1) против часовой стрелки.  d(i) = Расстояние от (i-1)-ой  координатной
системы  вдоль  оси  z(i-1)  до  оси  x(i).   a(i)  =  Расстояние  до  i-ой
координатной системы от оси z(i-1) вдоль оси -x(i).  альфа(i) = Угол  между
осью  z(i)  и  осью  z(i-1)  при  повороте  вокруг  оси x(i) против часовой
стрелки.

┌───────────────────────────────────────────────────────────────┐
│                                                               │
│                                                               │
│                            zi-1          xi-1                 │
│                yi-1        │      90   /                      │
│                  \         ├──────\  /                        │
│                    \       │       /\     тета                │
│                      \     │     /    \                       │
│                        \   │   /       *                      │
│                          \ │ /                                │
│             СОЕДИНЕНИЕ i-1 ├ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─      ──┬──   │
│                            │                            │     │
│                            │                            │     │
│                            │                            │     │
│                 альфаi     │                            │     │
│          \                 │                            │     │
│            \               │                                  │
│              \       * <───│───\                        di    │
│                \           │     \ 90                         │
│  zi              \         │      │                     │     │
│   \             yi \       │      │                     │     │
│     \           /    \     │      │                     │     │
│       \       /        \   │      │                     │     │
│         \   /            \ │      │                     │     │
│           ─────────────────┴──────┴───────────── xi   ──┴──   │
│  СОЕДИНЕНИЕi+1                                                │
│                                                               │
│           ├────── ai ──────┤                                  │
│                                                    240486/103 │
└───────────────────────────────────────────────────────────────┘
Рисунок 20-7. Отношения Между Смежными Звеньями


Матрица  преобразований  A(i)(i-1)  типа   D-H  для  смежных   координатных
участков от соединения (i-1) до соединения (i) вычисляется как:

A(i)(i-1) = T(z,d) x T(z,тета) x T(x,a) x T(x,альфа)
где:
T(z,d) представляет передачу вдоль оси z(i-1)
T(z,тета) представляет поворот угла тета вокруг оси z(i-1)
T(x,a) представляет передачу вдоль оси x(i)
T(x,альфа) представляет поворот угла альфа вокруг оси x(i)

A(i)(i-1) =

│ COSтет(i) -COSалф(i)SINтет(i)  SINалф(i)SINтет(i) COSтет(i) │
│                                                             │
│ SINтет(i)  COSалф(i)COSтет(i) -SINалф(i)COSтет(i) SINтет(i) │
│                                                             │
│ 0          SINалф(i)           COSалф(i)          d(i)      │
│                                                             │
│ 0          0                   0                  1         │

Композитная  гомогенная  матрица  T,  которая  представляет собой позицию и
ориентацию  пары   соединение/звено  по   отношению  к   основной  системе,
получается последовательным умножением  матриц преобразований типа  D-H для
смежных координатных участков.

T(i)(0) = A(1)(0) x A(2)(1) x ... x A(i)(i-1)
Пример  программы  на  Рисунке  20-8  иллюстрирует,  как  можно   выполнить
передаточный процесс, используя возможности обработки операций с  плавающей
точкой процессора i486. Программа состоит из двух главных процедур.  Первая
процедура  TRANS  PROC  используется  для  вычисления  элементов  в  каждой
матрице  A(i)(i-1)  типа  D-H.  Вторая  процедура  MATRIXMUL  PROC  находит
произведение двух последовательных матриц типа D-H.


Рисунок 20-8. Пример Кинематики Руки Робота

┌─────────────────────────────────────────────────────────────────────────┐
│                                                                         │
│                                                                         │
│    Name ROT_MATRIX_CAL                                                  │
│    ;                                                                    │
│    ; Этот пример иллюстрирует использование команд с                    │
│    ; плавающей точкой процессора i486 и частично                        │
│    ; функцию FSINCOS, которая дает значения синуса и                    │
│    ; косинуса одновременно. Программа вычисляет                         │
│    ; композитные матрицы, по которым работает механизм                  │
│    ; передачи.                                                          │
│    ;                                                                    │
│    ; В этом примере рассмотрена только кинематика                       │
│    ; робота.                                                            │

│    ;                                                                    │
│    ; Если композитная матрица, упомянутая выше,                         │
│    ; задается как:                                                      │
│    ; T1n = A1 x A2 x ... x An, то                                       │
│    ; T1n находится вызовом процедур trans_proc и                        │
│    ; matrixmul_proc, пока все матрицы не будут                          │
│    ; перемножены.                                                       │
│    ;                                                                    │
│    ; Процедура trans_proc вычисляет элементы каждой                     │
│    ; матрицы A(A1,.....An), пока процедура                              │
│    ; matrixmul_proc выполняет умножение матрицы Ai и                    │
│    ; Ai+1. Для умножения процедура matrixmul_proc                       │
│    ; использует процедуры matrix_row и matrix_elem.                     │
│    ;                                                                    │
│    ; Определить стековое пространство                                   │
│    ;                                                                    │
│    trans_stack stackseg 400                                             │
│                                                                         │
│    ; Определение матричной структуры для передаточных                   │
│    ; матриц размером 4x4                                                │
│                                                                         │
│    a_matrix struc                                                       │
│           a11   dq   ?                                                  │
│           a12   dq   ?                                                  │
│           a13   dq   ?                                                  │
│           a14   dq   ?                                                  │
│           a21   dq   ?                                                  │
│           a22   dq   ?                                                  │
│           a23   dq   ?                                                  │
│           a24   dq   ?                                                  │
│           a31   dq   0h                                                 │
│           a32   dq   ?                                                  │
│           a33   dq   ?                                                  │
│           a34   dq   ?                                                  │
│           a41   dq   0h                                                 │
│           a42   dq   0h                                                 │
│           a43   dq   0h                                                 │
│           a44   dq   1h                                                 │
│    a_matrix ends                                                        │
│    ;                                                                    │
│    ; Предполагаем, что одно соединение хранится в                       │
│    ; одой позиции и, следовательно, имеет два набора                    │
│    ; параметров. Однако, возможно и большее количество                  │
│    ; соединений.                                                        │
│    ;                                                                    │
│    alp_deg struc                                                        │
│           alpha_deg1 dd ?                                               │
│           alpha_deg2 dd ?                                               │
│    alp_deg ends                                                         │
│    ;                                                                    │
│    tht_deg struc                                                        │
│           theta_deg1 dd ?                                               │
│           theta_deg2 dd ?                                               │
│    tht_deg ends                                                         │
│    ;                                                                    │
│    A_array struc                                                        │
│           A1         dq ?                                               │
│           A2         dq ?                                               │
│    A_array ends                                                         │
│    ;                                                                    │
│    D_array struc                                                        │
│           D1         dq ?                                               │
│           D2         dq ?                                               │
│    D_array ends                                                         │
│    ;                                                                    │
│    ; Сегмент данных - trans_data                                        │
│    ;                                                                    │
│    trans_data             segment rw   public                           │
│           Amx             a_matrix<>                                    │
│           Bmx             a_matrix<>                                    │
│           Tmx             a_matrix<>                                    │
│           ALPHA_DEG       alp_deg<>                                     │
│           THETA_DEG       tht_deg<>                                     │
│           A_VECTOR        A_array<>                                     │
│           D_VECYOR        D_array<>                                     │
│           ZERO            dd           0                                │
│           d180            dd           180                              │
│           NUM_JOINT       equ          1                                │
│           NUM_ROW         equ          4                                │
│           NUM_COL         equ          4                                │
│           REVERSE         DB           1H                               │
│    trans_data             ends                                          │
│                                                                         │

│    assume  ds:trans_data, es:trans_data                                 │
│    ;                                                                    │
│    ; Сегмент trans_code содержит процедуры для                          │
│    ; вычисления элементов матрицы и умножения матриц.                   │
│    ;                                                                    │
│    trans_code      segment er    public                                 │
│    truns_proc      proc    far                                          │
│    ;                                                                    │
│    ; Вычислить углы альфа и тета в радианах из их значений              │
│    ; в градусах                                                         │
│    ;                                                                    │
│           fldpi                                                         │
│           fdiv  d180                                                    │
│    ;                                                                    │
│    ; Умножить на Пи/180                                                 │
│    ;                                                                    │
│           fld   st                                                      │
│           fmul  qword ptr ALPHA_DEG[ecx*8]                              │
│           fxch  st(1)                                                   │
│           fmul  qword ptr THETA_DEG[ecx*8]                              │
│    ;                                                                    │
│    ; Тета (в радианах) в ST                                             │
│    ; и альфа (в радианах) в ST(1)                                       │
│    ;                                                                    │
│    ; Вычисление элементов матрицы                                       │
│    ;                                                                    │
│    ;            a11 = COS тета                                          │
│    ;            a12 = -COS альфа* SIN тета                              │
│    ;            a13 = SIN альфа * SIN тета                              │
│    ;            a14 = A * COS тета                                      │
│    ;            a21 = SIN тета                                          │
│    ;            a22 = COS альфа * COS тета                              │
│    ;            a23 = -SIN альфа * COS тета                             │
│    ;            a24 = A * SIN тета                                      │
│    ;            a32 = SIN альфа                                         │
│    ;            a33 = COS альфа                                         │
│    ;            a34 = D                                                 │
│    ;            a31 = a41= a42 = a43 = 0.0                              │
│    ;            a44 = 1                                                 │
│    ;                                                                    │
│    ; Регистр EBX содержит смещение для матрицы                          │
│    ;                                                                    │
│           fsincos                       ; COS тета в ST                 │
│                                         ; SIN тета в ST(1)              │
│           fld   st                      ; удвоить COS тета              │
│           fst   [ebx].a11               ; COS тета в a11                │
│           fmul  qword ptr A_VECTOR[ecx*8]                               │
│           fstp  [ebx].a14               ; A * COS тета в a14            │
│           fxch  st(1)                   ; SIN тета в ST                 │
│           fst   [ebx].a21               ; SIN тета в a21                │
│           fld   st                      ; удвоить SIN тета              │
│           fmul  qword ptr A_VECTOR[ecx*8]                               │
│           fstp  [ebx].a24               ; A * SIN тета в a24            │
│           fld   st(2)                   ; альфа в ST                    │
│           fsincos                       ; COS альфа в ST                │
│    ;                SIN альфа в ST(1)                                   │
│    ;                SIN тета в ST(2)                                    │
│    ;                COS тета в ST(3)                                    │
│           fst   [ebx].a33               ; COS альфа в a33               │
│           fxch  st(1)                   ; SIN альфа в ST                │
│           fst   [ebx].a32               ; SIN альфа в a32               │
│           fld   st(2)                   ; SIN тета в ST                 │
│                                         ; SIN альфа в ST(1)             │
│           fmul  st,st(1)                ; SIN альфа * SIN тета          │
│           fchs  st(2)                   ; -COS тета * SIN альфа         │
│           fstp  [ebx].a23               ; хранится в a23                │
│           fld   st(2)                   ; COS тета в ST                 │
│                                         ; COS альфа в ST(1)             │
│                                         ; SIN тета в ST(2)              │
│                                         ; COS тета в ST(3)              │
│           fmul  st,st(1)                ; COS тета * COS альфа          │
│           fstp  [ebx].a22               ; хранится в A22                │
│           fmul  st,st(1)                ; COS альфа * SIN тета          │
│    ;                                                                    │
│    ;                Для того, чтобы получить преимущества               │
│    ;                параллельной работы IU и FPU                        │
│    ;                                                                    │
│           push  eax                     ; сохранить EAX                 │
│    ;                                                                    │
│    ;                Для ускорения поместить D в A34                     │
│    ;                                                                    │

│           mov   eax, dword ptr D_VECTOR[ecx*8]                          │
│           mov   dword ptr [ebx + 88],eax                                │
│           mov   eax, dword ptr D_VECTOR[ecx*8 + 4]                      │
│           mov   dword ptr [ebx + 92],eax                                │
│           pop   eax                     ; восстановить EAX              │
│           fchs                          ; COS альфа * SIN тета          │
│           fstp  [ebx].a12               ; хранится в a12                │
│                                         ; Вычисляются все               │
│                                         ; ненулевые элементы            │
│                                                                         │
│           ret                                                           │
│                                                                         │
│    trans_proc endp                                                      │
│                                                                         │
│    matrix_elem proc far                                                 │
│    ;                                                                    │
│    ;    Эта процедура вычисляет произведение i-той строки               │
│    ;    первой матрицы и j-того столбца второй матрицы:                 │
│    ;                                                                    │
│    ;       Tij, где Tij = сумме произведений Aik x Bkj по k             │
│    ;                                                                    │
│    ;    Параметры, передаваемые из вызвавшей процедуры                  │
│    ;    matrix_row:                                                     │
│    ;                                                                    │
│    ;                    ESI = (i-1)*8                                   │
│    ;                    EDI = (j-1)*8                                   │
│    ;                                                                    │
│    ; локальный регистр, EBP = (k-1)*8                                   │
│    ;                                                                    │
│           push  ebp             ; сохранить EBP                         │
│           push  ecx             ; для того, чтобы использовать          │
│                                 ; ESX как временный регистр             │
│           mov   ecx,esi         ; сохранить для дальнейшего             │
│                                 ;   индексирования                      │
│    ;                                                                    │
│    ; Взять элемент в первой матрице, A                                  │
│    ;                                                                    │
│           imul  ecx,NUM_COL     ; ECX содержит смещение предыдущих      │
│                                 ; строк; смещение берется от начала     │
│                                 ; матрицы                               │
│                                                                         │
│           xor   ebp,ebp         ; Очистить EBP, который будет нужен     │
│                                 ; как временный регистр для индекса     │
│                                 ; (k) по i-той строке первой            │
│                                 ; матрицы и вниз по j-тому столбцу      │
│                                 ; второй матрицы.                       │
│    ;                                                                    │
│    ;         Очистить Tij для накапливания пар Aik*Bkj                  │
│    ;                                                                    │
│           mov   dword ptr [edx][edi],ebp                                │
│           mov   dword ptr [edx][edi+4],ebp                              │
│                                                                         │
│           push  ecx             ; сохранить в стеке: ESI * num_col      │
│                                 ; = смещению начала i-той строки от     │
│                                 ; начала матрицы A                      │
│                                                                         │
│           add   ecx,ebp         ; взять k-тый элемент i-той строки      │
│                                 ; матрицы A                             │
│    ;                                                                    │
│    ;      Загрузить Aik в FPU                                           │
│    ;                                                                    │
│           fld   qword ptr [eax][ecx]                                    │
│    ;                                                                    │
│    ;      Взять Bkj                                                     │
│    ;                                                                    │
│           mov ecx,ebp                                                   │
│           imul  ecx,NUM_ROW     ; ECX содержит смещение начала          │
│                                 ; k-той строки от начала матрицы B      │
│           add   ecx,edi         ; Взять j-тый элемент k-той строки      │
│                                 ; матрицы B                             │
│           fmul  qword ptr [ebx][ecx]        ; Aik * Bkj                 │
│           pop   ecx             ; ESI * num_col                         │
│                                 ; в ECX снова                           │
│           pop   ecx             ; также в вершине программного          │
│                                 ; стека                                 │
│    ;                                                                    │
│    ;      Добавить к результату в выходной матрице, Tij                 │
│    ;                                                                    │
│           add   ecx,edi                                                 │
│    ;                                                                    │
│    ;      накопленные суммы пар Aik * Bkj                               │
│    ;                                                                    │

│           fadd  qword ptr [edx][ecx]                                    │
│           fstp  qword ptr [edx][ecx]                                    │
│    ;                                                                    │
│    ;      увеличить на единицу k, то есть                               │
│    ;      EBP на 8                                                      │
│    ;                                                                    │
│           add ebp,8                                                     │
│    ;                                                                    │
│    ; Достигло ли k ширины матрицы?                                      │
│    ;                                                                    │
│           cmp   ebp, NUM_COL*8                                          │
│           jl    NXT_k                                                   │
│    ;                                                                    │
│    ; Восстановить регистры                                              │
│    ;                                                                    │
│           pop   ecx              ; удалить из стека ESI * num_col       │
│           pop   ecx              ; восстановить ECX                     │
│           pop   ebp              ; восстановить EBP                     │
│                                                                         │
│    matrix_elem  endp                                                    │
│                                                                         │
│    matrix_row       proc     far                                        │
│           xor       edi,edi                                             │
│    ;                                                                    │
│    ;      Пройти по строке                                              │
│    ;                                                                    │
│    NXT_COL:                                                             │
│           call  matrix_ekem                                             │
│           add   edi,8                                                   │
│           cmp   edi, NUM_COL*8                                          │
│           jl    NXT_COL                                                 │
│           ret                                                           │
│                                                                         │
│    matrix_row endp                                                      │
│                                                                         │
│    matrixmul_proc proc far                                              │
│    ;                                                                    │
│    ; Эта процедура перемножает матрицы, используя                       │
│    ; процедуру matrix_row для вычисления элементов                      │
│    ; каждой строки.                                                     │
│    ;                                                                    │
│    ; Умножение матриц выполняется как:                                  │
│    ;                                                                    │
│    ; Tij = Aik x Bkj,                                                   │
│    ;                                                                    │
│    ; где i и j указывают на номера строки и столбца                     │
│    ; соответственно и k - индекс для прохода по i-той                   │
│    ; строке первой матрицы и по j-тому столбцу второй                   │
│    ; матрицы.                                                           │
│    ;                                                                    │
│           mov   ebp,esp                ; использует базовый указатель   │
│                                        ; для индексирования             │
│           mov   edx,dword ptr[ebp+4]   ; смещение Tmx в EDX             │
│           mov   ebx,dword ptr[ebp+8]   ; смещение Bmx в EBX             │
│           mov   eax, dword ptr[ebp+12] ; смещение Amx в EAX             │
│    ;                                                                    │
│    ;              Установка ESI и EDI                                   │
│    ;              EDI указывает столбец                                 │
│    ;              ESI указывает строку                                  │
│    ;                                                                    │
│           xor   esi,esi                ; очистить ESI                   │
│                                                                         │
│    NXT_ROW:                                                             │
│           call  matrix_row                                              │
│                                                                         │
│           add   esi,8                                                   │
│           cmp   esi,NUM_ROW*8                                           │
│           jl    NXT_ROW                                                 │
│           ret   12                ; вытолкнуть указатели матрицы        │
│                                                                         │
│    matrix_proc  endp                                                    │
│                                                                         │
│    trans_code   ends                                                    │
│                                                                         │
│    ; ********************************************** ;                   │
│    ;                                                ;                   │
│    ;                                                ;                   │
│    ;                                                ;                   │
│    ;            Главная   программа                 ;                   │
│    ;                                                ;                   │
│    ;                                                ;                   │
│    ;                                                ;                   │
│    ;                                                ;                   │
│    ; ********************************************** ;                   │

│                                                                         │
│    main_code   segment  er                                              │
│                                                                         │
│    START:                                                               │
│                                                                         │
│           mov   esp, stackstart trans_stack                             │
│    ;                                                                    │
│    ;            Сохранить все регистры                                  │
│    ;                                                                    │
│           pushad                                                        │
│    ;                                                                    │
│    ; ECX указывает число соединений, где число матриц                   │
│    ; равно NUM_JOINT + 1.                                               │
│    ; Найдем первую матрицу (от основания системы до                     │
│    ; первого соединения) и назовем ее Bmx.                              │
│    ;                                                                    │
│           xor   ecx,ecx                   ; первой матрицей             │
│           mov   ebx,offset Bmx            ;                             │
│           call  trans_proc                ; является Bmx                │
│           inc   ecx                                                     │
│                                                                         │
│    NXT_MATRIX:                                                          │
│    ;                                                                    │
│    ; Вторая матрица и выше будут сохраняться в Amx.                     │
│    ; Результат умножения матриц будет сохраняться в                     │
│    ; Tmx, но для следующего умножения будет доступен                    │
│    ; через Bmx. Такое дублирование необходимо для                       │
│    ; последовательного умножения матриц. Это                            │
│    ; достигается заменой поррядка следования указателей                 │
│    ; на Bmx и Tmx в программном стеке, хотя и является                  │
│    ; невидимым для процедуры перемножения матриц.                       │
│    ; REVERSE используется как индикатор;                                │
│    ; если REVERSE = 0, то это значит, что результат                     │
│    ; помещен в Tmx.                                                     │
│    ;                                                                    │
│           mov   ebx,offset Amx                 ; найти Amx              │
│           call  trans_proc                                              │
│           inc   ecx                                                     │
│           xor   REVERSE,1h                                              │
│           jnz   Bmx_as_Tmx                                              │
│    ;                                                                    │
│    ; Не менять. Bmx используется как вторая входная                     │
│    ; матрица, а Tmx - как выходная матрица.                             │
│    ;                                                                    │
│           push  offset Amx                                              │
│           push  offset Bmx                                              │
│           push  offset Tmx                                              │
│           jmp   CONTINUE                                                │
│    ;                                                                    │
│    ; Поменять. Tmx используется как вторая входная                      │
│    ; матрица, а Bmx - как выходная матрица.                             │
│    ;                                                                    │
│    Bmx_as_Tmx:                                                          │
│                                                                         │
│           push  offset Amx                                              │
│           push  offset Tmx         ; поменять переданные указатели      │
│           push  offset Bmx                                              │
│                                                                         │
│    CONTINUE:                                                            │
│                                                                         │
│           call  matrixmul_proc                                          │
│           cmp   ecx,NUM_JOINT                                           │
│           jle   NXT_MATRIX                                              │
│    ;                                                                    │
│    ; Если REVERSE = 1, то конечный результат будет в                    │
│    ; Bmx, а иначе в Tmx.                                                │
│    ;                                                                    │
│           popad                                                         │
│                                                                         │
│    main_code    ends                                                    │
│                                                                         │
│    end    START, ds:trans_data, ss:trans_stack                          │
│                                                                         │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
