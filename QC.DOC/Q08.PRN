


                 8.1.4.2. Выбор формата вывода файла:
                             Опции вывода.

    Выберите  одну  из  круглых  кнопок  выводных  опций для того, чтобы
задать, какой тип файла будет создан при компиляции редактируемого  вами
файла или файла, составляемого из модулей программного списка. Следующая
таблица описывает данные опции:

Опции                  Использование


Obj                    Создает объектный файл на диске с тем же базо-
                       вым именем, что и исходный файл плюс расшире-
                       ние .OBJ.
Memory                 Создает программу, которая может выполняться
                       в среде Quick-C. Если вы не выбрали никакой из
                       выводных опций, опция Memory является стандар-
                       тной.
Exe                    Создает выполняемый файл на диске, с тем же
                       самым именем, что и текущая программа плюс ра-
                       сширение .EXE. Данный выполняемый файл не мо-
                       жет работать в среде Quick-C, но может быть
                       запущен, как любая другая программа в среде
                       DOS.
Syntax Check Only      Проверяет синтаксис программы и высвечивает
                       диагностические сообщения для любых найденных
                       ошибок, но не создает объектный или выполняе-
                       мый файл.






                    8.1.4.3. Подготовка к отладке:
                             Опция Debug.

    Выбирайте контрольную  рамку Debug,  если вы  хотите отлаживать вашу
программу  в  среде  Quick-C.  Опция  Debug строит программу, содержащую
полную информацию для символической отладки в среде Quick-C.

    Если  вы  выбрали  данную  опцию,  а затем "нажали" командные кнопки
Build  Program  или  Rebuild  All  (смотрите  Раздел 8.1.4.10), редактор
связей  создает  на  диске  файл  карты распределения памяти, содержащий
отладочную  информацию.  Данный  файл  имеет  то  же  самое  имя,  что и
программа, но с расширением .MAP.  В разделе 9.5.10 вы найдете  описания
файлов типа .MAP и их форматы.

    Если вы выберете опцию вывода EXE вместе с опцией Debug, выполняемый
файл,  который  вы  создадите,  можно  будет отлаживать с использованием
полноэкранного отладчика Microsoft Code View.


            8.1.4.4. Использование "корректных указателей":
                         Опция Pointer Check.

    Контрольная рамка  Pointer Check  защищает вашу  программу от  часто
встречающихся  ошибок  указателей,  которые  могут  привести  к  ошибкам
периода выполнения.  Если вы  выберете опцию  Pointer Check,  компилятор
Quick-C   сгенерирует   выполняемый   код,   который   проверит    перед
использованием  указателей,  какие  данные  программы  адресуют   данные
указатели.

    Если нет в окне ошибок, пакет Quick-C высветит ошибки указателей  во
время выполнения программы.

    Проверка  указателей  может  предотвратить  ошибки,  которые   могут
перезаписать код или данные Quick-C или DOS и тем самым вызвать  останов
работы пакета  Quick-C или  системы DOS.  В результате,  мы настоятельно
рекомендуем пользоваться данной опцией во время разработки программ.

    Заметим,  что  опция  Pointer  Check  может  значительно   замедлить
выполнение программы. В альтернативу этому можем вам предложить включать
или  выключать  проверку  только  для  отдельных  указателей,   оставляя
стандартный  режим  для  остальных  указателей  модуля.  Если  вы хотите
включить  проверку  указателей  поместите  перед  описаниемем указателя,
который вы хотите проверить следующую строку:

    #pragma check pointer(on)

    Данная строка включит проверку для всех указателей, следующих за ней
в данном исходном файле, а не только находящихся в данной строке.  Чтобы
выключить проверку на указатели, введите следующую строку:

    #pragma check pointer(off)

    Если  для  директивы  pragma  check  pointer  не  задается  никакого
аргумента,  проверка  указателей  возвращается  к  поведению,  заданному
опцией  Pointer  Check:  включена,  если  включена опция Pointer Check;и
выключена  в  противном  случае.  Взаимодействие  директивы pragma check
pointer и опции Pointer Check подробно описано в Таблице 8.1.

                                                 Таблица 8.1.

             Использование директивы pragma check pointer.

Синтаксис              Компиляция   Действие


#pragma check pointer()   да        Включает проверку на указатели,
                                    следующие далее.
#pragma check pointer()   нет       Выключает проверку на указатели,
                                    следующие далее.
#pragma check pointer(on)     да или нет  Включает проверку на ука-
                                          затели, следующие далее.
#pragma check pointer(off)    да или нет  Выключает проверку на ука-
                                          затели, следующие далее.




               8.1.4.5. Проверка на переполнение стэка:
                          Опция Stack Check.

    Выберите  контрольную  рамку  Stack  Check,  если  вы  хотите, чтобы
Quick-C проверял, достаточно  ли стековой памяти  для вашей программы  и
выдавал диагностические сообщения, если недостаточно.

    Проверка  стека  выполняется  процедурами,  известными  как   "stack
probes" (контроль стека). Процедуры контроля стека вызываются из функции
для  проверки  достаточно  ли  места  в программном стеке для размещения
локальных  переменных  требуемых   функции.  Процедуры  контроля   стека
вызываются  при  каждом  вызове  функции  из  программы.  Они генерируют
сообщения  о   переполнении  стека   в  случае,   если  стековой  памяти
недостаточно. Поскольку проверка стека отлавливает ошибки, которые могут
привести к  сбою выполнения  операций Quick-C  или DOS,  мы настоятельно
рекомендуем применять при разработке программ опцию Stack Check.

    Если  проверка   стека  выключена,   процедуры  контроля   стека  не
вызываются, в этом случае переполнение стека происходит без  диагностики
(то есть сообщение об ошибке не выводится).

    Однако, программы,  не включающие  в себя  процедуры контроля стека,
меньше по объему и работают быстрее.

    Если  вы  хотите  включить  или  выключить проверку стека только для
некоторых  процедур  в  программе,  пользуйтесь  директивой pragma check
stack.  Для  функции,  в  которой  вы  хотите  включить  проверку стека,
поместите перед определением функции следующую строку:

    #pragma check stack(on)

    Данная строка  включает контроль  стека для  всех процедур следующих
далее в исходном  файле, а не  только для процедур  на следующей строке.
Для выключения проверки стека введите следующую строку:

    #pragma check stack(off)

    Если в директиве  pragma check stack  не задано никакого  аргумента,
контроль стека работает так, как было определено опцией Stack Check:  то
есть включен, если  опция Stack Check  включена, и выключен,  если опция
Stack Check выключена.

    Взаимодействие  директивы  pragma  check  stack  и опции Stack Check
подробно описано в Таблице 8.2.

                                                 Таблица 8.2.

              Использование директивы pragma check stack.

                             Компиляция с

Синтаксис                 опцией         Действие

                             Stack Check?


#pragma check stack()    Да              Включает контроль стека для
                                         процедур, следующих далее.
#pragma check stack()    Нет             Выключает контроль стека для
                                         процедур, следующих далее.
#pragma check stack(on)  Да или нет      Включает контроль стека для
                                         процедур, следующих далее.
#pragma check stack(off) Да или нет      Выключает контроль стека для
                                         процедур, следующих далее.



    Вам следует задавать опцию Stack Check до тех пор, пока вы не будете
уверены, что  в вашей  программе достаточно  стековой памяти.  Например,
данная опция может  совсем не понадобиться  вам для программы,  делающей
всего несколько вызовов функций, которые имеют умеренные запросы  памяти
для локальных переменных и не имеют рекурсий.


       8.1.4.6. Использование расширений Microsoft C к языку СИ:
                      Опция Language Extensions.

    Контрольная рамка  Language Extensions  применяется, если  вы хотите
использовать  в  программе  расширение  к  стандарту  языка СИ "ANSI C",
предлагаемые компилятором Microsoft Quick-C.

    - ключевые слова cdecl , far , fortran , near , pascal;

    - для получения значений  long используется приведение типов,  как в
следующем примере:

      int *p;
      ((long*)p)++;

    - использование хвостовой  запятой (,), а  не запятой с  многоточием
(,...) в описании функции для обозначения переменного списка аргументов,
как например:

    int printf(char *,);

    -  переопределение  typedef  разрешаеются  в  той  же  самой области
действия, как в следующем примере:

      typedef int INT;
      typedef int INT;

    -  В  инициализации  разрешается  применять  смешанные  строковые  и
символьные константы, как в следующем примере:

    char arr[6]= {'a', 'b', "cde"};

    - Использование битовых полей с базовыми типами данных, отличных  от
unsigned int, либо signed int.

---------------------------------------------------------------------

    Примечание:

    Ключевое слово far не может быть использовано для определения данных
в программах, работающих в памяти, даже если используется опция Language
Extensions. Однако, оно может быть использовано для описании  указателей
на данные.

---------------------------------------------------------------------

    Не   применяйте   опцию   Language   Extensions,   если   вы  будете
компилировать  вашу  программу  с  помощью компиляторов, не распознающих
расширения к языку СИ, имеющиеся в Microsoft Quick-C. Если вы  выключите
данную опцию, расширенные ключевые слова будут трактоваться, как простые
идентификаторы,  а  остальные  расширения,  приведенные  в списке, будут
восприниматься, как недопустимые конструкции.

    Если  языковые  расширения  не  разрешены,  компилятор автоматически
определяет идентификатор NO_EXT_KEYS. Во включаемых файлах, поставляемых
вместе  с  библиотекой  процедур,  данный  идентификатор  используется с
директивой препроцессора #ifndef для управления применения в  прототипах
библиотечных функций ключевого слова cdecl.

    Примером  данной  условной  компиляции  является  включаемый  файл с
именем stdio.h.




                  8.1.4.7. Создание быстрых программ:
                         Опция Optimizations.

    Данная  контрольная  рамка  оптимизирует  вашу программу по скорости
выполнения.  Оптимизация   выполняется  с   помощью  свертки   констант,
автоматического   управления   регистрами,   автоматической    генерации
инструкций микропроцессора 80286.

    Программы, скомпилированные с данной опцией, могут быть  значительно
больше, чем программы, без данной опции, но они работают быстрее.


                   8.1.4.8. Поиск включаемых файлов:
                       Текстовая рамка Include.

    Если вы хотите искать включаемые файлы в каталогах, отличных от тех,
что заданы в переменной  программной среды INCLUDE, введите  в текстовой
рамке INCLUDE один или более маршрутов поиска, отделенных друг от  друга
запятыми (,). Копилятор будет искать каталог или каталоги в том порядке,
в котором вы их введете,  причем до того, как он  просмотрит стандартные
места, заданные в  переменной INCLUDE. Каталоги  ищутся в заданном  вами
порядке.

    Если компилятор Quick-C не может найти включаемый фвйл в  каталогах,
заданных вами в текстовой рамке, или в каталогах, заданных в  переменной
INCLUDE, компилятор высвечивает сообщение об ошибке и прекращает работу.
В  этом  случае,  вам  следует  посторить  компиляцию программы, сообщив
Quick-C, где искать  недостающий включаемый файл,  воспользовавшись либо
переменной INCLUDE, либо текстовой рамкой INCLUDE.


             8.1.4.9. Определение констант и макрокоманд:
                        Текстовая рамка Define.

    Используйте  текстовую  рамку  Define  для определения константы или
макрокоманды вашего исходного файла. Введите одну или более констант или
макроопределений в следующей форме, отделенные запятыми (,):

    identifier=string

    В каждом определении, identifier-это имя константы или макрокоманды,
а string-ее значение или содержание. Если вы опустите и знак  равенства,
и string, считается, что данная  константа уже определена и ее  значение
равно 1. Например, Set-достаточно определить макрокоманду с именем Set и
значением 1.

    Опция define особенно  полезна, если вы  применяете директивы #if  и
#ifdef для выполнения условной компиляции исходных файлов.

    Если вы зададите  знак равенства с  пустой строкой данная  константа
или макрокоманда  считается определенной  и равна  пустой строке.  Такое
определение   может   эффективно   вычистить   все   появления   данного
идентификатора из исходного файла. Например, чтобы удалить все появления
идентификатора REGISTER, используйте следующую опцию:

    REGISTER=

    Заметим,   что   идентификатор   register   считается  определенным,
поскольку имена, заданные большими и малыми буквами рррррррр

    Макроопределения или  определения констат  в текстовой  рамке Define
имеют то  же самое  действие, что  и директива  препроцессора #define  в
начале вашего  исходного файла,  или опция  /D в  командной строке  QCL.
Идентификатор, определенный в  исходном файле, будет  компилироваться до
тех пор,  пока директива  #undef не  отменит определение,  либо не будет
достигнут конец файла.

    Если   идентификатор,   определенный   в   текстовой   рамке Define,
определяется также и в  исходном файле, определение, данное  в текстовой
рамке,   используется   до   тех   пор,   пока   идентификатор  не будет
переопределен в исходном файле.

      Пример:
#if !defined(RELEASE)
       _nheapchk();
#endif

    Данный  пример  вызывает  функцию  для проверки ближней динамической
области, до тех  пор, пока не  будет определена константа  RELEASE. Пока
программа  находится  в  стадии  разработки,  вы можете оставить RELEASE
неопределенным и выполнять  проверку динамической области  для выявления
сбоев.  Затем,  когда  вы  исправите  все  ошибки  в  вашей   программе,
определите RELEASE, и программа будет работать быстрее.


                 8.1.4.10. Командные кнопки диалоговой
                             рамки Compile.

    Командные  кнопки  в  диалоговой  рамке Compile сообщают компилятору
Quick-C, компилировать ли исходный файл, который вы редактировали,  либо
модули  из  текущего  программного  списка.  Выберите  одну из следующих
командных кнопок:

Командная кнопка       Использование


Build Program          Перекомпилирует все модули текущего программ-
                       ного списка, которые были обновлены со време-
                       ни последней перестройки програмы; затем прог-
                       рамма перестраивается. Детально данная проце-
                       дура описывается в Разделе 6.1.4. Результирую-
                       щие объектные файлы, файл для редактора свя-
                       зей, выполняемый файл, и (если включена опция
                       Debug) файл карты распределения памяти записы-
                       ваются на диск. Если не имеется программного
                       списка, компилируется исходный файл, который
                       вы редактировали.
Compile File           Компилируется редактируемый в данный момент
                       исходный файл.
Rebuild All            Перекомпилируются все модули из текущего прог-
                       раммного списка, независимо от того, изменя-
                       лись ли они со времени последней перестройки
                       программы; затем программа заново строится.
                       Подробно данная процедура описывается в Разде-
                       ле 6.1.4. Результирующие объектные файлы, файл
                       для редактора связей, выполняемый файл, и (ес-
                       ли включена опция Debug) файл карты распреде-
                       ления памяти записываются на диск. Если не су-
                       ществует программного списка, компилируется
                       редактирумый в данный момент исходный файл.
Cancel                 Снимает компиляцию и возвращает вас в окно об-
                       зора.



       8.1.5. Опции, управляющие процессом выполнения программ:
                    Команда Set Runtime Options...

    Команда  Set  Runtime  Options...  управляет  различными   аспектами
поведения программы во времы выполнения. Данные опции будут  действовать
и в следующий раз, когда программа будет запущена.

    Когда вы выберете  команду Set Runtime  Options... из меню  File, на
экране появится соответствующая диалоговая рамка, открытая для работы.

    В  следующем  списке  описаны  опции  диалоговой  рамки  Set Runtime
Options...:

Опция                  Использование


Command Line           Введите аргументы, которые бы вы набрали в
                       командной строке после имени программы, если
                       бы программа запускалась с помощью командной
                       строки DOS. Данные аргументы передаются прог-
                       рамме с помощью стандартных аргументов argv и
                       argc функции Main исходного текста СИ-програм-
                       мы.
Near Data              Чтобы уменьшить количество памяти, отведенной
                       для стандартного сегмента данных (по умолча-
                       нию 64К), введите количество отводимых байтов
                       (в десятичном виде). Стандартный сегмент со-
                       держит все инициализированные глобальные
                       данные и данные типа static, исключая данные
                       явно описанныеые с ключевым словом far. Вам
                       может понадобиться уменьшить размер данного
                       сегмента, если ваша программа не использует
                       большое количество данных, входящих в стандар-
                       тный сегмент, но использует большие по размеру
                       данные (как, например большие массивы), разме-
                       щаемые в других сегментах данных. Подробную
                       информацию о размещении данных вы можете найти
                       в Приложении В "Работа с моделями памяти
                       Quick-C". Подробности о стандартном сегменте
                       данных и других сегментах, используемых компи-
                       лятором Microsoft Quick-C, вы найдете в Прило-
                       жении С "Интерфейс между языком СИ и языком
                       Ассемблер".
Stack                  Чтобы использовать стек размером, отличный от
                       стандартного (2К), введите количество байтов
                       (в десятичном виде) в текстовой рамке Stack.
                       Наибольший размер стека, который вы можете
                       потребовать-64К. Вы можете увеличить размер
                       стэка, если ваша программа выдает диагности-
                       ческие сообщения о переполнении стека. И на-
                       оборот, если ваша программа использует очень
                       маленький стек, вам может понадобиться умень-
                       шить размер программы путем уменьшения размера
                       стека.




                        8.2. Отладка программ.

    Компилятор  Microsoft   Quick-C  имеет   мощные  средства   отладки,
облегчающие  процесс  выявления  ошибок  в программной логике. Например,
отладчик  можно  использовать  для  трассировки  и пошагового выполнения
программы, установки точек прерывания  и проверки значений переменных  и
выражений.



                  8.2.1. Основная процедура отладки.

      Для отладки программы в среде Quick-C используйте следующую
основную процедуру:

    1. Скомпилируйте программу с  включенной опцией Debug в  диалого вой
рамке Compile.

    2. Включите какие-либо средства отладки, такие как точки прерывания,
выражений  просмотра   или  прокрутка   экрана-либо  с   помощью  команд
клавиатуры, либо с помощью команд меню Debug, описанных в Разделе 8.2.3.

    3.  Запустите  вашу  программу   на  выполнение  с  помощью   команд
клавиатуры, описанных  в Разделе  8.2.2, либо  с помощью  команд из меню
Run:  Start,  Restart,  Continue.  Наблюдайте  при этом, в каком порядке
выполняются функции и операторы, какие изменения претерпели  переменные,
данные, выводимые программой.

    4. Отредактируйте вашу программу, чтобы исправить ошибки, выявленные
на  шаге  3.  Затем  перекомпилируйте  вашу программу снова выбрав опцию
Debug из меню Compile.

    5.  Если  вам  требуется  изменить какую-либо отладочную информацию,
вернитесь  к  шагу  2.  В   противном  случае  вернитесь  к  шагу   3  и
перезапустите вашу программу.

    6. Повторяйте  шаги 3-5  до тех  пор, пока  ваша программа  не будет
выполняться корректно.


               8.2.1.1. Добавление выражений просмотра.

    Если  вы  добавите   выражения  просмотра,  Quick-C   откроет  окно,
называемое  "окном   просмотра"-в  верхней   части  экрана,   где  будут
высвечиваться значения выражений просмотра.

    Во время  выполнения программы  пакет Quick-C  постоянно высвечивает
значения  выражений  просмотра,  изменяя  их,  в  зависимости  от  смены
значений  соответствующих  программных  переменных.  Не   прогнозируемые
значения выражений просмотра могут означать ошибки в программе.

    Для добавления выражения просмотра пользуйтесь командой Add Watch из
меню Debug.  Для удаления  только что  добавленного выражения  просмотра
пользуйтесь  командой  Delete  Last  Watch  из  меню Debug. Обеими этими
командами рекомендуется  пользоваться, если  вы просматриваете  значения
локальных переменных во  время прохода через  функции, в которых  данные
переменные  определены,  а  затем,  после  выхода  из  функции  удаляете
выражения просмотра для данных переменных.

    Чтобы  удалить  ВСЕ  выражения  просмотра, следует применить команду
Delete All Watch из меню Debug.


                 8.2.1.2. Установка точек прерывания.

    "Точки   прерывания"   устанавливаются   на   определенных   строках
программы.   Точка   прерывания   заставляет   пакет   Quick-C  временно
приостановить  выполнение  программы  в  данной строке. Точки прерывания
часто  используются  вместе  с  выражениями  просмотра: установите точки
прерывания  в  тех  строках  программы,  где  вы  ожидаете  сбой,  затем
проверьте значения выражений просмотра в данной точке.

    Чтобы включить или выключить точку прерывания, установите курсор  на
строку, где вы хотите переключить  данную точку. Затем либо нажмите  F9,
либо выберите команду Toggle Breakpoint из меню Debug.

    Для  удаления  всех  точек  прерывания,  выберете  команду Clear All
Breakpoints из меню Debug (Смотрите Раздел 8.2.3.5.  "Управление точками
прерывания" для получения более подробной информации о команде Clear All
Breakpoints).


              8.2.2. Отладка с помощью команд клавиатуры.

    Quick-C поддерживает следующие  команды, вызываемые нажатием  одного
ключа:

Команда для:                                      Ключ


Выполнение следующего оператора программы;        F8
трассировка функции.
Выполнение следующего программного оператора;     F10
трассировка в обход функции.
Выполнение программы до текущей позиции курсора.  F7
Высвечивание выводного экрана                     F4


    Для  выполнения  программы  до  строки,  в  которой   позиционирован
указатель мыши, щелкните на данной строки правой кнопкой мыши.


                  8.2.3. Команды отладки: Меню Debug.

    Команды из меню Debug выполняют следующие действия:

Команда                Действие


Add Watch              Добавляет в окно просмотра одно или более вы-
                       ражений просмотра.
Delete Last Watch      Удаляет из окна просмотра выражение просмотра,
                       добавленное последним. Ключевая последователь-
                       ность для данной команды SHIFT+F2.
Delete All Watch       Удаляет из окна просмотра все выражения про-
                       смотра.
Trace On               Включает, либо выключает трассировку программы
Scceen Swapping On     Включает, либо выключает прокрутку экрана.
Toggle Breakpoint      Включает или выключает точку прерывания на
                       строке в текущей позиции курсора. Ключ быстро-
                       го реагирования для данной команды F9.
Clear All Breakpoints  Очищает все точки прерывания из данной про-
                       граммы.



    В Разделах 8.2.3.1-8.2.3.5. описываются команды из меню Debug.


               8.2.3.1. Добавление выражений просмотра:
                         Команда Add Watch...

    Команда Add Watch... используется для добавления в окно просмотра  в
верхней части экрана одного или более выражений просмотра.

    Как только вы выберете команду Add Watch... из меню Debug, на экране
появится открытая диалоговая рамка.

    Введите в текстовую рамку  одно или более выражений  просмотра. Если
вы вводите  более одного  выражения, в  конце каждого  выражения вводите
точку с запятой.

    Выражение просмотра может быть одним из следующих:

    - переменная;

    - Си-выражение, состоящее из переменных, объедененных в скобки (()),
квадратные  скобки   ([]),  оператором   выбора  члена   структуры  (.),
оператором-указателем  на  структуру  (->),  либо  оператором косвенного
наименования (*);

    - содержимое структуры или массива

    Заметим,  что  в  выражениях  просмотра  математические операторы не
допускаются.

    Чтобы  высветить  значение  просматриваемой  переменной,   используя
различные формат вывода, введите после имени просматриваемой  переменной
запятую, за  которой следует  символ формата.  В Таблице  8.3 приводится
список  символов  формата  вместе  с  примерами  вывода  для   значений,
хранящихся в памяти.

                                                 Таблица 8.3.

         Спецификации формата для просматриваемых переменных.

Символ  Формат вывода          Просматриваемое   Высвечиваемое зна-

                               значение            чение


d      десятичное целое со     40000                 40000
        знаком
i      десятичное целое со     40000                 40000
        знаком
u      десятичное целое        40000                 40000
        без знака
o      восьмиричное целое      40000                 116100
       без знака
x      шестнадцатеричное целое 40000                  9с40
f      значение со знаком с    3./2.                  1.500000
       плавающей точкой в де-
       сятичном формате с 6-ю
       знаками после запятой.
e      число со знаком в фор-  3./2.                  1.500000е+000
       мате с плавающей точ-
       кой (экспонинциальном)
       до 6-и знаков после
       запятой (хвостовые нули
       и десятичная точка
       отбрасываются)
g      число со знаком с пла-  3./2.                   1.5
       вающей точкой в деся-
       тичном формате (f), ли-
       бо в экспонинциальном
       формате (е)-то что более
       компактно.
c      один символ             65                        А
s      символы, печатаемые до  "String"                  String
       первого пустого сим-
       вола.

    Если  не  задано  никакого  формата,  отладчик  Quick-C   использует
стандартную  спецификацию  формата  для  данного  типа   просматриваемой
переменной.   В   структурах   каждое   поле   высвечивается  в формате,
стандартном  для  типа  данного  поля.  Дейтсвительные  числа  простой и
двойной точности высвечиваются в формате g.

    Для обозначения двухбайтового  целого со спецификациями  формата (d,
o, u, x) используется префикс h. С теми же самыми типами префикс l может
использоваться для идентификации четырехбайтового целого.

    Например,   если   значение   просматриваемой   переменной   100000,
спецификация ld  дает 100000.  Однако, спецификация  hd вычисляет только
два старших байта и дает в выводе -31072.

    Спецификаторы формата для просматриваемых переменных работают тем же
самым способом, что и  спецификаторы формата для семейства  библиотечных
функций printf. Поэтому,  если вы определите  просматриваемую переменную
одного типа,  а спецификатор  формата другого  типа, неявное  приведение
типа просматриваемой  переменной к  типу спецификатора  формата не будет
произведено.  Вместо  этого,  битовый  шаблон  в  памяти, представляемый
просматриваемой  переменной,  появляется  в  таком  виде, как если бы он
представлялся элементом того же самого типа, что и спецификатор формата.
Например,  если  переменная  типа  int  имеет  значение  4,  и  если  вы
высвечиваете  ее  в  формате  f,  высвечиваться  будет  "0.00000'  а  не
'4.00000".  Данное  значение   высвечивается,  поскольку  в   формате  с
плавающей точкой битовый шаблон формата "00000100" представляет число  с
такой маленькой степенью, что она почти равна нулю.

    Вы  не   ограничены  в   высвечивании  содержимого   просматриваемой
переменной. Если вы после имени просматриваемой переменной введете более
одного символа формата, каждый символ формата будет представлять область
памяти,  находящуюся   после  области   памяти  данной   просматриваемой
переменной. Отладчик Quick-C высвечивает значение, хранимое в каждой  из
этих областей памяти, используя формат заданный данным символом формата.

    После того, как  вы введете в  текстовую рамку выражения  просмотра,
"нажмите" командную  кнопку ОК  для добавления  данных выражений  в окно
просмотра, либо командную кнопку Cancel для снятия команды Add Watch...

    Обратите  внимание,  что  выражение  просмотра  неопредены, если они
неопределены для функции, выполняемой в данный момент (то есть, если они
не попадают в свою область действия).

    Примеры:

    watchvar,f

    Пример,  приведенный  выше,  высвечивает  значение   просматриваемой
переменной watchvar  в десятичном  формате с  плавающей точкой  и шестью
десятичными знаками.

    watchavar,dulx10c

    Второй  пример   высвечивает  значение   просматриваемой  переменной
watchvar  в  десятичном  формате  со  знаком.  Кроме того, высвечиваются
значение  12  областей  памяти,   адреса  которых  следуют  за   адресом
watchavar, в форматах, приведенных ниже:

      - десятичное число без знака;
      - длинное шестнадцатеричное число;
      - десять символов.


        8.2.3.2. Удаление просматриваемых переменных: Команды
                     Delete Last Watch/All Watch.

    Команда Delete Last Watch удаляет из окна просмотра недавно  (только
что) добавленное выражение  просмотра. Если вы  с помощью одной  команды
Add Watch... добавили более одного выражения просмотра, удаляется только
последнее   выражение,   находящееся   в   текстовой   рамке.   Ключевая
последовательность для данной команды SHIFT+F2.

    Команда Delete All Watch удаляет все выражения просмотра и закрывает
окно просмотра.


                   8.2.3.3. Управление трассировкой:
                           Команда Trace On.

    Команда  Trace  On  включает,  либо выключает трассировку программы.
Если  данная  команда  включена,  в  меню  Debug  появляется контрольный
маркер. Если при включенной трассировке, вы вызовете из меню Run команды
Start  или  Continue,  программа  будет  выполняться  до следующей точки
прерывания, причем  текущий выполняемый  оператор будет  подсвечиваться.
Если следующий  выполняемый оператор  находится в  другом модуле, данный
модуль высвечивается в окне просмотра.

    Если   трассировка   включена,   текущий   выполняемый   оператор не
подсвечивается. Выполнение продолжается непосредственно до первой  точки
прерывания, которой является первый подсвеченный оператор.


                8.2.3.4. Управление прокруткой экрана:
                      Команда Screen Swapping On.

    Команда  Screen  Swapping  On  включает,  либо  выключает  прокрутку
экрана.  После  выполнения  команды  в  меню  Debug появится контрольная
метка, обозначающая включенную прокрутку экрана.

    Если прокрутка экрана включена, экран Quick,C исчезает и  заменяется
экраном  программного  вывода  по  каждому  шагу  выполнения  программы,
последовательно, с постоянным мерцанием.

    Если прокрутка экрана  выключена, выводной экран  появляется только,
если программы выполнеяет операцию вывода-либо с помощью функций вывода,
либо  с  помощью  графических  функций.  При  этом  эффекта  мерцания не
возникает, поскольку он является результатом прокрутки экрана.


            8.2.3.5. Управление точками прерываний: Команды
              Toggle Breakpoint и Clear All Breakpoints.

    Команда  Toggle  Breakpoint   и  Clear  All   Breakpoints  управляют
использованием в процессе отладки точками прерываний.

    Команда Toggle Breakpoint включает, либо выключает точку  прерываний
в  строке,  в  которой  в  данный  момент  установлен курсор. Если точка
прерывания уже установлена, команда  выключит ее; если точка  прерывания
не установлена,  команда Toggle  Breakpoint установит  ее. Ключ быстрого
реагирования для данной команды F9.

    Строки, в которых установлены точки прерывания, имеют цвета и другие
атрибуты, заданные опцией Breakpoint Lines в диалоговой рамке Options...
меню View.

    Команда  Clear  All  Breakpoints  удаляет  все  точки  прерывания из
отлаживаемой программы.


                  8.2.4. Перемещение между функциями:
                              Меню Calls.

    Меню Calls высвечивает список вызываемых функций. Этот список  можно
использовать   для   высвечивания   функций.   Кроме   того,   вы можете
использовать  список   данных  функций   для  выполнения   программы  до
определенной функции.

    Пока список  Calls высвечивается,  вы можете  использовать мышь  или
ключи управления курсором и ключ ENTER для выбора одной из функций.

    Пакет  Quick-C  высветит  функцию  и  поместит  курсор  на следующий
оператор,  который  будет  выполняться,  когда  управление  вернется   к
вызывающей функции.

    Если  вы  последовательно  проходите  через  функцию и хотите из нее
выйти, выполните следующие шаги:

    1. Откройте меню Calls.

    2. Воспользуйтесь  ключами управления  курсором для  подсветки имени
функции, из которой  вы вызвали функцию,  которую вы проходите  в данный
момент, и нажмите ENTER.

    3. Нажмите F7.

    Отладчик Quick-C возвратит вас в точку, непосредственно следующую за
той, из которой вы вызвали функцию.
