

                             ГЛАВА 4.


                    Запуск графики пакета  Quick-C.


4.1   Структура графической программы.
4.2   Установка видео-режима.
4.3   Определение видео-конфигурации.
4.4   Использование цветных текстовых режимов.
4.5   Использование цветных графических режимов CGA.
4.6   Использование цветных графических режимов EGA.
4.7   Использование цветных графических режимов VGA.
4.8   Понятие о координатных системах.
4.9   Расстановка точек.
4.10  Вычерчивание линий.
4.11  Описание графических объектов.
4.12  Изображение графических объектов.
4.13  Заполнение фигур по шаблонам.
4.14  Вычерчивание и запоминание фигур.
4.15  Использование мультипликации.

    Данная Глава кратко описывает основы графического  программирования.
Она разработана таким образом,  чтобы наиболее быстрым способом  научить
вас решать любые графичечские задачи.

    Чтобы  ускорить  ваше  обучение,  каждая  тема располагается на двух
страницах.  Темы   представлены  в   порядке  вызрастания   сложности  и
приблизительно отвечая частоте появления в ваших программах.

    Каждый раздел  сначала определяет  и описывает  тему (как,  нпример,
видео-режим), затем переходит к подробному рассмотрению данной операции.
Каждый  раздел,  кроме  того,  заканчивается  графической программой или
сегментом программы, которая поясняет тему.

---------------------------------------------------------------------

    Важное замечание:

    Чтобы выполнить графические примеры, приведенные в данной Главе, ваш
компьютер должен  обладать графическими  воэможностями. Это  может быть,
например,  встроенное  средство  или  плата  графического  адаптера,   и
видео-дисплей  (либо  монохронный,  либо  цветной), который поддерживает
точечную графику.

    Кроме  того,  вам  следует  включить  в  программный  список   вашей
выполняемой СИ-программы графическую  библиотеку. Подробно этот  процесс
описан в Разделе 6.1.

---------------------------------------------------------------------

    -Дополнительные источники по изучению графики.

    Для  дальнейшего  погружения  в  микрокомпьютерную графику вы можете
воспользоваться некоторыми из приведенных ниже пособий:

    -Artwick, Bruce.  "Microcomputer Displays, Graphics and Animaition".
Englewood Cliffs.  NJ:Prentice-Hall, Inc., 1985 (Обзор  микрокомпютерной
графики и мультипликации создателем "flight Simulator").

    -Cockerham, John T. "Tne EGA Standart" PC Teeh Journal 4:10 (October
1986): 48-79 (Обзор стандарта EGA).

    Hummel,Robert L.  "Get the  Full EGA  Color Spectrum".   PC Magazine
(June 23,1987):311-328.  (Обзор цветных палитр EGA).

    -International  Business  Mashines.   "Enhanced  Graphics   Adapter"
(manual part # 6280131).  (Официальное техническое руководство  адаптера
EGA, выпущенное фирмой IBM, 1-800-426-7282).

    -Norton,Peter "The Peter Norton  Programmer's Guide to the  IBM PC".
Redmond, WA:Microsoft press,  1985.  (Стандартное руководство  "изнутри"
по семейству компьютеров IBM-PC. Несколько глав посвящены видео-режимам,
за исключением режимов EGA и VGA).


                 4.1 Структура графической программы.

    Разработка всех графических программ включает следующие пять шагов:

      1.Подключение графической библиотеки.

      2.Установка видео-режима.

      3.Определение параметров видео-конфигурации.

      4.Создание и манипуляции графическими фигурами.

      5.Восстановление первоначальной конфигурации перед выходом из
        программы.



    -Подключение графической библиотеки.

    Выключаемый   заголовочный   файл   graph.h   определяет    основные
переменные, прототипы  функций и  константы, используемые  в графическом
программировании.   Подключайте   данный   файл   ко   всем  программам,
использующим графические функции.

    -Установка видео-режима.

    Первым   шагом   в   графических   программах   является   установка
видео-режима,  который  разрешает  выполнение  графических  функций.   В
графической  библиотеке  СИ  поддерживается  10 графических режимов. Они
перечислены в Разделе 4.2.

    Процесс установки видео-режима описан ниже:

      1. Установите наивысший уровень видео-режима, требуемый для ва-
         шей программы. Проверьте возвращаемое значение на сбой.

      2. Если вы не можете установить первоначально заданный видео-
         -режим, продолжите попытку с более слабыми режимами до
         тех пор, пока режим не будет установлен, или до тех пор,
         пока не останется видео-режимов, удовлетворяющих вашей прог-
         рамме. Если не найдено корректного видео-режима, выйдете из
         функции и напечатайте сообщение об ошибке.

    -Определение видео-конфигурации.

    Для определения характеристик  видео-режима следует вызвать  функцию
getvideoconfig.   Полученная   информация   включает   такие   вещи, как
количество пикселов  x и  y для  каждого размера  и количество возможных
цветов.

    -Восстановление первоначальной конфигурации.

    Восстановите  систему  в  ее  первоначальный видео-режим посредством
вызова  функции  setvideomode  с  константой  DEFAULTMODE. Отказ системы
выполнить данные  действия приведут  к тому,  что при  запуске следующей
программы машина будет "заблокирована".

      -Пример: Скелет графической программы.
#include <stdio.h>
#include <graph.h> /* подключаемый файл графических функций */
int set mode (void); /* прототип */
struct videoconfig vc; /* данные конфигурации */
char error message [] = "This video mode is not supported";
main()
{
/* программа требует разрешения экрана 640x200 */
   if (!set mode()){ /* если set mode завершилась неудачно */
     printf ("%s\n", error message); /* печать сообщения об ошибке */
     exit (0); /* и выход */
   }
   _getvideoconfig (&vc); /* данные видео-конфигурации в VC */
              /* здесь выполняются графические операции */
   /* восстановление видео-режима */
   _setvideomode (_DEFAULTMODE);
}
   /* функция для установки режима; предполагается, что программа
      требует разрешения 640x200 */
int set_mode()
{
   if (_setvideomode (_HRES16COLOR)) /* VGA или EGA */
      return (_HRES16COLOR);



   if (_setvideomode(_HRESBW)) /* VGA, EGA или CGA */
      return (_HRESBW);
   esle
     return (0);
}

    Программа,приведенная выше, в общих чертах обрисовывает  графическую
программу.


                     4.2. Установка видео-режима.

    Все  графические  программы  работают  в  определенном   графическом
режиме,  который  определяет  размер  экрана  (в  пикселах) и количество
возможных цветов. Режим, установленный программой, должен быть совместим
с конфигурацией оборудования.

    -Возможные режимы.

    Для установки видео-режимов используются приведенные ниже константы.
Размеры  даются  в  пикселах  для  графических  режимов,  и  в строках и
колонках для текстовых режимов.

Константа              Видео-режим                Текстовый или
                                                  графический

_DEFAULTMODE           Восстанавливает экран в   Оба
                       оригинальный режим
_TEXTBW40              40x25 текст, 16 серых     текстовый
_TEXTTC40              40x25 текст, 16/8 цветных текстовый
_TEXTBW80              80x25 текст, 16 серых     текстовый
_TEXTC80               80x25 текст, 16/8 цветных текстовый
_MRES4COLOR            320x200 ячеек, 4 цвета    графический
_MRESNOCOLOR           320x200 ячеек, 4 серых    графический
_HRESBW                640x200 ячеек, BW         графический
_TEXTMONO              80x25 текст, BW           текстовый
_MRES16COLOR           320x200 ячеек, 16 цветов  графический
_HRES16COLOR           640x200 ячеек, 16 цветов  графический
_ERESNOCOLOR           640x350 ячеек, BW         графический
_ERESCOLOR             640x350 ячеек,4/16 цветов графический
_VRES2COLOR            640x480 ячеек, 2 цвета    графический
_VRES16COLOR           640x480 ячеек, 16 цветов  графический
_MRES256COLOR          320x200 ячеек, 256 цветов графический



    -Выбор видео-режима.

    Выберете видео-режим  с требуемым  разрешением для  выполнения вашей
задачи.  Вам   нужно  сделать   выбор  между   повышениемем  разрешающей
способности экрана и количеством  цветов. Для установки режима  вызовите
функцию _setvideomode с одной из перечисленных выше констант.

    Возвращаемое  значение  0  обозначает,  что  ваше  оборудование   не
поддердивает  выбранный  видео-режим.  Сделайте  выход  из  программы  с
сообщением   о   том,   что   выбранный   видео-режим  не поддерживается
конфигурацией вашего оборудования.

    После того, как  требуемой видео-режим установлен,  вызовите функцию
_getvideoconfig  для  определения  параметров  выбранного   видео-режима
(такие, как размеры  экрана). Поместите информацию  видео-конфигурации в
специальную структуру, которую  будут использовать графические  функции.
Используйте  структуру  видео-конфигурации,   а  не  абсолютные   числа,
определяющие  характеристики  экрана.  Это  обеспечит  переносимость  на
другие экранные конфигурации (CGA, EGA или VGA).

    -Восстановление видео-режима.

    По окончанию программы  всегда следует восстанавливать  оригинальный
видео-режим  с  помощью   вызова  функции  _setvideomode   с  параметром
_DEFAULTMODE. Отказ системы восстановить оригинальный видео-режим  после
выполнения  графической  программы  приведет  к  тому,  что  при запуске
следующей программы машина будет "зблокирована".

      -Пример: Установка видео-режима.
#include <stdio.h>
#include <graph.h>
int set mode (void);
struct videoconfig vc;
char error _message [] = "Данный видео-режим не поддерживается".
main()
{
   if (!set_mode()) {
      printf ("%s\n", error_message);
      exit(0);
   }
  _setvideoconfig (&vc); /* помещение данных конфигурации в VC */
           /* далее следует тело программы */
   _setvideomode (_DEFAULTMODE); /* восстановление видео-режима */


}
int set_mode()
{
/* предполагается, что программа требует разрешения 640x200 */
if (_setvideomode(_HRES16COLOR))
   return (_HRES16COLOR);
if (_setvideomode(_HRESBW))
   return (_HRESBW);
else
   return (0);
}


                 4.3. Определение видео-конфигурации.

    Вся  информация  о  видео-конфигурации  содержится  в структуре типа
videoconfig. Содержимое данной структуры определено в файле graph.h. При
установке видео-режима, предварительно должна быть задана информация для
видео-конфигурации.

    -Переменная-структура videoconfig.

    Для получения  информации о  видео-конфигурации вам  следует описать
переменную  типа  videoconfig.  Данная  структура будет использоваться в
вызове getvideoconfig в следующем формате:

struct videoconfig vc; /* описание переменной-структуры */
   .
   .
   .
_getvideoconfig (&vc); /* использование переменной-структуры */


      -Содержимое структуры videoconfig.

    Структура videoconfig определяется в графическом заголовочном  файле
graph.h, и содержит следующие элементы:

struct videoconfig {
   short numxpixels; /* количество пикселов по оси X */
   short numypixels; /* количество пикселов по оси Y */
   short numtextcols; /* количество возможных текстовых колонок */
   short numtextrows; /* количество возможных текстовых строк */
   short numcolors; /* количество реальных цветов */
   short bitsperpixel; /* количество разрядов на пиксел */
   short numvideopages; /* количество доступных видео-страниц */
};

    -Использование информации с видео-конфигурации.

    Информация    видео-конфигурации    применяется    для   определения
размерностей экрана.  В любом  графическом режиме  центр экрана задается
следующими координатами:

xcenter =  vc.numxpixels/2 -  1; /*  координата центра  по оси  X */
Ycenter = vc.numypixels/2 - 1; /* координата центра по оси Y */

    Переменная vc.vcnumxpixels-это число пикселов по оси X, а переменная
vc.vcnumypixels-это  количество   пикселов  по   оси  Y   в  в   текущем
видео-режиме.

      -Пример: Обращение к структуре видео-конфигурации.
#include <stdio.h>
#include <ctype.h>
#include <graph.h>
struct videoconfig vc; /* переменная vc типа videoconfig */


/* опеределение массива видео-режимов и наименований режимов, пос-
   кольку числа не последовательны */
int modes[12] = {_TEXTBW40, _TEXTC40, _TEXTBW80, _TEXTC80,
    _MRES4COLOR, _MRESNOCOLOR, _HRESBW, _TEXTMONO,
    _MMRES16COLOR, _HRES16COLOR, _ERESNOCOLOR, _ERESCOLOR};
char *modenames[] = {"TEXTBW40", "TEXTC40", "TEXTBW80",
                      "TEXTC80", "MRES¤COLOR", "MRESNOCOLOR",
                      "HRESBW", "TEXTMONO", "MRES16COLOR",
                      "HRES16COLOR", "ERESNOCOLOR", "ERESCOLOR"};
main()
{
   int i;
   /* проверка всех видео-режимов */
   for (i=0; i<=11; i++) {
        setvideodeomode (modes[i]);
        getvideoconfig (&vc);
       printf ("\n video mode:\t%s\n",modenames[i]);
       printf (" x pixels:\t%d\n",vc.numxpixels);
       printf (" y pixels:\t%d\n",vc.numypixels);
       printf (" text columns:\t%d\n",vc.numtextcols);
       printf (" text rows:\t%d\n",vc.numtextrows);
       printf (" # of colors:\t%d\n",vc.numcolors);
       printf (" bits/pixel:\t%d\n",vc.bitsperpixel);
       printf (" video pages:\t%d\n",vc.numvideopages);
       print (" Hit return for next video mode");
      _setcolor (2);
       _rectangle (_GBORDER,0,0,vc.numxpixels-5,


       vc.numypixels-5);
       getchar();
       _clearscreen (_GCLEARSCREEN);
   }
   _setvideomode (_DEFAULTMODE);
}

    Программа, приведенная выше, вызывает каждый возможный видео-режим и
распечатывает  информации  видео-конфигурации.  Данная  программа  также
вычерчивает по краям экрана прямоугольник.


             4.4. Использование цветных текстовых режимов.

    С  дисплеями  CGA,  EGA  и  VGA можно использовать цветные текстовые
режиме _TEXTC40  и _TEXTC80.  Данные режимы  предлагают 16  передних и 8
фоновых цветов.

    -Основы выбора цвета текста.

    В  текстовом  режиме  каждый  высвечиваемый  символ  требует 2 байта
видео-памяти. Первый байт содержит  код ASCII, представляющий символ,  а
второй байт  содержит атрибут  изображиния. В  цветном текстовом  режиме
CGA, байт-атрибут определяет цвет и наличие мерцания символа. Имеются 16
цветов: значения пикселов CGA и стандартные значения пикселов EGA и VGA.

    Поскольку  палитры  EGA  и  VGA  могут  быть перепланированы, данные
значения должны быть заданы таким образом, чтобы соответствовать  любому
набору  16  цветов  с  соответствующей  картой  палитры.   (Информацию о
перепланировании  значений  ячеек  EGA  и  VGA  смотрите  соответственно
разделы 4.6 и 4.7).


    -Использование цветов текста.

    Для того,чтобы найти значение соответствующего значения пиксела  для
текущего  цвета  текста,  используйте  функцию  _gettextcolor.  Значения
пикселов  в  пределах  от  0  до  15 интерпретируются как обычные цвета.
Значения пикселов от 16  до 31-это те же  самые цвета, что и  0-15, но с
мерцающие.

    Устанавливаются  цвета  для  текстовых  режимов  посредством функции
_settextcolor. Данная функция использует единственный аргумент,  который
задает  значение  пиксела  для  использования  в  текстовых   операциях.
Значение пиксела  0 приводит  к невидимому  выводу, поскольку  он всегда
представляет текущий цвет фона. Цвет  текста не влияет на обычный  вывод
языка  СИ.  Для  вывода  цветного  текста  следует  использовать функцию
_outtext.  Ниже  определяются  значения  ячеек  для  цветных   текстовых
режимов:

№   Цвет        №   Цвет         №   Цвет          №   Цвет

0   черный      4   красный      8   темно-серый   12  светло-красный
1   голубой     5   лиловый      9   светло-голу-  13  светло-лиловый
                    (фруксин)        бой
2   зеленый     6   коричневый   10  светло-зеле-  14  желтый
                                     ный
3   зеленовато- 7   белый        11  светло-зеле-  15  ярко-белый
    -голубой                         новато-голубой



      -Пример: Вывод цветного текста.
#include <stdio.h>
#include <graph.h>
char buffer [225];


main()
{
   int i,j;
   long int delay;
   _setvideomode (_TEXTC80);
   for (j=0; j<= 7; j++) {
               _setbkcolor (j); /* фоновые цвета */
               _settextrosition (1,1);
               printf ("bkocolor: %d\n", j);
               for (i=0; i<= 15; i++) {
                  _settextcolor (i); /* цвета текста */
                  _settextrosition (5+i,i);
                  sprintf (buffer, "Color: %d\n", i9;
                  _outtext (buffer);
               }
                  /* пауза */
                 for (delay = 0; delay <=200000; delay++);
}
   _clearscreen (_GCLEARSCREEN);
   _setvideomode (_DEFAULTMODE);
}

    Приведенная выше  программа в  цикле проходит  через все  комбинации
цветов фона и текста.


          4.5. Использование цветных графических режимов CGA.

    Цветные графические режимы CGA  (то есть MRES4COLOR и  _MRESNOCOLOR)
высвечивают  4  цвета  (или  оттенки  серого),  выбираемые из нескольких
заданных палитр цветов. Они высвечивают цвета переднего плана на  цветах
фона, выбираемых из 16 возможных цветов.

    -Цветная графика CGA.

    В  графическом  режиме  пиксел  экрана  представляется в виде одно-,
двух-  или  четырех  разрядного  значения,  в  зависимости от выбранного
режима.  Данное  представление  известно,  как  "значение  пиксела".   В
добавление к  значению пиксела  существует еще  порядковое представление
цвета.  Каждый   цвет,  который   будет  высвечиваться   в  определенном
видео-режиме, представляется  в виде  уникального порядкового  значения.
Составление  карты  значений  пикселов,  соответствующих   действительно
изображаемым цветом,  дает в  результате "палитру".  Цветная графика CGA
поддерживает 4 палитры из 4 цветов. Палитра определяет подмножество всех
возможных цветов, и  состоит из цвета  фона (значение пиксела  0) и трех
наборов цветов переднего плана. Палитра определяет также  характеристики
всего изображения.

    Цвет фона может быть одним из имеющихся 16 цветов. Для  оборудования
CGA  палитра  цветов  переднего  плана  задана  заранее  и не может быть
изменена.  Номер  палитры-это  целое  число,  которое  выбирает  одну из
заданных палитр.

    -Использование палитр.

    В  видео-режиме  _MRES4COLOR  имеются  четыре палитры. Палитру можно
выбрать  с  помощью  функции  _selectpalette. Таблица, приведенная ниже,
показывает соответствие  между значениями  пикселов и  цветов для каждой
палитры. Фон может быть установлен одним из 16 возможных цветов.


Номер               Значение пиксела
палитры             1                  2                  3


0             зеленый          красный              коричневый
1             зеленовато-го-   лиловый              светло-серый
              лубой
2             светло-зеленый   светло-красный       желтый
3             светло-зелено-   светло-лиловый       белый
              вато-голубой



    Видео-режим _MRESNOCOLOR используется для черно-белого изображения с
помощью палитр, состоящих из оттенков серого цвета.

    Режим  _MRESNOCOLOR  может  также  воспроизводить  цвета  на цветном
дисплее.  Однако,  на  цветном  дисплее  имеются только две палитры. Для
выбора  одной  из   заранее  определенных  палитр   применяется  функция
_selectpalette.

    Приведенная ниже  палитра показывает  соответствие между  значениями
пикселов и цветами для каждой палитры:

Номер               Значение пиксела
палитры             1                  2                  3

0             голубой          красный              светло-серый
1             светло-голубой   светло-красный       белый



    Функцию _selectpalette  можно использовать  только с  видео-режимами
_MRES4COLOR и _MRESNOCOLOR.

      -Пример: Изображение цветов палитры.
#include <stdio.h>
#include <graph.h>


long bkcolor[8] = {_BLACK, _BLUE, _GREEN, _CYAN,
                   _RED, _MAGENTA, _BROWN, _WHITE};
char *blcolor name [] = {"_BLACK", "_BLUE", "_GREEN",
    "_CYAN", "_RED", "_MAGENTA", "_BROWN", "_WHITE"};
main()
{
 int i, j, k, delay;
 _setvideomode (_MRES4COLOR); /* использование цветного режима CGA
*/
 for (k=0; k <= 7; k++) {
   _setbkcolor (bkcolor[k]);
   for (i=0; i<= 3; i++) {
     _selectpalette (i);
     for (j=0; j<=3; j++) {
       _settextposition (1,1);
       _setcolor (j);
       printf ("background color: %8s\n", bkcolor nameGk[);
       printf ("palette: %d\ncolor: %d\n",i,j);
       _rectangle (_GFILLINTERIOR,160,100,320,200);
       for (delay=0; delay<= 20000; velay++)
     }
   }
 }
 _setvideomode (_DEFAULTMODE);
}

    Данная  программа  устанавливает  видео-режим  _MRES4COLOR  и  затем
прокручивает все комбинации фона и цветов палитр.




     4.6. Использование цветных графических режимов EGA.

    Видео-режимы  _  MRES16COLOR,  _HRES16COLOR, _ERESCOLOR используются
для получения  уличщенной цветной  графики с  адаптером EGA.  Режимы CGA
также можно использовать с адаптером EGA, но на уровне разрешения CGA  и
с уменьшенным набором цветов.

    -Цветные графические режимы EGA.

    В графических  режимах пиксел  может быть  представлена одно-, двух-
или  четырех-разрядным  значением  в  зависимости  от выбранного режима.
Данное представление  известно, как  "значение пиксела".  В дополнение к
значению  ячейки  существует  и  порядковое  представление цвета. Каждый
цвет,  который   может  быть   высвечен  в   определенном  видео-режиме,
представляется  уникальным  порядковым  значением.  Карта,   переводящая
значения  ячеек  в  реальные  высвечиваемые  цвета,  дает  в  результате
"палитру" высвечиваемых цветов.

    Палитра  цветов  доступна,  какой  бы  из графических режимов EGA не
использовался. Палитры EGA могут быть перепланированы и переопределены в
программе.  Стандартная  палитра  для  режимов  EGA  та  же самая, что и
палитра для цветных текстовых режимов.

    -Переопределение отдельных цветов.

    Для переопределения одного значения пиксела в заданный цвет (который
должен быть  обязательно цветом,  поддерживаемым текущим  видео-режимом)
используется функция _remappalette.  Например, приведенная ниже  функция
переопределяет  значение  ячейки  1  на  значение _RED. После выполнения
данного оператора голубой цвет будет везде появляться, как красный:

_remappalette (1, _RED); /* переназначение голубого на красный */


      -Переопределение набора цветов.

    Для переопределения всех значений пикселов одновременно используется
функция _remapallpalette. Аргумент  функции указывает на  массив номеров
цветов, отражающих  перепланировку. Первый  номер цвета  в списке станет
новым цветом, связанным со значением пиксела 0.

    Номер в вызове функции, устанавливающей цвет (такой, как  _setcolor)
является индексом  в имеющейся  палитре цветов.  В стандартной текстовой
палитре  индекс  1  означает  "голубой".  Если  палитра перепланируется,
порядок цветов в палитре  изменяется. В результате, цвет,  получаемый по
данному  значению  пиксела,  также  изменяется.  Количество  планируемых
цветов   зависит   от   количества   цветов,   поддерживаемых    текущим
видео-режимом.

    Функции _remappalette и  _remapallpalette работают во  всех режимах,
но  только  с  оборудованием  EGA  или  VGA.  Если  вы  сделаете попытку
выполнить данные  функции без  оборудования EGA  или VGA,  функции дадут
сбой и возвратят значение-1.

      -Пример: Перепланирование цветов палитры.
#include <stdio.h>
#include <graph.h>

main()
{
   _setdideomode (_ERESCOLOR);
   _settextposition (1,1); /* обычная палитра */
   printf ("Normal palette");
   _setcolor (4); /* красный в стандартной палитре */
   _rectangle (_ GFILLINTERIOR, 50,50,200,200);
   getchar(); /* ожидание ключа ENTER */
   _remappalette (4. _BLUE); /* превращение красного в голубой */


   _settextposition (1,1);
   printf ("Remapped palette");
   _setcolor (4); /* голубой */
   _rectangle (_GFILLINTERIOR, 50,50,200,200);
   getchar(); /* ожидание ключа ENTER */
   _remappalette (4, _RED); /* восстановление */
   _settextposition (1,1);
   printf ("Restored palette");
   _setcolor (4); /* красный */
   _rectangle (_GFILLINTERIOR,50,50,200,200);
   getchar(); /* ожидание ключа ENTER */
   _clearscreen (_GCLEARSCREEN);
   _setvideomode (_DEFAULTMODE);
}

    Данная  программа  вычерчивает   прямоугольник  красного  цвета.   В
стандартной палитре EGA значение пиксела 4 означает красный цвет. Данное
назначение переопределяется в данной программе на _BLUE и  прямоугольник
перечерчивается.  В  конце  программы  значение пиксела переопределяется
назад в оригинальный цвет.


          4.7. Использование цветных графических режимов VGA.

    С дисплеем VGA используются видео-режимы _VRES2COLOR,  _VRES16COLOR,
_MRES256COLOR. С оборудованием VGA  могут использоваться также и  режимы
EGA и  CGA, но  с более  низкой разрешающей  способностью и ограниченным
набором цветов.


    -Цветные графические режимы VGA.

    В графическом режиме пиксел может быть представлена как одно-, двух-
или четырех-битовое значение, в зависимости от выбранного режима. Данное
представление известно, как "значение пиксела". Кроме того, в дополнение
к  значению  пиксела  существует  порядковое представление цвета. Каждый
цвет, высвечиваемый в определенном видео-режиме, представлен  уникальным
порядковым   значением.   Распределение   значений   ячеек   в  реальные
высвечиваемые цвета дает в результате "палитру" высвечиваемых цветов.

    Цветная  графика  VGA  оперирует  почти  с  262144 (эквивалент 256К)
цветами.   Режим   графики   _VRES2COLOR   высвечивает   2  цвета, режим
_VRES16COLOR высвечивает 16 цветов, режим _MRES256COLOR высвечивает  256
цветов из имеющихся в VGA.

    Большое  количество  возможных  цветов  в  режимах  VGA   становится
возможным  при  использовании  трех  байтов  информации,  представляющей
интенсивность красного, зеленого и голубого для каждой пикселе. В каждом
байте  два  старших  разряда  должны  равняться  нулю.  Оставшиеся шесть
разрядов  определяют   интенсивность  голубого,   зеленого  и   красного
(читается от  старшего байта  к младшему).  Три цвета,  каждый с  шестью
разрядами  интенсивности  дают  64**3  или  262144 оттенка.  (эквивалент
256К).  Например,   равные  значения   красного,  зеленого   и  голубого
используются  для  получения  белого  низкой  интенсивности, так что три
байта цвета должны содержать следующее:

голубой             зеленый            красный
00011111            00011111           00011111
старшие разряды-------------------->младшие разряды

    Поскольку номера цветов разделяются между байтами, номера цветов  не
являются последовательными (как и в случае CGA или EGA).

    16 цветов для стандартной  палитры режима _VRES16COLOR и  первый для
стандартной  палитры  режима  _MRES256COLOR  те  же  самые,  что  и  для
текстовых цветных режимов.

    -Переопределение отдельных цветов.

    Для  переопределения  одного  значения  пиксела  в определенный цвет
используется   функция    _remappalette.   Приведенная    ниже   функция
переопределяет  значение  пиксела  1  в  цвет,  заданный константой _RED
(которая представляет  красный цвет).  После того,  как данный  оператор
выполнится, цвет, заданный голубым, будет высвечиваться , как красный:

_remappalette (1, _RED); /* переназначение голубого в красный в
                           режиме VGA */

    -Переназначение набора цветов.

    Чтобы  переназначить  все  имеющиеся  в  наличии цвета одновременно,
воспользуйтель  функцией  _remapallpalette.  Аргумент  функции  адресует
массив номеров цветов, отражающих  переназначение. Первый номер цвета  в
списке станет новым цветом, соответствующим значению пиксела 0.

    Число в вызове функции, устанавливающей цвет (такой как  _setcolor),
является индексом в палитре из имеющихся цветов. В стандартной текстовой
палитре индекс  1 соответствует  "голубому". При  переназначении палитры
порядок цветов  в палитре  меняется. В  результате, цвет,  полученный по
данному значению пиксела, также  изменится. Количество цветов в  таблице
зависит от количества цветов, поддерживаемых текущим видео-режимом.

    Функции _remappalette и  _remapallpalette работают во  всех режамах,
но  только  на  оборудовании  EGA  или  VGA.  Если  вы  сделаете попытку
переназначить палитру без оборудования EGA или VGA, функции

_remappalette и _remapallpalette дадут сбой и возвратят значение -1.

    Описывающие константы для стандартных номеров цветов задаются  таким
образом, что переназначение  цветов для VGA  совместимо с режимами  EGA.
Имена данных  констант самодокументируемы.  Например, номера  цветов для
черного,  красного   и  светло-желтого   цветов  задаются   объявляющими
константами _BLACK, _RED, _LIGHTYELLOW.

    Все  режимы   VGA  действуют   с  любым   видео-монитором  VGA.  При
подсоединенном монохромном мониторе все цвета высвечиваются, как оттенки
серого.

      -Пример: Переназначение цветных палитр VGA.
long colors1 [16] = {_BLACK, _BLUE, _GREEN, _RED, _RED, _MAGENTA,
       _BROWN, _WHITE, _GRAY, _LIGHTBLUE, _LIGHTGREEN, _LIGHTRED,
       _LIGHTRED, _LIGHTMAGENTA, _LIGHTYELLOW, _BRIGHWHITE};

    Приведенный  выше  массив  номеров  цветов переназначает стандартную
палитру  VGA  таким  образом,  что  вместо  цветов зеленовато-голубого и
светло-зеленовато-голубого будут высвечиваться красный и светло-красный.


                 4.8. Понятие о координатной системе.

    "Координатная система" используется для идентификации местоположения
пиксела относительно горизонтальной  и вертикальной осей.  В графическом
режиме  каждый  пиксел  на  экране  может  быть  обозначен   посредством
уникальной пары координат.  Графическая библиотека функций  поддерживает
две координатные системы: физическую и логическую.


    -Физические координаты.

    "Физическая  координатная  система"  помещает  начало  отсчета  (или
координатную пару 0,0) в верхний левый угол экрана. Рост  положительного
значения  координаты  Х  происходит  слева  направо. Рост положительного
значения  координаты  У  происходит  сверху  вниз. Таким образом, правый
нижний угол экрана имеет  координату Х, равную максимальному  количеству
пикселов  по  оси  Х,  поддерживаемому данным видео-режимом. Аналогично,
нижний  правый  угол  экрана  имеет  координату  У, равную максимальному
количеству пикселов по оси У в данном видео-режиме.

    Физическая  координатная   система  содержит   только  положительные
значения: Х от 0 ( в верхнем левом углу) до количества пикселов по оси Х
(правая граница); У от 0 (верхний левый угол) до количества пикселов  по
оси У (низ экрана).

    Физическая   координатная   система   зависит   от   оборудования  и
конфигурации изображения и не может быть изменена.

    -Логические координаты.

    "Логическая  координатная  система"  создается  перемещением  начала
координат   в   более   "логическую"   позицию   относительно абсолютных
физических  координат.  Она  определяется  функцией  _setlogorg, которая
устанавливает   новое   логическое   начало   координат.  Первоначально,
логическая  координатная   система  идентична   физической  координатной
системе.

    После перенесения начала координат, координаты Х и У  придерживаются
данной  ориентации.  При  увеличении  Х  позиция пиксела перемещается по
экрану слева направо; при увеличении У, позиция пиксела перемещается  от
верхней границы к нижней границе экрана.

    -Перемещение начала координат.

    Сегмент программы, приведенный  ниже, перемещает начало  координат в
центр экрана:

_getvideoconfig (&vc);
_setlogorg (vc.numxpixels/2-1, vc.numypixels/2-1);

    Вызов функции _getvideoconfig помещает информацию видео-конфигурации
в  переменную-структуру  vc.  Структура  конфигурации  содержит данные о
размере экрана.  Это используется  (после соответствующего  деления) для
перемещения начала координат в центр экрана.

    -Возврат к физическим координатам.

    Возврат от логических координат к физическим производится с  помощью
функции _setlogorg (то есть  перемещение начала координат снова  в левый
верхний  угол  экрана).  Ниже  приведен  пример  возврата  к  физическим
координатам:

 setlogorg (0,0);

    -Преобразование координат от одной координатной системы к другой.

    Для преобразования  физических координат  в логические  используется
функция  _getlogcoord.  Логические  координаты  помещаются  в  структуру
xycoord.  Для  преобразования  логических  координат заданного пиксела в
физические  координаты  используется  функция  _getphyscoord. Физические
координаты помещаются  в структуру  xycoord. Формат  двух данных  описан
ниже:

_getlogcoord (x,y);
_getphyscoord (x,y);
_getvideoconfig (&vc); /* получение информации видео-конфигурации */
x = vc.numxpixels/2 - 1; /* определение Х и У средних точек */
y = vc.numypixels/2 -1;
_setlogorg (x,y); /* перемещение начала координат */

    Данный   фрагмент   программы   находит   центр   экрана  для любого
видео-режима и устанавливает в нем начало координат.


                   4.9. Размещение отдельных точек.

    Простейшие  графические  функции  действуют  на одноточечном уровне.
Доступен любой пиксел экрана, в который может быть установлена точка.

    -Перемещение на заданную точку экрана.

    Текущую  графическую  позицию  можно  изменить  с  помощью   функции
_moveto.  Данная  функция  перемещает  текущую  позицию  (то есть ту, на
которой   закончилась   предыдущая   операция)   в   заданные логические
координаты. Формат данной функции следующий:

_moveto (10,10); /* сдвиг на 10 пикселов вправо и на 10 пикселов
                    вниз от логического начала координат */

    -Установка и очистка пикселов.

    Функция _setpixel используется для установки пиксела, расположенного
по заданным логическим координатам в текущий цвет. Ее формат следующий:

_setpixel (10,10); /* установка пиксела по координатам 10, 10 в
                      текущий цвет */


    Выключение  пиксела  производится  путем  установки  его в цвет фона
(который   имеет   всегда   значение   пиксела   0).   Ниже    приведена
последовательность команд, необходимая для очистки заданного пиксела:

_setcolor (0); /* установка текущего цвета в цвет фона */
_setpixel (x,y); /* очистка пиксела */

    -Пример: Установка пикселов.  Программа hyppix.c, приведенная  ниже,
вычерчивает  гипоциклоид-  -фигуру,  полученную  вращением  одного круга
внутри другого. Подключается библиотека math.h (математических функций),
поскольку потребуются функции синус и косинус. Используется видео-режим,
совместимый с  CGA. Кривая  вычерчивается во  времы работы  цикла while,
который может  быть прерван  нажатием функциьнального  ключа. Для  того,
чтобы получить более интересные  рисунки, задайте circle ratio  большим,
чем  pen  position  и  не  используйте  чисто  целых  значений. Наиболее
интересный  рисунок  получается  при  circle  ratio,  равном  3.2  и ren
position, равном  1.6.  (Более  подробную информацию  о гипоциклоидах  и
других  циклоидах  можно  найти  в  журнале  "Byte",  May, 1987 в статье
"Математические построения").

/* hyppix.c-построение гипоциклода-точечное */
#include <stdio.h>
#include <graph.h>
#include <mach.h>
#include <conio.h>
struct videoconfig vc;
char error_message [] = "This video mode is not supported";
main()
{
   if (_setvideomode(_MRES4COLOR) == 0) {


      printf ("%s\n", error_message);
      exit(0);
   }
   _getvideoconfig (&vc);
   hypcycle(); /* вызов функции рисования */
   _clearscreen(_GCLEARSCREEN);
   _setvideomode (_DEFAULTMODE); /* восстановление видео-режима */
}
hypcycle()
{
   float pi=3.14159; /* объявление и инциализация */
   float a,h,b,r,x0,y0,x,y, ang;
   int i;
   x0 = vc.numxpixels/2 -1;
   y0 = vc.numypixels/2 -1;
   printf ("circle ratio (>=1): ");
   schanf ("%f", &r);
   printf ("\npen position (>1): ");
   scanf ("%f",&h);
   _clearscreen(_GCLEARSCREEN);
   _setcolor (1);
   _moveto (x0,0); /* вычерчивание осей */
   _lineto (x0,vc.numypixels);
   _moveto (0,y0);
   _lineto (vc.numxpixels,y0);
    a = 0.5*r*vc.numypixels/(r+h-1);
   b = a/r;
   h = h*b;
   _setcolor (2);
   ang = 0;


   while (!kbhit()) { /* вычерчивание гипоциклоида */
       for (i=1; i<= 20; i++) {
          ang = ang + 2*pi/100;
          x = x0+(a-b)*cls(ang)+cos(ang*(a-b)/b);
          y = y0-(a-b)*sin(ang)+h*sin(ang*(a-b)/b);
           setpixel (x,y);
       }
   }
}


                        4.10. Рисование линий.

    Для рисования линий между двумя точками используются функция _moveto
и _lineto. Линия может быть вычерчена либо плотно (непрерывно), либо  по
образцу .

    -Перемещение в заданную позицию.

    Для перемещения  в заданную  логическими координатами  (парой чисел)
точку используется функция _moveto. Формат оператора _moveto  следующий:

_moveto (25,25); /* перемещение в точку с логическими координатами 25,25
*/

    -Вычерчивание линий.

    Для  того,  чтобы  прочертить  линию  от  текущей позиции курсора до
заданной в  функции конечной  точки, используется  функция _lineto. Если
линия была  успешно вычерчена,  текущая позиция  курсора перемещается на
координаты, указанные  в функции  _lineto .  Используемый цвет  является
текущим.  После  выполнение   описанной  выше  функции   _moveto(25,25),
приведенная ниже функция lineto  вычертит линию от точки  с координатами
(25,25) до точки (100,100), причем курсор установится в точке (100,100):

_lineto (100,100); /* вычерчивание линии от текущей позиции до точки
                      (100,100) */

    -Вычерчивание пунктирных линий либо линий определенного образца.

    Рисованием линии управляет  маска стиля. Маска-это  используемый для
рисования 16-разрядный шаблон. Каждый разряд в маске определяет пиксел в
линии. Если  разряд содержит  1, соответствующий  пиксел окрашивается  в
текущий цвет.  Если разряд  содержит 0-пиксел  устанавливается в фоновый
цвет. Стандартная маска-это непрерывная плотная линия (0хFFFF).

    Функция  _setlinestyle  устанавливает  стиль,  в котором вычерчивают
линии функции _lineto и _rectangle.

    Следующий пример изменяет  стиль линии на  пунктирный: _setlinestyle
(0xAAAA); /* стиль по шаблону 1010101010101010 */

      -Пример: Вычерчивание линий.
#include <stdio.h>
#include <graph.h>
#include <conio.h>
struct videoconfig vc;
char error_message [] = "This video mode is not supported";
main()
{
   if (_setvideomode(_MRES4COLOR) == 0) {
      printf ("%s\n", error message);
      exit(0);
   }


   _getvideoconfig (&vc);
   _setlinestyle (0x0001);
   _moveto (0,0); /* вычерчивание фигуры */
   _lineto (0,150);
   _setlinestyle (0x0bb0);
   _lineto (150,150);
   _setlinestyle (0x0ff0);
   _lineto (150,0);
   _setlinestyle (0xffff);
   _lineto (0,0);
   getchar(); /* ожидание возврата */
   _clearscreen( GCLEARSCREEN); /* очистка содержимого экрана */
   _setvideomode ( DEFAULTMODE); /* восстановление видео-режима */
}

    Приведенная выше программа вычерчивает прямоугольник, причем  каждую
сторону в разном стиле.


                 4.11. Описание графических объектов.

    Данный  раздел  дает  основополагающие  концепции,  используемые при
описании графических объектов.

    -Ограничивающий прямоугольник.

    Ограничивающий  прямоугольник  определяет  место,  в  котором  будет
расположена  круговая  фигура,  причем  центр  прямоугольника определяет
центр круговой фигуры. Другими словами, это площадь, заполняемая круглым
объектом.  Ограничивающий  прямоугольник  задается координатами верхнего
левого угла и  правого нижнего угла  данного прямоугольника. Два  других
угла подразумеваются.

    -Граница.

    Граница   кругового   объекта   вычерчивается   в   текущем  цвете и
непрерывной  линией.  Граница  прямоугольного  объекта  вычерчивается  в
текущем цвете и в любом стиле, заданном функцией _setlinestyle. Если для
вычерчивания границы не задано шаблона, используется стандартный  шаблон
(0xFFFF).

    -Флажок заполнения.

    Флажок заполнения используется для определения того, будет ли фигура
заполняться по текущей маске заполнения или останется пустой.  Константа
_GFILLINTERIOR  определяет,  каким  образом  будет заполняться объект, а
константа _GBORDER определяет, что будет вычерчиваться только граница.

    -Вектор начала и конца.

    Дуга или сектор начинаются в точке, где ограничивающий прямоугольник
пересекается  со  стартовым  вектором   и  заканчивается  там,  где   он
пересекается с заканчивающим вектором.

    -Коэффициент изображения.

    Коэффициент  изображения-это  количество  пикселов  на  вертикальной
линии, разделенное на количество пикселов по горизонтальной линии. Чтобы
вычертить квадрат или  окружность, вам следует  соизмерять их размеры  с
коэффициентом изображения.

    Коэффициент изображения зависит от двух факторов:

    1.  Горизонтальная  строка  имеет  больше пикселов, чем вертикальная
колонка той же самой физической длины-во всех режимах экра на, поскольку
на горизонтальной линии расстояние между точками меньше.

    2. Экран видео-дисплея шире, чем его высота, обычно с  коэффициентом
4:3.


    -Вычисление коэффициента изображения.

    Коэффициент  изображения  для  данного  видео-режима  вычисляется по
следующей формуле:

    коэф.изобр.=(ширина экрана/высота экрана)*(у-пиксел/х-пиксел),

    где "ширина экрана" и "высота экрана"-это физические размеры экрана,
а "у-пиксел"  и "х-пиксел"-это  текущее разрешение  экрана (измеряется в
пикселах).

      -Пример: Вычерчивание точно пропорциональных фигур.
#include <stdi.h>
#include <math.h>
#include <graph.h>
struct videoconfig vc;
char error_mesage [] = "this video mode is not supported";
main()
{
   float ar, x, y;
   if (_setvideomode(_MRES4COLOR == 0) {
      printf ("%s\n", error_message);
      exit(0);
   }
   _getvideoconfig (&vc);
   /* размеры экрана 10*6.6 дюймов */
   ar = (float) (10 * vc.numypixels) / (6.5 * vc.numhpixels);
   y = 100*ar;
   x = 100;
   _setlogorg (vc.numxpixels/2 - 1, vc.numypixels/2 - 1);
   _setcolor (1);
   _rectangle (_GFILIINTERIOR, -x, -y, x, y);
   _setcolor (3);


   _ellipse (_GFILLINTERIOR, -x, -y, x, y);
   getchar();
   _clearscreen(_GCLEARSCREEN);
   _setvideomode (_DEFAULTMODE); /* восстановление видео-режима*/
}

    Данная  программа  использует  коэффициент  изображения, для точного
вычерчивания квадрата и окружности.

    Круговая фигура освещает принцип ограничивающего прямоугольника.


                  4.12. Вычерчивание основных фигур.

    Основные фигуры, имеющиеся в стандартной библиотеке процедур  СИ-это
прямоугольник, эллипс, дуга и сектор.

    -Вычерчивание прямоугольников.

    Для  изображения  прямоугольников  используется  функция  rectangle.
Аргументами данной  функции являются  координаты противоположных  углов.
Остальные углы подразумеваются. Параметр флажка заполнения  используется
для  того,  чтобы  определить,  будет  ли прямоугольник обозначен только
границами или будет заполнент  текущим цветом. Две команды,  приведенные
ниже,   вычерчивают   прямоугольник   в   верхний   левой  части экрана.
Противоположные  углы  прямоугольника  задаются  координатами:  (0,0)  и
(25,25).

_rectangle (_GBORDER,0,0,25,25); /* вычерчивание только границ */
_restangle (_GFILLINTERIOR,25,25,0,0); /* закрашивание внутреннос-
                                          ти */

    -Вычерчивание окружностей и эллипсов.

    Для вычерчивания эллипсов  используется функция _ellipse.  Параметры
функции определяют противоположные углы ограничивающего  прямоугольника.
Центром  эллипса  является  центр  ограничивающего  прямоугольника. Если
ограничивающий    прямоугольник    является    квадратом-эллипс    будет
окружностью. Нижеприведенные команды  вычерчивают два эллипса  в верхний
левой части экрана:

_ellipse (_GBORDER,0,0,25,25); /* вычерчивание одних границ */
_ellipse (_GFILLINTERIOR,25,25,0,0); /* заполнение фигуры */
      Если принцип ограничивающего прямоугольника немного непонятен,
вы можете вызвать функцию _ellipse, используя только центр (х,у) и
радиус (r), как показано ниже.
_ellipse (_GBORDER,x-r,y-r,x+r,y+r); /* вычерчивание одних границ */

    -Изображение дуг и секторов.

    Дуга-это  часть  эллипса,  другими  словами,  короткая кривая линия.
Сектор-это часть эллипса, включающая в себя дугу и площадь, ограниченную
двмя линиями,  идущими от  центра. Площадь  сектора заполняется  текущим
цветом.Дуга    или    сектор    определяются    противоположными  углами
ограничивающего прямоугольника  и конечными  точками векторов,  задающих
конечные точки дуги или сектора. Центр дуги или сектора-это всегда центр
ограничивающего прямоугольника. Дуга или сектор начинаются в точке,  где
вектор, определяемый  центром ограничивающего  прямоугольника и  третьей
парой точек,  пересекает ограничивающий  прямоугольник. Дуга  или сектор
кончаются  там,   где  вектор,   определяемый  центром   ограничивающего
прямоугольника  и  последней  парой  точек,  пересекает   ограничивающий
прямоугольник. Дуга или сектор рисуются с использованием текущего  цвета
по направлению часовой стрелки. Дуга-незамкнутая фигура, поэтому она  не
закрашивается.  Сектор  закрашивается  текущим  цветом. Приведенные ниже
примеры показывают использование данных функций:

/* ограничивающий прямоугольник определяется координатами: (,0) и
(50,50), вектор начала-центр ограничивающего прямоугольника &
(0,100); конечный вектор-центр ограничивающего прямоугольника
&(100,100) */
_arc (0, 0, 50, 50, 0, 100, 100, 100);
_pie (_GFILLINTERIOR, 0, 0, 50, 50, 0, 100, 100, 100);

      -Пример: Рисование фигур.
#include <stdio.h>
#include <graph.h>
#include <math.h>
struct videoconfig vc;
char error_message [] = "Данный видео-режим поддерживается";
main()
{
   int x = 50;
   int y = 40;
   if (_setvideomode(_MRES4COLOR) == 0) {
      printf ("%s\n", error_message);
      exit (0);
   }
   _getvideoconfig (&vc);
   _setlogorg (vc.numxpixels/2 - 1, vc.numypixels/2 - 1);
   _setcolor (1);
   _setlogorg (vc.numxpixels/2 - 2, vc.numypixels/2 - 1);
   _setlinestyle (0x5555);
   _rectangle (_GBORDER, -x, -y, x, y);
   _setcolor (2);
   _ellipse (_GFILLINTERIOR, -x, -y, x, y);
   _setcolor (3);


   _pie (_GFILLINTERIOR,-x, -y, x, y, -x-10, y+10, x+10, y-10);
   getchar();
   _clearscreen(_GCLEARSCREEN);
   _setdideomode (_DEFAULTMODE); /* восстановление видео-режима */
}


                  4.13. Заполнение фигур по шаблону.

    Для  заполнения  любой  замкнутой  фигуры  по  шаблону  используется
функция _floodfill. Замкнутая фигура-это  фигура, не имеющая разрывов  в
ограничивающей ее линии.

    -Заполнение фигур по шаблону.

    Функция _floodfill используется  для заполнения замкнутой  фигуры по
шаблону,  задаваемому  параметром  fillmask.   (маска заполнения). Маска
заполнения-это массив восьмиразрядных значений, в котором каждый  разряд
представляет  соответствующий  пиксел.  Если  разряд  содержит 0, пиксел
остается незаполненной. Если бит содержит 1, ячейка заполняется  текущим
цветом. Данная маска заполнения повторяется всюду на заполняемой площади
фигуры. Стандартная маска заполнения-это сплошное закрашивание.

    Маска заполнения действует в  явном режиме закрашивания. Если  бит в
маске равен нулю, пиксел остается незаполненным. Единица, содержащаяся в
маске  закрашивает  соответствующий  пиксел  в  текущий цвет. По-разному
раскрашенные  фигуры  могут  быть  созданы  с  помощью установки и смены
цветов  между  вызовами  функции  _floodfill.  Граница,  не   являющаяся
непрерывной   (шаблон   которой    не   равен   0хFFFF),    приведет   к
непредсказуемому  результату,  если  вы  сделаете  попытку  заполнения с
помощью  функции   _floodfill  (вероятно   к  переполнению   графической
области).

    Чтобы  вернуться  к  текущей  маске  заполнения, используйте функцию
_getfillmask.   Функция   _getfillmask   применяется   для   того, чтобы
установить текущую  маску заполнения  в заданное  значение. Ниже показан
формат функций задания маски заполнения:

_getfillmask (fillmask);
_setfillmask (fillmask);

      Маска заполнения NULL используется для переключения режима
заполнения фигуры в сплошное заполнение, как показано ниже:
_setfillmask (NULL); /* переключение маски на сплошное заполнение */

      -Создание маски заполнения.

    Маска заполнения представляет собой массив восьмиразрядных  значений
(определяемый, как обычный символьный массив). Создание маски заполнения
описывается ниже:

    1. Нарисуйте таблицу-шаблон с восемью колонками и восемью  строками,
заполненную нулями.  Поместите единицы  (1) в  каждую ячейку  которую вы
хотите закрасить.

    2.  Преобразуйте  8-разрядные  числа  в  каждой колонке в десятичные
целые.

    3. Создайте из этих значений массив, как показано ниже:

      /* маска заполнения для шаблона X
         двоичное          десятичное
         представление     представление

         10000001           129
         01000010            66
         00100100            36
         00011000            24
         00011000            24
         00100100            36
         01000010            66
         10000001           129 */

      char fill_mask [] = {129,66,36,24,24,36,66,129};

      4. Нарисуйте фигуру и закрасьте ее внутренность с помощью толь-
         ко что созданной маски.
_setfillmask (fill_mask);
_rectangle (_GFILLINTERIOR,50,50,25,25,100);

      -Пример: Заполнение фигур по образцам.
#include <stdio.h>
#include <graph.h>
char mask1 [] = {0,66,36,24,24,36,36,66,0}; /* 2 маски заполнения */
char mask2 [] = {0,24,0,102,102,0,24,0};
char error_message [] = This video mode is not supported";
main()
{
   if (_setvideomode(_MRES4COLOR) == 0) {
      printf ("%s'n", error_message);
      exit(0);
   }
   _setfillmask (mask1);
   _setcolor (1); /* использование многоцветности */
   _rectangle (_GBORDER,0,0,150,150);
   _setcolor (2);
   _floodfill (100,100,1); /* стоп на границе цвета */
   _setcolor (3);
   _setfillmask (mask2);
   _floodfill (100,100,1);
   getchar(); /* ожидание возврата каретки */
   _clearsceen(_GCLEARSCREEN);
   _setvideomode (_DEFAULTMODE); /* восстановлени видео-режима */
}



                4.14. Вычерчивание и запоминание фигур.

    В   памяти   можно   запоминать   сложные   фигуры   для дальнейшего
использования  их   в  мультипликации.   Функция  _getimage   записывает
изобрражение в память, а функция _putimage вызывает хранящийся в  памяти
изображение на экран.

    -Запоминание изображений.

    Размеры  сохраняемого  в  памяти  экранного  образа   ограничиваются
размерами ограничивающего  прямоугольника. Для  того, чтобы  скопировать
область  экрана,  находящуюся  внутри  ограничивающего прямоугольника, в
буферную память, используется функция _getimage, как показано ниже:

    _getimage (0,0,10,10,buffer);

    Ограничивающий прямоугольник имеет координаты противоположных  углов
(0,0) и  (10,10). Переменная  buffer-это указатель  на буфер,  в которой
будет храниться данный экранный образ.

    -Требования памяти для функции _getimage.

    Буфер должен иметь достаточные размеры для размещения изображения  в
памяти.  Перед   тем,  как   записать  изображение,   выполните  функцию
_getimagesize,  определяющую  размер  буфера  для  хранения изображения.
Пример,  приведенный   в  конце   данного  раздела   иллюстрирует  также
использование функции malloc для распределения памяти под буфер.

    Вывод изображений из памяти.

    Функция  _putimage  используется  для  вызова  образа   сохраненного
прямоугольника  на  экран,  причем  в  функции задаются координаты точки
верхнего  левого  угла  желаемого  появления  прямоугольника  на экране.
Функция, приведенная ниже, иллюстрирует  вывод изображения из памяти  на
экран  внутрь.  прямоугольника  с  координатами  в  левом  верхнем  углу
(50,50).    Последний    параметр-это    аргумент     "глагол-действия",
определяющий,  каким   образом  образ,   хранящийся  в   памяти,  должен
взаимодействовать с текущим экраном. _putimage (50,50,buffer,_GPSET);

    -Аргумент "глагол-действия функции _putimage.

    Глагол   действия   управляет   тем,   каким   образом изобрражение,
вызываемое из  памяти, будет  взаимодействовать с  тем, что  уже есть на
экране.  Описывающие  константы  данного  аргумента приводят к следующим
действиям:

 Константа             Действие


 _GPSET                Прямая пересылка.
 _GPRESET              Прямая пересылка, цвет инвертирован.
 _GAND                 Логическое AND вызванного образа и текущего
                       экрана образа.
 _GOR                  Наложение образа на существующий образ.
 _GXOR                 Инверсия экрана там, где в буфере существует
                       точка.



      -Пример: рисование и запоминание фигуры.
draw_and_store_figure()
{
   _setbkcolor (0);
   _setcolor (1);
   _rectangle (_GBORDER,0,0,10,10);
   _setcolor (2);
   _rectangle (_GFILLINTERIOR,1,1,9,9);
   _setcolor (3);
   _moveto (1,1);


   _lineto (9,9);
   _moveto (1,9);
   _lineto (9,1);
   buffer=(char far *)malloc((unsigned int)
          _imagesize(0,0,10,10));
   _getimage (0,0,10,10, buffer);
}

    Данная  функция  рисует  фигуру,  определяет  размер,  требуемый для
размещения изображения в памяти, затем помещает фигуру в память  (буфер)
для  дальнейшего  использования  ее  в  мультипликации.  (Данная функция
позднее  появляется  в  Разделе  4.15, "Использование мультипликации", в
полной программе на языке СИ.


                  4.15. Использование мультипликации.

    Простейшая мультипликация может быть создана, например, перемещением
фигуры в новую  позицию на экране  с удалением старого  изображения. Для
более  быстрой  и  эффективной  мультипликации  с помощью сложных фигур,
используйте функции _getimage и _ putimage.

    -Создание мультипликации.

    Создайте  изображение  на  экране,  используя  графические  функции,
сделайте  "снимок"  этого  изображения   в  память  с  помощью   функции
_getimage. Затем посредством  функции _putimage вы  можете воспроизвести
данное изображение где-нибудь на экране.

    Для  мультипликации  хорошо  подходят  два глагола-действия: _GXOR и
_GPSET. Мультипликация с помощью _GPSET работает быстрее, но  уничтожает
фон, напротив, мультипликация с  _GXOR работает медленнее, но  сохраняет
фон экрана.


    -Использование в мультипликации константы _GXOR.

    Мультипликация  с   применением  _GXOR   осуществляется  выполнением
следующих четырех шагов:

    1.Поместите объект на экран с помощью _GXOR.

    2.Вычислите новое положение объекта.

    3.Поместите  объект  на  экран  второй  раз  по  старой  позиции   с
константой GXOR-чтобы удалить старое изображение

    4.Перейдите  к  шагу  1,  но  на  этот раз поместите объект на новую
позицию.

    Перемещение  объекта,  выполненное  с  помощью данных четырех шагов,
оставляет  фон  неизменным  после  шага  3. От мигания изображения можно
избавиться посредством минимизации времени работы между шагами 4 и 1,  и
уверенности, что  между шагами  1 и  3 прошло  достаточно времени.  Если
перемещается более,  чем 1  объект, каждый  объект должен обрабатываться
отдельно, один шаг за один прием.

    -Использование в мультипликации константы _GPSET.

    Если  сохранение  фона  не  является  важным,  мультипликацию  можно
выпольнить  с  помощью   опции  _GPSET.  Если   граница  ограничивающего
прямоугольника  вокруг  изображения  такая  же  большая  или больше, чем
максимальное расстояние, на которое перемещается объект, то всякий  раз,
как образ будет помещаться в новую позицию, граница будет уничтожать все
следы образа в старой позиции.

      -Пример: Мультипликация с помощью запоминания образов.
   .
   .     previous includes from huppix.c
   .
#include qmalloc.h> /* требуется для использования буфера */
   .


   .     declarations from hyppix.c
   .
char far *buffer; /* используется с функциями _getimage и
                     _putimage */
main()
{  .
   .     body of program from hyppix.c
   .
}
hypcycle()
{  .
   .    declarations and initialization from hyppix.c
   .
   draw_and_store_figure(); /* помещение фигуры в буфер */
   _clearscreen (_GCLEARSCREEN);
   .
   .    drawing of axes as in hyppix.c
   .
   /* расстановка точек и помещение образа из буфера на экран */
   while (!kbhit()) {
        for (i=1; i<= 20; i++) {
           ang = ang + 2*pi/100;
           x = x=+(a-b)*cos(ang)+h*cos(ang*(a-b)/b);
           y = y0-(a-b)*sin(ang)+h*sin(ang*(a-b)/b);
           _putimage (x,y,buffer?GXOR);
           for (j=1; j<=6000; j++)
              ;
           _putimage (x,y,buffer,GXOR);


         }
  }
}
draw_and_store_figure()
{  .
   .   содержине функции из предыдущего раздела.
   .
}

    Программа   вычерчивания   гипоциклоида   из   Раздела   4.9    была
модифицирована с тем, чтобы вычерчивание кривой производилось с  помощью
запомненного    шаблона    и    поверх    фона    на    экране.  Функция
_draw_and_store_ligure взята из Раздела 4.14, она используется  функцией
_getimage для  сохранения всей  графической фигуры  в буферной  области.
Скелет  данной  программы  приведен  выше  с замечаниями о произведенных
изменениях.
