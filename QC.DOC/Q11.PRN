


                              ГЛАВА 11.


               Автоматизированная разработка программ с
                        помощью утитлиты MAKE.


11.1. "Сердце" утитилиты MAKE:
      Файлы описания.
      11.1.1. Построение файла описания утилиты MAKE.
      11.1.2. Блоки описания.
11.2. Запуск утилиты MAKE.
11.3. Использование в утилите MAKE макро-
      определений.
      11.3.1. Определение и задание макрокоманд.
      11.3.2. Использование макрокоманд в макро-
              определениях.
      11.3.3. Использование специальных макрокоманд.
11.4. Определение правил вывода.
11.5. Использование файлов типа .MAK.
      11.5.1. Использование файлов типа .MAK с
              утилитой MAKE.
      11.5.2. Включение зависимостей файлов.
      11.5.3. Задание опций компановщика.


    Утилита разработки программ MAKE поможет вам в разработке  программ,
содержащих  более  одного  модуля.  Утилита MAKE автоматически обновляет
файл, устаревший по дате по сравнению с другими родственнами файлами,  и
бывает полезна в следующих ситуациях:

    -При разработке программ утилита MAKE может автоматически  обновлять
выполняемый  файл,  как  только  изменится  любой исходный или объектный
файл.

    -При  управлении  библиотеками  утилита  MAKE  может   автоматически
перестроить библиотеку, как только изменится один из модулей библиотеки.

    -В  сетевой  среде   утилита  MAKE  может   автоматически  обновлять
локальную  копию  программы  или  файла,  хранимых  в  сети,  как только
основная копия будет изменена.

    При запуске утилиты  MAKE вы должны  задать имя файла.  Данный файл,
известный  под   названием  "файл   описаний  утилиты   MAKE",  содержит
инструкции, сообщающие утилите MAKE, какие файлы следует обновить, какие
файлы должны измениться перед обновлением, какой тип обновления  следует
выполнить.

    Файл описаний может содержать следующие данные:

    TEST.EXE: TEST.C TEST2.C
    QCL TEST.C TEST2.C

    В данном  примере TEST.EXE-это  файл, который  должен быть обновлен,
если  какой-либо  из  исходных  файлов  TEST.C  или  TEST2.C   претерпит
изменения.Реальное  обновление  выполняется  с  помощью  команды  QCL на
следующей строке.  Подробности о  файлах описаний  вы найдете  в Разделе
11.1.

    Если вы компилируете ваши  программы в среде Quick-C,  файл описаний
для ваших программ строится автоматически.

    В  Разделе  11.2  описывается  информация,  которую следует задать в
командной строке утилиты  MAKE вместе с  именем файла описаний,  включая
опции   программы   MAKE.   В   Разделах   11.3-11.4  описываются другие
осбоенности утилиты MAKE.


                     11.1 "Сердце" программы MAKE:
                            Файлы описаний.

    Утилита MAKE использует "файлы описаний" для того, чтобы определить,
какие файлы следует  обновлять, когда их  обновлять и какие  следует для
этого выполнить операции. Файл  описаний утилиты MAKE состоит  из одного
или  более  "блоков  описаний",  каждый  из  которых задает описание для
одного файла.

    В Разделе 11.1.1 рассказывается, как создать простой файл  описаний,
состоящий из единственного блока описаний.

    В Разделах 11.1.1-11.1.2 разъясняется формат блока описаний, правила
для  их  установки  и  знаки  для  обозначения  отдельных блоков в файле
описаний.

    В  Разделе  11.1.2  рассматриваются  файлы  описаний программы MAKE,
которые строит Quick-C при разработке программ в среде Quick-C.


          11.1.1. Построение файла описаний для утилиты MAKE.

    В этом  разделе для  иллюстрации работы  утилиты MAKE  показано, как
построить простейший  файл описаний  для программы  MAKE. Поскольку файл
описаний  утилиты  MAKE-это  текстовый  файл,  для  его  создания  можно
воспользоваться любым редактором текстов.

    В нашем  примере, предположим,  что вы  хотите обновить  выполняемый
файл с именем UPDATE.EXE, как только изменится один из исходных  файлов.
Предположим далее,  что имена  исходных файлов  GETINPUT.C, FINDREC.C  и
UPDATE.C. Для создания файла  описания утилиты MAKE, с  помощью которого
автоматически   обновляется   файл   UPDATE.EXE,   используйте следующую
процедуру:

    1.С помощьюя  текстового редактора,  создайте файл  с именем UPDATE.
Хотя файл описаний утилиты MAKE  может иметь любое имя, может  оказаться
полезным присвоение файлу описаний то же самое имя, что и обрабатываемый
файл (без расширения).

    2.Введите имя обрабатываемого  файла, за которям  следует двоеточие,
как  показано  ниже.  Данный  файл  известен,  как "выходной", поскольку
утилита MAKE  создает обновленную  версию этого  файла.  (Выходные файлы
также могут называться "целевыми").

    UPDATE.EXE:

    3.Далее за двоеточием введите имена файлов, изменение которых  может
привести  к  изменению  выходного  файла.  В  нашем  примере,  вы должны
обновить  файл   UPDATE.EXE,  как   только  изменится   один  из  файлов
GETINPUT.C, FINDREC.C, UPDATE.C; строка  файла описания в данном  случае
будет выглядеть следующим образом:

    UPDATE.EXE: UPDATE.C GETINPUT.C FINDREC.C

    Файлы справа от двоеточия называются "входными", поскольку программа
MAKE  использует  их  в  качестве  входной инфолрмации, чтобы определить
следует или нет обновить выходной файл.  (Входные файлы называются также
"зависимые файлы"). Каждый входной файл отделяется от другого пробелом.

    4.Если  вы  хотите  добавить  комментарий  к  любой  из  строк файла
описаний утилиты MAKE,  введите знак (#)  Программа MAKE игнорирует  все
символы  между  этим  знаком  (#)  и  символом перехода на новую строку.
Например, вы можете задать следующий комментарий:

    UPDATE.EXE: UPDATE.C GETINPUT.C FINDREC.C #UPDATE ROUTINE

    5.Если любой их входный файлов изменяется, введите команду,  которую
вы  хотите  выполнить.  В  данном  примере предполагается, что вы хотите
перекомпилировать  и  перекомпановать  все  входные файлы. В результате,
файл описаний будет выглядеть следующим образом:

    UPDATE.EXE:UPDATE.C GETINP.C FINDREC.C #UPDATE ROUTINE
    QCL UPDATE.C GETINPUT.C FINDREC.C

    Если вы хотите добавить  комментарий до или после  командной строки,
комментарий, как показано ниже, должен начинаться в ко- лонке 1:

    UPDATE.EXE:UPDATE.C GETINPUT.C FINDREC.C #UPDATE ROUTINE
    # RECOMPILE AND RELINK
    QCL UPDATE.C GETINPUT.C FINDREC.C

    6.При выходе  из редактора  текстов сохраните  файл описаний.  Затем
введите: MAKE

    за  которым  следует  имя  файла  описаний  и нажмите ENTER. В нашем
примере вам следует ввести:

    MAKE UPDATE

    7.Утилита  MAKE  сравнивает  даты  последней  модификации каждого из
входных файлов  с датой  выходного файла.  Если все  даты входных файлов
"старее", чем дата выходного  файла, утилита MAKE не  производит никаких
действий. Если же какой-либо входной файл "новее" по дате, чем  выходной
файл,  утилита  MAKE  распознает,  по  отношению к какому входному файлу
"устарел" выходной файл и, таким образом, выполняет команду, назначенную
вами. В данном примере  программа MAKE перекомпилирует исходные  файлы и
перекомпанует соответсвующие объектные  файлы для создания  нового файла
UPDATE.EXE.


                        11.1.2. Блоки описаний.

    Блок описаний имеет следующую основную форму:

    outfile:[infile]...[#comment]

  [#comment]
      command
      [command]
         .
         .
         .

    В  следующей  Таблице  приведено  описание  составных  частей  блока
описаний:

Поле                   Значение


ontfile                Имя обновляемого файла; может включать специфи-
                       кацию дивковода или маршрута. Допускается толь
                       ко один выходной файл.
infile                 Имена файлов, которые при изменении приведут к
                       изменению выходного файла; могут включать спе-
                       цификации дисковода или маршрута. Одно имя вхо
                       дного файла от другого должно отделяться по
                       крайней мере одним пробелом. Если у вас файлов
                       больше, чем может уместиться на одной строке,
                       введите обратный слэш (\), нажмите ENTER и за-
                       тем продолжите ввод на следующей строке. Если
                       не задано ни одного входного файла, утилита
                       MAKE выполняет все команды в блоке автомати-
                       чески.
command                Команда, которая будет выполняться автомати-
                       чески, если выходной файл устарел по дате по
                       отношению к входному файлу. Командами в данном
                       случае могут быть программы, пакетные команды,
                       либо команды DOS. Команд может быть любое чис-
                       ло, но каждая должна начинаться с новой строки
                       и ей должен предшествовать хотя бы один пробел
                       или знак табуляции.
comment                Символ комментария (#), за которым следует
                       один или более символов. Программа MAKE игно-
                       рирует все символы, которые в данной строке
                       следуют за символом комментария. Поэтому, если
                       вы хотите разместить комментарий на той же
                       строке, что и имя выходного файла, вы должны
                       ввести его после имен входных файлов. Если ко-
                       мментарий появляется в строке, в которой ожи-
                       дается команда, символ комментария должен быть
                       первым символом в строке, причем лидирующие
                       пробелы не допускаются.



---------------------------------------------------------------------

    Примечание:

    Хороший  способ  запомнить  формат  файла описанний утилиты MAKE-это
представить его в форме "если, то": "если выходной файл устарел по  дате
по сравнению с  входным файлом, либо  если выходной файл  не существует,
выполняются команды".

---------------------------------------------------------------------


    В файле описаний вы можете задать любое количество блоков  описаний.
Между  последней  строкой  одного   блока  описаний  и  первой   строкой
следующего  блока  описаний  должна  быть  строка.  Когда  вы запускаете
утилиту  MAKE,  она  считывает  строку  в первом блоке описаний, которая
именует  входные  и  выходные  файлы  и затем проверяет даты модификации
данных  файлов.  Если  дата  модификации  для какого-либо входного файла
"старее"  даты  модификации  выходного  файла,  если  выходной  файл  не
существует,либо если входные файлы  не заданы, утилита MAKE  высвечивает
команды, заданные в блоке.

    В противном случае она переходит к следующему блоку, повторяя  такую
же последовательность действий для каждого блока в файле.

    Если утилита  MAKE не  может найти  входной файл,  выходной файл или
команду,  она  высвечивает  диагностическое  сообщение. Если пропущенный
файл является  выходным, утилита  MAKE проджолжает  работать, так  как в
большинстве   случаев,   недостающие   файлы   создаются  нижеследующими
командами.  Если  файл-входной  либо  командный-утилита  MAKE прекращает
работу.

    Утилита  MAKE,  кроме  того,  прекращает  работу  и  высвечивает код
прерывания  если  хотя  бы  одна  команда  возвращает  ошибку. Поскольку
утилита MAKE обрабатывает  блоки описаний в  том порядке, в  котором они
расположены  в  файле  описаний,   важно,  чтобы  блоки  описаний   были
расположены в требуемом порядке.

    -Пример:

MOD1.OBJ:      MOD1.C
        QCL /c MOD1.C
MOD2.OBJ:      MOD2.C
        QCL /c MOD2.C
EXAMPLE.EXE:   MOD1.OBJ MOD2.OBJ
        LINK MOD2+MOD2,EXAMPLE,EXAMPLE;

    В приведенном выше примере блоки описаний находятся в том порядке, в
котором  обновляются  или  создаются  выходные  файлы.  Таким   образом,
программа MAKE  обновляет файлы  MOD1.OBJ и  MOD2.OBJ (либо  создает их,
если  необходимо)  до   того,  как  будет   обновлен  или  создан   файл
EXAMPLE.EXE. После работы утилиты MAKE любые изменения в исходных файлах
будут отражены в файле EXAMPLE.EXE.


                     11.2. Запуск программа MAKE.

    -Синтаксис:

    MAKE [опции] [макроопределения] имя файла

    Если  вы  запускаете  утилиту  MAKE  на  системе  с  жестким диском,
используйье  команду  DOS  CD  для  того, чтобы сделать рабочим каталог,
содержащий файл  описаний и  ваши рабочие  файлы. Если  вы работаете  на
системе с гибкими дисками, установите в дискавод А рабочую копию  вашего
дистрибутивного диска  Libraries#1, а  диск, содержащий  файл описаний и
ваши рабочие файлы в дисковод В..

    Командная строка утилиты  MAKE позволяет вам  вместе с именем  файла
задать  дополнительную  информацию.  В  следующей  таблице   описывается
информация, которую вы можете задать в командной строке утилиты MAKE.

Поле    Значение


опции   Одна или более опций утилиты MAKE.
макро-  Одно или более макроопределений утилиты MAKE.
опреде-
ления
имя     Имя файла описаний утилиты MAKE. Обычно, это имя обрабатыва-
файла   емой программы без расширения. Если вы обновляете программу с
        именем PROGRAM.C, созданную в среде Quick-C, имя файла будет

        PROGRAM.MAK.

    В следующем списке описывается каждая опция, используемая с утилитой
MAKE и ее действия:

Опция   Действие


/D      Высвечивает последнюю дату модификации для каждого обрабаты-
        ваемого файла.
/I      Игнорирует коды завершения (называемые также кодами по уровню
        ошибок), возвращаемые программами, вызываемыми из файла опи-
        саний утилиты MAKE.
/N      "без выполнения" высвечивает команды из файла описаний, но не
        выполняет их. Данная опция бывает полезна для отладки файла
        описаний утилиты MAKE.
/S      "Режим молчания" строки во времы выполнения не высвечиваются.
/X имя  Переадресует сообщение об ошибках утилиты MAKE или любой дру-
файла   гой программы, вызываемой утилитой MAKE в данный файл. Если
        вместо имени файла стоит дефис (-), сообщения об ошибках на-
        правляются на стандартное устройство вывода. Если данная оп-
        ция не определена, сообщения об ошибках направляются на стан
        дартное устройство для вывода сообщений об ошибках вообще.



                 11.3. Использование макроопределений
                           для утилиты MAKE.

    Один  из  способов  упростить  файлы  определений-это   использовать
макрокоманды.  Макрокоманда-это  просто  имя,  которое  затем  в   файле
описаний утилиты MAKE вы можете заменить на любой текст. Если вы  хотите
изменить текст,  подставляемой на  место имени  макрокоманды, вы  можете
просто изменить  его в  макроопределении. Текст  автоматически обновится
повсюду, где используется имя данной макрокоманды.

    Макрокоманды могут вам понадобиться:

    -В качестве базовых имен исходных, объектных и выполняемых  файлов в
процессе разработки.  Если имя  программы меняется,  вы можете  изменить
базовое имя макроопределения; тогда базовое имя автоматически  изменится
для  исходного,  объектного  и  выполняемого  файла,  заданного  в файле
описания.

    -Для задания определенного  набора опций таких  команд, как QCL  или
LINK.  Если  опция  изменяется,  вы  можете  поменять  их  во всем файле
описаний путем простого изменения макроопределения.




              11.3.1. Определение и задание макрокоманд.

    Макроопределение имеет следующую основную форму:

    name=text

    После того, как вы  определите макрокоманду, вы можете  использовать
ее в файле описаний следующим способом ниже:

    $(name)

    Как только шаблон $(name)  появится в файле описаний,  данный шаблон
заменяется  на  text.  Имя  name  преобразуется  к  верхнему   регистру;
например,  имена  flags  и  FLAGS  эквивалентны.  Если вы определите имя
макрокоманды,  но  text  оставите  пустым,  либо если вы используете имя
макрокоманды, которое  не определено,  text будет  нулевой строкой.  Для
имени name можно также использовать любую переменную операционной среды,
определенную  в  текущей  среде.  Например,  если  переменная среды PATH
определена  в  текущей  среде,  значение  PATH  заменит  все   вхождения
макрокоманды $(PATH) в файле описаний.  (Заметим, что применение  данной
макрокоманды не переопределит значение переменной PATH в текущей среде).

    Макроопределения вы можете задать в одном из следующих мест:

    -Перед любым блоком описаний  в файле описаний утилиты  MAKE. Каждое
макроопределение должно быть расположено на отдельной строке. Все  знаки
табуляции или пробелы между name  и знаком равенства, либо между  знаком
равенства  и  text-игнорируются.  Все  табуляции  или  пробелы считаются
частью текста text.

    -В командной строке утилиты MAKE.

    Для   того,   чтобы   включить   знаки   табуляции   или   пробелы в
макроопределение в командной строке, заключите содержимое определения  в
двойные кавычки ('' '').

    Если одно и то же имя name определено более одного раза, соблюдается
следующий приоритет:

    1. Определение командной строки.

    2. Определение файла описаний.

    3. Определение операционной среды.

    Например,  если  PATH  определена  в  среде  DOS и в файле описаний,
утилита MAKE использует определение, находящееся в файле описаний.  Если
она определена также в командной строке утилиты MAKE, данное определение
подавляет оба других определения.

    -Пример:

    Предположим, что существует следующий  файл описаний утилиты MAKE  с
именем COMPILE:

base = ABC
debug = "/Zi"
$(base).EXE:         $(base).C
       QCL $(debug)$(base).C

    В  данном  файле  описаний  макроопределения  заданы для имен base и
debug.

    Макрокоманда base определяет  базовое имя объектного  и выполняемого
файлов, которые будут обрабатываться. Утилита MAKE заменит соответсвенно
все вхождения $(base)  на текст ABC.  Если имя программы  изменится, вам
будет  нужно  только  заменить  ABC  в  макроопределении  на  новое  имя
программы, и базовые имена двух файлов будут изменены автоматически.

    Макрокоманда debug просит команду  QCL создать выполняемый файл  для
отладчика Quick-C, либо отладчика Code View.

    Если  вы  хотите  отменить  одно  из макроопределений, находящихся в
файле описаний, вы можете задать  в командной строке утилиты MAKE  новое
макроопределение, как описано в следующем примере:

    MAKE base = DEF compile

    Данное  определение  макрокоманды  base  отменяет определение base в
файле описаний. В результате, base  заменяется на DEF, вместо ABC.  Если
вы  не   хотите  создавать   выполняемый  файл,   содержащий  отладочную
информацию,  вы  можете  запускать  утилиту  MAKE  с  помощью  следующей
командной строки:

    MAKE debug = compile

    Поскольку  макрокоманды,  определенные  в  командной  строке,  имеют
приоритет выше, чем те  же макрокоманды, определенные в  файле описаний,
утилита MAKE использует для макрокоманды $(debug) определения  командной
строки  (нулевую  строку;  обратите  внимание  на  пробел  между  знаком
равенства  и  именем  файла   описаний  утилиты  MAKE).  В   результате,
переключатель /Zi в командной строке QCL не появится, и выполняемый файл
не будет включать информацию для отладки.


                   11.3.2. Использование макрокоманд
                         в макроопределениях.

    Макрокоманды  могут  быть  использованы  внутри  других макрокоманд.
Например,  в  файле  описаний  утилиты  MAKE  PICTURE  вы  можете  иметь
следующее макроопределение:

    LIBS=$(DLIB)\MLIBCE.LIB $(DLIB)\GRAPHICS.LIB

    Вы  можете  затем  запустить  утилиту  MAKE и задать определение для
макрокоманды  с  именем  $(DLIB)  в  командной  строке,  как  показано в
следующем примере:

    MAKE DLIB = C:\LIB PICTURE

    В данном случае, каждое вхождение макрокоманды $(DLIB) будет в файле
описаний расширено до  C:\LIB; соответственно, определение  макрокоманды
LIBS в файле описаний будет расширено до следующего:

    LIBS=C:\LIB\MLIBCE.LIB C:\LIB\GRAPHICS.LIB

    Будьте осторожны, избегайте  рекурсивного вложения макрокоманд,  как
например, в следующем случае:

A= $(B)
B= $(C)
C= $(A)

    В  приведенном  выше  примере,   если  макрокоманда  $(B)  не   была
определена перед выполнением строки A= $(B), все остальные  макрокоманды
также не будут определены.




            11.3.3. Использование специальных макрокоманд.

    Утилита MAKE  имеет возможность  распознавать следующие  специальные
имена макрокоманд и автоматически подставляет для каждой соответствующий
текст:

Имя   Подставляемый текст


$*    Базовое имя выходного файла
$@    Полное имя выходного файла.
$**   Полный список имен входных файлов.


    -Пример:

TEST.EXE: MOD1.OBJ MOD2.OBJ MOD3.OBJ
          LINK $**, $@;
          $*

    В  приведенном  выше  примере  команды  LINK,  $**  представляет все
входные файлы, соответствующие выходному файлу TEST.EXE, а $@ определяет
полное имя TEST.EXE, как имя выполняемого файла в командной строке LINK.
Последняя строка  использует символы  $* для  определения базового имени
файла TEST.EXE,  то есть  TEST-как следующую  выполняемую команду. Таким
образом, приведенный выше пример эквивалентен следующему:

TEST.EXE: MOD1.OBJ MOD2.OBJ MOD3.OBJ
          LINK MOD1.OBJ MOD2.OBJ MOD3.OBJ, TEST.EXE;
          TEST




                   11.4. Определение правил вывода.

    Часто, утилита MAKE используется  для обновления файлов одного  типа
при  изменении  файлов  другого  типа.  Например, часто следует обновить
объектные файлы при изменении исходных файлов, либо обновить выполняемые
файлы или библиотеки при изменении исходных или объектных файлов.

    В  таких  случаях  вы  можете  задать  специальные "правила вывода",
которым будет следовать в  работе утилита MAKE. Данные  правила позволят
вам задать  единственную команду  MAKE для  преобразования всех выходных
файлов  с  данным  расширением  в  файлы с другим расширением. Например,
можно применить  правила вывода  для задания  единстнвенной команды QCL,
которая  превратит  все  файлы  (то  есть  файлы  с  расширением  .C)  в
выполняемые  файлы  (которые  имеют  расширение .EXE). Поскольку утилита
MAKE ищет соответствующие правила вывода, как только в блоке описаний не
окажется  команд,  вам  не  нужно  включать  команду QCL во все блоки, в
которых вы компилируете и компануете файл.

    Правила вывода имеют следующую основную форму:

.inextension.outextension:
    command
    [command]
    .
    .
    .

    В  данном  формате,  command  определяет  одну из команд, которую вы
должны использовать для преобразования файлов с расширением  inextension
в файлы с расширением outextension.

    Если мы рассмотрим приведенный ранее пример преобразования  исходных
файлов  в  выполняемые  файлы,  вам  следует определить для компиляции и
компановки  всех  исходных  файлов  текущего  каталога в объектные файлы
следующие правила вывода:

.C.EXE:
   QCL $*.C

    Задание  правил  вывода  без   команд  имеет  действие  снятия   уже
определенных ранее правил.

    Если утилита MAKE находит  блок описания без каких-либо  команд, она
ищет правила вывода, подходящие как для расширения выходного файла,  так
и для  расширения входного  файла. Если  такое правило  найдено, утилита
MAKE выполняет все команды, заданные в данном правиле.

    Правила вывода вы можете разместить в одном из следующих мест:

    -В файле описаний утилиты MAKE.

    -В  файле  с  именем  TOOLS.INI.  Данный файл известен под названием
"инструментальный стартовый  файл". Строка,  начинающаяся с  тэга [make]
должна стоять в файле TOOLS.INI перед всеми правилами зависимостей.

    Утилита MAKE ищет правила зависимостей в следующем порядке:

    1.В текущем файле описаний.

    2.В файле TOOLS.INI в текущем каталоге и на текущем устройстве. Если
она  не  может  найти  данный  файл,  то файл TOOLS.INI будет искаться в
каталоге, определенном  переменной операционной  среды INIT.  Как только
утилита MAKE находит  файл TOOLS.INI, она  просматривает файл в  поисках
строки, начинающейся с тэга  [make]. Затем она применяет  все подходящие
правила вывода, следующие за данной строкой.



    -Пример:

    Предположим, что файл TOOLS.INI содержит следующее:

[make]
.OBJ.LIB:
       LIB TEST.LIB +$*.OBJ;

    Теперь, предположим, что вы имеете следующий файл описаний:

EXAMPLE1.LIB: EXAMPLE1.OBJ
EXAMPLE2.EXE: EXAMPLE2.OBJ
       LINK /C0 EXAMPLE2,,,LIBV3.LIB

    Файл TOOLS.INI определяет правила вывода, которые выполняют  команду
LIB  в  файле  описаний,  чтобы  обновить  библиотеку,  как только будут
сделаны изменения в соответствующем объектном файле. Имя файла в правиле
вывода определяется специальной макрокомандой $*, так что данное правило
будет применяться к любому файлу с расширением .OBJ.

    Как только утилита MAKE встречает строку, содержащую выходной файл и
один или  более входных  файлов, сначала  она ищет  команды в  следующей
строке.  Если  никаких  команд  не  найдено,  утилита MAKE ищет правило,
которое  она  может  применить;  в  данном случае будет найдено правило,
определенное в  файле TOOLS.INI.  Утилита MAKE  применит данное правило,
заменив  при  выполнении  данной  команды  макрокоманду  $* на EXAMPLE1.
Соответственно, команда LIB будет выглядеть:

    LIB TEST.LIB +EXAPLE1.OBJ

    Когда  утилита  MAKE  достигает  строки,  содержащей  выходной  файл
EXAMPLE2.EXE, она  не ищет  правило зависимости,  поскольку для  данного
соотношения между входным и  выходным файлом команда задана  явно. Таким
образом, в  данном случае,для  создания выполняемого  файла утилита MAKE
скомпанует объектный  файл EXAMPLE2.OBJ  с библиотекой  LIBV3.LIB вместо
добавления файла EXAPMLE2.OBJ к библиотеке TEST.LIB.


                   11.5. Использование файлов .MAK.

    Если вы создаете программный  список для программы в  среде Quick-C,
Quick-C автоматически  строит файл  описания для  данной программы. Файл
описания  имеет  то  же  самое  базовое  имя,  что  и  программа,  но  с
расширением    .MAK.    Файл    описания    позволяет    пакету  Quick-C
перекомпилировать и перекомпановать все модули, составляющие  программу,
если какой-либо модуль в программе, либо подключаемый файл, определенный
в программном модуле, претерпел изменения.


                11.5.1. Использование файлов типа .MAK
                           с утилитой MAKE.

    При  незначительных  изменениях  утилиту  MAKE  и  файл  .MAK  можно
использовать вне программной среды  Quick-C. Если вы создаете  программу
вне среды Quick-C в файле .MAK должен присутствовать вызов библиотеки  с
расширением .LIB. Если же во время компиляции программы в среде  Quick-C
была загружена  библиотека Quick,  файл .MAK  будет содержать библиотеки
Quick.

    При  обновлении  программы  вне  среды Quick-C пользуйтесь следующей
процедурой:


    1.Создайте копию файла .MAK с другим именем, для того, чтобы Quick-C
мог продолжать использовать оригинал.

    2.Отредактируйте   данную   копию,   подставив   имя соответствующей
автономной   библиотеки   в   строку   комментария,   показывающую какая
библиотека будет использоваться.

    3.Запустите  утилиту  MAKE  и  задайте  имя измененного файла .MAK в
качестве программного входа. Утилита MAKE автоматически  перекомпилирует
и перекомпанует программу, которая может быть загружена в среду Quick-C,
как обычно.


                11.5.2. Зависимости включаемых файлов.

    В  процессе  разработки  программ  вам  часто  придется  накапливать
определения во включаемом файле, а затем использовать директиву #include
для включения  данного кода  в различные  программные модули.  Используя
данный  механизм,  вы  можете   изменять  только  код,  содержащийся   в
подключаемом файле,  поскольку, модули,  содержащие копии  данного кода,
будут автоматически обновляться при повторной компиляции.

    Чтобы  иметь  гарантию  того,  что  программа  будет   автоматически
обновляться при изменении любого из подключаемых файлов,  удостоверьтесь
что вы  задали включаемые  файлы в  качестве входных  файлов файла .MAK.
Хотя  компилятор  Quick-C  не  помещает  включаемые  файлы  в  файл .MAK
автоматически, он сохранит все включаемые файлы, которые вы поместите  в
файл .MAK с  помощью редактора текстов.  Когда вы загрузите  программный
список  в  среду  Quick-C  с  помощью  команды  Set  Program  LIst,  все
включаемые файлы,  заданные в  файле .MAK  будут включены  в программный
список. Компилятор Quick-C использует включаемые файлы тем же  способом,
что и  остальные файлы  в программном  списке, если  включаемый файл был
обновлен  со  времени  последней  компиляции  программы, программа будет
перекомпилирована.

    -Пример:

    Предположим, что  каждый модуль  программы с  именем Lexer  содержит
включаемый файл  с именем  globals.h, который  располагается в  каталоге
\INCLUDE. Предположим также, что первые несколько строк файла  lexer.mak
следующие:

#
# Program: Lexer
#
        qcl -c -WO -Zq -AM $*.c
lexer.obj : C:\SRC\lexer.c
gettoken.obj : C:\SRC\gettoken.c
       .
       .
       .


    Вы  можете  изменить  файл  lexer.mak,  как показано ниже- для того,
чтобы  иметь  уверенность,  что  программа  Lexer  будет  обновлена  при
изменении файла globals.h:

#
# Program: Lexer
#
        qcl -c -WO -Zq -AM $*.c
lexer.obj : C:\SRC\lexer.c C:\INCLUDE\globals.h
gettoken.obj : C:\SRC\gettoken.c C:\INCLUDE\globals.h
       .
       .


                  11.5.3. Задание опций компановщика.

    Когда   компилятор   Quick-C   компилирует   программу   с   помощью
программного списка, сначала он компилирует модули в программном списке,
а затем связывает  результирующие объектные файлы.  Процессом компановки
можно  управлять  с  помощью  задания  специальных условий в файле .MAK,
содержащем программный список.

    Можно просто определить макрокоманду с именем LDFLAGS, как  показано
ниже:

    LDFLAGS= link-opt...

    Макрокоманда LDFLAGS автоматически помещается в строку команды  LINK
файла  .MAK.Ваше  определение  должно  следовать  правилам,  описанным в
Разделе 11.3.1.

    Опции программы  LINK, определенные  вами, используются  каждый раз,
как только вы перекомпилируете  и перекомпануете модули из  программного
списка; они действуют до тех пор, пока вы не измените значение LDFLAGS в
файле .MAK.

