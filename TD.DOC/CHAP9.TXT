ГЛАВА 9  ВЫРАЖЕНИЯ

     Выражения могут содержать обозначения,  принятые в программе
(то  есть  имена  переменных и подпрограмм),  а также константы и
знаки операций,  допустимые в одном из поддерживаемых  отладчиком
языков (Си, Паскале и ассемблере).

     Turbo Debugger может вычислять значения выражений и сообщать
программисту результат.  Выражения можно также  использовать  для
обращения  к  определенной  области  памяти,  содержимое  которой
необходимо проверить.  Выражение может быть введено  в  ответ  на
любой  запрос  отладчика,  в котором требуется значение или адрес
ячейки памяти.  (Заметим,  что в каждом языке  используются  свои
правила вычисления выражений.)

     Для вычисления  значения  введенного  выражения используется
команда   Data/Evaluate/Modify,    открывающая    блок    диалога
Evaluate/Modify.  Эту  команду  можно использовать как в качестве
простого калькулятора,  так и  для  проверки  значений  элементов
данных отлаживаемой программы.

     В этой  главе описывается,  как Turbo Debugger выбирает язык
программирования для вычисления значений выражений,  и как  можно
заставить   его   использовать   конкретный   язык.   Описываются
компоненты выражений,  которые являются общими для  всех  языков,
такие  как  номера строк исходного текста и обращения к регистрам
процессора.  Затем описываются компоненты,  из  которых  строятся
выражения  в  каждом из языков,  такие как константы,  переменные
программы,  строки и знаки операций. Для каждого языка приводится
перечень  операций,  поддерживаемых отладчиком Turbo Debugger,  и
описывается синтаксис выражений.

     Для получения  более   подробной   информации   о   правилах
построения выражений в языках Си,  Паскаль и ассемблер обратитесь
к  соответствующей  документации:  Руководству   пользователя   и
Справочному  руководству по компилятору Turbo C (Turbo C Compiler
User's Guide  и  Reference  Guide),  Руководству  пользователя  и
Справочному  руководству  по  языку  Turbo  Pascal  (Turbo Pascal
User's Guide и Reference Guide) или  Справочному  руководству  по
языку Turbo Assembler (Turbo Assembler Reference Guide).

Выбор языка для вычисления выражений
------------------------------------

     Обычно Turbo Debugger определяет,  какой  язык  использовать
для  вычисления выражений,  анализируя расширение имени исходного
файла  текущего  модуля,  то  есть  модуля,   на   котором   было
остановлено выполнение программы.  Это определение можно отменить
с помощью команды  Options/Language,  которая  позволяет  выбрать
один  из  трех языков:  Си,  Паскаль или ассемблер.  Если выбрана
опция  Source,  выражения  будут  вычисляться  в  соответствии  с
правилами  языка  исходного файла.  (Если Turbo Debugger не может
определить,  на каком языке написана программа, он использует для
вычисления выражений правила языка Си.

     Обычно Turbo  Debugger сам правильно определяет,  какой язык
надо использовать.  Однако в некоторых  случаях  может  оказаться
полезным   точно  указать  отладчику,  какой  язык  использовать,
например, при отладке ассемблерного модуля, который вызывается из
программы, написанной на другом языке. Точно указав язык, который
должен использоваться для вычисления выражений,  можно обращаться
к данным так,  как это принято в данном языке,  даже если текущий
модуль написан на другом языке.

     Иногда бывает рассматривать выражения  или  переменные,  как
если бы  они  были  написаны на другом языке;  например,  если вы
отлаживаете Паскаль-программу, соглашения языка ассемблера или Си
могут давать  более  простой  способ  изменения  значения  байта,
хранимого в строке.

     Если при  входе  в  Turbo  Debugger  выбор  языка был сделан
правильно, далее трудностей с  использованием  соглашений  других
языков у  вас  не  будет.  Turbo  Debugger  хранит  инфыормацию о
первоначально выбранном языке  исходного  кода  и  соответственно
работает с   преобразованиями   и   хранением   данных.  Если  же
относительно языка возникает неоднозначность,  Turbo Debugger  по
умолчанию принимает язык ассемблера.

     Даже если при  входе  в  Turbo  Debugger  намеренно  выбрать
неправильный язык,   Е   В   способен   самостоятельно   получить
информацию о языке из  таблицы  символических  имен  и  исходного
файла. Однако, при некоторых обстоятельствах Turbo Debugger может
иметь проблемы,  связанные с неверным  способом  хранения  данных
вследствие неоднозначности определения языка.

Адреса кода, адреса данных и номера строк
-----------------------------------------------------------------

     Обычно, если в программе требуется  обратиться  к  некоторой
переменной  или  фукнции,  то  просто указывается ее имя.  Однако
можно и записать выражение,  в котором вычисляется  указатель  на
область  памяти,  или  задать  адреса  кода  в виде номеров строк
исходного текста,  поместив перед номером строки знак #, например
#123.   В   следующем   разделе   описано,   как   обращаться   к
идентификаторам, вне текущей области действия.

     Разумеется, вы можете задать непосредственно адрес в формате
сегмент:смещение в  шестнадцатиричной  записи  для исходного кода
вашей программы:

-----------------------------------------
Язык       Формат      Пример
-----------------------------------------
Си         0xnnnn      0x1234:0x0010
Паскаль    $nnnn       $1234:$0010
Ассемблер  nnnnh       1234h:0B234h

     В ассемблере шестнадцатиричные числа,
начинающиеся с цифр от A до E, должны иметь
ведуший ноль.
-----------------------------------------

Доступ к идентификаторам вне текущей области действия
-----------------------------------------------------------------

     Часть программы,  в  которой  отладчик  ищет  идентификатор,
называется областью  действия  (диапазоном  доступности)  данного
идентификатора.  Доступ  к  идентификаторам  за пределами текущей
области действия является достаточно сложным  вопросом, понимания
которого в большинстве случаев от пользователя не требуется.

     Как правило, Turbo Debugger ищет идентификатор, используемый
в выражении точно так же,  как это делает  компилятор.  Например,
компилятор  языка  Си  сначала  ищет  в текущей функции,  затем в
текущем модуле статический  (локальный)  идентификатор,  а  затем
глобальный идентификатор. Компилятор языка Паскаль сначала ищет в
текущей процедуре или функции,  затем в вызвавшей ее подпрограмме
(если  текущая  область  действия  является  вложенной),  затем в
разделе реализации текущего модуля (если текущая область действия
находится в модуле), а затем ищется глобальный идентификатор.

     Если, применив указанную методику поиска,  Turbo Debugger не
нашел идентификатор,  он продолжает поиск в других модулях,  пока
не находит локальный идентификатор, соответствующий искомому. Это
позволяет обращаться  к  идентификаторам,  находящимся  в  других
модулях, не указывая точное имя модуля.

     Если необходимо     заставить    Turbo    Debugger    искать
идентификатор в каком-то другом месте,  можно указать имя модуля,
имя  файла  внутри  модуля и/или имя подпрограммы.  Таким образом
можно обращаться к любому идентификатору программы, который имеет
определенное значение,  даже к локальным идентификаторам процедур
и функций, идентичным другим идентификаторам.

Замена области действия

     Независимо от того,  на каком  языке  написана  отлаживаемая
программа, для замены области действия используется один и тот же
способ.

     Обычно для   разделения   компонентов    области    действия
используется  знак  номера (#).  Кроме того,  если в данном языке
точка (.) не имеет другого назначения,  она может  использоваться
вместо знака номера.

     Для замены  области  действия  идентификатор  записывается в
следующем формате:

     [#модуль[#имя файла]]#номер строки[#имя переменной]

     или

     [#модуль[#имя файла]][#имя функции]#имя переменной

     Если не указано имя модуля,  поиск  производится  в  текущем
модуле.  Ниже приведен ряд примеров написания выражений с заменой
области действия.  Каждый пример соответствует  одной  допустимой
комбинации  элементов,  которую  можно  использовать  для  замены
области действия.

     Первые шесть  примеров   демонстрируют   различные   способы
использования номеров  строк  для  генерирования адресов и замены
области действия


     #123                          Строка 123 текущего модуля.

     #123#myvar1                   Идентификатор myvar1,
                                   находящийся в строке 123
                                   текущего модуля.

     #mymodule#123                 Строка 123 модуля mymodule.

     #mymodule#123#myvar1          Идентификатор myvar1,
                                   находящийся    в строке 123
                                   модуля mymodule.

     #mymodule#file1#123           Строка 123 исходного файла
                                   file1, который является частью
                                   модуля mymodule.

     #mymodule#file1#123#myvar1    Идентификатор myvar1,
                                   находящийся в стоке 123
                                   исходного файла file1, который
                                   является частью модуля
                                   mymodule.

     В следующих  шести примерах  показаны различные  способы замены
области действия  переменной с  использованием имен  модуля, файла и
функции.

     #myvar2                       То же, что и myvar2 без #.

     #myfunc#myvar                 Переменная myvar2 подпрограммы
                                   myfunc.

     #mymodule#myvar2              Переменная myvar2 модуля
                                   mymodule.

     #mymodule#myfunc#myvar2       Переменная myvar2 подпрограммы
                                   myfunc модуля mymodule.

     #mymodule#file2#myvar2        Переменная myvar2 из файла
                                   file2, включенного в модуль
                                   mymodule.

     #mymodule#file2#myfunc#myvar2 Переменная myvar2 функции
                                   myfunc, определенной в файле
                                   file2, описанном в модуле
                                   mymodule.

     И наконец,  Turbo Debugger позволяет замену области действия
при использовании имен объекта,  класса,  правила и  компонентной
функции. Вот несколько примеров:

     AnInstance                    Вхождение AnInstance, доступное
                                   в текущей области действия.

     AnInstance.AField             Поле AField, доступное через
                                   вхождение AnInstance, доступное
                                   в текущей области действия.

     AnObjectType.AMethod          Правило AMethod, доступное
                                   через объект типа AnObjectType,
                                   доступный в текущей области
                                   действия.

     AnInstance.AMethod            Правило AMethod, доступное
                                   через вхождение AnInstance,
                                   доступное в текущей области
                                   действия

     AUnit.AnInstance.AField       Поле AField, доступное через
                                   вхождение AnInstance, доступное
                                   через модуль AUnit.

     AUnit.AnObjectType.AMethod    Правило AMethod,  доступное
                                   через объект типа AnObjectType,
                                   доступный через модуль AUnit.

     AUnit.AnObjectType.AMethod.   Локальная переменная AVar,
     ANestedProc.AVar              доступная через процедуру
                                   ANestedProc, доступную через
                                   правило AMethod, доступное
                                   через тип объекта AnObjectType,
                                   доступный через модуль AUnit.

     Такие выражения  с квалифицированными идентификаторами можно
использовать везде, где возможно использование выражения, включая
блок диалога  Evaluate/Modify и окно Watches,  либо при изменении
выражения в окне Inspector,  либо  при  использовании  локального
меню в  окне  Module для перехода (Goto) к правилу,  компонентной
функции или процедуре в исходном коде.

     Если вы при отладке программы  на  С++  желаете  исследовать
функцию с перегруженным именем, введите это имя в соответствующем
блоке ввода.  Turbo Debugger откроет блок диалога Pick  A  Symbol
Name с  блоком  списка  всех  функций,  имеющих данное имя,  и вы
сможете выбрать желаемое.

Подразумеваемая область действия для вычисления значений выражений

     Когда Turbo Debugger вычисляет значение выражение, он должен
решить,   какая   часть  программы  является  "текущей"  областью
действия,  то есть областью действия идентификаторов,  записанных
без  замены  области  действия.  Во  многих  языках  это является
важным,  поскольку идентификаторы,  описанные внутри  процедур  и
функций,    могут    совпадать   по   написанию   с   глобальными
идентификаторами.  Поэтому Turbo  Debugger  должен  знать,  какой
экземпляр идентификатора имеется в виду.

     Для принятия  решения  об  области  действия  Turbo Debugger
обычно использует в качестве контекста текущее положение курсора.
Например,   можно   задать  область  действия,  в  которой  будет
вычисляться выражение,  поместив курсор на определенную строку  в
окне модуля.

     Это означает,  что  если курсор был перемещен со строки,  на
которой было остановлено  выполнение  программы,  при  вычислении
выражения  можно получить неожиданный результат.  Если необходимо
быть уверенным в том, что выражения вычисляются в текущей области
действия,  можно  воспользоваться командой Origin локального меню
окна модуля,  которая возвращает курсор в текущую точку исходного
текста программы.  Можно также задать область действия выражения,
перемещая курсор в подокне  кода  окна  процессора,  устанавливая
курсор  на  определенную  подпрограмму  в окне стека,  или на имя
подпрограммы в окне переменных.

Последовательности байтов
-----------------------------------------------------------------

     При выполнении    некоторых    команд    требуется   вводить
последовательности байтов.  К  ним  относятся  команды  Search  и
Change  локального  меню подокна данных окна процессора,  а также
команды Search и Change локального меню окна файла, отображающего
содержимое файла в шестнадцатиричном формате.

     В последовательности   байтов   могут  сочетаться  скалярные
значения (без плавающей точки) и строки,  записанные  в  формате,
допустимым   в   текущем   языке,  выбранным  с  помощью  команды
Options/Language.  Для  записи  строк  и  скалярных  значений   в
выражениях используется одинаковый синтаксис.  Скалярные значения
преобразуются  в  последовательность  байтов,  например  значение
123456  типа  longint  языка  Паскаль  преобразуется в 4-байтовое
шестнадцатиричное значение 40 E2 01 00.

     ---------------------------------------------------------
     Язык           Последовательность       Шестнадцатиричное
                         байтов                   значение
     ---------------------------------------------------------
     Си                "ab"0x04"c"             61 62 04 63
     Паскаль           'ab'#4'c'               61 62 04 63
     Ассемблер         1234 "AB"               34 12 41 42
     ---------------------------------------------------------

Выражения языка Си
-----------------------------------------------------------------

     Turbo Debugger полностью поддерживает  синтаксис  выражений,
принятый  в  языке  Си.  Выражение может включать идентификаторы,
знаки  операций,  строки,  переменные  и   константы.   Все   эти
компоненты описаны в следующих разделах.

Идентификаторы языка Си

     Идентификатор -  это  имя  элемента данных или подпрограммы,
принятое в программе. Идентификатор должен начинаться с буквы или
символа   подчеркивания  (_).  Далее  могут  следовать  такие  же
символы, а также цифры от 0 до 9. При вводе идентификатора первый
символ  подчеркивания  можно опускать.  Если идентификатор введен
без подчеркивания и  он  не  может  быть  найден,  в  его  начало
добавляется  символ подчеркивания и поиск повторяется.  Поскольку
обычно  компилятор   ставит   символ   подчеркивания   в   начало
идентификаторов,  это  освобождает  пользователя от необходимости
добавлять его самому.

Регистровые псевдопеременные языка Си

     Turbo Debugger обеспечивает доступ к  регистрам  процессора,
используя  тот  же  метод,  что  и  компилятор  Turbo C,  который
называется псевдопеременными. Псевдопеременная представляет собой
идентификатор, соответствующий регистру процессора.

     ----------------------------------------------------------
     Псевдопеременная         Тип                 Регистр
     ----------------------------------------------------------
          _AX            unsigned int               AX
          _AL            unsigned char              AL
          _AH            unsigned char              AH

          _BX            unsigned int               BX
          _BL            unsigned char              BL

                             117
          _BH            unsigned char              BH

          _CX            unsigned int               CX
          _CL            unsigned char              CL
          _CH            unsigned char              CH

          _DX            unsigned int               DX
          _DL            unsigned char              DL
          _DH            unsigned char              DH

          _CS            unsigned int               CS
          _DS            unsigned char              DS
          _SS            unsigned char              SS
          _ES            unsigned char              ES

          _SP            unsigned int               SP
          _BP            unsigned char              BP
          _DI            unsigned char              DI
          _SI            unsigned char              SI

          _IP            unsigned int               IP
     ----------------------------------------------------------

     Следующие псевдопеременные  обеспечивают  доступ к регистрам
процессора 80386.

     -----------------------------------------------------
     Псевдопеременная         Тип                 Регистр
     -----------------------------------------------------
          _EAX           unsigned long              EAX
          _EBX           unsigned long              EBX
          _ECX           unsigned long              ECX
          _EDX           unsigned long              EDX

          _ESP           unsigned long              ESP
          _EBP           unsigned long              EBP
          _EDI           unsigned long              EDI
          _ESI           unsigned long              ESI

          _FS            unsigned int               FS
          _GS            unsigned int               GS
     -----------------------------------------------------

Константы и форматы чисел языка Си

     Константы могут  быть  либо  целыми числами,  либо числами с
плавающей точкой.

     Целочисленная константа задается в десятичном  формате, если
не  используется  один из способов его замены,  предусмотренных в
Си.

          --------------------------------------
          Формат              Система счисления
          --------------------------------------
          цифры               Десятичная
          0цифры              Восьмиричная
          0Xцифры             Шестнадцатиричная
          0xцифры             Шестнадцатиричная
          --------------------------------------

     Обычные константы  имеют тип int (16 битов).  Если требуется
определить константу типа long,  после ее значения надо поставить
букву l или L, например 123456L.

     Константа с  плавающей  точкой  содержит  десятичную точку и
может записываться в  десятичном  или  експоненциальном  формате,
например,

     1.234  4.5e+11

Строки символов и Esc-последовательности языка Си
-----------------------------------------------------------------

     Строка представляет   собой   последовательность   символов,
заключенная   в  кавычки  ("").  В  качестве  символа  Esc  можно
использовать принятый в Си обратный слеш (\).

     ------------------------------------------------------
     Последовательность  Значение       Символ
     ------------------------------------------------------
     \\                                 Обратный слеш
     \a                  0X07           Звуковой сигнал
     \b                  0X08           Стирание влево
     \f                  0X0C           Перевод страницы
     \n                  0X0A           Перевод строки
     \r                  0X0D           Возврат каретки
     \t                  0X09           Горизонтальная
                                        табуляция
     \v                  0X0B           Вертикальная
                                        табуляция
     \xnn                nn             Шестнадцатиричное
                                        байтовое значение
     \nnn                nnn            Восмиричное
                                        байтовое значение
     ------------------------------------------------------

     Если после обратного слеша поставить любой из указанных выше
символов,  этот символ будет вставлен в строку в неизменном виде.

Операции языка Си и старшинство операций

     В отладчике Turbo Debugger используются те же  операции, что
и  в  языке  Си,  и установлено такое же старшинство операций.  В
отладчике предусмотрена одна дополнительная операция,  которая не
входит  в  набор  операций  языка  Си:  она  обозначается двойным
двоеточием (::).  Эта операция имеет более высокий приоритет, чем
все  операции  языка  Си  и  используется  для создания константы
дальнего  адреса  из  выражения,  стоящего  слева  и   выражения,
стоящего справа. Например,

     0X1234::0X1000  _ES::_BX

     Первостепенные операции

     () [] . -> sizeof

имеют высший приоритет и выполняются слева направо. Унарные операции

     * & - ! ~ ++ --

     имеют более  низкий приоритет,  чем первостепенные операции,
но более высокий приоритет,  чем бинарные операции, и выполняются
справа  налево.  В  приведенном  ниже  перечне  бинарные операции
расположены в порядке уменьшения приоритета; операции, записанные
в одной строке, имеют одинаковый приоритет.

     высший    * / %
               + -
               >> <<
               <> <= >=
               == !=
               &
               ^
               |
               &&
     низший    ||

     Единственная троичная  операция  ?:   имеет   более   низкий
приоритет, чем все бинарные операции.

     Все операции  присваивания  имеют  равный  приоритет,  более
низкий, чем троичная операция, и группируются справа налево.

     = += =+ *= /= \= >>= <<= &= ^= |=

Выполнение функций в си-программе

     Из выражения на языке Си можно вызывать  функции  точно  так
же,  как это делается в исходном тексте программы. Turbo Debugger
будет выполнять программу с заданными аргументами  функции.  Этот
способ   может   оказаться  очень  удобным  для  проверки  работы
написанной функции.  Можно вызывать ее несколько  раз  с  разными
аргументами и каждый раз проверять возвращаемое ею значение.

     Допустим, в  программе  имеется  следующая функция,  которая
возводит число x в степень y:

     long power(int x, int y) {
        long temp = 1;
        while (y--)
           temp *= x;
        return(temp);
     }

     Приведенная ниже  таблица  показывает  результаты выполнения
этой функции при вызове ее с разными аргументами.

          ----------------------------------------------
          Выражение           Результат
          ----------------------------------------------
          power(3,2)*2        18
          25 + power(5,8)     390650
          power(2)            Ошибка (пропущен аргумент)
          ----------------------------------------------

Выражения языка Си с побочными эффектами

     Побочный эффект возникает в  том  случае,  если  в  процессе
вычисления  выражения  языка  Си,  изменяется  значениие элемента
данных.  В  некоторых  случаях   побочный   эффект   может   быть
желательным   и   использоваться  для  преднамеренного  изменения
значения  какой-либо  переменной  пргограммы.  В  других  случаях
побочных эффектов требуется избегать,  поэтому важно понимать,  в
каких случаях они могут возникать.

     Операции присваивания  (=,  +=  и  т.д.)  изменяют  значение
элемента  данных,  записанного слева от знака операции.  Операции
приращения и отрицательного приращения (++ --)  изменяют значение
элемента  данных,  который  записан  справа  или слева от них,  в
зависимости от того,  используются ли они в  качестве  префиксной
или постфиксной операции.

     Встречаются и более трудноуловимые побочные эффекты, которые
возникают при выполнении функции,  являющейся  частью  программы.
Например, если в вычислить значение выражения

     myfunc(1,2,3) + 7


     то позже программа может начать работать  неправильно  из-за
того,  что  функция  myfunc  изменила  значения других переменных
программы.

Зарезервированные слова языка Си и преобразование типов

     Отладчик Turbo  Debugger  позволяет   явно   указывать   тип
указателя   точно  так  же,  как  это  делается  в  си-программе.
Преобразование типа  содержит  описание  типа  данных  языка  Си,
заключенное  в  круглые  скобки.  Оно  должно  быть  записано  до
выражения, в котором вычисляется указатель на область памяти.

     Преобразование типа   удобно   использовать   для   проверки
содержимого  ячейки  памяти,  обращение  к которой производится с
помощью дальнего адреса,  сформированного с помощью операции  ::,
например,

     (long far *)0x3456::0
     (char far *)_ES::_BX

     Преобразование типа  можно  использовать  для  обращения   к
переменной, о типе которой нет никакой информации. Такая ситуация
может возникнуть,  если модуль был скомпилирован без формирования
информации    для   отладки.   Если   тип   переменной   известен
программисту,  он может просто указать его  в  явном  виде  перед
именем   переменной,   вместо  того,  чтобы  перекомпилировать  и
перекомпоновывать программу.

     Например, если  переменная  iptr  является   указателем   на
целочисленное значение,  то можно проверить значение,  на которое
он указывает, вычислив значение выражения:

     *(int *)iptr

     Для этого также служит команда  Type  Cast  локального  меню
окна Inspector.

     Для преобразования типа в  отладчике  Turbo  Debugger  можно
использовать следующие зарезервированные слова языка Си:

     char                float               near
     double              huge                short
     enum                int                 struct
     far                 long                union
                                             unsigned

Выражения языка Паскаль
-----------------------------------------------------------------

     Turbo Debugger   поддерживает   синтаксис   выражений  языка
Паскаль за исключением операции конкатенации строк и операций над
множествами.   Выражение   состоит  из  знаков  операций,  строк,
переменных  и  констант.  Все  компоненты  выражений  описаны   в
следующих разделах.

Идентификаторы языка Паскаль

     Идентификаторами в   языке   Паскаль  являются  определяемые
пользователем имена элементов данных и  подпрограмм, используемые
в  программе.  Идентификатор  в  языке Паскаль может начинаться с
буквы (a-z,  A-Z) или  символа  подчеркивания  (_).  Далее  могут
следовать цифры (0-9), символы подчеркивания и буквы.

     Обычно идентификатор  подчиняется правилам области действия,
которые гласят, что "вложенные" локальные идентификаторы заменяют
другие  идентификаторы  с  теми  же  именами.  Это  правило можно
обойти,  если требуется обратиться к идентификаторам, находящимся
в   других  областях  действия.  Для  получения  более  подробной
информации обратитесь к разделу  "Доступ  к  идентификаторам  вне
текущей области действия" данной главы.

Константы и форматы чисел языка Паскаль

     Константы могут  быть  либо  целыми,  либо  вещественными (с
плавающей точкой).  Отрицательные константы начинаются  со  знака
"минус" (-).  Если в числе имеется десятичная точка или символ e,
означающий  экспоненту,  то  это  число  является   вещественным,
например,

     123.4  456e34  123.45e-5

     Целочисленные константы  обычно  записываются  в  десятичном
формате,  но могут записываться и в шестнадцатиричном формате.  В
этом   случае   перед   константой  ставится  знак  доллара  ($).
Десятичные целочисленные константы должны лежать в диапазоне от -
2137483648  до  2137483647.  Шестнадцатиричные  константы  должны
лежать в диапазоне от $00000000 до $FFFFFFFF.

Строки языка Паскаль

     Строка в языке Паскаль  определяется  как  группа  символов,
заключенная в одиночные кавычки, например,

     'abc'

     В строку  можно включать управляющие символы.  В этом случае
перед десятичным значением управляющего символа ставится  знак #,
например,

     'def'#7'xyz'

Операции языка Паскаль

     Turbo Debugger   поддерживает  все  операции,  допустимые  в
выражениях паскаль-программы.

     Унарные операции  имеют  высший  приоритет  по  отношению  к
другим операциям и равный приоритет между собой.

     @         Получение адреса переменной
     ^         Значение указателя
     not       Побитовое дополнение
     тип       Преобразование типа
     +         Унарный плюс, положительное число
     -         Унарный минус, отрицательное число

     Бинарные операции имеют более низкий приоритет и расположены
в порядке понижения приоритета.

     * / div mod and shl shr
     in + - or xor
     < <= > <= = <>

     Операция присваивания   (:=)   имеет   низший   приоритет  и
возвращает некоторое значение, так же как и в Си.

Вызов процедур и функций паскаль-программы

     Обращения к  функциям  могут  производиться  из   выражений.
Например,  допустим,  что  в  паскаль-программе  описана  функция
HalfFunc, которая выполняет деление целого числа на 2:

     function HalfFunc(i: integer): real;

     Используя команду   Data/Evaluate/Modify,   можно   вызывать
функцию HalfFunc следующим образом:

     HalfFunc(3)
     HalfFunc(10)=HalfFunc(10 div 2)

     Можно также  вызывать  процедуры,  хотя,  конечно,   не   из
выражений.  Если  ввести  одно  имя процедуры или функции,  Turbo
Debugger укажет ее адрес  и  описание.  Для  того  чтобы  вызвать
процедуру или функцию,  для которой не требуется параметров, надо
поставить после ее имени пустые круглые скобки, например,

     MyProc()       Вызывает процедуру MyProc
     MyProc         Указывает адрес процедуры MyProc и т.д.
     MyFunc=5       Сравнивает адрес функции MyFunc с числом 5
     MyFunc()=5     Вызывает функцию MyFunc и сравнивает
                    возвращенное ею значение с числом 5.

Выражения языка ассемблера
-----------------------------------------------------------------

     Turbo Debugger  полностью  поддерживает  синтаксис выражений
языка  ассемблера.  Выражение   состоит   из   операций,   строк,
переменных  и  констант.  В  следующих  разделах  описаны все эти
компоненты.

Идентификаторы языка ассемблера

     Идентификаторами являются определяемые  пользователем  имена
элементов   данных   и  подпрограмм,  используемые  в  программе.
Идентификатор в языке ассемблера начинается с  буквы  (a-z,  A-Z)
или  одного из следующих символов:  @ ?  _ $.  Далее могут стоять
цифры от 0 до 9  и  такие  же  символы.  Точка  (.)  также  может
использоваться  в качестве первого символа идентификатора,  но не
может находиться внутри него.

     Специальный символ $ означает текущую  точку  программы,  на
которую указывает регистровая пара CS:IP.

Константы языка ассемблера

     Константы могут  быть  целыми или вещественными (с плавающей
точкой). Вещественные константы содержат десятичную точку и могут
записываться в десятичном или экспоненциальном формате, например,

     1.234  4.5e+11

     Целочисленные константы   записываются  в  шестнадцатиричном
формате или к ним применяется один из способов  изменения системы
счисления языка ассемблера.

          --------------------------------------
          Формат              Система счисления
          --------------------------------------
          цифры               Шестнадцатиричная
          цифрыO              Восьмиричная
          цифрыQ              Восьмиричная
          цифрыD              Десятичная
          цифрыB              Двоичная
          --------------------------------------

     Шестнадцатиричное число  всегда должно начинаться с цифры от
0 до 9.  Если требуется ввести число, начинающееся с буквы (A-F),
надо поставить перед ним цифру 0.

Операции языка ассемблера

     Turbo Debugger   поддерживает   большинство  операций  языка
ассемблера,  которые  расположены   ниже   в   порядке   убывания
приоритета.

     xxxPTR(BYTE PTR...)
     . (выбор элемента структуры)
     : (смена сегмента)
     OR XOR							    
     AND
     NOT
     EQ NE LT LE GT GE
     + -
     * / MOD SHR SHL
     Унарный +, унарный -
     OFFSET SEG
     () []

     Значение переменной может быть изменено с  помощью  операции
присваивания, например,

     a = [BYTE PTR DS:4]

Управление форматом
-----------------------------------------------------------------

     Когда  вы   задаете  отладчику   выражение,  которое  требуется
отобразить,  он  отображает  его  в  формате,  соответствующем  типу
используемых в нем данных.  Turbo Debugger игнорирует управляющие
форматы, являющиеся недопустимыми для конкретного типа данных.

     Если требуется  изменить  формат отображения,  выбираемый по
умолчанию для  данного  выражения,  можно  поставить  после  него
запятую  и  ввести  значение,  задающее  количество  повторений и
букву,  задающую  формат  отображения.  Число  повторений   можно
задавать  только  для  указателей и массивов.  Заметим,  что если
указатель формата применяется к  неверному  типу  данных,  он  не
воспринимается отладчиком.

     ---------------------------------------------------------------
     Символ                        Формат
     ---------------------------------------------------------------
     c         Отображает символьное или строковое выражение в
               виде необработанных символов. Обычно непечатаемые
               символьные значения отображаются в виде Esc-
               последовательностей или десятичных чисел. Этот
               указатель формата заставляет отладчик отображать
               символы, используя полный набор символов фирмы IBM.
     d         Отображает целочисленные значения в десятичном
               формате.
     f[#]      Отображает число в формате с плавающей точкой с
               указанным количеством цифр. Если количество цифр не
               указано, используется столько цифр, сколько
               необходимо.
     m         Отображает выражение, обращающееся к памяти, в виде
               шестнадцатиричных байтов.
     md        Отображает выражение, обращающееся к памяти, в виде
               десятичных байтов.
     p         Отображает необработанное ссылочное значение,
               указывая (если возможно) в качестве сегмента
               название регистра. Показывает также объект, на
               который оно указывает. Если не задан указатель
               формата, этот формат используется по умолчанию.
     s         Отображает массив или указатель на массив в виде
               заключенной в кавычки строки символов. Стока
               заканчивается нулем.
     x или h   Отображает целое число в шестнадцатиричном формате.

     ---------------------------------------------------------------
