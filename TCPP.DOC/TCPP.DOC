 Предисловие

                           Язык формирует наш способ мышления
                        и определяет, о чем мы можем мыслить.
                                                  - Б.Л. Ворф

     С++ - это универсальный язык программирования,  задуман-
ный так,    чтобы сделать программирование более приятным для
серьезного программиста.  За исключением второстепенных дета-
лей С++ является надмножеством языка программирования C.  По-
мимо возможностей, которые дает C, С++ предоставляет гибкие и
эффективные средства определения новых типов. Используя опре-
деления новых типов,  точно отвечающих концепциям приложения,
программист может разделять разрабатываемую программу на лег-
ко поддающиеся контролю части.  Такой метод построения  прог-
рамм часто   называют абстракцией данных.  Информация о типах
содержится в некоторых объектах типов, определенных пользова-
телем. Такие   объекты просты и надежны в использовании в тех
ситуациях, когда  их тип нельзя установить на стадии компиля-
ции. Программирование  с применением таких объектов часто на-
зывают объектно-ориентированным. При правильном использовании
этот метод   дает  более  короткие,  проще понимаемые и легче
контролируемые программы.

     Ключевым понятием С++ является класс.  Класс - это  тип,
определяемый пользователем. Классы обеспечивают сокрытие дан-
ных, гарантированную инициализацию данных, неявное преобразо-
вание типов для типов, определенных пользователем, динамичес-
кое задание типа,   контролируемое  пользователем  управление
памятью и   механизмы перегрузки операций.  С++ предоставляет
гораздо лучшие, чем в C, средства выражения модульности прог-
раммы и  проверки типов.  В языке есть также усовершенствова-
ния, не  связанные непосредственно с классами,  включающие  в
себя символические константы, inline-подстановку функций, па-
раметры функции по умолчанию,  перегруженные  имена  функций,
операции управления свободной памятью и ссылочный тип.  В С++
сохранены возможности языка C по работе с основными объектами
аппаратного обеспечения (биты,  байты, слова, адреса и т.п.).
Это позволяет весьма эффективно реализовывать типы, определя-
емые пользователем.

     С++ и  его  стандартные  библиотеки  спроектированы так,
чтобы обеспечивать переносимость. Имеющаяся на текущий момент
реализация языка будет идти в большинстве систем, поддержива-
ющих C.  Из С++ программ можно использовать C библиотеки, и с
С++ можно     использовать   большую  часть  инструментальных
средств, поддерживающих программирование на C.

     Эта книга предназначена главным образом для того,  чтобы
помочь серьезным программистам изучить язык и применять его в
нетривиальных проектах. В ней дано полное описание С++, много
примеров и еще больше фрагментов программ.

Благодарности

     С++ никогда  бы не созрел без постоянного использования,
предложений и конструктивной критики со стороны многих друзей
и коллег. Том Карджилл, Джим Коплин, Сту Фельдман, Сэнди Фре-
зер, Стив  Джонсон, Брайэн Керниган, Барт Локанти, Дуг МакИл-
рой, Дэннис  Риччи,  Лэрри Рослер, Джерри Шварц и Джон Шопиро
подали важные для развития языка идеи.  Дэйв Пресотто написал
текущую реализацию библиотеки потоков ввода/вывода.

     Кроме того,   в развитие С++ внесли свой вклад сотни лю-
дей, которые присылали мне предложения по усовершенствованию,
описания трудностей,   с которыми они сталкивались,  и ошибки
компилятора. Здесь я могу упомянуть лишь немногих из них: Гэ-
ри Бишоп, Эндрю Хьюм, Том Карцес, Виктор Миленкович, Роб Мюр-
рэй, Леони Росс, Брайэн Шмальт и Гарри Уокер.


                                    - 2 -

     В издании этой книги мне помогли многие люди, в частнос-
ти, Джон  Бентли,  Лаура Ивс, Брайэн Керниган, Тэд Ковальски,
Стив Махани, Джон Шопиро и участники семинара по С++, который
проводился в Bell Labs,  Колумбия, Огайо, 26-27 июня 1985 го-
да.

                     Мюррэй Хилл, Нью Джерси Бьярн Страустрап









                       Заметки для Читателя

                        "О многом," - молвил Морж, - "Пришла
                                           пора поговорить."
                                                 - Л. Кэррол

     В этой главе содержится обзор книги, список библиографи-
ческих ссылок   и некоторые замечания по С++ вспомогательного
характера. Замечания  касаются истории С++,  идей,  оказавших
влияние на разработку С++,  и мыслей по поводу программирова-
ния на С++.  Эта глава не является введением:   замечания  не
обязательны для   понимания последующих глав,  и некоторые из
них предполагают знание С++.

                    Структура Этой Книги

     Глава 1 - это короткое турне по основным особенностям С+
+, предназначенное  для того,  чтобы дать читателю почувство-
вать язык. Программисты на C первую половину главы могут про-
читать очень   быстро,  она охватывает главным образом черты,
общие для C и С++. Во второй главе описаны средства определе-
ния новых  типов в С++,  начинающие могут отложить более под-
робное изучение этого до того, как прочтут Главы 2, 3 и 4.

     В Главах 2,  3 и 4 описываются средства С++, не входящие
в определение новых типов:  основные типы, выражения и струк-
туры управления в С++ программах. Другими словами, в них опи-
сывается подмножество С++,  которое по существу является язы-
ком C.  Рассмотрение в них проводится гораздо подробнее,   но
полную информацию   можно найти только в справочном руководс-
тве.

     В Главах 5,  6 и 7 описываются средства С++ по  описанию
новых типов, особенности языка, не имеющие эквивалента в C. В
Главе 5 приводится понятие базового класса,  и  показывается,
как можно инициализировать объекты типа,  определяемого поль-
зователем, обращаться к ним и, наконец, убирать их. В Главе 6
объясняется, как для определяемого пользователем типа опреде-
лять унарные и бинарные операции, как задавать преобразования
между типами, определяемыми пользователем, и как как задавать
то, каким  образом  должно  обрабатываться  каждое  создание,
уничтожение и  копирование значения определяемого пользовате-
лем типа.  Глава 7 описывает концепцию  производных  классов,
которая позволяет   программисту строить более сложные классы
из более  простых,   обеспечивать  альтернативные  интерфейсы
класса и работать с объектами эффективно и с гарантией типа в
тех ситуациях,  когда типы объектов не могут быть известны на
стадии компиляции.



                                    - 3 -
     В Главе 8 представлены классы ostream и istream, предос-
тавляемые стандартной библиотекой для осуществления ввода-вы-
вода. Эта глава имеет двоякую цель: в ней представлены полез-
ные средства,  что одновременно  является  реальным  примером
использования С++.

 И, наконец, в книгу включено справочное руководство по С++.

     Ссылки на  различные  части  этой  книги  даются в форме
#2.3.4 (Глава 2 подраздел 3.4).  Глава с - это справочное ру-
ководство например #с.8.5.5.

                   Замечания по Реализации

     Во время написания этой книги все реализации С++ исполь-
зовали версии единственного интерфейсного  компилятора*.   Он
используется на многих архитектурах, включая действующие вер-
сии системы операционной системы UNIX на AT&T 3B,   DEC  VAX,
IBM 370 и Motorolla 68000. Фрагменты программ, которые приво-
дятся в этой книге, взяты непосредственно из исходных файлов,
которые компилировались  на 3B в UNIX System V версии 2 [15],
VAX11/750 под 8-ой Редакцией UNIX [16] и CCI Power  6/32  под
BSD4.2 UNIX [17]. Язык, описанный в этой книге, - это "чистый
С++", но  имеющиеся на текущий момент  компиляторы  реализуют
большое число  "анахронизмов" (описанных в #с.15.3),  которые
должны способствовать переходу от C к С++.

--------------------
     * С++ можно купить в AT&T, Software Sales and Marketing,
PO Box   25000,   Greensboro,   NC   27420,    USA   (телефон
800-828-UNIX) или  в ваших местных организациях, осуществляю-
щих продажу Системы UNIX. (прим. автора)

                         Упражнения

     Упражнения находятся в конце глав.  Все упражнения глав-
ным образом типа напишите-программу. Для решения всегда пиши-
те такую программу,  которая будет компилироваться и работать
по меньшей   мере на нескольких тестовых случаях.  Упражнения
различаются в основном по сложности,   поэтому  они  помечены
оценкой степени  сложности.  Шкала экспоненциальная,  так что
если на упражнение (*1)  вам потребовалось пять минут,  то на
упражнение (*2)    вам может потребоваться час,  а на (*3)  -
день. Время, которое требуется на то, чтобы написать и оттес-
тировать программу,  зависит больше от опыта читателя, нежели
от самого упражнения. Упражнение (*1) может отнять день, если
для того,  чтобы запустить ее, читателю сначала придется зна-
комиться с новой вычислительной системой.  С другой  стороны,
тот, у  кого под рукой окажется нужный набор программ,  может
сделать упражнение (*5) за час. В качестве источника упражне-
ний к Главам 2-4 можно использовать любую книгу по C. У Ахо и
др. [1]  приведено большое количество общих структур данных и
алгоритмов в   терминах  абстрактных типов данных.  Эту книгу
также может служить источником упражнений к Главам 5-7. Одна-
ко языку,  который в этой книге использовался,  недостает как
функций членов, так и производных классов. Поэтому определяе-
мые пользователем  типы часто можно выражать в С++ более эле-
гантно.

                 Замечания по Проекту Языка

     Существенным критерием при разработке языка была просто-
та. Там,   где возникал выбор между упрощением руководства по
языку и другой документации и упрощением компилятора, выбира-
лось первое. Огромное значение также предавалось совместимос-
ти с C, это помешало удалить синтаксис C.



                                    - 4 -
     В С++ нет типов данных высокого уровня и  нет  первичных
операций высокого уровня. В нем нет, например, матричного ти-
па с операцией обращения или типа строка с операцией конкате-
нации. Если  пользователю понадобятся подобные типы, их можно
определить в самом языке. По сути дела, основное, чем занима-
ется программирование  на С++ - это определение универсальных
и специально-прикладных типов.  Хорошо разработанный тип, оп-
ределяемый пользователем,    отличается  от  встроенного типа
только способом определения, но не способом использования.

     Исключались те черты,  которые могли бы повлечь дополни-
тельные расходы памяти или времени выполнения. Например, мыс-
ли о том, чтобы сделать необходимым хранение в каждом объекте
"хозяйственной" информации,  были отвергнуты.  Если пользова-
тель описывает структуру,  состоящую из двух 16-битовых вели-
чин, то структура поместится в 32-битовый регистр.

     С++ проектировался для использования в довольно традици-
онной среде компиляции и выполнения,  среде  программирования
на C в системе UNIX. Средства обработки особых ситуаций и па-
раллельного программирования, требующие нетривиальной загруз-
ки и поддержки в процессе выполнения, не были включены в С++.
Вследствие этого реализация С++ очень легко переносима. Одна-
ко есть полные основания использовать С++ в среде, где имеет-
ся гораздо более существенная поддержка.  Такие средства, как
динамическая загрузка, пошаговая трансляция и база данных оп-
ределений типов могут с пользой применяться  без  воздействия
на язык.

     Типы и  средства сокрытия данных в С++ опираются на про-
водимый во время компиляции анализ программ с целью  предотв-
ращения случайного искажения данных. Они не обеспечивают сек-
ретности или защиты от умышленного нарушения правил.   Однако
эти средства можно использовать без ограничений,  что не при-
водит к дополнительным расходам  времени  на  выполнение  или
пространства памяти.

                   Исторические Замечания

     Безусловно, С++ восходит главным образом к C [7]. C сох-
ранен как подможество,  поэтому сделанного  в  C  акцента  на
средствах низкого уровня достаточно,  чтобы справляться с са-
мыми насущными задачами системного программирования.   C,   в
свою очередь,  многим обязан своему предшественнику BCPL [9].
На самом деле, комментарии // (заново) введены в С++ из BCPL.
Если вы  знаете BCPL,  то вы заметите,  что в С++ по-прежнему
нет VALOF блока.  Еще одним источником  вдохновения  послужил
язык Simula67   [2,3],  из него была позаимствована концепция
класса (вместе с производными классами и функциями  членами).
Это было сделано,  чтобы способствовать модульности через ис-
пользование виртуальных функций. Возможности С++ по перегруз-
ке операций и свобода в расположении описаний везде,  где мо-
жет встречаться оператор, похожи на Алгол68 [14].

     Название С++  -  изобретение   совсем   недавнее   (лета
1983-его). Более ранние версии языка использовались начиная с
1980-ого и были известны как "C с  Классами".   Первоначально
язык был придуман потому,  что автор хотел написать событийно
управляемые модели для чего был бы идеален Simula67,  если не
принимать во внимание эффективность. "C с Классами" использо-
вался для крупных проектов моделирования,  в  которых  строго
тестировались возможности    написания  программ,   требующих
(только) минимального пространства памяти и времени на выпол-
нение. В  "C с Классами" не хватало перегрузки операций, ссы-
лок, виртуальных  функций и многих деталей.  С++ был  впервые
введен за   пределами  исследовательской группы автора в июле
1983го. Однако  тогда многие особенности С++ были еще не при-


                                    - 5 -
думаны.

     Название С++ выдумал Рик Масситти. Название указывает на
эволюционную природу перехода к нему от C.  "++" - это опера-
ция приращения в C.  Чуть более короткое имя C+ является син-
таксической ошибкой,  кроме того,  оно уже было  использовано
как имя   совсем другого языка.  Знатоки семантики C находят,
что С++ хуже,  чем ++C. Названия D язык не получил, поскольку
он является   расширением C и в нем не делается попыток исце-
литься от проблем путем выбрасывания различных  особенностей.
Еще одну  интерпретацию названия С++ можно найти в приложении
к Оруэллу [8].

     Изначально С++ был разработан, чтобы автору и его друзь-
ям не приходилось программировать на ассемблере, C или других
современных языках высокого уровня. Основным его предназначе-
нием было  сделать написание хороших программ более простым и
приятным для отдельного программиста. Плана разработки С++ на
бумаге никогда   не было.  Проект,  документация и реализация
двигались одновременно. Разумеется, внешний интерфейс С++ был
написан на С++.  Никогда не существовало "Проекта С++" и "Ко-
митета по разработке С++". Поэтому С++ развивался и продолжа-
ет развиваться   во  всех направлениях,  чтобы справляться со
сложностями, с  которыми сталкиваются пользователи, а также в
процессе дискуссий автора с его друзьями и коллегами.

     В качестве  базового языка для С++ был выбран C,  потому
что он

[1] многоцелевой, лаконичный и относительно низкого уровня,

[2] отвечает большинству задач системного программирования,

[3] идет везде и на всем и

[4] пригоден в среде программирования UNIX.

     В C есть свои сложности,  но в  наспех  спроектированном
языке тоже  были бы свои,  а сложности C нам известны.  Самое
главное, работа  с C позволила "C с Классами"  быть  полезным
(правда, неудобным) инструментом в ходе первых месяцев разду-
мий о добавлении к C Simula-подобных классов.

     С++ стал использоваться шире,  и по мере того,  как воз-
можности, предоставляемые  им помимо возможностей C, станови-
лись все более существенными, вновь и вновь поднимался вопрос
о том,  сохранять ли совместимость с C. Ясно, что отказавшись
от определенной части наследия C можно было бы избежать  ряда
проблем (см.,  например, Сэти [12]). Это не было сделано, по-
тому что

     [1] есть миллионы строк на C,  которые могли бы принести
пользу в  С++ при условии,  что их не нужно было бы полностью
переписывать с C на С++,

     [2] есть сотни тысяч строк библиотечных функций  и  сер-
висных программ,  написанных на C,  которые можно было бы ис-
пользовать из или на С++ при условии,  что С++ полностью сов-
местим с C по загрузке и синтаксически очень похож на C,

     [3] есть десятки тысяч программистов, которые знают C, и
которым, поэтому,   нужно только научиться использовать новые
особенности С++, а не заново изучать его основы и

     [4] поскольку  С++  и  C будут использоваться на одних и
тех же системах одними и теми же людьми,  отличия должны быть
либо очень  большими,  либо очень маленькими,  чтобы свести к


                                    - 6 -
минимуму ошибки и недоразумения.

     Позднее была проведена проверка определения С++,   чтобы
удостовериться в том, что любая конструкция, допустимая и в C
и в С++,  действительно означает в обоих языках одно и то же.

     Язык C сам эволюционировал за последние  несколько  лет,
частично под влиянием развития С++ (см.  Ростлер [11]). Пред-
варительный грубый ANSI стандарт C  [10]  содержит  синтаксис
описаний функций, заимствованный из "C с Классами". Заимство-
вание идей идет в обе стороны.  Например, указатель void* был
придуман для   ANSI C и впервые реализован в С++.  Когда ANSI
стандарт разовьется несколько дальше,  придет время пересмот-
реть С++,  чтобы удалить необоснованную несовместимость.  Бу-
дет, например,   модернизирован препроцессор (#с.11), и нужно
будет, вероятно,  отрегулировать правила выполнения плавающей
арифметики. Это не должно оказаться болезненным, и C и ANSI C
очень близки   к  тому,   чтобы стать подмножествами С++ (см.
#с.11).

                  Эффективность и Структура

     С++ был развит из языка программирования C  и  за  очень
немногими исключениями сохраняет C как подмножество.  Базовый
язык, C  подмножество С++,  спроектирован так,   что  имеется
очень близкое   соответствие  между его типами,  операциями и
операторами и компьютерными объектами,  с которыми непосредс-
твенно приходится иметь дело:  числами, символами и адресами.
За исключением операций свободной памяти new и  delete,   от-
дельные выражения и операторы С++ обычно не нуждаются в скры-
той поддержке во время выполнения или подпрограммах.

     В С++ используются те  же  последовательности  вызова  и
возврата из  функций,  что и в C.  В тех случаях,  когда даже
этот довольно эффективный механизм является слишком  дорогим,
С++ функция может быть подставлена inline,  удовлетворяя, та-
ким образом,  соглашению о записи функций без  дополнительных
расходов времени выполнения.

     Одним из первоначальных предназначений C было применение
его вместо программирования на ассемблере  в  самых  насущных
задачах системного   программирования.   Когда проектировался
С++, были  приняты меры, чтобы не ставить под угрозу успехи в
этой области. Различие между C и С++ состоит в первую очередь
в степени внимания,  уделяемого типам и структурам. C вырази-
телен и  снисходителен.  С++ еще более выразителен,  но чтобы
достичь этой  выразительности,   программист  должен  уделить
больше внимания типам объектов. Когда известны типы объектов,
компилятор может правильно обрабатывать выражения,  тогда как
в противном случае программисту пришлось бы задавать действия
с мучительными подробностями.  Знание  типов  объектов  также
позволяет компилятору обнаруживать ошибки,  которые в против-
ном случае остались бы до тестирования. Заметьте, что исполь-
зование системы типов для того, чтобы получить проверку пара-
метров функций,  защитить  данные  от  случайного  искажения,
задать новые   операции  и т.д.,  само по себе не увеличивает
расходов по времени выполнения и памяти.

     Особое внимание, уделенное при разработке С++ структуре,
отразилось на   возрастании масштаба программ,  написанных со
времени разработки C. Маленькую программу (меньше 1000 строк)
вы можете заставить работать с помощью грубой силы,  даже на-
рушая все правила хорошего стиля. Для программ больших разме-
ров это   не совсем так.  Если программа в 10 000 строк имеет
плохую структуру,  то вы обнаружите, что новые ошибки появля-
ются так же быстро,  как удаляются старые. С++ был разработан
так, чтобы  дать возможность разумным образом структурировать


                                    - 7 -
большие программы таким образом, чтобы для одного человека не
было непомерным справляться с программами в 25 000 строк. Су-
ществуют программы гораздо больших размеров, однако те, кото-
рые работают,  в целом,  как оказывается, состоят из большого
числа почти независимых частей, размер каждой из которых нам-
ного ниже указанных пределов.  Естественно, сложность написа-
ния и поддержки программы зависит от сложности разработки,  а
не просто от числа строк текста программы,   так  что  точные
цифры, с   помощью которых были выражены предыдущие соображе-
ния, не следует воспринимать слишком серьезно.

     Не каждая часть программы,  однако,  может  быть  хорошо
структурирована, независима от аппаратного обеспечения, легко
читаема и т.п.  С++ обладает возможностями,  предназначенными
для того, чтобы непосредственно и эффективно работать с аппа-
ратными средствами,  не заботясь о безопасности или  простоте
понимания. Он  также имеет возможности,  позволяющие скрывать
такие программы за элегантными и надежными интерфейсами.

     В этой книге особый акцент делается на методах  создания
универсальных средств,  полезных типов,  библиотек и т.д. Эти
средства пригодятся как тем программистам,  которые пишут не-
большие программы,  так и тем,  которые пишут большие.  Кроме
того, поскольку  все нетривиальные программы состоят из боль-
шого числа   полунезависимых  частей,  методы написания таких
частей пригодятся и системным, и прикладным программистам.

     У кого-то может появиться подозрение,  что  спецификация
программы с  помощью более подробной системы типов приведет к
увеличению исходных текстов программы.  В С++ это не так. С++
программа, описывающая  типы параметров функций, использующая
классы и т.д., обычно немного короче эквивалентной C програм-
мы, в которой эти средства не используются.

                    Философские Замечания

     Язык программирования  служит двум связанным между собой
целям: он дает программисту аппарат для задания действий, ко-
торые должны быть выполнены,  и формирует концепции, которыми
пользуется программист,  размышляя о том,  что делать. Первой
цели идеально отвечает язык,  который настолько "близок к ма-
шине", что  всеми основными машинными аспектами можно легко и
просто оперировать  достаточно очевидным для программиста об-
разом. С  таким умыслом первоначально задумывался C.   Второй
цели идеально отвечает язык,  который настолько "близок к ре-
шаемой задаче",  чтобы концепции ее решения можно было  выра-
жать прямо и коротко.  С таким умыслом предварительно задумы-
вались средства, добавленные к C для создания С++.

     Связь между языком,  на котором мы думаем/программируем,
и задачами и решениями, которые мы можем представлять в своем
воображении, очень  близка.   По  этой  причине  ограничивать
свойства языка только целями исключения ошибок программиста в
лучшем случае опасно. Как и в случае с естественными языками,
есть огромная   польза быть по крайней мере двуязычным.  Язык
предоставляет программисту набор концептуальных инструментов,
если они не отвечают задаче,  то их просто игнорируют. Напри-
мер, серьезные  ограничения  концепции  указателя  заставляют
программиста применять вектора и целую арифметику, чтобы реа-
лизовать структуры, указатели и т.п. Хорошее проектирование и
отсутствие ошибок не может гарантироваться чисто за счет язы-
ковых средств.

     Система типов должна быть особенно полезна в нетривиаль-
ных задачах.  Действительно, концепция классов в С++ показала
себя мощным концептуальным средством.



                                    - 8 -
            Размышления о Программировании на С++

     В идеальном случае подход к разработке программы делится
на три части:  вначале получить ясное понимание задачи, потом
выделить ключевые идеи,  входящие в ее решение, и наконец вы-
разить решение в виде программы.  Однако подробности задачи и
идеи решения часто становятся ясны только в результате попыт-
ки выразить  их в виде программы - именно в этом случае имеет
значение выбор языка программирования.

     В большинстве разработок имеются понятия, которые трудно
представить в   программе в виде одного из основных типов или
как функцию без ассоциированных с ней статических данных. Ес-
ли имеется  подобное понятие,  опишите класс,  представляющий
его в программе.  Класс - это тип,  это значит, что он задает
поведение объектов его класса:  как они создаются,  как может
осуществляться работа с ними,  и как они уничтожаются.  Класс
также задает способ представления объектов. Но на ранних ста-
диях разработки программы это не является (не должно  являть-
ся) главной заботой.
     Ключом к написанию хорошей программы является разработка
таких классов,  чтобы каждый из них представлял одно основное
понятие. Обычно это означает, что программист должен сосредо-
точиться на вопросах: Как создаются объекты этого класса? Мо-
гут ли эти объекты копироваться  и/или  уничтожаться?   Какие
действия можно производить над этими объектами? Если на такие
вопросы нет удовлетворительных ответов,  то во-первых, скорее
всего, понятие  не было "ясно", и может быть неплохо еще нем-
ного подумать над задачей и предлагаемым решением, вместо то-
го, чтобы сразу начинать "программировать" сложности.

     Проще всего иметь дело с такими понятиями, которые имеют
традиционную математическую форму: числа всех видов, множест-
ва, геометрические  фигуры и т.п. На самом деле, следовало бы
иметь стандартные библиотеки классов,   представляющих  такие
понятия, но  к моменту написания это не имело места.  С++ еще
молод, и  его библиотеки не развились еще до той же  степени,
что и сам язык.

     Понятие не существует в пустоте, всегда есть группы свя-
занных между собой понятий.  Организовать в программе взаимо-
отношения между классами,  то есть определить точную взаимос-
вязь между различными понятиями,  часто труднее,  чем сначала
спланировать отдельные классы. Лучше, чтобы не получилось не-
разберихи, когда  каждый класс (понятие)  зависит от всех ос-
тальных. Рассмотрим  два класса,  A и B. Взаимосвязи вроде "A
вызывает функции из B", "A создает объекты B" и "A имеет чле-
ны B"  редко вызывают большие сложности,  а взаимосвязь вроде
"A использует данные из B" обычно можно исключить (просто  не
используйте открытые данные-члены). Неприятными, как правило,
являются взаимосвязи,  которые по своей природе имеют вид  "A
есть B и ...".

     Одним из наиболее мощных интеллектуальных средств,  поз-
воляющих преодолевать сложность,  является иерархическое упо-
рядочение, то  есть организация связанных между собой понятий
в древовидную структуру с самым общим понятием в корне. В С++
такие структуры  представляются производными классами.  Часто
можно организовать программу как множество  деревьев  (лес?).
То есть, программист задает множество базовых классов, каждый
из которых имеет свое собственное множество производных клас-
сов. Для  определения набора действий для самой общей интерп-
ретации понятия (базового класса)  часто  можно  использовать
виртуальные функции   (#7.2.8).   Интерпретацию этих действий
можно, в  случае необходимости, усовершенствовать для отдель-
ных специальных классов (производных классов).



                                    - 9 -
     Естественно, такая организация имеет свои ограничения. В
частности, множество понятий иногда лучше организуется в виде
ациклического графа,  в котором понятие может непосредственно
зависеть от более чем одного другого понятия,  например,   "A
есть B и C и ...".  В С++ нет непосредственной поддержки это-
го, но  подобные связи можно представить,  немного потеряв  в
элегантности и     проделав   малость  дополнительной  работы
(#7.2.5).

     Иногда для организации понятий некоторой программы  ока-
зывается непригоден даже ациклический граф, некоторые понятия
оказываются взаимозависимыми по своей природе. Если множество
взаимозависимых классов   настолько мало,  что его легко себе
представить, то  циклические зависимости  не  должны  вызвать
сложностей. Для  представления множеств взаимозависимых клас-
сов с С++ можно использовать идею friend классов (#5.4.1).

     Если вы можете организовать понятия программы  только  в
виде общего  графа (не дерева или ациклического направленного
графа), и  если вы не можете локализовать взаимные зависимос-
ти, то  вы, по всей видимости, попали в затруднительное поло-
жение, из которого вас не выручит ни один язык программирова-
ния. Если     вы  не  можете  представить  какой-либо  просто
формулируемой зависимости между основными понятиями,  то ско-
рее всего справиться с программой не удастся.

     Напомню, что  большую часть программирования можно легко
и очевидно выполнять, используя только простые типы, структу-
ры данных, обычные функции и небольшое число классов из стан-
дартной библиотеки.  Весь аппарат, входящий в определение но-
вых типов,    не  следует  использовать  за  исключением  тех
случаев, когда он действительно нужен.

     Вопрос "Как пишут хорошие программы на С++" очень  похож
на вопрос "Как пишут хорошую английскую прозу?" Есть два вида
ответов: "Знайте,   что вы хотите сказать" и  "Практикуйтесь.
Подражайте хорошему языку." Оба совета оказываются подходящи-
ми к С++ в той же мере,  сколь и для английского - и им столь
же трудно следовать.

                    Правила Правой Руки*

--------------------
* Некоторые легко запоминаемые эмпирические правила. (прим.
перев.)

     Здесь приводится  набор  правил,   которых вам хорошо бы
придерживаться изучая С++.  Когда вы станете более опытны, вы
можете превратить их в то, что будет подходить для вашего ро-
да деятельности и вашего стиля программирования. Они умышлен-
но сделаны очень простыми, поэтому подробности в них опущены.
Не воспринимайте их чересчур  буквально.   Написание  хороших
программ требует ума, вкуса и терпения. Вы не собираетесь как
следует понять это с самого начала, поэкспериментируйте!

     [1] Когда вы  программируете,   вы  создаете  конкретное
представление идей   вашего  решения некоторой задачи.  Пусть
структура отражает эти идеи настолько  явно,   насколько  это
возможно:

  [a] Если вы считаете "это" отдельным понятием, сделайте его
       классом.

  [b] Если вы считаете "это" отдельным объектом, сделайте его
       объектом некоторого класса.

 [c] Если два класса имеют общим нечто существенное, сделайте


                                    - 10 -
      его базовым классом. Почти все классы в вашей программе
      будут иметь нечто общее. Заведите (почти) универсальный
      базовый класс, и разработайте его наиболее тщательно.

     [2] Когда вы определяете класс, который не реализует не-
который математический объект, вроде матрицы или комплексного
числа, или тип низкого уровня, вроде связанного списка, то:

 [a] Не используйте глобальные данные.

 [b] Не используйте глобальные функции (не члены).

 [c] Не используйте открытые данные-члены.

 [d] Не используйте друзей,  кроме как для того, чтобы  избе-
      жать [a], [b] или [c].

 [e] Не обращайтесь к данным-членам или другим объектам
      непосредственно.

 [f] Не помещайте в класс "поле типа", используйте  виртуаль-
      ные функции.

 [g] Не используйте inline-функции, кроме как средство
      существенной оптимизации.

              Замечания для Программистов на C

     Чем лучше кто-нибудь знает C, тем труднее окажется избе-
жать писания на С++ в стиле C,  теряя,  тем самым,  некоторые
возможные выгоды С++.  Поэтому проглядите, пожалуйста, раздел
"Отличия от C" в справочном руководстве (#с.15). Там указыва-
ются области,  в которых С++ позволяет делать  что-то  лучше,
чем C.  Макросы (#define) в С++ почти никогда не бывают необ-
ходимы, чтобы  определять провозглашаемые константы,  исполь-
зуйте const (#2.4.6)  или enum (#2.4.7),  и inline (#1.12)  -
чтобы избежать лишних расходов на вызов функции.   Старайтесь
описывать все функции и типы всех параметров - есть очень ма-
ло веских причин этого не делать. Аналогично, практически нет
причин описывать   локальную  переменную не инициализируя ее,
поскольку описание может появляться везде,  где может  стоять
оператор, -  не описывайте переменную, пока она вам не нужна.
Не используйте malloc()  - операция new (#3.2.6) делает ту же
работу лучше.   Многие объединения не нуждаются в имени - ис-
пользуйте безымянные объединения (#2.5.2).


                  Библиографические Ссылки

     В тексте мало прямых ссылок на литературу, но здесь при-
веден короткий список книг и статей,  которые прямо или  кос-
венно упоминаются.

[1] A.V.  Aho, J.E. Hopcroft, and J.D. Ulman: Data Structures
   and Algorithms.  Addison-Wesley,  Reading,  Massachusetts.
   1983.

[2] O-J. Dahl, B. Myrhaug, and K. Nygaard: SIMULA Common Base
   Language. Norwegian  Computer Center S-22,  Oslo,  Norsay.
   1970

[3] O-J.   Dahl  and  C.A.R.   Hoare:   Hierarchical  Program
   Construction in "Structured Programming." Academic  Press,
   New York. 1972. pp 174-220.

[4] A.  Goldberg and D. Robson: SMALLTALK-80 The Language and
   Its Implementation.          Addison-Wesley,      Reading,


                                    - 11 -
   Massachusetts. 1983.

[5] R.E.  Griswold et.al.:  The Snobol4 Programming Language.
   Prentice-Hall, Englewood Cliffs, New Jersey. 1970.

[6] R.E.  Griswold and M.T.  Griswold:  The ICON  Programming
   Language. Prentice-Hall,    Englewood Cliffs,  New Jersey.
   1983.

[7] Brian W.   Kernighan  and  Dennis  M.   Ritchie:   The  C
   Programming Language. Prentice-Hall, Englewood Cliffs, New
   Jersey. 1978.  Русский перевод в: Б.В. Керниган, Д. Ритчи,
   А. Фьюэр.  Язык программирования Си. М.: Финансы и Статис-
   тика. 1985.

[8] George Orwell:  1984.  Secker and Warburg,  London. 1949.
   Русский перевод: Дж. Оруэлл. 1984. ...

[9] Martin  Richards  and  Colin Whitby-Strevens:  BCPL - The
   Language and Its Compiler.   Cambridge  University  Press.
   1980.

[10] L.  Rosler (Chairman, ANSI X3J11 Language Subcommittee):
   Preliminary Draft Proposed Standard - The C Language.   X3
   Secretariat: Computer        and    Busineess    Equipment
   Manufacturers Association,  311 First Street,  N.W,  Suite
   500, Washington, DC 20001, USA.

[11] L.Rosler:   The  Evolution of C - Past and Future.  AT&T
   Bell Laboratories Technical Journal.  Vol.63 No.8 Part  2.
   October 1984. pp 1685-1700.

[12] Ravi  Sethi:   Uniform  Syntax  for Type Expressions and
   Declarations. Software  Practice  &  Experience,   Vol  11
   (1981), pp 623-628.

[13] Bjarne Stroustrup:  Adding Classes to C:  An Exercise in
   Language Evolution.  Software Practice &  Experience,   13
   (1981), pp 139-61.

[14] P.M. Woodward and S.G. Bond: Algol 68-R Users Guide. Her
   Majesty's Stationery Office, London. 1974.

[15] UNIX System V Release 2.0 User Reference  Manual.   AT&T
   Bell Laboratories, Murray Hill, New Jersey. December 1983.

[16] UNIX Time-Sharing System:  Programmer's Manual. Research
   Version, Eighth  Edition.  AT&T Bell Laboratories,  Murray
   Hill, New Jersey. February 1985.

[17] UNIX   Programmer's   Manual.    4.2  Berkeley  Software
   Distribution University     of   California,     Berkeley,
   California. March 1984.




                                    - 12 -

Глава 1
Турне по С++

                       Единственный способ изучать новый язык
                  программирования - писать на нем программы.
                                            - Брайэн Керниган

     Эта глава представляет собой краткий обзор основных черт
языка программирования С++. Сначала приводится программа на С
++, затем показано, как ее откомпилировать и запустить, и как
такая программа может выводить выходные  данные  и  считывать
входные. В первой трети этой главы после введения описаны на-
иболее обычные черты С++: основные типы, описания, выражения,
операторы, функции   и структура программы.  Оставшаяся часть
главы посвящена возможностям С++ по определению новых  типов,
сокрытию данных, операциям, определяемым пользователем, и ие-
рархии определяемых пользователем типов.

                        1.1 Введение

     Это турне проведет вас через ряд программ и частей прог-
рамм на С++. К концу у вас должно сложиться общее представле-
ние об   основных  особенностях  С++,   и  будет   достаточно
информации, чтобы    писать простые программы.  Для точного и
полного объяснения понятий, затронутых даже в самом маленьком
законченном примере, потребовалось бы несколько страниц опре-
делений. Чтобы  не превращать эту главу в описание или в  об-
суждение общих понятий, примеры снабжены только самыми корот-
кими определениями      используемых    терминов.     Термины
рассматриваются позже,  когда будет больше примеров, способс-
твующих обсуждению.

                         1.1.1 Вывод

     Прежде всего, давайте напишем программу, выводящую стро-
ку выдачи:

          #include <stream.h>

          main()
          (*
              cout << "Hello, world\n";
	  *)

     Строка #include <stream.h> сообщает компилятору,   чтобы
он включил стандартные возможности потока ввода и вывода, на-
ходящиеся в файле stream.h.  Без этих описаний выражение cout
<< "Hello,  world\n" не имело бы смысла. Операция << ("помес-
тить в"*) пишет свой первый аргумент во второй (в данном слу-
чае, строку    "Hello,   world\n"  в стандартный поток вывода
cout). Строка  - это последовательность символов, заключенная
в двойные кавычки. В строке символ обратной косой \, за кото-
рым следует другой символ,  обозначает один специальный  сим-
вол, в  данном случае, \n является символом новой строки. Та-
ким образом выводимые символы  состоят  из  Hello,   world  и
перевода строки.

--------------------
     * Программирующим на C << известно как  операция  сдвига
влево для целых.  Такое использование << не утеряно, просто в
дальнейшем << было определено для случая,   когда  его  левый
операнд является потоком вывода.  Как это делается, описано в
#1.8. (прим. автора)

Остальная часть программы

main() (* ... *)


                                    - 13 -

     определяет функцию,  названную main.   Каждая  программа
должна содержать   функцию с именем main,  и работа программы
начинается с выполнения этой функции.

                      1.1.2 Компиляция

     Откуда появились выходной поток cout и код,  реализующий
операцию вывода <<?  Для получения выполняемого кода написан-
ная на С++ программа должна быть скомпилирована. По своей су-
ти процесс компиляции такой же, как и для С, и в нем участву-
ет большая часть входящих в последний программ.  Производится
чтение и анализ текста программы,  и если не обнаружены ошиб-
ки, то генерируется код. Затем программа проверяется на нали-
чие имен и операций, которые использовались, но не были опре-
делены (в нашем случае это cout и <<).  Если это возможно, то
программа делается  полной посредством дополнения недостающих
определений из библиотеки (есть  стандартные  библиотеки,   и
пользователи могут создавать свои собственные).  В нашем слу-
чае cout и << были описаны в stream.h,  то есть, были указаны
их типы, но не было дано никаких подробностей относительно их
реализации. В  стандартной библиотеке содержится спецификация
пространства и  инициализирующий код для cout и <<.  На самом
деле, в  этой библиотеке содержится  и  много  других  вещей,
часть из которых описана в stream.h,  однако к скомпилирован-
ной версии добавляется только подмножество библиотеки,  необ-
ходимое для того, чтобы сделать нашу программу полной.

     Команда компиляции  в С++ обычно называется CC.  Она ис-
пользуется так  же,   как  команда  cc  для  программ  на  C,
подробности вы можете найти в вашем руководстве. Предположим,
что программа с "Hello,  world" хранится  в  файле  с  именем
hello.c, тогда   вы можете ее скомпилировать и запустить при-
мерно так ($ - системное приглашение):

   $ CC hello.c
   $ a.out
   Hello,world
   $

     a.out -  это  принимаемое  по умолчанию имя исполняемого
результата компиляции. Если вы хотите назвать свою программу,
вы можете сделать это с помощью опции -o:

   $ CC hello.c -o hello
   $ hello
   Hello,world
   $

                         1.1.3 Ввод

     Следующая (довольно многословная)  программа  предлагает
вам ввести число дюймов. После того, как вы это сделаете, она
напечатает соответствующее число сантиметров.

   #include <stream.h>

   main()
   (*
       int inch = 0; // inch - дюйм
       cout << "inches";
       cin >> inch;
       cout << inch;
       cout << " in = ";
       cout << inch*2.54;
       cout << " cm\n";
   *)


                                    - 14 -

     Первая строка функции main()  описывает целую переменную
inch. Ее  значение считывается с помощью операции >>  ("взять
из") над   стандартным потоком ввода cin.  Описания cin и >>,
конечно же, находятся в <stream.h>. После ее запуска ваш тер-
минал может выглядеть примерно так:

   $ a.out
   inches=12
   12 in = 30.48 cm
   $

     В этом примере на каждую команду вывода приходится  один
оператор. Это слишком длинно. Операцию вывода << можно приме-
нять к ее собственному результату,  так что последние  четыре
команды вывода можно было записать одним оператором:

   cout << inch << " in = " << inch*2.54 << " cm\n";

     В последующих разделах ввод и вывод будут описаны гораз-
до более подробно.  Вся эта глава фактически может рассматри-
ваться как   объяснение  того,  как можно написать предыдущие
программы на языке,  который не  обеспечивает  операции  вво-
да-вывода. На самом деле, приведенные выше программы написаны
на С++, "расширенном" операциями ввода-вывода посредством ис-
пользования библиотек  и включения файлов с помощью #include.
Другими словами,  язык С++ в том виде,  в котором он описан в
справочном руководстве,   не определяет средств ввода-вывода.
Вместо этого исключительно с помощью средств, доступных любо-
му программисту, определены операции << и >>.

                       1.2 Комментарии

     Часто бывает полезно вставлять в программу текст,  кото-
рый предназначается в качестве комментария только для  читаю-
щего программу     человека  и  игнорируется  компилятором  в
программе. В С++ это можно сделать одним из двух способов.

     Символы /* начинают комментарий,  заканчивающийся симво-
лами */.    Вся  эта последовательность символов эквивалентна
символу пропуска (например,  символу пробела).  Это  наиболее
полезно для многострочных комментариев и изъятия частей прог-
раммы при редактировании, однако следует помнить, что коммен-
тарии /* */ не могут быть вложенными.

     Символы // начинают комментарий, который заканчивается в
конце строки, на которой они появились. Опять, вся последова-
тельность символов эквивалентна пропуску.  Этот способ наибо-
лее полезен для коротких комментариев.  Символы // можно  ис-
пользовать для   того,  чтобы закомментировать символы /* или
*/, а символами /* можно закомментировать //.

                     1.3 Типы и Описания

     Каждое имя и каждое выражение имеет  тип,   определяющий
операции, которые    могут над ними производиться.  Например,
описание

   int inch;

     определяет, что inch имеет тип int,  то есть, inch явля-
ется целой переменной.

     Описание - это оператор, который вводит имя в программе.
Описание задает тип этого имени.  Тип  определяет  правильное
использование имени или выражения. Для целых определены такие
операции, как  +,  -,  * и /.  После того,  как включен  файл


                                    - 15 -
stream.h, объект   типа int может также быть вторым операндом
<<, когда первый операнд ostream.
     Тип объекта определяет не только то,  какие операции мо-
гут к нему применяться,  но и смысл этих операций.  Например,
оператор

   cout << inch << " in = " << inch*2.54 << " cm\n";

     правильно обрабатывает четыре входных значения различным
образом. Строки  печатаются буквально, тогда как целое inch и
значение с плавающей точкой  inch*2.54  преобразуются  из  их
внутреннего представления в подходящее для человеческого гла-
за символьное представление.

     В С++ есть несколько основных типов и несколько способов
создавать новые. Простейшие виды типов С++ описываются в сле-
дующих разделах, а более интересные оставлены на потом.

                     1.3.1 Основные Типы

     Основные типы,   наиболее   непосредственно   отвечающие
средствам аппаратного обеспечения, такие:

   char short int long float double

     Первые четыре типа используются для представления целых,
последние два - для представления чисел с  плавающей  точкой.
Переменная типа char имеет размер,  естественный для хранения
символа на данной машине (обычно,  байт),  а переменная  типа
int имеет размер,  соответствующий целой арифметике на данной
машине (обычно,  слово).  Диапазон целых чисел, которые могут
быть представлены типом, зависит от его размера (sizeof). В С
++ размеры измеряются в единицах размера  данных  типа  char,
поэтому char по определению имеет размер единица. Соотношение
между основными типами можно записать так:

1=sizeof(char)<=sizeof(short) <= sizeof(int) <= sizeof(long)
   sizeof(float) <= sizeof(double)

     В целом, предполагать что-либо еще относительно основных
типов неразумно.  В частности,  то,  что целое достаточно для
хранения указателя, верно не для всех машин.

     К основному  типу  можно применять прилагательное const.
Это дает тип,  имеющий те же свойства, что и исходный тип, за
исключением того, что значение переменных типа const не может
изменяться после инициализации.

   const float pi = 3.14;
   const char plus = '+';

     Символ, заключенный  в одинарные кавычки,  является сим-
вольной константой. Заметьте, что часто константа, определен-
ная таким образом, не занимает память. Просто там, где требу-
ется, ее    значение  может  использоваться  непосредственно.
Константа должна  инициализироваться при описании.  Для пере-
менных инициализация необязательна,  но настоятельно рекомен-
дуется. Оснований    для введения локальной переменной без ее
инициализации очень немного.

     К любой комбинации этих типов могут применяться  арифме-
тические операции:

   + (плюс, унарный и бинарный)
   - (минус, унарный и бинарный)
   * (умножение)
   / (деление)


                                    - 16 -


     А также операции сравнения:
   == (равно)
   != (не равно)
   < (меньше)
   > (больше)
   <= (меньше или равно)
   >= (больше или равно)

     Заметьте, что  целое  деление дает целый результат:  7/2
есть 3. Над целыми может выполняться операция % получения ос-
татка: 7%2 равно 1.

     При присваивании и арифметических операциях С++ выполня-
ет все осмысленные  преобразования  между  основными  типами,
чтобы их можно было сочетать без ограничений:

   double d = 1;
   int i = 1;
   d = d + i;
   i = d + i;

                   1.3.2 Производные Типы

     Вот операции, создающие из основных типов новые типы:

   * указатель на
   *const константный указатель на
   & ссылка на
   [] вектор*
   () функция, возвращающая

 --------------------
     * одномерный массив. Это принятый термин (например, век-
тора прерываний), и мы сочли, что стандартный перевод его как
"массив" затуманит изложение. (прим. перев.)

   Например:

   char* p       // указатель на символ
   char *const q // константный указатель на символ
   char v[10]    // вектор из 10 символов

     Все вектора  в  качестве  нижней  границы  индекса имеют
ноль, поэтому  в v десять элементов: v[0]..v[9]. Функции объ-
ясняются в  #1.5,  ссылки в #1.9.  Переменная указатель может
содержать адрес объекта соответствующего типа:

   char c;
   // ...
   p = &c; // p указывает на c

     Унарное & является операцией взятия адреса.

                  1.4 Выражения и Операторы

     В С++ имеется богатый набор операций,  с помощью которых
в выражениях  образуются новые значения и изменяются значения
переменных. Поток  управления в программе задается с  помощью
операторов, а  описания используются для введения в программе
имен переменных, констант и т.д. Заметьте, что описания явля-
ются операторами,    поэтому  они свободно могут сочетаться с
другими операторами.





                                    - 17 -

                       1.4.1 Выражения
     В С++ имеется большое число операций, и они будут объяс-
няться там, где (и если) это потребуется. Следует учесть, что
операции

  ~ (дополнение)
  & (И)
  ^ (исключающее ИЛИ)
  ! (включающее ИЛИ)
  << (логический сдвиг влево)
  >> (логический сдвиг вправо)

применяются к целым, и что нет отдельного типа данных для
логических действий.

     Смысл операции зависит от числа операндов. Унарное & яв-
ляется операцией  взятия адреса,  а бинарное & - это операция
логического И.  Смысл операции зависит также от типа ее  опе-
рандов: +  в выражении a+b означает сложение с плавающей точ-
кой, если  операнды имеют тип float,  но целое сложение, если
они типа int. В #1.8 объясняется, как можно определить опера-
цию для типа, определяемого пользователем, без потери ее зна-
чения, предопределенного для основных и производных типов.

     В С++ есть операция присваивания =,  а не оператор прис-
ваивания, как в некоторых языках. Таким образом, присваивание
может встречаться в неожиданном контексте, например, x=sqrt(a
=3*x). Это бывает полезно. a=b=c означает присвоение c объек-
ту b, а затем объекту a. Другим свойством операции присваива-
ния является то, что она может совмещаться с большинством би-
нарных операций.          Например,     x[i+3]*=4    означает
x[i+3]=x[i+3]*4, за исключением того факта, что выражение x[i
+3] вычисляется   только  один раз.  Это дает привлекательную
степень эффективности без необходимости обращения к оптимизи-
рующим компиляторам. К тому же это более кратко.

  В большинстве программ на С++ широко применяются указатели.
Унарная операция * разыменовывает* указатель, т.е. *p есть
объект, на который указывает p. Эта операция также называется
косвенной адресацией. Например, если имеется char* p, то *p
есть символ, на который указывает p. Часто при работе с ука-
зателями бывают полезны операция увеличения ++ и операция
уменьшения --. Предположим, p указывает на элемент вектора v,
тогда p++ делает p указывающим на следующий элемент.

--------------------
     * англ.  dereference - получить значение объекта, на ко-
торый указывает данный указатель. (прим. перев.)

                  1.4.2 Операторы Выражения

     Самый обычный вид оператора - выражение;.  Он состоит из
выражения, за которым следует точка с запятой. Например:

  a = b*3+c;
  cout << "go go go";
  lseek(fd,0,2);

                    1.4.3 Пустой оператор

     Простейшей формой оператора является оператор:

  ;

     Он не делает ничего.  Однако он может быть полезен в тех
случаях, когда  синтаксис требует наличие оператора,   а  вам


                                    - 18 -
оператор не нужен.
                         1.4.4 Блоки
     Блок - это возможно пустой список операторов,  заключен-
ный в фигурные скобки:

  (* a=b+2; b++; *)

     Блок позволяет рассматривать  несколько  операторов  как
один. Область  видимости имени, описанного в блоке, простира-
ется до конца блока.  Имя можно сделать невидимым  с  помощью
описаний такого же имени во внутренних блоках.

                      1.4.5 Оператор if

     Программа в  следующем примере осуществляет преобразова-
ние дюймов в сантиметры и сантиметров в дюймы.  Предполагает-
ся, что  вы укажете единицы измерения вводимых данных, добав-
ляя i для дюймов и c для сантиметров:

  #include <stream.h>

  main()
  (*
      const float fac = 2.54;
      float x, in, cm;
      char ch = 0;

      cout << "введите длину: ";
      cin >> x >> ch;

      if (ch == 'i') (*     // inch - дюймы
          in = x;
          cm = x*fac;
      *)
      else if (ch == 'c')  // cm - сантиметры
          in = x/fac;
          cm = x;
      *)
      else
          in = cm = 0;

      cout << in << " in = " << cm << " cm\n";
  *)

     Заметьте, что   условие   в  операторе  if  должно  быть
заключено в круглые скобки.

                   1.4.6 Операторы switch

     Оператор switch производит сопоставление значения с мно-
жеством констант.  Проверки в предыдущем примере можно  запи-
сать так:

  switch (ch) (*
  case 'i':
      in = x;
      cm = x*fac;
      break;
  case 'c':
      in = x/fac;
      cm = x;
      break;
  default:
      in = cm = 0;
      break;
  *)
     Операторы break  применяются  для  выхода  из  оператора


                                    - 19 -
switch. Константы  в вариантах case должны быть различными, и
если проверяемое   значение  не совпадает ни с одной из конс-
тант, выбирается вариант default. Программисту не обязательно
предусматривать default.

                    1.4.7 Оператор while

     Рассмотрим копирование строки,  когда заданы указатель p
на ее первый символ и указатель q на целевую строку.  По сог-
лашению строка оканчивается символом с целым значением 0.

  while (p != 0) (*
      *q = *p; // скопировать символ
      q = q+1;
      p = p+1;
  *)
  *q = 0;      // завершающий символ 0 скопирован не был

     Следующее после while условие должно  быть  заключено  в
круглые скобки.  Условие вычисляется,  и если его значение не
ноль, выполняется  непосредственно следующий за ним оператор.
Это повторяется  до тех пор,  пока вычисление условия не даст
ноль.

     Этот пример слишком пространен.  Можно использовать опе-
рацию ++ для непосредственного указания увеличения, и провер-
ка упростится:

  while (*p) *q++ = *p++;
  *q = 0;

     где конструкция *p++ означает: "взять символ, на который
указывает p, затем увеличить p."

     Пример можно еще упростить,  так как указатель p разыме-
новывается дважды  за каждый цикл.  Копирование символа можно
делать тогда же, когда производится проверка условия:

  while (*q++ = *p++) ;

     Здесь берется символ, на который указывает p, p увеличи-
вается, этот  символ копируется туда,  куда указывает q,  и q
увеличивается. Если  символ ненулевой, цикл повторяется. Пос-
кольку вся работа выполняется в условии,  не требуется ни од-
ного оператора.  Чтобы указать на это,   используется  пустой
оператор. С++    (как и C)  одновременно любят и ненавидят за
возможность такого чрезвычайно краткого  ориентированного  на
выразительность программирования*.

--------------------
* в оригинале expression-oriented (expression - выразитель-
ность и выражение). (прим. перев.)

                     1.4.8 Оператор for

     Рассмотрим копирование десяти элементов одного вектора в
другой:

  for (int i=0; i<10; i++) q[i]=p[i];










                                    - 20 -

  Это эквивалентно
  int i = 0;
  while (i<10) (*
      q[i] = p[i];
      i++;
  *)
     но более удобочитаемо,  поскольку вся информация, управ-
ляющая циклом, локализована. При применении операции ++ к це-
лой переменной к ней просто добавляется единица. Первая часть
оператора for не обязательно должна быть описанием, она может
быть любым оператором. Например:

  for (i=0; i<10; i++) q[i]=p[i];

тоже эквивалентно предыдущей записи при условии, что i
соответствующим образом описано раньше.

                       1.4.9 Описания

     Описание - это оператор,  вводящий имя в программе.  Оно
может также инициализировать объект с этим именем. Выполнение
описания означает, что когда поток управления доходит до опи-
сания, вычисляется инициализирующее выражение (инициализатор)
и производится инициализация. Например:

  for (int i = 1; i<MAX; i++) (*
      int t = v[i-1];
      v[i-1] = v[i];
      v[i] = t;
  *)

     При каждом  выполнении оператора for i будет инициализи-
роваться один раз, а t MAX-1 раз.

                         1.5 Функции

     Функция - это именованная часть  программы,   к  которой
можно обращаться   из  других  частей  программы столько раз,
сколько потребуется. Рассмотрим программу, печатающую степени
числа 2:

  extern float pow(float, int);  //pow() определена в другом
                                   месте

  main()
  (*
      for (int i=0; i<10; i++) cout << pow(2,i) << "\n";
  *)

     Первая строка  функции - ее описание,  указывающее,  что
pow - функция,  получающая параметры типа float и int и возв-
ращающая float. Описание функции используется для того, чтобы
сделать определенными обращения к функции в других местах.

     При вызове функции тип каждого параметра  сопоставляется
с ожидаемым  типом точно так же,  как если бы инициализирова-
лась переменная описанного типа.  Это гарантирует  надлежащую
проверку и     преобразование  типов.   Например,   обращение
pow(12.3,"abcd") вызовет  недовольство компилятора, поскольку
"abcd" является строкой, а не int. При вызове pow(2,i) компи-
лятор преобразует 2 к типу float,  как того требует  функция.
Функция pow может быть определена например так:



                                    - 21 -


  float pow(float x, int n)
  (*
      if (n < 0) error("sorry, negative exponent to pow()");
              // извините, отрицательный показатель для pow()
      switch (n) (*
      case 0: return 1;
      case 1: return x;
      default: return x*pow(x,n-1);
      *)
  *)
     Первая часть определения функции задает имя функции, тип
возвращаемого ею   значения  (если таковое имеется)  и типы и
имена ее параметров (если они есть). Значение возвращается из
функции с помощью оператора return.

     Разные функции,  обычно имеют разные имена, но функциям,
выполняющим сходные действия над объектами  различных  типов,
иногда лучше   дать возможность иметь одинаковые имена.  Если
типы их параметров различны,  то компилятор всегда может раз-
личить их и выбрать для вызова нужную функцию.  Может, напри-
мер, иметься  одна функция возведения в степень для целых пе-
ременных и другая для переменных с плавающей точкой:

  overload pow;
  int pow(int, int);
  double pow(double, double);
  //...
  x=pow(2,10);
  y=pow(2.0,10.0);

  Описание

  overload pow;

     сообщает компилятору,  что использование имени pow более
чем для одной функции является умышленным.

     Если функция не возвращает значения,  то ее следует опи-
сать как void:

  void swap(int* p, int* q) // поменять местами
  (*
      int t = *p;
      *p = *q;
      *q = t;
  *)

                   1.6 Структура программы

     Программа на С++ обычно состоит из большого числа исход-
ных файлов,  каждый из которых содержит описания типов, функ-
ций, переменных и констант. Чтобы имя можно было использовать
в разных исходных файлах для ссылки на один и тот же  объект,
оно должно быть описано как внешнее. Например:

  extern double sqrt(double);
  extern instream cin;

     Самый обычный способ обеспечить согласованность исходных
файлов - это поместить такие описания в отдельные файлы,  на-
зываемые заголовочными (или хэдер) файлами, а затем включить,
то есть скопировать, эти заголовочные файлы во все файлы, где
нужны эти описания.  Например,  если описание sqrt хранится в
заголовочном файле   для  стандартных  математических функций
math.h, и вы хотите извлечь квадратный корень из 4, можно на-


                                    - 22 -
писать:

  #include <math.h>
  //...
  x = sqrt(4);

     Поскольку обычные  заголовочные файлы включаются во мно-
гие исходные файлы,  они не содержат  описаний,   которые  не
должны повторяться.  Например, тела функций даются только для
inline-подставляемых функций (#1.12)  и инициализаторы даются
только для   констант (#1.3.1).  За исключением этих случаев,
заголовочный файл является хранилищем информации о типах.  Он
обеспечивает интерфейс  между отдельно компилируемыми частями
программы.

     В команде включения include имя файла, заключенное в уг-
ловые скобки,    например <math.h>,  относится к файлу с этим
именем в стандартном каталоге (часто это /usr/include/CC), на
файлы, находящиеся в каких-либо других местах ссылаются с по-
мощью имен, заключенных в двойные кавычки. Например:

  #include "math1.h"
  #include "/usr/bs/math2.h"

     включит math1.h  из текущего пользовательского каталога,
а math2.h из каталога /usr/bs.

     Здесь приводится  очень  маленький  законченный   пример
программы, в  котором строка определяется в одном файле, а ее
печать производится в другом.  Файл header.h определяет необ-
ходимые типы:

  // header.h

  extern char* prog_name;
  extern void f();

  В файле main.c находится главная программа:

  // main.c

  #include "header.h"
  char* prog_name = "дурацкий, но полный";
  main()
  (*
      f();
  *)

а файл f.c печатает строку:

  // f.c

  #include <stream.h>
  #include "header.h"
  void f()
  (*
      cout << prog_name << "\n";
  *)

     Скомпилировать и запустить программу вы можете  например
так:

  $ CC main.c f.c -o silly
  $ silly
  дурацкий, но полный
  $



                                    - 23 -


                         1.7 Классы

     Давайте посмотрим, как мы могли бы определить тип потока
вывода ostream.  Чтобы упростить задачу, предположим, что для
буферизации определен тип streambuf.  Тип streambuf на  самом
деле определен в <stream.h>,  где также находится и настоящее
определение ostream.

     Пожалуйста, не испытывайте примеры, определяющие ostream
в этом  и последующих разделах.  Пока вы не сможете полностью
избежать использования <stream.h>, компилятор будет возражать
против переопределений.

     Определение типа, определяемого пользователем (который в
С++ называется class,  т.е. класс), специфицирует данные, не-
обходимые для  представления объекта этого типа,  и множество
операций для работы с этими объектами.  Определение имеет две
части: закрытую (private) часть, содержащую информацию, кото-
рой может пользоваться только его  разработчик,   и  открытую
(public) часть,   представляющую интерфейс типа с пользовате-
лем:

  class ostream (*
      streambuf* buf;
      int state;
  public:
      void put(char*);
      void put(long);
      void put(double);
  *)

     Описания после метки public: задают интерфейс: пользова-
тель может обращаться только к трем функциям put().  Описания
перед меткой   public  задают  представление  объекта  класса
ostream. Имена  buf и state могут использоваться только функ-
циями put(), описанными в открытой части.

     class определяет тип,  а не объект данных, поэтому чтобы
использовать ostream,  мы должны один  такой  объект  описать
(так же, как мы описываем переменные типа int):

  ostream my_out;

     Считая, что my_out был соответствующим образом проиници-
ализирован (как, объясняется в #1.10), его можно использовать
например так:

  my_out.put("Hello, world\n");

     С помощью операции точка выбирается член класса для дан-
ного объекта этого класса. Здесь для объекта my_out вызывает-
ся член функция put().

  Функция может определяться так:

  void ostream::put(char* p)
  (*
      while (*p) buf.sputc(*p++);
  *)

     где sputc()   -  функция,   которая  помещает  символ  в
streambuf. Префикс   ostream необходим,  чтобы отличить put()
ostream'а от других функций с именем put().

     Для обращения к функции члену должен быть указан  объект


                                    - 24 -
класса. В  функции члене можно ссылаться на этот объект неяв-
но, как  это делалось выше в ostream::put():  в каждом вызове
buf относится к члену buf объекта,  для которого функция выз-
вана.
     Можно также ссылаться на этот  объект  явно  посредством
указателя с именем this. В функции члене класса X this неявно
описан как X* (указатель на X)  и инициализирован  указателем
на тот объект,  для которого эта функция вызвана. Определение
ostream::put() можно также записать в виде:

  void ostream::put(char* p)
  (*
      while (*p) this->buf.sputc(*p++);
  *)
     Операция -> применяется для выбора члена объекта, задан-
ного указателем.

                   1.8 Перегрузка операций

     Настоящий класс ostream определяет операцию  <<,   чтобы
сделать удобным   вывод нескольких объектов одним оператором.
Давайте посмотрим, как это сделано.

     Чтобы определить @,  где @ -  некоторая  операция  языка
С++, для  каждого определяемого пользователем типа вы опреде-
ляете функцию с именем operator@,  которая получает параметры
соответствующего типа. Например:

  class ostream (*
      //...
      ostream operator<<(char*);
  *);

  ostream ostream::operator<<(char* p)
  (*
      while (*p) buf.sputc(*p++);
      return *this;
  *)

     определяет операцию << как член класса ostream,  поэтому
s<<p интерпретируется  как s.operator<<(p),  когда s является
ostream и p - указатель на символ.  Операция <<  бинарна,   а
функция operator<<(char*)  на первый взгляд имеет только один
параметр. Однако, помимо этого она имеет свой стандартный па-
раметр this.

     То, что  в  качестве возвращаемого значения возвращается
ostream, позволяет применять << к результату операции вывода.
Например, s<<p<<q                 интерпретируется        как
(s.operator<<(p)).operator<<(q). Так задаются операции вывода
для встроенных типов.

     С помощью множества операций, заданных как открытые чле-
ны класса ostream,  вы можете теперь определить << для такого
определяемого типа,  как complex,  не изменяя описание класса
ostream:

  ostream operator<<(ostream s, complex z)
  // у complex две части: действительная real и мнимая imag
  // печатает complex как (real,imag)
  (*
      return s << "(" << z.real << "," << z.imag << ")';
  *)

     Поскольку operator<<(ostream,complex)  не является функ-
цией членом,  для бинарности необходимо два явных  параметра.
Вывод значений будет производиться в правильном порядке,  по-


                                    - 25 -
тому что <<, как и большинство операций С++, группирует слева
направо, то  есть f<<b<<c означает (a<<b)<<c. При интерпрета-
ции операций компилятору  известна  разница  между  функциями
членами и функциями не членами.  Например, если z - комплекс-
ная переменная,  то s<<z будет расширяться с  помощью  вызова
стандартной функции (не члена) operator<<(s,z).

                         1.9 Ссылки

     К сожалению, последняя версия ostream содержит серьезную
ошибку и к тому же очень неэффективна.  Сложность  состоит  в
том, что   ostream копируется дважды при каждом использовании
<<: один  раз как параметр и один раз как возвращаемое значе-
ние. Это   оставляет state неизмененным после каждого вызова.
Необходима возможность передачи указателя на  ostream  вместо
передачи самого ostream.

     Это можно сделать с помощью ссылок. Ссылка действует как
имя для объекта.  T& означает ссылку на T. Ссылка должна быть
инициализирована, и  она становится другим именем того объек-
та, которым она инициализирована. Например:

  ostream& s1 = my_out;
  ostream& s2 = cout;

     Теперь можно  использовать ссылку s1 и my_out одинаково,
и они будут иметь одинаковые значения. Например, присваивание

  s1 = s2;

     копирует объект,  на  который  ссылается  s2  (то  есть,
cout), в  объект,  на который ссылается s1 (то есть, my_out).
Члены берутся с помощью операции точка

  s1.put("не надо использовать ->");

     а если применить операцию взятия адреса,  то вы получите
адрес объекта, на который ссылается ссылка:

  &s1 == &my_out

     Первая очевидная  польза от ссылок состоит в том,  чтобы
обеспечить передачу адреса объекта,  а не самого объекта,   в
функцию вывода   (в  некоторых языках это называется вызов по
ссылке):

  ostream& operator<<(ostream& s, complex z) (*
      return s << "(" << z.real << "," << z.imag << ")";
  *)

     Достаточно интересно,  что тело функции осталось без из-
менений, но   если вы будете осуществлять присваивание s,  то
будете воздействовать на сам объект,  а не на его  копию.   В
данном случае то, что возвращается ссылка, также повышает эф-
фективность, поскольку  очевидный способ реализации ссылки  -
это указатель,  а передача указателя гораздо дешевле, чем пе-
редача большой структуры данных.

     Ссылки также существенны для определения  потока  ввода,
поскольку операция   ввода получает в качестве операнда пере-
менную для считывания.  Если бы ссылки не использовались,  то
пользователь должен  был бы явно передавать указатели в функ-
ции ввода.






                                    - 26 -


  class istream (*
      //...
      int state;
  public:
      istream& operator>>(char&);
      istream& operator>>(char*);
      istream& operator>>(int&);
      istream& operator>>(long&);
      //...
  *);

     Заметьте, что  для чтения long и int используются разные
функции, тогда как для их печати требовалась только одна. Это
вполне обычно, и причина в том, что int может быть преобразо-
вано в long по стандартным правилам  неявного  преобразования
(#с.6.6), избавляя таким образом программиста от беспокойства
по поводу написания обеих функций ввода.

                      1.10 Конструкторы

     Определение ostream как класса сделало члены данные зак-
рытыми. Только   функция член имеет доступ к закрытым членам,
поэтому надо предусмотреть функцию для инициализации.   Такая
функция называется конструктором и отличается тем,  что имеет
то же имя, что и ее класс:

  class ostream (*
      //...
      ostream(streambuf*);
      ostream(int size, char* s);
  *);

     Здесь задано два конструктора.  Один получает вышеупомя-
нутый streambuf для реального вывода,  другой получает размер
и указатель на символ для форматирования строки.  В  описании
необходимый для конструктора список параметров присоединяется
к имени. Теперь вы можете, например, описать такие потоки:

  ostream my_out(&some_stream_buffer);
  char xx[256];
  ostream xx_stream(256,xx);

     Описание my_out не только задает  соответствующий  объем
памяти где-то в другом месте,  оно также вызывает конструктор
ostream::ostream(streambuf*), чтобы  инициализировать его па-
раметром &some_stream_buffer,  предположительно указателем на
подходящий объект класса streambuf.   Описание  конструкторов
для класса  не только дает способ инициализации объектов,  но
также обеспечивает то,  что все объекты  этого  класса  будут
проинициализированы. Если для класса были описаны конструкто-
ры, то  невозможно описать переменную этого класса так, чтобы
конструктор не был вызван.  Если класс имеет конструктор,  не
получающий параметров, то этот конструктор будет вызываться в
том случае, если в описании нет ни одного параметра.

                        1.11 Вектора

     Встроенное в  С++  понятие вектора было разработано так,
чтобы обеспечить максимальную  эффективность  выполнения  при
минимальном расходе памяти. Оно также (особенно когда исполь-
зуется совместно с указателями) является весьма универсальным
инструментом для построения средств более высокого уровня. Вы
могли бы, конечно, возразить, что размер вектора должен зада-
ваться как константа, что нет проверки выхода за границы век-
тора и т.д.  Ответ на подобные возражения таков:  "Вы  можете


                                    - 27 -
запрограммировать это сами." Давайте посмотрим, действительно
ли оправдан такой ответ.  Другими словами,  проверим средства
абстракции языка С++, попытавшись реализовать эти возможности
для векторных типов,  которые мы создадим сами,  и посмотрим,
какие с этим связаны трудности,  каких это требует затрат,  и
насколько получившиеся векторные типы удобны в обращении.
  class vector (*
      int* v;
      int sz;
  public:
          vector(int); // конструктор
          ~vector(); // деструктор
      int size() (* return sz; *)
      void set_size(int);
      int& operator[](int);
      int& elem(int i) (* return v[i]; *)
  *);
     Функция size возвращает число элементов вектора,   таким
образом индексы   должны  лежать в диапазоне 0 ...  size()-1.
Функция set_size сделана для изменения этого  размера,   elem
обеспечивает доступ   к  элементам  без  проверки индекса,  а
operator[] дает доступ с проверкой границ.

     Идея состоит в том,  чтобы класс сам был структурой фик-
сированного размера, управляющей доступом к фактической памя-
ти вектора,  которая выделяется конструктором вектора  с  по-
мощью распределителя свободной памяти new:

  vector::vector(int s)
  (*
      if (s<=0) error("bad vector size");
                    // плохой размер вектора
      sz = s;
      v = new int[s];
  *)

     Теперь вы  можете  описывать  вектора  типа vector почти
столь же элегантно, как и вектора, встроенные в сам язык:

  vector v1(100);
  vector v2(nelem*2-4);

  Операцию доступа можно определить как

  int& vector::operator[](int i)
  (*
      if(i<0 !! sz<=i) error("vector index out of range");
                         // индекс выходит за границы вектора
      return v[i];
  *)

     Операция !! (ИЛИИЛИ)  - это логическая операция ИЛИ.  Ее
правый операнд вычисляется только тогда,  когда это необходи-
мо, то  есть если вычисление левого операнда дало ноль. Возв-
ращение ссылки обеспечивает то, что запись [] может использо-
ваться с любой стороны операции присваивания:

  v1[x] = v2[y];

     Функция со странным именем ~vector - это деструктор,  то
есть функция,   описанная для того,  чтобы она неявно вызыва-
лась, когда объект класса выходит из области видимости. Дест-
руктор класса C имеет имя ~C. Если его определить как






                                    - 28 -


  vector::~vector()
  (*
      delete v;
  *)

     то он будет,  с помощью  операции  delete,   освобождать
пространство, выделенное  конструктором, поэтому когда vector
выходит из области видимости,  все его пространство возвраща-
ется обратно в память для дальнейшего использования.

                   1.12 Inline-подстановка
     Если часто повторяется обращение к очень маленькой функ-
ции, то  вы можете начать  беспокоиться  о  стоимости  вызова
функции. Обращение    к  функции  члену не дороже обращения к
функции не члену с тем же числом  параметров  (надо  помнить,
что функция член всегда имеет хотя бы один параметр), и вызо-
вы в функций в С++ примерно столь же эффективны,  сколь  и  в
любом языке.    Однако  для  слишком  маленьких функций может
встать вопрос о накладных расходах на обращение.  В этом слу-
чае можно   рассмотреть  возможность спецификации функции как
inline-подставляемой. Если  вы поступите таким  образом,   то
компилятор сгенерирует для функции соответствующий код в мес-
те ее вызова. Семантика вызова не изменяется. Если, например,
size и elem inline-подставляемые, то

  vector s(100);
  //...
  i = s.size();
  x = elem(i-1);

порождает код, эквивалентный

  //...
  i = 100;
  x = s.v[i-1];

     С++ компилятор обычно достаточно разумен,  чтобы генери-
ровать настолько хороший код,  насколько вы можете получить в
результате прямого макрорасширения.  Разумеется,   компилятор
иногда вынужден   использовать  временные переменные и другие
уловки, чтобы сохранить семантику.

     Вы можете указать,  что вы хотите,  чтобы  функция  была
inline-подставляемой, поставив   ключевое слово inline,  или,
для функции члена,  просто включив определение функции в опи-
сание класса, как это сделано в предыдущем примере для size()
и elem().

     При хорошем использовании inline-функции резко  повышают
скорость выполнения и уменьшают размер объектного кода. Одна-
ко, inlineфункции  запутывают описания и могут замедлить ком-
пиляцию, поэтому,   если они не необходимы,  то их желательно
избегать. Чтобы  inlineфункция давала существенный выигрыш по
сравнению с  обычной функцией,  она должна быть очень малень-
кой.

                   1.13 Производные классы

     Теперь давайте определим вектор,  для которого пользова-
тель может задавать границы изменения индекса.

  class vec: public vector (*
      int low, high;
  public:
      vec(int,int);


                                    - 29 -
      int& elem(int);
      int& operator[](int);
  *);

Определение vec как
  :public vector

     означает, в  первую  очередь,  что vec - это vector.  То
есть, тип  vec имеет (наследует) все свойства типа vector до-
полнительно к тем,  что описаны специально для него. Говорят,
что vector является базовым классом для vec, а о vec говорит-
ся, что он производный класс от vector.
     Класс vec модифицирует класс vector тем, что в нем зада-
ется другой конструктор, который требует от пользователя ука-
зывать две границы изменения индекса,  а не длину,  и имеются
свои собственные функции доступа elem(int) и operator[](int).
Функция elem() класса vec легко выражается через elem() клас-
са vector:
  int& vec::elem(int i)
  (*
      return vector::elem(i-low);
  *)

     Операция разрешения  области  видимости ::  используется
для того,  чтобы не было  бесконечной  рекурсии  обращения  к
vec::elem() из нее самой. с помощью унарной операции :: можно
ссылаться на нелокальные имена. Было бы разумно описать vec::
elem() как inline, поскольку, скорее всего, эффективность су-
щественна, но  необязательно, неразумно и невозможно написать
ее так,  чтобы она непосредственно использовала закрытый член
v класса vector.  Функции производного класса не имеют специ-
ального доступа к закрытым членам его базового класса.

  Конструктор можно написать так:

  vec::vec(int lb, int hb) : (hb-lb+1)
  (*
      if (hb-lb<0) hb = lb;
      low = lb;
      high = hb;
  *)

     Запись: (hb-lb+1)  используется для  определения  списка
параметров конструктора   базового  класса  vector::vector().
Этот конструктор вызывается перед телом vec::vec().  Вот  не-
большой пример,  который можно запустить, если скомпилировать
его вместе с остальными описаниями vector:

  #include <streams.h>

  void error(char* p)
  (*
      cerr << p << "\n";
          // cerr - выходной поток сообщений об ошибках
      exit(1);
  *)

  void vector::set_size(int) (* /* пустышка */ *)

  int& vec::operator[](int i)
  (*
      if (i<low !! high<i) error("vec index out of range");
                               // индекс vec за границами
      return elem(i);
  *)




                                    - 30 -


  main()
  (*
      vector a(10);
      for (int i=0; i<a.size(); i++) (*
          a[i] = i;
          cout << a[i] << " ";
      *)
      cout << "\n";
      vec b(10,19);
      for (i=0; i<b.size(); i++) b[i+10] = a[i];
      for (i=0; i<b.size(); i++) cout << b[i+10] << " ";
      cout << "\n";
  *)

  Он выдает
  0 1 2 3 4 5 6 7 8 9
  0 1 2 3 4 5 6 7 8 9

     Это направление  развития векторного типа можно разраба-
тывать дальше.  Довольно просто сделать многомерные  массивы,
массивы, в   которых число размерностей задается как параметр
конструктора, массивы  в стиле Фортрана,  к которым можно од-
новременно обращаться и как к имеющим две размерности,  и как
к имеющим три, и т.д.

     Так класс управляет доступом к некоторым  данным.   Пос-
кольку весь доступ осуществляется через интерфейс, обеспечен-
ный открытой частью класса, то можно использовать представле-
ние данных  в соответствие с нуждами разработчика.  Например,
тривиально можно было бы поменять  представление  вектора  на
связанный список. Другая сторона этого состоит в том, что при
заданной реализации можно обеспечить любой удобный интерфейс.

                    1.14 Еще об операциях

     Другое направление развития - снабдить вектора операция-
ми:

  class Vec : public vector (*
  public:
      Vec(int s) : (s) (**)
      Vec(Vec&);
      ~Vec() (**)
      void operator=(Vec&);
      void operator*=(Vec&);
      void operator*=(int);
      //...
  *);

     Обратите внимание  на  способ  определения  конструктора
производного класса, Vec::Vec(), когда он передает свой пара-
метр конструктору базового класса vector::vector()  и  больше
не делает ничего. Это полезная парадигма. Операция присваива-
ния перегружена, ее можно определить так:

  void Vec::operator=(Vec& a)
  (*
      int s = size();
      if (s!=a.size()) error("bad vector size for =");
                           // плохой размер вектора для =
      for (int i = 0; i<s; i++) elem(i) = a.elem(i);
  *)

     Присваивание объектов класса  Vec  теперь  действительно
копирует элементы,    в  то  время  как присваивание объектов


                                    - 31 -
vector просто копирует структуру, управляющую доступом к эле-
ментам. Последнее,   однако, происходит и тогда, когда vector
копируется без явного  использования  операции  присваивания:
(1) когда  vector передается как параметр и (3)  когда vector
передается как значение, возвращаемое функцией. Чтобы обраба-
тывать эти случаи для векторов Vec,  вы определяете конструк-
тор Vec(Vec&):
  Vec::Vec(Vec& a) : (a.size())
  (*
      int sz = a.size();
      for (int i = 0; i<sz; i++) elem(i) = a.elem(i);
  *)
     Этот конструктор инициализирует Vec как копию другого
Vec, и будет вызываться в отмеченных выше случаях.
     Выражение в левой части таких операций,  как = и +=, бе-
зусловно определено, поэтому кажется вполне естественным реа-
лизовать их  как операции над объектом,  который обозначается
(денотируется) этим выражением. В частности, тогда они смогут
изменять значение своего первого операнда.  Левый операнд та-
ких операций, как + и - не требует особого внимания. Вы могли
бы, например, передавать оба аргумента по значению и все рав-
но получить правильную реализацию векторного сложения. Однако
вектора могут оказаться большими,  поэтому чтобы избежать не-
нужного копирования операнды операции + передаются в operator
+() по ссылке:

  Vec operator+(Vec& a,Vec &b)
  (*
      int s = a.size();
      if (s != b.size()) error("bad vector size for +");
                             // плохой размер вектора для +
      Vec sum(s);
      for (int i=0; i<s; i++)
          sum.elem(i) = a.elem(i) + b.elem(i);
      return sum;
  *)

     Вот пример небольшой программы, которую можно выполнить,
если скомпилировать ее вместе с ранее приведенными описаниями
vector:

  #include <stream.h>

  void error(char* p) (*
      cerr << p << "\n";
      exit(1);
  *)

  void vector::set_size(int) (* /*...*/ *)

  int& vec::operator[](int i) (* /*...*/ *)

  main()
  (*
      Vec a(10);
      Vec b(10);
      for (int i=0; i<a.size(); i++) a[i] = i;
      b = a;
      Vec c = a+b;
      for (i=0; i<c.size(); i++) cout << c[i] << "\n";
  *)

                    1.15 Друзья (friend)

     Функция operator+()   не воздействует непосредственно на
представление вектора.  Действительно, она не может этого де-
лать, поскольку  не является членом. Однако иногда желательно


                                    - 32 -
дать функциям не членам возможность доступа к закрытой  части
класса. Например,   если бы не было функции "доступа без про-
верки" vector::elem(),  вам пришлось бы проверять индекс i на
соответствие границам три раза за каждый проход цикла.  Здесь
мы избежали этой сложности,  но она довольно типична, поэтому
у класса   есть механизм предоставления права доступа к своей
закрытой части функциям не членам.  Просто в класс помещается
описание функции,  перед которым стоит ключевое слово friend.
Например, если имеется

  class Vec; // Vec - имя класса
  class vector (*
      friend Vec operator+(Vec, Vec);
      //...
  *);

То вы можете написать
  Vec operator+(Vec a, Vec b)
  (*
      int s = a.size();
      if (s != b.size()) error("bad vector size for +");
                             // плохой размер вектора для +
      Vec& sum = *new Vec(s);
      int* sp = sum.v;
      int* ap = a.v;
      int* bp = b.v;
      while (s--) *sp++ = *ap++ + *bp++;
      return sum;
  *)

     Одним из особенно полезных аспектов механизма friend яв-
ляется то,   что функция может быть другом двух и более клас-
сов. Чтобы  увидеть это,   рассмотрим  определение  vector  и
matrix, а затем определение функции умножения (см. #с.8.8).

                   1.16 Обобщенные Вектора

     "Пока все  хорошо,"  - можете сказать вы,  - "но я хочу,
чтобы один из этих векторов был типа matrix, который я только
что определил." К сожалению,  в С++ не предусмотрены средства
для определения класса векторов с типом элемента  в  качестве
параметра. Один из способов - продублировать описание и клас-
са, и  его функций членов. Это не идеальный способ, но зачас-
тую вполне приемлемый.

     Вы можете  воспользоваться препроцессором (#4.7),  чтобы
механизировать работу.  Например,  класс vector -  упрощенный
вариант класса,  который можно найти в стандартном заголовоч-
ном файле. Вы могли бы написать:

  #include <vector.h>

  declare(vector,int);

  main()
  (*
      vector(int) vv(10);
      vv[2] = 3;
      vv[10] = 4; // ошибка: выход за границы
  *)

     Файл vector.h  таким  образом определяет макросы,  чтобы
макрос declare(vector,int)  после  расширения  превращался  в
описание класса vector, очень похожий на тот, который был оп-
ределен выше, а макрос implement(vector,int) расширялся в оп-
ределение функций       этого   класса.    Поскольку   макрос
implement(vector,int) в  результате расширения превращается в


                                    - 33 -
определение функций, его можно использовать в программе толь-
ко один раз,  в то время как declare(vector,int)  должно  ис-
пользоваться по одному разу в каждом файле, работающем с этим
типом целых векторов.

  declare(vector,char);
  //...
  implement(vector,char);

даст вам отдельный тип "вектор символов". Пример реализации
обобщенных классов с помощью макросов приведен в #7.3.5.
                  1.17 Полиморфные Вектора

     У вас есть другая возможность - определить ваш векторный
и другие вмещающие классы через указатели на объекты  некото-
рого класса:
  class common (*
      //...
  *);
  class vector (*
      common** v;
      //...
  public:
      cvector(int);
      common*& elem(int);
      common*& operator[](int);
      //...
  *);

     Заметьте, что поскольку в таких векторах хранятся указа-
тели, а не сами объекты, объект может быть "в" нескольких та-
ких векторах   одновременно.   Это  очень  полезное  свойство
подобных вмещающих  классов,  таких,  как вектора,  связанные
списки, множества и т.д. Кроме того, можно присваивать указа-
тель на производный класс указателю на его базовый класс, по-
этому можно использовать приведенный выше cvector для  хране-
ния указателей на объекты всех производных от common классов.
Например:

  class apple : public common (* /*...*/ *)
  class orange : public common (* /*...*/ *)
  class apple_vector : public cvector (*
  public:

  cvector fruitbowl(100);
  //...
  apple aa;
  orange oo;
  //...
  fruitbowl[0] = &aa;
  fruitbowl[1] = &oo;
  *)

     Однако, точный тип объекта,  вошедшего в такой вмещающий
класс, больше компилятору не известен. Например, в предыдущем
примере вы знаете,  что элемент вектора является common,   но
является он apple или orange?  Обычно точный тип должен впос-
ледствии быть восстановлен,  чтобы обеспечить правильное  ис-
пользование объекта.    Для  этого нужно или в какой-то форме
хранить информацию о типе в самом объекте,   или  обеспечить,
чтобы во   вмещающий  класс помещались только объекты данного
типа. Последнее  легко  достигается  с  помощью  производного
класса. Вы   можете,  например,  создать вектор указателей на
apple:





                                    - 34 -


  class apple_vector : public cvector (*
  public:
      apple*& elem(int i)
	  (* return (apple*&) cvector::elem(i); *)
      //...
  *);

     используя запись приведения к типу (тип)выражение, чтобы
преобразовать common*& (ссылку на указатель на common), кото-
рую возвращает   cvector::elem,  в apple*&.  Такое применение
производных классов создает альтернативу обобщенным  классам.
Писать его  немного труднее (если не использовать макросы та-
ким образом, чтобы производные классы фактически реализовыва-
ли обобщенные классы,  см.  #7.3.5),  но оно имеет то преиму-
щество, что   все  производные  классы  совместно  используют
единственную копию функции базового класса. В случае обобщен-
ных классов,  таких, как vector(type), для каждого нового ис-
пользуемого типа   должна создаваться (с помощью implement())
новая копия таких функций.  Другой способ, хранение идентифи-
кации типа в каждом объекте,  приводит нас к стилю программи-
рования, который часто называют объекто-основанным или объек-
тно-ориентированным.

                  1.18 Виртуальные Функции

     Предположим, что  мы пишем программу для изображения фи-
гур на экране.  Общие атрибуты  фигуры  представлены  классом
shape, а специальные атрибуты - специальными классами:

  class shape (*
      point center;
      color col;
      //...
  public:
      void move(point to) (* center=to; draw(); *)
      point where() (* return center; *)
      virtual void draw();
      virtual void rotate(int);
      //...
  *);

   Функции, которые можно определить не зная точно определен-
ной фигуры (например, move и where, то есть, "передвинуть"  и
"где"),  можно описать как обычно. Остальные функции описыва-
ются как virtual,  то есть такие, которые должны определяться
в производном классе. Например:

  class circle: public shape (*
      int radius;
  public:
      void draw();
      void rotatte(int i) (**)
      //...
  *);

Теперь, если shape_vec - вектор фигур, то можно написать:

  for (int i = 0; i<no_of_shapes; i++)
      shape_vec[i].rotate(45);

     чтобы повернуть все фигуры на 45 градусов (и заново  на-
рисовать)

     Такой стиль особенно полезен в интерактивных программах,
когда объекты разных типов одинаково обрабатываются  основным


                                    - 35 -
программным обеспечением.  Ведь по сути дела,  типичное дейс-
твие пользователя - это ткнуть в какой-нибудь объект  и  ска-
зать Кто ты?  Что ты такое? и Делай, что надо! не давая ника-
кой информации о типе.  Программа может и должна уяснить  это
для себя сама.

                                    - 36 -

Глава 2

Описания и Константы

             Совершенство достигается только к моменту краха.
                                             - С.Н. Паркинсон

     В этой главе описаны основные типы (char,  int,  float и
т.д.) и основные способы построения из них новых типов (функ-
ций, векторов,   указателей и т.д.). Имя вводится в программе
посредством описания, которое задает его тип и, возможно, на-
чальное значение. Даны понятия описания, определения, области
видимости имен,  времени жизни объектов и типов.  Описываются
способы записи констант в С++,  а также  способы  определения
символических констант.   Примеры просто демонстрируют харак-
терные черты языка.  Более развернутый и реалистичный  пример
приводится в   следующей главе для знакомства с выражениями и
операторами языка С++.  Механизмы задания типов, определяемых
пользователем, с    присоединенными операциями представлены в
Главах 4, 5 и 6 и здесь не упоминаются.

                        2.1 Описания

     Прежде чем имя (идентификатор) может быть использовано в
С++ программе,  он должно быть описано.  Это значит, что надо
задать его тип,  чтобы сообщить компилятору,  к  какого  вида
сущностям относится имя. Вот несколько примеров, иллюстрирую-
щих разнообразие описаний:

  char ch;
  int count = 1;
  char* name = "Bjarne";
  struct complex (* float re, im; *);
  complex cvar;
  extern complex sqrt(complex);
  extern int error_number;
  typedef complex point;
  float real(complex* p) (* return p->re; *);
  const double pi = 3.1415926535897932385;
  struct user;

     Как можно видеть из этих примеров, описание может делать
больше чем   просто  ассоциировать тип с именем.  Большинство
описаний являются также определениями то есть они также опре-
деляют для имени сущность,  к которой оно относится.  Для ch,
count и cvar этой сущностью  является  соответствующий  объем
памяти, который    должен использоваться как переменная - эта
память будет выделена.  Для real это заданная  функция.   Для
constant pi  это значение 3.1415926535897932385.  Для complex
этой сущностью является новый тип. Для point это тип complex,
поэтому point становится синонимом complex. Только описания

  extern complex sqrt(complex);
  extern int error_number;
  struct user;

     не являются  одновременно  определениями.  Это означает,
что объект,  к которому они относятся,  должен быть определен
где-то еще.  Код (тело)  функции sqrt должен задаваться неким
другим описанием, память для переменной error_number типа int
должна выделяться  неким другим описанием,  и какое-то другое
описание типа user должно определять,  что он из себя  предс-
тавляет. В С++ программе всегда должно быть только одно опре-
деление каждого имени,  но описаний может быть много,  и  все
описания должны  согласовываться с типом объекта,  к которому
они относятся, поэтому в этом фрагменте есть две ошибки:



                                    - 37 -
  int count;
  int count;               // ошибка: переопределение
  extern int error_number;
  extern int error_number; // ошибка: несоответствие типов

     а в этом - ни одной (об использовании extern см.  #4.2):

  extern int error_number;
  extern int error_number;

     Некоторые описания задают "значение" для сущностей,  ко-
торые они определяют:

  struct complex (* float re, im; *);
  typedef complex point;
  float real(complex* p) (* return p->re *);
  const double pi = 3.1415926535897932385;

     Для типов,  функций и констант "значение" неизменно. Для
неконстантных типов данных начальное значение может впоследс-
твии изменяться:

  int count = 1;
  char* name = "Bjarne";
  //...
  count = 2;
  name = "Marian";

  Из всех определений только

  char ch;

     не задает значение.  Всякое описание, задающее значение,
является определением.

                   2.1.1 Область Видимости

     Описание вводит  имя в области видимости.  То есть,  имя
может использоваться только в определенной  части  программы.
Для имени, описанного в функции (такое имя часто называют ло-
кальным), эта  область видимости простирается от точки описа-
ния до конца блока,  в котором появилось описание.  Для имени
не в функции и не в классе (называемого часто глобально види-
мым именем)  область видимости простирается от точки описания
до конца файла,  в котором появилось описание. Описание имени
в блоке может скрывать (прятать) описание во внутреннем блоке
или глобальное имя.  Это значит, что можно переопределять имя
внутри блока   для  ссылки на другой объект.  После выхода из
блока имя вновь обретает свое прежнее значение. Например:

  int x;         // глобальное x

  f() (*
      int x;     // локальное x прячет глобальное x
      x = 1;     // присвоить локальному x
      (*
          int x; // прячет первое локальное x
          x = 2; // присвоить второму локальному x
      *)
      x = 3;     // присвоить первому локальному x
  *)

  int* p = &x;   // взять адрес глобального x

     Сокрытие имен неизбежно при написании больших  программ.
Однако читающий   человек  легко  может не заметить,  что имя
скрыто, и  некоторые ошибки,  возникающие  вследствие  этого,


                                    - 38 -
очень трудно обнаружить, главным образом потому, что они ред-
кие. Значит сокрытие имен следует минимизировать. Использова-
ние для глобальных переменных имен вроде i или x напрашивает-
ся на неприятности.

     С помощью   применения   операции   разрешения   области
видимости ::  можно использовать скрытое глобальное имя. Нап-
ример:

  int x;

  f()
  (*
      int x = 1; // скрывает глобальное x
      ::x = 2;   // присваивает глобальному x
  *)

     Но возможности использовать скрытое локальное имя нет.

     Область видимости имени начинается в точке описания. Это
означает, что    имя  можно использовать даже для задания его
собственного значения. Например:

  int x;

  f()
  (*
      int x = x; // извращение
  *)

     Это не  является  недопустимым,  хотя и бессмысленно,  и
компилятор предупредит, что x "used before set" ("использова-
но до   того,  как задано"),  если вы попробуете так сделать.
Можно, напротив,   не применяя операцию ::, использовать одно
имя для ссылки на два различных объекта в блоке. Например:

  int x;

  f()             // извращение
  (*
      int y = x;  // глобальное x
      int x = 22;
      y = x;      // локальное x
  *)

     Переменная y инициализируется значением  глобального  x,
11, а   затем ему присваивается значение локальной переменной
x, 22.

     Имена параметров функции считаются  описанными  в  самом
внешнем блоке функции, поэтому

  f(int x)
  (*
      int x; // ошибка
  *)

     содержит ошибку,  так как x определено дважды в одной  и
той же области видимости.

               2.1.2 Объекты и Адреса (Lvalue)

     Можно назначать  и  использовать переменные,  не имеющие
имен, и  можно осуществлять присваивание выражениям странного
вида (например,  *p[a+10]=7). Следовательно, есть потребность
в имени "нечто в памяти". Вот соответствующая цитата из спра-
вочного руководства   по  С++:   "Объект есть область памяти.


                                    - 39 -
lvalue есть выражение,  ссылающееся на объект" (#с.5).  Слово
"lvalue" первоначально   было  придумано для значения "нечто,
что может стоять в левой части присваивания".  Однако не вся-
кое lvalue можно использовать в левой части присваивания; бы-
вают lvalue, ссылающиеся на константу (см. #2.4).

                      2.1.3 Время Жизни

     Если программист не указал иного,  то объект  создается,
когда встречается его описание, и уничтожается, когда его имя
выходит из области видимости,  Объекты с глобальными  именами
создаются и  инициализируются один раз (только)  и "живут" до
завершения программы.  Объекты, определенные описанием с клю-
чевым словом static, ведут себя так же. Например*:

--------------------
     * Команда #include <stream.h> была выброшена из примеров
в этой  главе для экономии места.  Она необходима в примерах,
производящих вывод, чтобы они были полными. (прим. автора)

  int a = 1;

  void f()
  (*
      int b = 1;         // инициализируется при каждом
                         //  вызове f()
      static int c = 1;  // инициализируется только один раз
      cout << " a = " << a++
           << " b = " << b++
           << " c = " << c++ << "\n";
  *)

  main()
  (*
      while (a < 4) f();
  *)

производит вывод

  a = 1 b = 1 c = 1
  a = 2 b = 1 c = 2
  a = 3 b = 1 c = 3

     Не инициализированная явно статическая (static) перемен-
ная неявно инициализируется нулем.

     С помощью операций new и delete программист может  также
создавать объекты, время жизни которых управляется непосредс-
твенно, см. #3.2.4.

                          2.2 Имена

     Имя (идентификатор) состоит из последовательности букв и
цифр. Первый    символ должен быть буквой.  Символ подчерка _
считается буквой. С++ не налагает ограничений на число симво-
лов в имени,  но некоторые части реализации находятся вне ве-
дения автора компилятора (в частности,  загрузчик),  и они, к
сожалению, такие ограничения налагают. Некоторые среды выпол-
нения также делают необходимым расширить или ограничить набор
символов, допустимых  в идентификаторе. Расширения (например,
при допущении в именах символа  $)   порождают  непереносимые
программы. В  качестве имени не могут использоваться ключевые
слова С++ (см. #с.2.3). Примеры имен:

  hello this_is_a_most_unusially_long_name
  DEFINED foO bAr u_name HorseSense
  var0 var1 CLASS _class ___


                                    - 40 -

     Примеры последовательностей символов,  которые не  могут
использоваться как идентификаторы:

  012 a fool $sys class 3var
  pay.due foo~bar .name if

     Буквы в верхнем и нижнем регистрах считаются различными,
поэтому Count   и count - различные имена,  но вводить имена,
лишь незначительно отличающиеся друг от друга,  нежелательно.
Имена, начинающиеся  с подчерка, по традиции используются для
специальных средств среды выполнения,   поэтому  использовать
такие имена в прикладных программах нежелательно.

     Во время  чтения программы компилятор всегда ищет наибо-
лее длинную строку, составляющую имя, поэтому var10 - это од-
но имя, а не имя var, за которым следует число 10, и elseif -
одно имя, а не ключевое слово else, после которого стоит клю-
чевое слово if.

                          2.3 Типы

     Каждое имя (идентификатор) в С++ программе имеет ассоци-
ированный с ним тип. Этот тип определяет, какие операции мож-
но применять   к  имени  (то  есть к объекту,  на который оно
ссылается), и как эти операции интерпретируются. Например:

  int error number;
  float real(complex* p);

     Поскольку error_number описано как int,  его можно прис-
ваивать, использовать в арифметических выражениях и т.д. Тог-
да как  функция real может вызываться с адресом complex в ка-
честве параметра.  Можно взять адрес любого из них. Некоторые
имена, вроде  int и complex,  являются именами типов.  Обычно
имя типа используется в  описании  для  спецификации  другого
имени. Единственные отличные от этого действия над именем ти-
па - это sizeof (для определения количества памяти,   которая
требуется для   хранения объекта типа)  и new (для размещения
объекта типа в свободной памяти). Например:

  main()
  (*
      int* p = new int;
      cout << "sizeof(int) = " << sizeof(int) "\n";
  *)

     Имя типа можно также  использовать  для  задания  явного
преобразования одного типа в другой, например:

  float f;
  char* p;
  //...
  long ll = long(p); // преобразует p в long
  int i = int(f);    // преобразует f в int

                     2.3.1 Основные Типы

     В С++  есть набор основных типов,  которые соответствуют
наиболее общим основным единицам памяти компьютера и наиболее
общим основным способам их использования:

  char
  short int
  int
  long int



                                    - 41 -
для представления целых различных размеров,

  float
  double

для представления чисел с плавающей точкой,

  unsigned char
  unsigned short int
  unsigned int
  unsigned long int

     для представления беззнаковых целых,  логических  значе-
ний, битовых  массивов и т.п. Для большей компактности записи
можно опускать int в комбинациях из нескольких слов,  что  не
меняет смысла.  Так,  long означает long int,  и unsigned тип
означает тип unsigned int.  В общем,  когда в описании опущен
тип, он предполагается int. Например:

  const a = 1;
  static x;

все определяют объект типа int.

     Целый тип char наиболее удобен для хранения и  обработки
символов на   данном  компьютере,  обычно это 8-битовый байт.
Размеры объектов С++ выражаются в единицах размера char, поэ-
тому по  определению sizeof(char)==1.  В зависимости от аппа-
ратного обеспечения char является  знаковым  или  беззнаковым
целым. Тип  unsigned char, конечно, всегда беззнаковый, и при
его использовании получаются более переносимые программы,  но
из-за применения  его вместо просто char могут возникать зна-
чительные потери в эффективности.

     Причина того,  что предоставляется более чем один  целый
тип, более    чем один беззнаковый тип и более чем один тип с
плавающей точкой,  в том, чтобы дать возможность программисту
воспользоваться характерными  особенностями аппаратного обес-
печения. На  многих машинах между различными  разновидностями
основных типов  существуют значительные различия в потребнос-
тях памяти,  временах доступа к памяти и временах вычислений.
Зная машину  обычно легко,  например,  выбрать подходящий тип
для конкретной переменной. Написать действительно переносимую
программу нижнего уровня сложнее.  Вот все, что гарантируется
относительно размеров основных типов:

   1==sizeof(char)<=sizeof(short)<= sizeof(int)<=sizeof(long)
   sizeof(float)<=sizeof(double)

     Однако обычно  разумно  предполагать,   что в char могут
храниться целые числа в диапазоне 0..127 (в нем всегда  могут
храниться символы машинного набора символов), что short и int
имеют не менее 16 бит,  что int имеет размер, соответствующий
целой арифметике,   и что long имеет по меньшей мере 24 бита.
Предполагать что-либо помимо этого рискованно, и даже эти эм-
пирические правила применимы не везде.  Таблицу характеристик
аппаратного обеспечения для некоторых машин можно найти в #с.
2.6.

     Беззнаковые (unsigned)  целые типы идеально подходят для
применений, в  которых память рассматривается как массив  би-
тов. Использование  unsigned вместо int с тем, чтобы получить
еще один бит для представления положительных целых, почти ни-
когда не оказывается хорошей идеей. Попытки гарантировать то,
что некоторые значения положительны, посредством описания пе-
ременных как unsigned, обычно срываются из-за правил неявного
преобразования. Например:


                                    - 42 -

  unsigned surprise = -1;

допустимо (но компилятор обязательно сделает предупреждение).

              2.3.2 Неявное Преобразование Типа

     Основные типы можно свободно сочетать в присваиваниях  и
выражениях. Везде,   где это возможно, значения преобразуются
так, чтобы информация не терялась. Точные правила можно найти
в #с.6.6.

     Существуют случаи,   в которых информация может теряться
или искажаться.  Присваивание значения одного типа переменной
другого типа,   представление которого содержит меньшее число
бит, неизбежно  является источником неприятностей.  Допустим,
например, что следующая часть программы выполняется на машине
с двоичным дополнительным представлением целых  и  8-битовыми
символами:

  int i1 = 256+255;
  char ch = i1 // ch == 255
  int i2 = ch; // i2 == ?

     В присваивании  ch=i1  теряется  один  бит (самый значи-
мый!), и  ch будет содержать двоичный код "все-единицы" (т.е.
8 единиц); при присваивании i2 это никак не может превратить-
ся в 511! Но каким же может быть значение i2? На DEC VAX, где
char знаковое,  ответ будет -1, на AT&T 3B-20, где char безз-
наковые, ответ будет 255. В С++ нет динамического (т.е. дейс-
твующего во время исполнения) механизма для разрешения такого
рода проблем,  а выяснение на стадии компиляции вообще  очень
сложно, поэтому программист должен быть внимателен.

                   2.3.3 Производные Типы

     Другие типы  можно  выводить из основных типов (и типов,
определенных пользователем) посредством операций описания:

  * указатель
  & ссылка
  [] вектор
  () функция

и механизма определения структур. Например:

  int* a;
  float v[10];
  char* p[20]; // вектор из 20 указателей на символ
  void f(int);
  struct str (* short length; char* p; *);

     Правила построения типов с помощью этих операций подроб-
но объясняются в #с.8.3-4.  Основная идея состоит в том,  что
описание производного типа отражает его использование. Напри-
мер:

  int v[10]; // описывает вектор
  i = v[3];  // использует элемент вектора

  int* p;    // описывает указатель
  i = *p;    // использует указываемый объект

     Вся сложность понимания записи производных типов  проис-
текает из того,  что операции * и & префиксные, а операции []
() постфиксные, поэтому для формулировки типов в тех случаях,
когда приоритеты операций создают затруднения, надо использо-


                                    - 43 -
вать скобки.  Например,  поскольку приоритет у [] выше, чем у
*, то

  int* v[10]; // вектор указателей
  int (*p)[10]; // указатель на вектор

     Большинство людей просто помнят,  как выглядят  наиболее
обычные типы.

     Описание каждого  имени,   вводимого в программе,  может
оказаться утомительным,  особенно если их типы одинаковы.  Но
можно описывать в одном описании несколько имен.  В этом слу-
чае описание содержит вместо одного имени список имен, разде-
ленных запятыми. Например, два имени можно описать так:

  int x, y;        // int x; int y;

     При описании производных типов можно указать, что опера-
ции применяются только к  отдельным  именам  (а  не  ко  всем
остальным именам в этом описании). Например:

  int* p, y;       // int* p; int y; НЕ int* y;
  int x, *p;       // int x; int* p;
  int v[10], *p;   // int v[10]; int* p;

     Мнение автора  таково,   что подобные конструкции делают
программу менее удобочитаемой, и их следует избегать.

                       2.3.4 Тип void

     Тип void (пустой)  синтаксически ведет себя как основной
тип. Однако использовать его можно только как часть производ-
ного типа,  объектов типа void не существует. Он используется
для того,  чтобы указать, что функция не возвращает значения,
или как базовый тип для указателей  на  объекты  неизвестного
типа.

  void f()   // f не возвращает значение
  void* pv;  // указатель на объект неизвестного типа

     Переменной типа указатель на void (void *),  можно прис-
ваивать указатель любого типа. На первый взгляд это может по-
казаться не особенно полезным, поскольку void* нельзя разыме-
новать, но    именно  это  ограничение  и  делает  тип  void*
полезным. Главным образом, он применяется для передачи указа-
телей функциям,  которые не позволяют сделать предположение о
типе объекта, и для возврата из функций нетипизированных объ-
ектов. Чтобы  использовать такой объект, необходимо применить
явное преобразование типа.  Подобные функции обычно находятся
на самом нижнем уровне системы, там, где осуществляется рабо-
та с основными аппаратными ресурсами. Например:

  void* allocate(int size);  // выделить
  void deallocate(void*);    // освободить

  f() (*
      int* pi = (int*)allocate(10*sizeof(int));
      char* pc = (char*)allocate(10);
  //...
  deallocate(pi);
  deallocate(pc);
  *)

                       2.3.5 Указатели

     Для большинства типов T T* является типом арифметический
указатель на T. То есть, в переменной типа T* может храниться


                                    - 44 -
адрес объекта типа T.  Для указателей на вектора и указателей
на функции вам,  к сожалению,   придется  пользоваться  более
сложной записью:

  int* pi;
  char** cpp;             // указатель на указатель на char
  int (*vp)[10];          // указатель на вектор из 10 int'ов
  int (*fp)(char, char*); // указатель на функцию
                          //получающую параметры(char, char*)
                          // и возвращающую int

     Основная операция над указателем  -  разыменование,   то
есть ссылка  на объект,  на который указывает указатель.  Эта
операция также называется косвенным обращением.  Операция ра-
зыменования - это унарное * (префиксное). Например:

  char c1 = 'a';
  char* p = &c1; // в p хранится адрес c1
  char c2 = *p; // c2 = 'a'

     Переменная, на которую указывает p,- это c1, а значение,
которое хранится в c1, это 'a', поэтому присваиваемое c2 зна-
чение *p есть 'a'.

     Над указателями  можно  осуществлять некоторые арифмети-
ческие действия. Вот, например, функция, подсчитывающая число
символов в строке (не считая завершающего 0):

  int strlen(char* p)
  (*
      int i = 0;
      while (*p++) i++;
      return i;
  *)

     Другой способ найти длину состоит в том,  чтобы  сначала
найти конец   строки,  а затем вычесть адрес начала строки из
адреса ее конца:

  int strlen(char* p)
  (*
      char* q = p;
      while (*q++) ;
      return q-p-1;
  *)

     Очень полезными  могут  оказаться  указатели на функции.
Они обсуждаются в #4.6.7.

                        2.3.6 Вектора

     Для типа T T[size] является типом "вектор из  size  эле-
ментов типа T".  Элементы индексируются (нумеруются)  от 0 до
size-1. Например:

  float v[3]; // вектор из трех float: v[0], v[1], v[2]
  int a[2][5]; // два вектора из пяти int
  char* vpc; // вектор из 32 указателей на символ

     Цикл для печати целых  значений  букв  нижнего  регистра
можно было бы написать так:

  extern int strlen(char*);

  char alpha[] = "abcdefghijklmnoprstuvwxyz";

  main()


                                    - 45 -
  (*
      int sz = strlen(alpha);

      for (int i=0; i<sz; i++) (*
          char ch = alpha[i];
          cout << "'" << chr(ch) << "'"
               << " = " << ch
               << " = 0" << oct(ch)
               << " = 0x" << hex(ch) << "\n";
      *)
  *)

     Функция chr() возвращает представление небольшого целого
в виде строки; например,  chr(80) это "P" на машине, на кото-
рой используется набор символов ASCII.  Функция oct()  строит
восьмеричное представление  своего целого аргумента,  а hex()
строит шестнадцатиричное представление своего целого аргумен-
та; chr()    oct()   и  hex()  описаны в <stream.h>.  Функция
strlen() использовалась  для подсчета числа символов в alpha;
вместо этого   можно было использовать значение размера alpha
(#2.4.4). Если  применяется набор символов ASCII,  то  выдача
выглядит так:

  'a' = 97 = 0141 = 0x61
  'b' = 98 = 0142 = 0x62
  'c' = 99 = 0143 = 0x63
  ...

     Заметим, что задавать размер вектора alpha  необязатель-
но. Компилятор    считает число символов в символьной строке,
указанной в качестве инициализатора. Использование строки как
инициализатора для вектора символов - удобное, но к сожалению
и единственное применение строк. Аналогичное этому присваива-
ние строки вектору отсутствует. Например:

  char v[9];
  v = "строка"; // ошибка

ошибочно, поскольку присваивание не определено для векторов.

     Конечно, для инициализации символьных массивов  подходят
не только  строки.  Для остальных типов нужно применять более
сложную запись.  Эту запись можно использовать и для символь-
ных векторов. Например:

  int v1[] = (* 1, 2, 3, 4 *);
  int v2[] = (* 'a', 'b', 'c', 'd' *);

  char v3[] = (* 1, 2, 3, 4 *);
  char v4[] = (* 'a', 'b', 'c', 'd' *);

     Заметьте, что v4 - вектор из четырех (а не пяти)  симво-
лов; он не оканчивается нулем,  как того требуют соглашение и
библиотечные подпрограммы. Обычно применение такой записи ог-
раничивается статическими объектами.

     Многомерные массивы представляются как вектора векторов,
и применение записи через запятую, как это делается в некото-
рых других языках,  дает ошибку при компиляции, так как запя-
тая (,) является операцией следования (см. #3.2.2). Попробуй-
те, например, сделать так:

  int bad[5,2];       // ошибка

и так:

  int v[5][2];


                                    - 46 -
  int bad = v[4,1];   // ошибка
  int good = v[4][1]; // ошибка

  Описание

  char v[2][5];

     описывает вектор из двух элементов,  каждый  из  которых
является вектором типа char[5]. В следующем примере первый из
этих векторов инициализируется первыми пятью буквами,  а вто-
рой - первыми пятью цифрами.

  char v[2][5] = (*
      'a', 'b', 'c', 'd', 'e',
      '0', '1', '2', '3', '4'
  *)

  main() (*
      for (int i = 0; i<2; i++) (*
          for (int j = 0; j<5; j++)
              cout << "v[" << i << "][" << j
                   << "]=" << chr(v[i][j]) << " ";
          cout << "\n";
      *)
  *)

это дает в результате

  v[0][0]=a v[0][1]=b v[0][2]=c v[0][3]=d v[0][4]=e
  v[1][0]=0 v[1][1]=1 v[1][2]=2 v[1][3]=3 v[1][4]=4

                  2.3.7 Указатели и Вектора

     Указатели и вектора в С++ связаны очень тесно.  Имя век-
тора можно  использовать как указатель на его первый элемент,
поэтому пример с алфавитом можно было написать так:

  char alpha[] = "abcdefghijklmnopqrstuvwxyz";
  char* p = alpha;
  char ch;

  while (ch = *p++)
      cout << chr(ch) << " = " << ch
           << " = 0" << oct(ch) << "\n";

  Описание p можно было также записать как

  char* p = &alpha[0];

     Эта эквивалентность широко используется в вызовах  функ-
ций, в  которых векторный параметр всегда передается как ука-
затель на первый элемент вектора. Так, в примере

  extern int strlen(char*);
  char v[] = "Annemarie";
  char* p = v;
  strlen(p);
  strlen(v);

     функции strlen в обоих вызовах передается одно и  то  же
значение. Вся  штука в том, что этого невозможно избежать; то
есть не существует способа описать функцию так,  чтобы вектор
v в вызове функции копировался (#4.6.3). Результат применения
к указателям арифметических операций +,  -, ++ или -- зависит
от типа объекта,  на который они указывают. Когда к указателю
p типа T* применяется арифметическая операция,  предполагает-
ся, что   p указывает на элемент вектора объектов типа T; p+1


                                    - 47 -
означает следующий элемент этого вектора, а p- 1 - предыдущий
элемент. Отсюда  следует, что значение p+1 будет на sizeof(T)
больше значения p. Например, выполнение

  main()
  (*
      char cv[10];
      int iv[10];

      char* pc = cv;
      int* pi = iv;

      cout << "char* " << long(pc+1)-long(pc) << "\n";
      cout << "int* " << long(ic+1)-long(ic) << "\n";
  *)

дает

  char* 1
  int* 4

     поскольку на  моей  машине  каждый  символ занимает один
байт, а  каждое целое занимает четыре байта. Перед вычитанием
значения указателей   преобразовывались к типу long с помощью
явного преобразования типа (#3.2.5).  Они преобразовывались к
long, а  не к "очевидному" int, поскольку есть машины, на ко-
торых указатель      не    влезет    в    int    (то    есть,
sizeof(int)<sizeof(long) ).

     Вычитание указателей определено только тогда,  когда оба
указателя указывают на элементы одного и того же вектора (хо-
тя в языке нет способа удостовериться, что это так). Когда из
одного указателя вычитается другой, результатом является чис-
ло элементов   вектора между этими указателями (целое число).
Можно добавлять целое к указателю или вычитать целое из  ука-
зателя; в  обоих случаях результатом будет значение типа ука-
зателя. Если  это значение не указывает на  элемент  того  же
вектора, на который указывал исходный указатель, то результат
использования этого значения неопределен. Например:

  int v1[10];
  int v2[10];

  int i = &v1[5]-&v1[3]; // 2
      i = &v1[5]-&v2[3]; // результат неопределен

  int* p = v2+2;         // p == &v2[2]
       p = v2-2;         // p неопределено

                       2.3.8 Структуры

     Вектор есть  совокупность элементов одного типа,  struct
является совокупностью элементов (практически)   произвольных
типов. Например:

  struct address (* // почтовый адрес
      char* name; // имя "Jim Dandy"
      long number; // номер дома 61
      char* street; // улица "South Street"
      char* town; // город "New Providence"
      char* state[2]; // штат 'N' 'J'
      int zip; // индекс 7974
  *)

     определяет новый тип,  названный address  (почтовый  ад-
рес), состоящий  из пунктов, требующихся для того, чтобы пос-
лать кому-нибудь корреспонденцию (вообще говоря,  address  не


                                    - 48 -
является достаточным для работы с полным почтовым адресом, но
в качестве примера достаточен).  Обратите внимание на точку с
запятой в  конце; это одно из очень немногих мест в С++,  где
необходимо ставить точку с запятой после фигурной скобки, по-
этому люди склонны забывать об этом.

     Переменные типа  address  могут описываться точно также,
как другие переменные, а доступ к отдельным членам получается
с помощью операции . (точка). Например:

  address jd;
  jd.name = "Jim Dandy";
  jd.number = 61;

     Запись, которая  использовалась для инициализации векто-
ров, можно применять и к переменным структурных типов. Напри-
мер:

  address jd = (*
      "Jim Dandy",
      61, "South Street",
      "New Providence", (*'N','J'*), 7974
  *);

     Однако обычно  лучше  использовать конструктор (#5.2.4).
Заметьте, что  нельзя было бы инициализировать jd.state стро-
кой "NJ".  Строки оканчиваются символом '\0',  поэтому в "NJ"
три символа, то есть на один больше, чем влезет в jd.state.

     К структурным объектам часто обращаются посредством ука-
зателей используя операцию ->. Например:

  void print_addr(address* p)
  (*
      cout << p->name << "\n"
          << p->number << " " << p->street << "\n"
          << p->town << "\n"
          << chr(p->state[0]) << chr(p->state[1])
          << " " << p->zip << "\n";
  *)

     Объекты типа структура можно присваивать, передавать как
параметры функции  и возвращать из функции в качестве резуль-
тата. Например:

  address current;

  address set_current(address next)
  (*
      address prev = current;
      current = next;
      return prev;
  *)

     Остальные осмысленные операции,  такие как сравнение (==
и !=) не определены. Однако пользователь может определить эти
операции, см. Главу 6. Размер объекта структурного типа нель-
зя вычислить просто как сумму его членов.  Причина этого сос-
тоит в том,  что многие машины требуют, чтобы объекты опреде-
ленных типов  выравнивались  в  памяти  только  по  некоторым
зависящим от   архитектуры  границам (типичный пример:  целое
должно быть выравнено по границе слова),  или просто  гораздо
более эффективно обрабатывают такие объекты,  если они вырав-
нены в машине.  Это приводит к "дырам" в структуре. Например,
(на моей машине) sizeof(address) равен 24, а не 22, как можно
было ожидать.



                                    - 49 -
     Заметьте, что имя типа становится доступным сразу  после
того, как  оно встретилось,  а не только после того, как пол-
ностью просмотрено все описание. Например:

  struct link(*
      link* previous;
      link* successor;
  *)

     Новые объекты структурного типа не могут быть описывать-
ся, пока все описание не просмотрено, поэтому

  struct no_good (*
      no_good member;
  *);

     является ошибочным (компилятор не может установить  раз-
мер no_good).    Чтобы  дать  возможность  двум  (или  более)
структурным типам ссылаться друг на друга,  можно просто опи-
сать имя как имя структурного типа. Например:

  struct list; // должна быть определена позднее

  struct link (*
      link* pre;
      link* suc;
      link* member_of;
  *);

  struct list (*
      link* head;
  *)

     Без первого  описания  list  описание  link вызвало бы к
синтаксическую ошибку.

                 2.3.9 Эквивалентность типов

     Два структурных типа являются различными даже когда  они
имеют одни и те же члены. Например:

  struct s1 (* int a; *);
  struct s2 (* int a; *);

есть два разных типа, поэтому

  s1 x;
  s2 y = x; // ошибка: несоответствие типов

     Структурные типы отличны также от основных типов, поэто-
му

  s1 x;
  int i = x; // ошибка: несоответствие типов

     Однако, существует  механизм  для  описания нового имени
для типа без введения  нового  типа.   Описание  с  префиксом
typedef описывает  не новую переменную данного типа,  а новое
имя этого типа. Например:

  typedef char* Pchar;
  Pchar p1, p2;
  char* p3 = p1;

  Это может служить удобной сокращенной записью.

                        2.3.10 Ссылки


                                    - 50 -

     Ссылка является другим именем объекта.  Главное примене-
ние ссылок состоит в спецификации операций для типов, опреде-
ляемых пользователем; они обсуждаются в Главе 6.   Они  могут
также быть  полезны в качестве параметров функции.  Запись x&
означает ссылка на x. Например:

  int i = 1;
  int& r = i; // r и i теперь ссылаются на один int
  int x = r // x = 1
  r = 2; // i = 2;

     Ссылка должна быть инициализирована (должно быть что-то,
для чего она является именем).  Заметьте,  что  инициализация
ссылки есть нечто совершенно отличное от присваивания ей.

     Вопреки ожиданиям,   ни одна операция на ссылку не дейс-
твует. Например:

  int ii = 0;
  int& rr = ii;
  rr++; // ii увеличивается на 1

     допустимо, но rr++ не увеличивает ссылку; вместо этого +
+ применяется к int,  которым оказывается ii.  Следовательно,
после инициализации значение ссылки не может  быть  изменено;
она всегда ссылается на объект,  который ей было дано обозна-
чать (денотировать)  при инициализации. Чтобы получить указа-
тель на объект,  денотируемый ссылкой rr, можно написать &rr.

     Очевидным способом  реализации ссылки является констант-
ный указатель,  который разыменовывается при каждом использо-
вании. Это    делает инициализацию ссылки тривиальной,  когда
инициализатор является lvalue (объектом,  адрес  которого  вы
можете взять,  см. #с.5). Однако инициализатор для &T не обя-
зательно должен быть lvalue,  и даже не должен быть типа T. В
таких случаях:

     [1] Во-первых, если необходимо, применяется преобразова-
ние типа (#с.6.6-8, #с.8.5.6),

     [2] Затем полученное значение  помещается  во  временную
переменную и

     [3] Наконец,   ее адрес используется в качестве значения
инициализатора.

Рассмотрим описание

  double& dr = 1;

Это интерпретируется так:

  double* drp; // ссылка, представленная как указатель
  double temp;
  temp = double(1);
  drp = &temp;

  int x = 1;
  void incr(int& aa) (* aa++; *)
  incr(x) // x = 2

     По определению  семантика передачи параметра та же,  что
семантика инициализации,  поэтому параметр  aa  функции  incr
становится другим именем для x.  Однако,  чтобы сделать прог-
рамму читаемой,  в большинстве случаев лучше  всего  избегать
функций, которые   изменяют значение своих параметров.  Часто

                                    - 51 -
предпочтительно явно возвращать значение из функции или  тре-
бовать в качестве параметра указатель:

  int x = 1;
  int next(int p) (* return p+1; *)
  x = next(x); // x = 2

  void inc(int* p) (* (*p)++; *)
  inc(&x); // x = 3

     Ссылки также можно применять  для  определения  функций,
которые могут   использоваться  и  в левой,  и в правой части
присваивания. Опять, большая часть наиболее интересных случа-
ев этого встречается при разработке нетривиальных типов,  оп-
ределяемых пользователем. Для примера давайте определим прос-
той ассоциативный массив. Вначале мы определим структуру пары
следующим образом:

  struct pair (*
      char* name;
      int val;
  *);

     Основная идея состоит в том, что строка имеет ассоцииро-
ванное с ней целое значение.  Легко определить функцию поиска
find(), которая  поддерживает структуру данных,  состоящую из
одного pair для каждой отличной отличной  от  других  строки,
которая была ей представлена. Для краткости представления ис-
пользуется очень простая (и неэффективная) реализация:

  const large = 1024;
  static pair vec[large+1*);

  pair* find(char* p)
  /*
      поддерживает множество пар "pair":
      ищет p, если находит, возвращает его "pair",
      иначе возвращает неиспользованную "pair"
  */
  (*
      for (int i=0; vec[i].name; i++)
          if (strcmp(p,vec[i].name)==0) return &vec[i];

      if (i == large) return &vec[large-1];

      return &vec[i];
  *)

     Эту функцию может использовать функция value(), реализу-
ющая массив   целых,   индексированный  символьными  строками
(вместо обычного способа):

  int& value(char* p)
  (*
      pair* res = find(p);
      if (res->name == 0) (* // до сих пор не встречалось:
        res->name = new char[strlen(p)+1]; // инициализи-
                                           // ровать
        strcpy(res->name,p);
        res->val = 0; // начальное значение 0
      *)
      return res->val;
  *)

     Для данной в качестве параметра строки value()   находит
целый объект   (а не значение соответствующего целого); после
чего она возвращает ссылку на него.  Ее  можно  использовать,

                                    - 52 -
например, так:

  const MAX = 256; // больше самого большого слова

  main()
  // подсчитывает число вхождений каждого слова во вводе
  (*
      char buf[MAX];

      while (cin>>buf) value(buf)++;

      for (int i=0; vec[i].name; i++)
          cout << vec[i].name << ": " << vec [i].val << "\n";
  *)

     На каждом проходе цикл считывает одно слово из стандарт-
ной строки ввода cin в buf (см.  Главу 8),  а затем обновляет
связанный с ней счетчик с помощью find(). И, наконец, печата-
ется полученная   таблица различных слов во введенном тексте,
каждое с числом его встречаемости. Например, если вводится

  aa bb bb aa aa bb aa aa

то программа выдаст:

  aa: 5
  bb: 3

     Легко усовершенствовать  это  в  плане собственного типа
ассоциированного массива с  помощью  класса  с  перегруженной
операцией (#6.7) выбора [].

                       2.3.11 Регистры

     Во многих  машинных архитектурах можно обращаться к (не-
большим) объектам  заметно быстрее,  когда они помещены в ре-
гистр. В идеальном случае компилятор будет сам определять оп-
тимальную стратегию использования всех регистров,   доступных
на машине,   для которой компилируется программа.  Однако это
нетривиальная задача,  поэтому иногда программисту стоит дать
подсказку компилятору. Это делается с помощью описания объек-
та как register. Например:

  register int i;
  register point cursor;
  register char* p;

     Описание register следует использовать только в тех слу-
чаях, когда  эффективность действительно важна. Описание каж-
дой переменной как register засорит текст программы  и  может
даже увеличить   время  выполнения (обычно воспринимаются все
инструкции по помещению объекта в регистр  или  удалению  его
оттуда).

     Невозможно получить   адрес   имени,    описанного   как
register, регистр не может также быть глобальным.

                        2.4 Константы

     С++ дает возможность  записи  значений  основных  типов:
символьных констант,    целых констант и констант с плавающей
точкой. Кроме  того,  ноль (0) может использоваться как конс-
танта любого указательного типа, и символьные строки являются
константами типа char[].  Можно также задавать  символические
константы. Символическая  константа - это имя, значение кото-
рого не может быть изменено в его области видимости.   В  С++
имеется три вида символических констант:  (1) любому значению

                                    - 53 -
любого типа можно дать имя и использовать его как  константу,
добавив к   его описанию ключевое слово const; (2)  множество
целых констант может быть определено как перечисление; и  (3)
любое имя вектора или функции является константой.

                    2.4.1 Целые Константы

     Целые константы  предстают в четырех обличьях:  десятич-
ные, восьмеричные,   шестнадцатиричные константа и символьные
константы. Десятичные используются чаще всего и выглядят так,
как можно было бы ожидать:

  0 1234 976 12345678901234567890

     Десятичная константа имеет тип int, при условии, что она
влезает в   int,  в противном случае ее тип long.  Компилятор
должен предупреждать о константах, которые слишком длинны для
представления в машине.

     Константа, которая начинается нулем за которым идет x (0
x), является  шестнадцатиричным числом (с основанием 16),   а
константа, которая    начинается нулем за которым идет цифра,
является восьмеричным числом (с основанием 8).   Вот  примеры
восьмеричных констант:

  0 02 077 0123

     их десятичные эквиваленты - это 0, 2, 63, 83. В шестнад-
цатиричной записи эти константы выглядят так:

  0x0 0x2 0x3f 0x53

     Буквы a,  b,  c,  d, e и f, или их эквиваленты в верхнем
регистре, используются  для представления чисел 10,  11,  12,
13, 14 и 15, соответственно. Восьмеричная и шестнадцатиричная
записи наиболее   полезны  для записи набора битов применение
этих записей для выражения обычных чисел может привести к не-
ожиданностям. Например, на машине, где int представляется как
двоичное дополнительное шестнадцатиричное целое, 0xffff явля-
ется отрицательным   десятичным числом -1; если бы для предс-
тавления целого использовалось большее число битов,   то  оно
было бы числом 65535.

             2.4.2 Константы с Плавающей Точкой

     Константы с  плавающей точкой имеют тип double.  Как и в
предыдущем случае, компилятор должен предупреждать о констан-
тах с плавающей точкой, которые слишком велики, чтобы их мож-
но было представить. Вот некоторые константы с плавающей точ-
кой:

  1.23 .23 0.23 1. 1.0 1.2e10 1.23e-15

     Заметьте, что в середине константы с плавающей точкой не
может встречаться пробел.  Например,  65.43 e-21 является  не
константой с  плавающей точкой,  а четырьмя отдельными лекси-
ческими символами (лексемами):

  65.43 e - 21

и вызовет синтаксическую ошибку.

     Если вы хотите иметь  константу  константа  с  плавающей
точкой; типа float, вы можете определить ее так (#2.4.6):

  const float pi = 3.14159265;


                                    - 54 -
                 2.4.3 Символьные Константы

     Хотя в  С++  и  нет  отдельного символьного типа данных,
точнее, символ может храниться в целом типе, в нем для симво-
лов имеется специальная и удобная запись. Символьная констан-
та - это символ,  заключенный в одинарные кавычки;  например,
'a' или   '0'.  Такие символьные константы в действительности
являются символическими константами для целого значения  сим-
волов в  наборе символов той машины,  на которой будет выпол-
няться программа (который не обязательно совпадает с  набором
символов, применяемом на том компьютере, где программа компи-
лируется). Поэтому, если вы выполняетесь на машине, использу-
ющей набор символов ASCII, то значением '0' будет 48, но если
ваша машина использует EBCDIC набор символов,  то  оно  будет
240. Употребление символьных констант вместо десятичной запи-
си делает программу более  переносимой.   Несколько  символов
также имеют стандартные имена, в которых обратная косая \ ис-
пользуется как escape-символ:

      '\b', возврат назад
      '\f', перевод формата
      '\n', новая строка
      '\r', возврат каретки
      '\t', горизонтальная табуляция
      '\v', вертикальная табуляция
      '\\', \ обратная косая (обратный слэш)
      '\'', одинарная кавычка '
      '\"', двойная кавычка "
      '\0', null, пустой символ, целое значение 0

     Вопреки их внешнему виду каждое является одним символом.
Можно также представлять символ одно-,  дву- или  трехзначным
восьмеричным числом  (символ \,  за которым идут восьмеричные
цифры), или  одно-,  дву- или  трехзначным  шестнадцатиричным
числом (\x,  за которым идут шестнадцатиричные цифры). Напри-
мер:

  '\6' '\x6' 6 ASCII ack
  '\60' '\x30' 48 ASCII '0'
  '\137' '\x05f' 95 ASCII '_'

     Это позволяет представлять каждый  символ  из  машинного
набора символов, и в частности вставлять такие символы в сим-
вольные строки (см.  следующий раздел).  Применение  числовой
записи для  символов делает программу непереносимой между ма-
шинами с различными наборами символов.

                        2.4.4 Строки

     Строковая константа - это  последовательность  символов,
заключенная в двойные кавычки "

  "это строка"

     Каждая строковая константа содержит на один символ боль-
ше, чем  кажется; все они заканчиваются пустым символом  '\0'
со значением 0. Например:

  sizeof("asdf")==5;

     Строка имеет  тип "вектор из соответствующего числа сим-
волов", поэтому "asdf" имеет тип char[5]. Пустая строка запи-
сывается "" (и имеет тип char[1]).  Заметьте,  что для каждой
строки s strlen(s)==sizeof(s)-1, поскольку strlen() не учиты-
вает завершающий 0.

     Соглашение о  представлении неграфических символов с об-

                                    - 55 -
ратной косой можно использовать также и внутри  строки.   Это
дает возможность   представлять двойные кавычки и escape-сим-
вол. Самым  обычным символом этого рода является, безусловно,
символ новой строки '\n'. Например:

  cout << "гудок в конце сообщения\007\n"

где 7 - значение ASKII символа bel (звонок).

  В строке невозможно иметь "настоящую" новую строку:

    "это не строка,
    а синтаксическая ошибка"

     Однако в строке может стоять обратная косая, сразу после
которой идет новая строка; и то,  и другое будет проигнориро-
вано. Например:

    cout << "здесь все \
    ok"

напечатает

    здесь все ok

     Новая строка,   перед  которой идет escape (обратная ко-
сая), не  приводит к появлению в строке  новой  строки,   это
просто договоренность о записи.

     В строке можно иметь пустой символ, но большинство прог-
рамм не будет предполагать, что есть символы после него. Нап-
ример, строка  "asdf\000hjkl" будет рассматриваться стандарт-
ными функциями, вроде strcpy() и strlen(), как "asdf".

     Вставляя численную  константу   в   строку   с   помощью
восьмеричной или шестнадцатиричной записи благоразумно всегда
использовать число из трех цифр.   Читать  запись  достаточно
трудно и   без необходимости беспокоиться о том,  является ли
символ после константы цифрой или нет. Разберите эти примеры:

    char v1[] = "a\x0fah\0129";  // 'a' '\xfa' 'h' '\12' '9'
    char v2[] = "a\xfah\129";    // 'a' '\xfa' 'h' '\12' '9'
    char v3[] = "a\xfad\127";    // 'a' '\xfad' '\127'

     Имейте в виду,  что двухзначной шестнадцатиричной записи
на машинах с 9-битовым байтом будет недостаточно.

                         2.4.5 Ноль

     Ноль можно употреблять как константу любого целого, пла-
вающего или указательного типа. Никакой объект не размещается
по адресу 0.  Тип нуля определяется контекстом. Обычно (но не
обязательно) он  представляется набором битов все-нули  соот-
ветствующей длины.

                         2.4.6 Const

     Ключевое слово const может добавляться к описанию объек-
та, чтобы  сделать этот объект константой,  а не  переменной.
Например:

  const int model = 145;
  const int v[] = (* 1, 2, 3, 4 *);

     Поскольку константе ничего нельзя присвоить,  она должна
быть инициализирована.  Описание чего-нибудь как const гаран-
тирует, что его значение не изменится в области видимости:

                                    - 56 -

  model = 145;  // ошибка
  model++;      // ошибка

     Заметьте, что  const изменяет тип,  то есть ограничивает
способ использования объекта,  вместо того,   чтобы  задавать
способ размещения константы. Поэтому например вполне разумно,
а иногда и полезно, описывать функцию как возвращающую const:

  const char* peek(int i)
  (*
      return private[i];
  *)

     Функцию вроде  этой можно было бы использовать для того,
чтобы давать кому-нибудь читать строку, которая не может быть
затерта или переписана (этим кем-то).

     С другой  стороны,   компилятор может несколькими путями
воспользоваться тем, что объект является константой (конечно,
в зависимости   от того,  насколько он сообразителен).  Самое
очевидное - это то,  что для константы не требуется  выделять
память, поскольку  компилятор знает ее значение.  Кроме того,
инициализатор константы часто (но не всегда)  является  конс-
тантным выражением,  то есть он может быть вычислен на стадии
компиляции. Однако для вектора констант обычно приходится вы-
делять память,   поскольку компилятор в общем случае не может
вычислить, на какие элементы вектора сделаны ссылки в выраже-
ниях. Однако  на многих машинах даже в этом случае может дос-
тигаться повышение эффективности  путем  размещения  векторов
констант в память, доступную только для чтения.

     Использование указателя вовлекает два объекта:  сам ука-
затель и указываемый объект.   Снабжение  описания  указателя
"префиксом" const делает объект,  но не сам указатель,  конс-
тантой. Например:

  const char* pc = "asdf"; // указатель на константу
  pc[3] = 'a'; // ошибка
  pc = "ghjk"; // ok

     Чтобы описать сам const указатель, а не указываемый объ-
ект, как константный, используется операция const*. Например:

  char *const cp = "asdf"; // константный указатель
  cp[3] = 'a'; // ok
  cp = "ghjk"; // ошибка

     Чтобы сделать константами оба объекта, их оба нужно опи-
сать const. Например:

  const char *const cpc = "asdf"; // const указатель на const
  cpc[3] = 'a'; // ошибка
  cpc = "ghjk"; // ошибка

     Объект, являющийся константой при доступе к  нему  через
один указатель,  может быть переменной, когда доступ осущест-
вляется другими путями.  Это в частности полезно для парамет-
ров функции.    Посредством  описания параметра указателя как
const функции запрещается изменять объект, на который он ука-
зывает. Например:

 char* strcpy(char* p, const char* q); // не может изменить q

     Указателю на  константу можно присваивать адрес перемен-
ной, поскольку  никакого вреда от этого быть не может. Однако
нельзя присвоить адрес константы указателю, на который не бы-

                                    - 57 -
ло наложено ограничение,  поскольку это позволило бы изменить
значение объекта. Например:

  int a = 1;
  const c = 2;
  const* p1 = &c; // ok
  const* p2 = &a; // ok
  int* p3 = &c; // ошибка
  *p3 = 7; // меняет значение c

     Как обычно,  если тип в описании опущен, то он предпола-
гается int.

                     2.4.7 Перечисления

     Есть другой  метод  определения целых констант,  который
иногда более удобен, чем применение const. Например:

  enum (* ASM, AUTO, BREAK *);

     перечисление определяет три целых константы,  называемых
перечислителями, и  присваивает им значения. Поскольку значе-
ния перечислителей по умолчанию присваиваются начиная с  0  в
порядке возрастания, это эквивалентно записи:

  const ASM = 0;
  const AUTO = 1;
  const BREAK = 2;

Перечисление может быть именованным. Например:

  enum keyword (* ASM, AUTO, BREAK *);

     Имя перечисления  становится  синонимом int,  а не новым
типом. Описание  переменной keyword,  а не просто int,  может
дать как программисту, так и компилятору подсказку о том, что
использование преднамеренное. Например:

  keyword key;

  switch (key) (*
  case ASM:
      // что-то делает
      break;
  case BREAK:
      // что-то делает
      break;
  *)

     побуждает компилятор  выдать  предупреждение,  поскольку
только два значения keyword из трех используются.

     Можно также задавать значения перечислителей явно.  Нап-
ример:

  enum int16 (*
      sign=0100000, // знак
      most_significant=040000, // самый значимый
      least_significant=1 // наименее значимый
  *);

     Такие значения  не  обязательно  должны быть различными,
возрастающими или положительными.

                  2.5 Экономия Пространства

     В ходе программирования нетривиальных  разработок  неиз-

                                    - 58 -
бежно наступает время,  когда хочется иметь больше пространс-
тва памяти, чем имеется или отпущено. Есть два способа выжать
побольше пространства из того, что доступно:

     [1] Помещение в байт более одного небольшого объекта и

     [2] Использование одного и того же пространства для хра-
нения разных объектов в разное время.

     Первого можно достичь  с  помощью  использования  полей,
второго -   через использование объединений.  Эти конструкции
описываются в следующих разделах. Поскольку обычное их приме-
нение состоит   чисто в оптимизации программы,  и они в боль-
шинстве случаев непереносимы, программисту следует дважды по-
думать, прежде    чем  использовать их.  Часто лучше изменить
способ управления данными; например, больше полагаться на ди-
намически выделяемую память (#3.2.6)  и меньше на заранее вы-
деленную статическую память.

                         2.5.1 Поля

     Использование char для представления  двоичной  перемен-
ной, например,     переключателя  включено/выключено,   может
показаться экстравагантным,  но char является наименьшим объ-
ектом, который  в С++ может выделяться независимо. Можно, од-
нако, сгруппировать   несколько  таких  крошечных  переменных
вместе в виде полей struct.  Член определяется как поле путем
указания после его имени числа битов,  которые  он  занимает.
Допустимы неименованные   поля; они не влияют на смысл имено-
ванных полей,  но неким машинно-зависимым образом могут улуч-
шить размещение:

  struct sreg (*
      unsigned enable : 1;
      unsigned page : 3;
      unsigned : 1; // неиспользуемое
      unsigned mode : 2;
      unsigned : 4: // неиспользуемое
      unsigned access : 1;
      unsigned length : 1;
      unsigned non_resident : 1;
  *)

     Получилось размещение регистра 0 состояния DEC  PDP11/45
(в предположении,   что поля в слове размещаются слева напра-
во). Этот  пример также иллюстрирует другое основное примене-
ние полей:   именовать части внешне предписанного размещения.
Поле должно быть целого типа и используется как другие целые,
за исключением того,  что невозможно взять адрес поля. В ядре
операционной системы или в отладчике тип sreg можно  было  бы
использовать так:

  sreg* sr0 = (sreg*)0777572;
  //...
  if (sr->access) (* // нарушение доступа
      // чистит массив
      sr->access = 0;
  *)

     Однако применение полей для упаковки нескольких перемен-
ных в   один  байт не обязательно экономит пространство.  Оно
экономит пространство, занимаемое данными, но объем кода, не-
обходимого для манипуляции этими переменными,  на большинстве
машин возрастает.  Известны программы,   которые  значительно
сжимались, когда двоичные переменные преобразовывались из по-
лей бит в символы!  Кроме того,  доступ к char или int обычно
намного быстрее, чем доступ к полю. Поля - это просто удобная

                                    - 59 -
и краткая запись для применения логических операций  с  целью
извлечения информации  из части слова или введения информации
в нее.

                      2.5.2 Объединения

     Рассмотрим проектирование символьной таблицы,  в которой
каждый элемент содержит имя и значение, и значение может быть
либо строкой, либо целым:

  struct entry (*
      char* name;
      char type;
      char* string_value;   // используется если type == 's'
      int int_value;        // используется если type == 'i'
  *);

  void print_entry(entry* p)
  (*
      switch p->type (*
      case 's':
          cout << p->string_value;
          break;
      case 'i':
          cout << p->int_value;
          break;
      default:
          cerr << "испорчен type\n";
          break;
      *)
  *)

     Поскольку string_value и int_value никогда не могут  ис-
пользоваться одновременно,  ясно,  что пространство пропадает
впустую. Это можно легко исправить, указав, что оба они долж-
ны быть членами union. Например, так:

  struct entry (*
      char* name;
      char type;
      union (*
          char* string_value; //используется если type == 's'
          int int_value;      //используется если type == 'i'
      *);
  *);

     Это оставляет всю часть программы,  использующую  entry,
без изменений,    но  обеспечивает,  что при размещении entry
string_value и int_value имеют один и тот же  адрес.   Отсюда
следует, что    все  члены  объединения  вместе занимают лишь
столько памяти, сколько занимает наибольший член.

     Использование объединений таким образом,  чтобы при чте-
нии значения всегда применялся тот член,  с применением кото-
рого оно записывалось,  совершенно оптимально.  Но в  больших
программах непросто гарантировать,  что объединения использу-
ются только таким образом,  и из-за неправильного использова-
ния могут появляться трудно уловимые ошибки.  Можно @капсули-
зировать объединение таким образом,  чтобы соответствие между
полем типа   и  типами  членов было гарантированно правильным
(#5.4.6).

     Объединения иногда используют для "объединения и  преоб-
разование типа"   (это  делают  главным образом программисты,
воспитанные на языках,  не обладающих средствами преобразова-
ния типов,  где жульничество является необходимым). Например,
это "преобразует" на VAX'е int в int*, просто предполагая по-

                                    - 60 -
битовую эквивалентность:

  struct fudge (*
      union (*
          int i;
          int* p;
      *);
  *);

  fudge a;
  a.i = 4096;
  int* p = a.p; // плохое использование

     Но на самом деле это совсем не преобразование:  на неко-
торых машинах int и int* занимают неодинаковое количество па-
мяти, а  на других никакое  целое  не  может  иметь  нечетный
адрес. Такое  применение объединений непереносимо, а есть яв-
ный способ указать преобразование типа (#3.2.5).

     Изредка объединения умышленно применяют,  чтобы избежать
преобразования типов.  Можно,  например,  использовать fudge,
чтобы узнать представление указателя 0:

  fudge.p = 0;
  int i = fudge.i; // i не обязательно должно быть 0

     Можно также  дать  объединению имя,  то есть сделать его
полноправным типом.  Например,  fudge можно было  бы  описать
так:

  union fudge (*
          int i;
          int* p;
  *);

     и использовать (неправильно) в точности как раньше. Име-
ются также  и оправданные применения именованных объединений,
см. #5.4.6.

                       2.6 Упражнения

     1. (*1)  Заставьте работать программу с "Hello,   world"
(1.1.1).

     2. (*1)  Для каждого описания в #2.1 сделайте следующее:
Если описание не является определением, напишите для него оп-
ределение. Если  описание является определением, напишите для
него описание, которое при этом не является определением.

     3. (*1) Напишите описания для: указателя на символ; век-
тора из  10 целых; ссылки на вектор из 10 целых; указателя на
вектор из символьных строк; указателя на указатель на символ;
константного целого;  указателя на константное целое; и конс-
тантного указателя на целое. Каждый из них инициализируйте.

     4. (*1.5)  Напишите программу,  которая печатает размеры
основных и указательных типов. Используйте операцию sizeof.

     5. (*1.5)   Напишите  программу,  которая печатает буквы
'a'...'z' и цифры '0'...'9' и их числовые значения.  Сделайте
то же для остальных печатаемых символов.  Сделайте то же,  но
используя шестнадцатиричную запись.

     6. (*1)  Напечатайте набор битов, которым представляется
указатель 0 на вашей системе. Подсказка: #2.5.2.

     7. (*1.5) Напишите функцию, печатающую порядок и мантис-

                                    - 61 -
су параметра типа double.

     8. (*2)  Каковы наибольшие и наименьшие значения, на ва-
шей системе,  следующих типов: char, short, int, long, float,
double, unsigned,   char*,  int* и void*? Имеются ли дополни-
тельные ограничения   на принимаемые ими значения?  Может ли,
например, int* принимать нечетное значение? Как выравниваются
в памяти объекты этих типов?  Может ли,  например,  int иметь
нечетный адрес?

     9. (*1)  Какое самое длинное локальное имя можно исполь-
зовать в  С++ программе в вашей системе?  Какое самое длинное
внешнее имя можно использовать в С++ программе в вашей систе-
ме? Есть ли какие-нибудь ограничения на символы, которые мож-
но употреблять в имени?

     10. (*2) Определите one следующим образом:

       const one = 1;

     Попытайтесь поменять значение one на 2.  Определите  num
следующим образом:

       const num[] = (* 1, 2 *);

     Попытайтесь поменять значение num[1] на 2.

     11. (*1) Напишите функцию, переставляющую два целых (ме-
няющую значения). Используйте в качестве типа параметра int*.
Напишите другую   переставляющую функцию,  использующую в ка-
честве типа параметра int&.

     12. (*1) Каков размер вектора str в следующем примере:

       char str[] = "a short string";

     Какова длина строки "a short string"?

     13. (*1.5)  Определите таблицу названий месяцев  года  и
числа дней в них.  Выведите ее.  Сделайте это два раза:  один
раз используя вектор для названий и вектор для числа дней,  и
один раз используя вектор структур,  в каждой из которых хра-
нится название месяца и число дней в нем.

     14. (*1)  С помощью typedef определите типы: беззнаковый
char, константный  беззнаковый char, указатель на целое, ука-
затель на указатель на char,  указатель на вектора  символов,
вектор из 7 целых указателей,  указатель на вектор из 7 целых
указателей, и вектор из 8 векторов из 7 целых указателей.

                                    - 62 -


Глава 3
Выражения и Операторы

                                            С другой стороны,
                       мы не можем игнорировать эффективность
                                                - Джон Бентли

     С++ имеет  небольшой,   но  гибкий набор различных видов
операторов для контроля потока управления в программе и бога-
тый набор операций для манипуляции данными. С наиболее общеп-
ринятыми средствами вас познакомит один  законченный  пример.
После него   приводится  резюмирующий обзор выражений и с до-
вольно подробно описываются явное описание типа и  работа  со
свободной памятью.   Потом представлена краткая сводка опера-
ций, а в конце обсуждаются стиль выравнивания* и комментарии.

--------------------
     * Нам неизвестен русскоязычный термин, эквивалентный ан-
глийскому indentation.    Иногда  это  называется  отступами.
(прим. перев.)

                 3.1 Настольный калькулятор

     С операторами  и  выражениями вас познакомит приведенная
здесь программа настольного  калькулятора,   предоставляющего
четыре стандартные арифметические операции над числами с пла-
вающей точкой.  Пользователь может также определять  перемен-
ные. Например, если вводится

  r=2.5
  area=pi*r*r

(pi определено заранее), то программа калькулятора напишет:

  2.5
  19.635

     где 2.5 - результат первой введенной строки,  а 19.635 -
результат второй.

     Калькулятор состоит из четырех основных частей: програм-
мы синтаксического разбора (parser'а), функции ввода, таблицы
имен и управляющей программы (драйвера).  Фактически, это ми-
ниатюрный компилятор,    в  котором программа синтаксического
разбора производит синтаксический анализ,  функция ввода осу-
ществляет ввод и лексический анализ,  в таблице имен хранится
долговременная информация,  а драйвер распоряжается инициали-
зацией, выводом и обработкой ошибок. Можно было бы многое до-
бавить в этот калькулятор,  чтобы сделать его более полезным,
но в  существующем виде эта программа и так достаточно длинна
(200 строк),  и  большая  часть  дополнительных  возможностей
просто увеличит  текст программы не давая дополнительного по-
нимания применения С++.

           3.1.1 Программа синтаксического разбора

  Вот грамматика языка, допускаемого калькулятором:

  program:
      END                 // END - это конец ввода
      expr_list END

  expr_list:
      expression PRINT    // PRINT - это или '\n' или ';'
      expression PRINT expr_list


                                    - 63 -
  expression:
      expression + term
      expression - term
      term

  term:
      term / primary
      term * primary
      primary

  primary:
      NUMBER              // число с плавающей точкой в С++
      NAME                // имя С++ за исключением '_'
      NAME = expression
      - primary
      ( expression )

     Другими словами,    программа   есть  последовательность
строк. Каждая  строка состоит из одного или более  выражений,
разделенных запятой.  Основными элементами выражения являются
числа, имена  и операции *, /, +, - (унарный и бинарный) и =.
Имена не обязательно должны описываться до использования.

     Используемый метод обычно называется рекурсивным спуском
это популярный и простой нисходящий метод. В таком языке, как
С++, в котором вызовы функций относительно дешевы, этот метод
к тому же и эффективен. Для каждого правила вывода грамматики
имеется функция, вызывающая другие функции. Терминальные сим-
волы (например,  END, NUMBER, + и -) распознаются лексическим
анализатором get_token(),  а нетерминальные символы распозна-
ются функциями синтаксического  анализа  expr(),   term()   и
prim(). Как  только оба операнда (под)выражения известны, оно
вычисляется; в настоящем компиляторе в этой точке производит-
ся генерация кода.

     Программа разбора для получения ввода использует функцию
get_token(). Значение последнего вызова get_token() находится
в переменной  curr_tok; curr_tok имеет одно из значений пере-
числения token_value:

  enum token_value (*
      NAME NUMBER END
      PLUS='+' MINUS='-' MUL='*' DIV='/'
      PRINT=';' ASSIGN='=' LP='(' RP=')'
  *);
  token_value curr_tok;

     В каждой функции разбора предполагается,  что было обра-
щение к get_token(), и в curr_tok находится очередной символ,
подлежащий анализу.  Это позволяет программе разбора загляды-
вать на один лексический символ (лексему) вперед и заставляет
функцию разбора всегда читать на одну лексему больше, чем ис-
пользуется правилом, для обработки которого она была вызвана.
Каждая функция разбора вычисляет "свое" выражение и возвраща-
ет значение.  Функция expr()  обрабатывает сложение и вычита-
ние; она   состоит из простого цикла,  который ищет термы для
сложения или вычитания:

  double expr()            // складывает и вычитает
  (*
      double left = term();

      for(;;)              // ``навсегда``
          switch(curr_tok) (*
          case PLUS:
              get_token(); // ест '+'
              left += term();

                                    - 64 -
              break;
          case MINUS:
              get_token(); // ест '-'
              left -= term();
              break;
          default:
              return left;
	  *)
  *)

     Фактически сама функция делает не очень много. В манере,
достаточно типичной для функций более высокого уровня в боль-
ших программах,    она  вызывает для выполнения работы другие
функции. Заметьте, что выражение 2-3+4 вычисляется как (2-3)+
4, как указано грамматикой.

     Странная запись for(;;)  - это стандартный способ задать
бесконечный цикл.  Можно произносить это как "навсегда"*. Это
вырожденная форма оператора for, альтернатива - while(1). Вы-
полнение оператора switch повторяется до тех пор, пока не бу-
дет найдено ни + ни -,  и тогда выполняется оператор return в
случае default.

--------------------
* игра слов: "for" - "forever" (навсегда). (прим. перев.)

     Операции +=,  -= используются для осуществления сложения
и вычитания.  Можно было бы не изменяя смысла  программы  ис-
пользовать left=left+term() и left=left-term(). Однако left+=
term() и left-=term() не только короче, но к тому же явно вы-
ражают подразумеваемое действие.  Для бинарной операции @ вы-
ражение x@=y означает x=x@y за исключением того, что x вычис-
ляется только один раз. Это применимо к бинарным операциям

  + - * / % & ! ^ << >>

поэтому возможны следующие операции присваивания:

  += -= *= /= %= &= != ^= <<= >>=

     Каждая является   отдельной  лексемой,   поэтому  a+  =1
является синтаксической ошибкой из-за пробела между + и =. (%
является операцией взятия по модулю; &,! и ^ являются побито-
выми операциями И,  ИЛИ и исключающее ИЛИ; << и  >>  являются
операциями левого   и  правого  сдвига).   Функции  term()  и
get_token() должны быть описаны до expr().

     Как организовать программу в виде набора файлов,  обсуж-
дается в Главе 4.  За одним исключением все описания в данной
программе настольного  калькулятора  можно  упорядочить  так,
чтобы все описывалось ровно один раз и до использования. Иск-
лючением является expr(),  которая обращается к term(), кото-
рая обращается к prim(),  которая в свою очередь обращается к
expr(). Этот круг надо как-то разорвать;

Описание

  double expr(); // без этого нельзя

перед prim() прекрасно справляется с этим.

     Функция term()  аналогичным образом обрабатывает умноже-
ние и сложение:

  double term() // умножает и складывает
  (*
      double left = prim();

                                    - 65 -
      for(;;)
          switch(curr_tok) (*
          case MUL:
              get_token(); // ест '*'
              left *= prim();
              break;
          case DIV:
              get_token(); // ест '/'
              double d = prim();
              if (d == 0) return error("деление на 0");
              left /= d;
              break;
          default:
              return left;
	  *)
  *)

     Проверка, которая делается,  чтобы удостовериться в том,
что нет деления на ноль,  необходима, поскольку результат де-
ления на ноль неопределен и  как  правило  является  роковым.
Функция error(char*)  будет описана позже.  Переменная d вво-
дится в программе там,  где она нужна, и сразу же инициализи-
руется. Во  многих языках описание может располагаться только
в голове блока.  Это ограничение может приводить  к  довольно
скверному искажению   стиля  программирования  и/или излишним
ошибкам. Чаще всего неинициализированные локальные переменные
являются просто признаком плохого стиля; исключением являются
переменные, подлежащие инициализации посредством ввода, и пе-
ременные векторного   или  структурного типа,  которые нельзя
удобно инициализировать одними присваиваниями*. Заметьте, что
= является операцией присваивания,  а == операцией сравнения.

--------------------
* В  языке немного лучше этого с этими исключениями тоже надо
бы справляться. (прим. автора)

     Функция prim,  обрабатывающая primary, написана в основ-
ном в том же духе, не считая того, что немного реальной рабо-
ты в ней все-таки выполняется, и нет нужды в цикле, поскольку
мы попадаем на более низкий уровень иерархии вызовов:

  double prim()      // обрабатывает primary (первичные)
  (*
      switch (curr_tok) (*
      case NUMBER:  // константа с плавающей точкой
          get_token();
          return number_value;
      case NAME:
          if (get_token() == ASSIGN) (*
              name* n = insert(name_string);
              get_token();
              n->value = expr();
              return n->value;
	  *)
          return look(name-string)->value;
      case MINUS:   // унарный минус
          get_token();
          return -prim();
      case LP:
          get_token();
          double e = expr();
          if (curr_tok != RP) return error("должна быть )");
          get_token();
          return e;
      case END:
          return 1;
      default:

                                    - 66 -
          return error("должно быть primary");
      *)
  *)

     При обнаружении NUMBER (то есть,  константы с  плавающей
точкой), возвращается его значение. Функция ввода get_token()
помещает значение в глобальную переменную number_value.   Ис-
пользование в программе глобальных переменных часто указывает
на то, что структура не совсем прозрачна, что применялась не-
которого рода оптимизация. Здесь дело обстоит именно так. Те-
оретически лексический символ обычно состоит из двух  частей:
значения, определяющего вид лексемы (в данной программе token
_value), и  (если необходимо) значения лексемы. У нас имеется
только одна простая переменная curr_tok, поэтому для хранения
значения последнего считанного NUMBER понадобилась глобальная
переменная переменная number_value. Это работает только пото-
му, что  калькулятор при вычислениях использует  только  одно
число перед чтением со входа другого.

     Так же, как значение последнего встреченного NUMBER хра-
нится в number_value,  в name_string в виде символьной строки
хранится представление   последнего прочитанного NAME.  Перед
тем, как что-либо сделать с именем, калькулятор должен загля-
нуть вперед, чтобы посмотреть, осуществляется ли присваивание
ему, или  оно просто используется. В обоих случаях надо спра-
виться в   таблице  имен.  Сама таблица описывается в #3.1.3;
здесь надо знать только, что она состоит из элементов вида:

  srtuct name (*
      char* string;
      char* next;
      double value;
  *)

где next используется только функциями, которые поддерживают
работу с таблицей:

  name* look(char*);
  name* insert(char*);

     Обе возвращают указатель на name,  соответствующее пара-
метру - символьной строке; look() выражает недовольство, если
имя не было определено.  Это значит, что в калькуляторе можно
использовать имя без предварительного описания, но первый раз
оно должно использоваться в левой части присваивания.

                     3.1.2 Функция ввода

     Чтение ввода - часто самая запутанная  часть  программы.
Причина в  том,  что если программа должна общаться с челове-
ком, то  она должна справляться с его причудами, условностями
и внешне случайными ошибками. Попытки заставить человека вес-
ти себя более удобным для машины образом часто (и  справедли-
во) рассматриваются как оскорбительные. Задача низкоуровневой
программы ввода состоит в том, чтобы читать символы по одному
и составлять  из них лексические символы более высокого уров-
ня. Далее  эти лексемы служат вводом для программ более высо-
кого уровня.    У  нас  ввод  низкого  уровня  осуществляется
get_token(). Обнадеживает  то,  что написание программ  ввода
низкого уровня не является ежедневной работой; в хорошей сис-
теме для этого будут стандартные функции.

     Для калькулятора правила сознательно были выбраны  таки-
ми, чтобы    функциям  по работе с потоками было неудобно эти
правила обрабатывать; незначительные изменения в  определении
лексем сделали бы get_token() обманчиво простой.
     Первая сложность состоит в том,  что символ новой строки

                                    - 67 -
'\n' является для калькулятора существенным, а функции работы
с потоками считают его символом пропуска.  То есть,  для этих
функций '\n' значим только как ограничитель  лексемы.   Чтобы
преодолеть это,  надо проверять пропуски (пробел, символы та-
буляции и т.п.):

  char ch

  do (* // пропускает пропуски за исключением '\n'
      if(!cin.get(ch)) return curr_tok = END;
  *) while (ch!='\n' && isspace(ch));

     Вызов cin.get(ch)  считывает один символ из стандартного
потока ввода  в ch.  Проверка if(!cin.get(ch))  не проходит в
случае, если  из cin нельзя считать ни одного символа. В этом
случае возвращается END, чтобы завершить сеанс работы кальку-
лятора. Используется операция ! (НЕ), поскольку get() возвра-
щает в случае успеха ненулевое значение.

     Функция (inline)   isspace()   из <ctype.h> обеспечивает
стандартную проверку на то,   является  ли  символ  пропуском
(#8.4.1); isspace(c)   возвращает ненулевое значение,  если c
является символом пропуска,  и ноль в противном случае.  Про-
верка реализуется в виде поиска в таблице,  поэтому использо-
вание isspace()  намного быстрее,  чем проверка на  отдельные
символы пропуска;   это  же относится и к функциям isalpha(),
isdigit() и isalnum(), которые используются в get_token().

     После того, как пустое место пропущено, следующий символ
используется для   определения того,  какого вида какого вида
лексема приходит. Давайте сначала рассмотрим некоторые случаи
отдельно, прежде чем приводить всю функцию. Ограничители лек-
сем '\n' и ';' обрабатываются так:

  switch (ch) (*
  case ';':
  case '\n':
      cin >> WS; // пропустить пропуск
      return curr_tok=PRINT;

     Пропуск пустого места делать необязательно, но он позво-
ляет избежать   повторных  обращений к get_token().  WS - это
стандартный пропусковый объект,  описанный в  <stream.h>;  он
используется только для сброса пропуска.  Ошибка во вводе или
конец ввода не будут обнаружены до следующего обращения к get
_token(). Обратите    внимание на то,  как можно использовать
несколько меток case (случаев)  для одной и той же последова-
тельности операторов, обрабатывающих эти случаи. В обоих слу-
чаях возвращается лексема PRINT и помещается в curr_tok.

  Числа обрабатываются так:

  case '0': case '1': case '2': case '3': case '4':
  case '5': case '6': case '7': case '8': case '9':
  case '.':
      cin.putback(ch);
      cin >> number_value;
      return curr_tok=NUMBER;

     Располагать метки случаев case горизонтально,  а не вер-
тикально, не  очень  хорошая  мысль,   поскольку  читать  это
гораздо труднее,  но отводить по одной строке на каждую цифру
нудно.

     Поскольку операция >>  определена  также  и  для  чтения
констант с плавающей точкой в double,  программирование этого
не составляет труда:  сперва начальный символ (цифра или точ-

                                    - 68 -
ка) помещается  обратно в cin,  а затем можно считывать конс-
танту в number_value.

     Имя, то есть лексема NAME,  определяется как буква,   за
которой возможно следует несколько букв или цифр:

  if (isalpha(ch)) (*
      char* p = name_string;
      *p++ = ch;
      while (cin.get(ch) && isalnum(ch)) *p++ = ch;
      cin.putback(ch);
      *p = 0;
      return curr_tok=NAME;
  *)

     Эта часть строит в name_string строку,   заканчивающуюся
нулем. Функции    isalpha()  и isalnum()  заданы в <ctype.h>;
isalnum(c) не  ноль, если c буква или цифра, ноль в противном
случае.

  Вот, наконец, функция ввода полностью:

  token_value get_token()
  (*
      char ch;

      do (* // пропускает пропуски за исключением '\n'
          if(!cin.get(ch)) return curr_tok = END;
      *) while (ch!='\n' && isspace(ch));

      switch (ch) (*
      case ';':
      case '\n':
          cin >> WS; // пропустить пропуск
          return curr_tok=PRINT;
      case '*':
      case '/':
      case '+':
      case '-':
      case '(':
      case ')':
      case '=':
          return curr_tok=ch;
      case '0': case '1': case '2': case '3': case '4':
      case '5': case '6': case '7': case '8': case '9':
      case '.':
          cin.putback(ch);
          cin >> number_value;
          return curr_tok=NUMBER;
      default: // NAME, NAME= или ошибка
          if (isalpha(ch)) (*
              char* p = name_string;
              *p++ = ch;
              while (cin.get(ch) && isalnum(ch)) *p++ = ch;
              cin.putback(ch);
              *p = 0;
              return curr_tok=NAME;
	  *)
          error("плохая лексема");
          return curr_tok=PRINT;
      *)
  *)

     Поскольку token_value (значение лексемы)  операции  было
определено как целое значение этой операции*,  обработка всех
операций тривиальна.


                                    - 69 -
--------------------
* знака этой операции. (прим. перев.)

                     3.1.3 Таблица имен

     К таблице  имен  доступ  осуществляется  с помощью одной
функции

  name* look(char* p, int ins =0);

     Ее второй параметр указывает, нужно ли сначала поместить
строку символов в таблицу.  Инициализатор =0 задает параметр,
который надлежит использовать по умолчанию,  когда look() вы-
зывается с одним параметром.  Это дает удобство записи, когда
look("sqrt2") означает look("sqrt2",0), то есть просмотр, без
помещения в таблицу.  Чтобы получить такое же удобство записи
для помещения в таблицу, определяется вторая функция:

  inline name* insert(char* s) (* return look(s,1);*)

  Как уже отмечалось раньше, элементы этой таблицы имеют тип:

  srtuct name (*
      char* string;
      char* next;
      double value;
  *)

  Член next используется только для сцепления вместе имен в
таблице.

  Сама таблица - это просто вектор указателей на объекты типа
name:

  const TBLSZ = 23;
  name* table[TBLSZ];

     Поскольку все  статические  объекты инициализируются ну-
лем, это тривиальное описание таблицы table гарантирует также
надлежащую инициализацию.

     Для нахождения  элемента в таблице в look()  принимается
простой алгоритм хэширования (имена с одним и тем же  хэш-ко-
дом зацепляются вместе):

  int ii = 0; // хэширование
  char* pp = p;
  while (*pp) ii = ii<<1 ^ *pp++;
  if (ii < 0) ii = -ii;
  ii %= TBLSZ;

     То есть,   с  помощью  исключающего ИЛИ каждый символ во
входной строке "добавляется" к ii ("сумме" предыдущих  симво-
лов). Бит в x^y устанавливается единичным тогда и только тог-
да, когда соответствующие биты в x и y различны. Перед приме-
нением в символе исключающего ИЛИ,  ii сдвигается на один бит
влево, чтобы  не использовать в слове только один байт.   Это
можно было написать и так:

  ii <<= 1;
  ii ^= *pp++;

     Кстати, применение ^ лучше и быстрее, чем +. Сдвиг важен
для получения приемлемого хэш-кода в обоих случаях. Операторы

  if (ii < 0) ii = -ii;
  ii %= TBLSZ;

                                    - 70 -

     обеспечивают, что ii будет лежать в диапазоне 0...TBLSZ-
1; %  - это операция взятия по модулю (еще называемая получе-
нием остатка).

  Вот функция полностью:

  extern int strlen(const char*);
  extern int strcmp(const char*, const char*);
  extern int strcpy(const char*, const char*);

  name* look(char* p, int ins =0)
  (*
      int ii = 0; // хэширование
      char* pp = p;
      while (*pp) ii = ii<<1 ^ *pp++;
      if (ii < 0) ii = -ii;
      ii %= TBLSZ;

      for (name* n=table[ii]; n; n=n->next) // поиск
          if (strcmp(p,n->string) == 0) return n;

      if (ins == 0) error("имя не найдено");

      name* nn = new name; // вставка
      nn->string = new char[strlen(p)+1];
      strcpy(nn->string,p);
      nn->value = 1;
      nn->next = table[ii];
      table[ii] = nn;
      return nn;
  *)

     После вычисления хэш-кода ii имя находится простым прос-
мотром через поля next.  Проверка каждого name осуществляется
с помощью стандартной функции strcmp().  Если строка найдена,
возвращается ее name, иначе добавляется новое name.

     Добавление нового  name  включает в себя создание нового
объекта в  свободной  памяти  с  помощью  операции  new  (см.
#3.2.6), его  инициализацию,  и добавление его к списку имен.
Последнее осуществляется просто путем помещения нового  имени
в голову списка, поскольку это можно делать даже не проверяя,
имеется список,  или нет.  Символьную строку для  имени  тоже
нужно сохранить в свободной памяти.  Функция strlen() исполь-
зуется для определения того,  сколько памяти нужно, new - для
выделения этой памяти,  и strcpy() - для копирования строки в
память.

                   3.1.4 Обработка ошибок

     Поскольку программа так проста, обработка ошибок не сос-
тавляет большого труда.  Функция обработки ошибок просто счи-
тает ошибки,  пишет сообщение об ошибке и возвращает управле-
ние обратно:

  int no_of_errors;

  double error(char* s) (*
      cerr << "error: " << s << "\n";
      no_of_errors++;
      return 1;
  *)

     Возвращается значение   потому,    что   ошибки   обычно
встречаются в середине вычисления выражения,  и поэтому  надо
либо полностью прекращать вычисление,  либо возвращать значе-

                                    - 71 -
ние, которое  по всей видимости не должно вызвать последующих
ошибок. Для  простого калькулятора больше подходит последнее.
Если бы get_token() отслеживала номера строк, то error() мог-
ла бы   сообщать пользователю,  где приблизительно обнаружена
ошибка. Это  наверняка было бы полезно,  если бы  калькулятор
использовался неитерактивно.

     Часто бывает  так,  что после появления ошибки программа
должна завершиться,  поскольку нет  никакого  разумного  пути
продолжить работу. Это можно сделать с помощью вызова exit(),
которая очищает все вроде потоков вывода (#8.3.2),   а  затем
завершает программу   используя  свой  параметр в качестве ее
возвращаемого значения.  Более радикальный способ  завершения
программы -   это вызов abort(),  которая обрывает выполнение
сразу же или сразу после сохранения где-то информации для от-
ладчика (дамп памяти); о подробностях справьтесь, пожалуйста,
в вашем руководстве.

                        3.1.5 Драйвер

     Когда все части программы на месте,   нам  нужен  только
драйвер для инициализации и всего того,  что связано с запус-
ком. В этом простом примере main() может работать так:

  int main()
  (*
      // вставить предопределенные имена:
      insert("pi")->value = 3.1415926535897932385;
      insert("e")->value = 2.7182818284590452354;

      while (cin) (*
          get_token();
          if (curr_tok == END) break;
          if (curr_tok == PRINT) continue;
          cout << expr() << "\n";
      *)
      return no_of_errors;
  *)

     Принято обычно,  что main() возвращает ноль при нормаль-
ном завершении программы и не ноль в противном случае, поэто-
му это   прекрасно может сделать возвращение числа ошибок.  В
данном случае оказывается, что инициализация нужна только для
введения предопределенных имен в таблицу имен.

     Основная работа цикла - читать выражения и писать ответ.
Это делает строка:

  cout << expr() << "\n";

     Проверка cin на каждом проходе цикла обеспечивает завер-
шение программы в случае, если с потоком ввода что-то не так,
а проверка на END обеспечивает  корректный  выход  из  цикла,
когда get_token()  встречает конец файла. Оператор break осу-
ществляет выход   из  ближайшего  содержащего  его  оператора
switch или оператора цикла (то есть, оператора for, оператора
while или оператора do).  Проверка на PRINT (то есть, на '\n'
или ';')  освобождает expr() от обязанности обрабатывать пус-
тые выражения. Оператор continue равносилен переходу к самому
концу цикла, поэтому в данном случае
                                        
                                        
                                        
                                        
                                        
                                        
                                        

                                    - 72 -
  while (cin) (*
      // ...
      if (curr_tok == PRINT) continue;
      cout << expr() << "\n";
  *)

эквивалентно

  while (cin) (*
      // ...
      if (curr_tok == PRINT) goto end_of_loop;
      cout << expr() << "\n";
      end_of_loop
  *)

  Более подробно циклы описываются в #с.9.

              3.1.6 Параметры командной строки

     После того, как программа была написана и оттестирована,
я заметил, что часто набирать выражения на клавиатуре в стан-
дартный ввод надоедает,  поскольку обычно использование прог-
раммы состоит   в вычислении одного выражения.  Если бы можно
было представлять это выражение как параметр командной  стро-
ки, не приходилось бы так много нажимать на клавиши.

     Как уже   говорилось,    программа  запускается  вызовом
main(). Когда  это происходит,  main() получает два параметра
указывающий число параметров, обычно называемый argc и вектор
параметров, обычно  называемый argv. Параметры - это символь-
ные строки, поэтому argv имеет тип char*[argc]. Имя программы
(так, как оно стоит в командной строке) передается в качестве
argv[0], поэтому  argc всегда не меньше единицы.  Например, в
случае команды

  dc 150/1.1934

параметры имеют значения:

  argc 2
  argv[0] "dc"
  argv[1] "150/1.1934"

     Научиться пользоваться параметрами командной строки нес-
ложно. Сложность  состоит в том,  как использовать их без пе-
репрограммирования. В  данном случае это  оказывается  совсем
просто, поскольку    поток  ввода  можно связать с символьной
строкой, а  не с файлом (#8.5). Например, можно заставить cin
читать символы из стандартного ввода:

  int main(int argc, char* argv[])
  (*
      switch(argc) (*
      case 1: // читать из стандартного ввода
          break;
      case 2: // читать параметр строку
          cin = *new istream(strlen(argv[1]),argv[1]);
          break;
      default:
          error("слишком много параметров");
          return 1;
      *)
      // как раньше
  *)

     Программа осталась без изменений,  за исключением добав-
ления в  main()  параметров и использования этих параметров в

                                    - 73 -
операторе switch.  Можно было бы легко модифицировать  main()
так, чтобы  она получала несколько параметров командной стро-
ки, но  это оказывается ненужным,  особенно потому,  что нес-
колько выражений можно передавать как один параметр:
  dc "rate=1.1934;150/rate;19.75/rate;217/rate"

     Здесь кавычки необходимы,  поскольку ; является раздели-
телем команд в системе UNIX.

                 3.2 Краткая сводка операций

     Операции С++ подробно и систематически описываются в #с.
7; прочитайте,  пожалуйста,  этот раздел. Здесь же приводится
операция краткая сводка и некоторые  примеры.   После  каждой
операции приведено одно или более ее общеупотребительных наз-
ваний и пример ее использования. В этих примерах имя_класса -
это имя класса,  член - имя члена, объект - выражение, дающее
в результате объект класса,  указатель - выражение,  дающее в
результате указатель,  выр - выражение, а lvalue - выражение,
денотирующее неконстантный объект.  Тип может быть совершенно
произвольным именем   типа (со * ()  и т.п.)  только когда он
стоит в скобках, во всех остальных случаях существуют ограни-
чения.

     Унарные операции  и  операции присваивания правоассоциа-
тивны, все  остальные левоассоциативны. Это значит, что a=b=c
означает a=(b=c), a+b+c означает (a+b)+c, и *p++ означает *(p
++), а не (*p)++.

                  Сводка Операций (часть 1)
 ===========================================================
   :: разрешение области видимости имя_класса :: член
   :: глобальное :: имя
 ===========================================================
   -> выбор члена указатель->член
   [] индексация указатель [ выр ]
   () вызов функции выр (список_выр)
   () построение значения тип (список_выр)
   sizeof размер объекта sizeof выр
   sizeof размер типа sizeof ( тип )
 ===========================================================
   ++ приращение после lvalue++
   ++ приращение до ++lvalue
   -- уменьшение после lvalue--
   -- уменьшение до --lvalue
   ~ дополнение ~ выр
   ! не ! выр
   - унарный минус - выр
   + унарный плюс + выр
   & адрес объекта & lvalue
   * разыменование * выр
   new создание (размещение) new тип
   delete уничтожение (освобождение) delete указатель
   delete[] уничтожение вектора delete[ выр ] указатель
   () приведение (преобразование типа) ( тип ) выр
 ===========================================================
   * умножение выр * выр
   / деление выр / выр
   % взятие по модулю (остаток) выр % выр
 ===========================================================
   + сложение (плюс) выр + выр
   - вычитание (минус) выр - выр
 ===========================================================
   << сдвиг влево lvalue << выр
   >> сдвиг вправо lvalue >> выр
 ===========================================================
   < меньше выр < выр

                                    - 74 -
   <= меньше или равно выр <= выр
   > больше выр > выр
   >= больше или равно выр >= выр
 ===========================================================
   == равно выр == выр
   != не равно выр != выр
 ===========================================================
   & побитовое И выр & выр
 ===========================================================
   ^ побитовое исключающее ИЛИ выр ^ выр
 ===========================================================
   ! побитовое включающее ИЛИ выр ! выр
 ===========================================================
   && логическое И выр && выр
 ===========================================================
   !! логическое включающее ИЛИ выр !! выр
 ===========================================================
   ? : арифметический if выр ? выр : выр
 ===========================================================
   = простое присваивание lvalue = выр
   *= умножить и присвоить lvalue = выр
   /= разделить и присвоить lvalue /= выр
   %= взять по модулю и присвоить lvalue %= выр
   += сложить и присвоить lvalue += выр
   -= вычесть и присвоить lvalue -= выр
   <<= сдвинуть влево и присвоить lvalue <<= выр
   >>= сдвинуть вправо и присвоить lvalue >>= выр
   &= И и присвоить lvalue &= выр
   != включающее ИЛИ и присвоить lvalue != выр
   ^= исключающее ИЛИ и присвоить lvalue ^= выр
 ===========================================================
   , запятая (следование) выр , выр
 ===========================================================

     В каждой  очерченной части находятся операции с одинако-
вым приоритетом.  Операция имеет приоритет больше, чем опера-
ции из частей, расположенных ниже. Например: a+b*c означает a
+(b*c), так  как * имеет приоритет выше, чем +, а a+b-c озна-
чает (a+b)-c,   поскольку + и - имеют одинаковый приоритет (и
поскольку + левоассоциативен).

                    3.2.1 Круглые скобки

     Скобками синтаксис С++ злоупотребляет; количество спосо-
бов их использования приводит в замешательство:  они применя-
ются для заключения в них параметров в вызовах функций, в них
заключается тип в преобразовании типа (приведении к типу),  в
именах типов для обозначения функций,  а также для разрешения
конфликтов приоритетов.  К счастью,  последнее  требуется  не
слишком часто, потому что уровни приоритета и правила ассоци-
ативности определены таким образом, чтобы выражения "работали
ожидаемым образом" (то есть, отражали наиболее привычный спо-
соб употребления). Например, значение

  if (i<=0 !! max<i) // ...

     очевидно. Тем не менее, всегда, когда программист сомне-
вается относительно этих правил,  следует употреблять скобки,
и некоторые программисты предпочитают немного более длинное и
менее элегантное

  if ( (i<=0) !! (max<i) ) // ...

     При усложнении  подвыражений  употребление скобок стано-
вится более обычным явлением, но сложные подвыражения являют-
ся источником ошибок,  поэтому если вы чувствуете потребность
в скобках,  попробуйте оборвать выражение и использовать  до-

                                    - 75 -
полнительную переменную. Есть и такие случаи, когда приорите-
ты операций не приводят к "очевидному" результату. Например в

  if (i&mask == 0) // ...

     не происходит применения маски mask к  i  и  последующей
проверки результата на ноль. Поскольку == имеет приоритет вы-
ше, чем &, выражение интерпретируется как i&(mask==0). В этом
случае скобки оказываются важны:

  if ((i&mask) == 0) // ...

     Но, с другой стороны, то, что следующее выражение не ра-
ботает так, как может ожидать наивный пользователь, ничего не
значит:

  if (0 <= a <= 99) // ...

     Оно допустимо,   но интерпретируется оно как (0<=a)<=99,
где результат первого подвыражения или 0 или 1, но не a (если
только a не равно 1). Чтобы проверить, лежит ли a в диапазоне
0...99, можно написать

  if (0<=a && a<=99) // ...

                  3.2.2 Порядок вычисления

     Порядок вычисления подвыражений в выражении неопределен.
Например

  int i = 1;
  v[i] = i++;

     может вычисляться или как v[1]=1,  или как v[2]=1.   При
отсутствии ограничений  на порядок вычисления выражения может
генерироваться более хороший код.  Было бы замечательно, если
бы компилятор   предупреждал о подобных неоднозначностях,  но
большинство компиляторов этого не делают.

  Относительно операций && и !! гарантируется, что их левый
операнд вычисляется раньше, чем правый. Например, b=(a=2,a=1)
присвоит b 3.В #3.3.1приводятся примеры использования&& и !!.
Заметьте, что операция следования , (запятая) логически
отличается от запятой, которая используется для разделения
параметров в вызове функции. Рассмотрим

  f1(v[i],i++); // два параметра
  f2( (v[i],i++) ) // один параметр

     В вызове f1 два параметра,  v[i] и i++, и порядок вычис-
ления выражений-параметров неопределен. Зависимость выражения
-параметра от порядка вычисления - это очень плохой стиль,  а
также непереносимо.   В вызове f2 один параметр,  выражение с
запятой, которое эквивалентно i++.

     С помощью скобок нельзя задать порядок вычисления.  Нап-
ример, a*(b/c) может вычисляться и как (a*b)/c, поскольку * и
/ имеют одинаковый приоритет.  В тех случаях, когда важен по-
рядок вычисления,    можно вводить дополнительную переменную,
например, (t=b/c,a*t).

               3.2.3 Увеличение и уменьшение*

--------------------
     * Следовало бы переводить как "инкремент" и "декремент",
однако мы следовали терминологии, принятой в переводной лите-
ратуре по C, поскольку эти операции унаследованы от C. (прим.

                                    - 76 -
перев.)

     Операция ++ используется для явного выражения приращения
вместо его неявного выражения с помощью комбинации сложения и
присваивания. По определению ++lvalue означает lvalue+=1, что
в свою   очередь  означает  lvalue=lvalue+1 при условии,  что
lvalue не вызывает  никаких  побочных  эффектов.   Выражение,
обозначающее (денотирующее)  объект, который должен быть уве-
личен, вычисляется  один раз (только). Аналогично, уменьшение
выражается операцией --. Операции ++ и -- могут применяться и
как префиксные, и как постфиксные. Значением ++x является но-
вое (то есть увеличенное) значение x. Например, y=++x эквива-
лентно y=(x+=1). Значение x++, напротив, есть старое значение
x. Например, y=x++ эквивалентно y=(t=x,x+=1,t), где t - пере-
менная того же типа, что и x.

     Операции приращения особенно полезны  для  увеличения  и
уменьшения переменных в циклах.  Например, оканчивающуюся ну-
лем строку можно копировать так:

  inline void cpy(char* p, const char* q)
  (*
      while (*p++ = *q++) ;
  *)

     Напомню, что увеличение и уменьшение арифметических ука-
зателей, так же как сложение и вычитание указателей, осущест-
вляется в   терминах элементов вектора,  на которые указывает
указатель p++ приводит к тому,  что p указывает на  следующий
элемент. Для   указателя p типа T* по определению выполняется
следующее:

  long(p+1) == long(p)+sizeof(T);

             3.2.4 Побитовые логические операции

  Побитовые логические операции

  & ! ^ ~ >> <<

     применяются к целым,  то  есть  к  объектам  типа  char,
short, int,  long и их unsigned аналогам, результаты тоже це-
лые.

     Одно из стандартных применений побитовых логических опе-
раций -   реализация  маленького множества (вектор битов).  В
этом случае каждый бит беззнакового целого представляет  один
член множества,  а число членов ограничено числом битов.  Би-
нарная операция & интерпретируется как  пересечение,   !  как
объединение, а ^ как разность. Для наименования членов такого
множества можно использовать перечисление. Вот маленький при-
мер, заимствованный   из реализации (не пользовательского ин-
терфейса) <stream.h>:

  enum state_value (* _good=0, _eof=1, _fail=2, _bad=4 *);
                   // хорошо, конец файла, ошибка, плохо

     Определение _good не является необходимым.  Я просто хо-
тел, чтобы  состояние,  когда все в порядке, имело подходящее
имя. Состояние потока можно установить заново следующим обра-
зом:

  cout.state = _good;

     Например, так можно проверить,  не был ли испорчен поток
или допущена операционная ошибка:


                                    - 77 -
  if (cout.state&(_bad!_fail)) // не good

     Еще одни скобки необходимы,  поскольку & имеет более вы-
сокий приоритет, чем !.

     Функция, достигающая конца ввода, может сообщать об этом
так:

  cin.state != _eof;

     Операция !=  используется  потому,   что поток уже может
быть испорчен (то есть, state==_bad), поэтому

  cin.state = _eof;

     очистило бы этот признак.  Различие двух  потоков  можно
находить так:

  state_value diff = cin.state^cout.state;

     В случае типа stream_state (состояние потока) такая раз-
ность не очень нужна,  но для других похожих типов она оказы-
вается самой полезной.  Например,  при сравнении вектора бит,
представляющего множество прерываний, которые обрабатываются,
с другим, представляющим прерывания, ждущие обработки.

     Следует заметить,   что  использование полей (#2.5.1)  в
действительности является сокращенной записью сдвига и маски-
рования для извлечения полей бит из слова. Это, конечно, мож-
но сделать и с помощью побитовых логических операций,  Напри-
мер, извлечь    средние  16  бит  из  32-битового  int  можно
следующим образом:

  unsigned short middle(int a) (* return (a>>8)&0xffff; *)

     Не путайте побитовые логические операции  с  логическими
операциями:

    && !! !

     Последние возвращают 0 или 1,  и они главным образом ис-
пользуются для записи проверки в операторах if, while или for
(#3.3.1). Например, !0 (не ноль) есть значение 1, тогда как ~
0 (дополнение нуля)  есть набор битов  все-единицы,   который
обычно является значением -1.

                  3.2.5 Преобразование типа

     Бывает необходимо явно преобразовать значение одного ти-
па в значение другого.  Явное преобразование типа дает значе-
ние одного типа для данного значения другого типа.  Например:

  float r = float(1);

     перед присваиванием  преобразует целое значение 1 к зна-
чению с плавающей точкой 1.0.  Результат преобразования  типа
не является   lvalue,   поэтому  ему нельзя присваивать (если
только тип не является ссылочным типом).

     Есть два способа записи явного преобразования типа: тра-
диционная в   C запись приведения к типу (double)a и функцио-
нальная запись double(a). Функциональная запись не может при-
меняться для    типов,   которые  не  имеют  простого  имени.
Например, чтобы  преобразовать значение к указательному  типу
надо или использовать запись преобразования типа

  char* p = (char*)0777;

                                    - 78 -

или определить новое имя типа:

  typedef char* Pchar;
  char* p = Pchar(0777);

     По моему мнению,  функциональная запись в  нетривиальных
случаях предпочтительна. Рассмотрим два эквивалентных примера

  Pname n2 = Pbase(n1->tp)->b_name;   //функциональная запись
  Pname n3 = ((Pbase)n2->tp)->b_name;  // запись приведения
                                       // к типу
     Поскольку операция -> имеет больший приоритет,  чем при-
ведение, последнее выражение интерпретируется как

  ((Pbase)(n2->tp))->b_name

     С помощью  явного преобразования типа к указательным ти-
пам можно симитировать,  что объект имеет  совершенно  произ-
вольный тип. Например:

  any_type* p = (any_type*)&some_object;

     позволит работать  посредством  p  с  некоторым объектом
some_object как с любым типом any_type.

     Когда преобразование типа не необходимо, его следует из-
бегать. Программы,  в которых используется много явных преоб-
разований типов,  труднее понимать,  чем те, в которых это не
делается. Однако такие программы легче понимать, чем програм-
мы, просто не использующие типы для представления понятий бо-
лее высокого уровня (например,  программу,  которая оперирует
регистром устройства с помощью сдвига и маскирования,  вместо
того, чтобы    определить подходящую struct и оперировать ею,
см. #2.5.2).   Кроме того, правильность явного преобразования
типа часто  критическим образом зависит от понимания програм-
мистом того,  каким образом объекты различных типов обрабаты-
ваются в   языке,   и очень часто от подробностей реализации.
Например:

  int i = 1;
  char* pc = "asdf";
  int* pi = &i;

  i = (int)pc;
  pc = (char*)i;    // остерегайтесь! значение pc может изме-
                    //ниться
                    // на некоторых машинах
                    // sizeof(int)<sizeof(char*)
  pi = (int*)pc;
  pc = (char*)pi;   // остерегайтесь! значение pc может изме-
                    // ниться
                    // на некоторых машинах char*
                    // представляется иначе, чем int*

     На многих  машинах  ничего плохого не произойдет,  но на
других результаты будут катастрофическими.  Этот код в лучшем
случае непереносим.  Обычно можно без риска предполагать, что
указатели на различные структуры имеют одинаковое представле-
ние. Кроме того, любой указатель можно (без явного преобразо-
вания типа) присвоить void*, а void* можно явно преобразовать
к указателю любого типа.

     В С++  явное преобразование типа оказывается ненужным во
многих случаях, когда C (и другие языки) требуют его. Во мно-
гих программах  явного преобразования типа можно совсем избе-
жать, а  во многих других его применение можно локализовать в

                                    - 79 -
небольшом числе подпрограмм.

                   3.2.6 Свободная память
     Именованный объект является либо статическим, либо авто-
матическим (см.  #2.1.3).  Статический объект размещается  во
время запуска программы и существует в течение всего выполне-
ния программы.  Автоматический объект размещается каждый  раз
при входе в его блок и существует только до тех пор,  пока из
этого блока не вышли. Однако часто бывает полезно создать но-
вый объект, существующий до тех пор, пока он не станет больше
не нужен.  В частности, часто полезно создать объект, который
можно использовать после возврата из функции, где он создает-
ся. Такие  объекты создает операция new, а впоследствии унич-
тожать их можно операцией delete.  Про объекты,  выделенные с
помощью операции new,  говорят,  что они в свободной  памяти.
Такими объектами обычно являются вершины деревьев или элемен-
ты связанных списков,  являющиеся  частью  большей  структуры
данных, размер  которой не может быть известен на стадии ком-
пиляции. Рассмотрим,  как можно было бы написать компилятор в
духе написанного настольного калькулятора.  Функции синтакси-
ческого анализа могут строить древовидное представление выра-
жений, которое  будет использоваться при генерации кода. Нап-
ример:

  struct enode (*
      token_value oper;
      enode* left;
      enode* right;
  *);

  enode* expr()
  (*
  enode* left = term();

  for(;;)
      switch(curr_tok) (*
      case PLUS:
      case MINUS:
          get_token();
          enode* n = new enode;
          n->oper = curr_tok;
          n->left = left;
          n->right = term();
          left = n;
          break;
      default:
          return left;
      *)
  *)

     Получающееся дерево генератор  кода  может  использовать
например так:

  void generate(enode* n)
  (*
      switch (n->oper) (*
      case PLUS:
          // делает нечто соответствующее
          delete n;
      *)
  *)

     Объект, созданный с помощью new,  существует, пока он не
будет явно уничтожен delete, после чего пространство, которое
он занимал, опять может использоваться new. Никакого "сборщи-
ка мусора",  который ищет объекты,  на которые нет ссылок,  и
предоставляет их в распоряжение new, нет. Операция delete мо-

                                    - 80 -
жет применяться   только  к указателю,  который был возвращен
операцией new,  или к нулю. Применение delete к нулю не вызы-
вает никаких действий.

     С помощью  new  можно  также создавать вектора объектов.
Например:

  char* save_string(char* p)
  (*
      char* s = new char[strlen(p)+1];
      strcpy(s,p);
      return s;
  *)

     Следует заметить, что чтобы освободить пространство, вы-
деленное new, delete должна иметь возможность определить раз-
мер выделенного объекта. Например:

  int main(int argc, char* argv[])
  (*
      if (argc < 2) exit(1);
      char* p = save_string(argv[1]);
      delete p;
  *)

     Это приводит к тому,  что объект, выделенный стандартной
реализацией new, будет занимать больше места, чем статический
объект (обычно, больше на одно слово).

     Можно также явно указывать  размер  вектора  в  операции
уничтожения delete. Например:

  int main(int argc, char* argv[])
  (*
      if (argc < 2) exit(1);
      int size = strlen(argv[1])+1;
      char* p = save_string(argv[1]);
      delete[size] p;
  *)

     Заданный пользователем  размер  вектора  игнорируется за
исключением некоторых   типов,   определяемых   пользователем
(#5.5.5).

  Операции свободной памяти реализуются функциями (#с.7.2.3):

  void operator new(long);
  void operator delete(void*);

     Стандартная реализация new не инициализирует  возвращае-
мый объект.

     Что происходит,  когда new не находит памяти для выделе-
ния? Поскольку  даже виртуальная память конечна,  это  иногда
должно происходить. Запрос вроде

  char* p = new char[100000000];

     как правило,  приводит к каким-то неприятностям. Когда у
new ничего не получается,  она вызывает функцию,  указываемую
указателем _new_handler (указатели на функции обсуждаются в #
4.6.9). Вы  можете задать  указатель  явно  или  использовать
функцию set_new_handler(). Например:

  #include <stream.h>

  void out_of_store()

                                    - 81 -
  (*
    cerr << "операция new не прошла: за пределами памяти\n";
    exit(1);
  *)

  typedef void (*PF)(); // тип указатель на функцию

  extern PF set_new_handler(PF);

  main()
  (*
      set_new_handler(out_of_store);
      char* p = new char[100000000];
      cout << "сделано, p = " << long(p) << "\n";
  *)

     как правило,  не будет писать "сделано",  а будет вместо
этого выдавать

    операция new не прошла: за пределами памяти

     Функция _new_handler может делать и кое-что поумней, чем
просто завершать выполнение программы.  Если вы знаете,   как
работают new и delete,  например,  потому, что вы задали свои
собственные operator new() и operator delete(), программа об-
работки может   попытаться найти некоторое количество памяти,
которое возвратит new.  Другими словами,  пользователь  может
сделать сборщик мусора,  сделав, таким образом, использование
delete необязательным.  Но это,  конечно,  все-таки задача не
для начинающего.

     По историческим причинам new просто возвращает указатель
0, если она не может найти достаточное количество памяти и не
был задан никакой _new_handler. Например

  include <stream.h>

  main()
  (*
      char* p = new char[100000000];
      cout << "сделано, p = " << long(p) << "\n";
  *)

выдаст

  сделано, p = 0

     Вам сделали предупреждение! Заметьте, что тот, кто зада-
ет _new_handler,  берет на себя заботу по проверке  истощения
памяти при  каждом использовании new в программе (за исключе-
нием случая,  когда пользователь задал отдельные подпрограммы
для размещения объектов заданных типов,  определяемых пользо-
вателем, см. #5.5.6).

                    3.3 Сводка операторов

     Операторы С++  систематически  и  полностью  изложены  в
#с.9, прочитайте, пожалуйста, этот раздел. А здесь приводится
краткая сводка и некоторые примеры.

                           Синтаксис оператора
   ----------------------------------------------------------
   оператор:
       описание
       (*список_операторов opt*)
       выражение opt


                                    - 82 -
       if оператор
   if ( выражение ) оператор
       if ( выражение ) оператор else оператор
       switch оператор
   switch ( выражение ) оператор

       while ( выражение ) оператор
       do оператор while (выражение)
       for ( оператор выражение opt; выражение opt ) оператор

       case константное_выражение : оператор
       default : оператор
       break ;
       continue ;

       return выражение opt ;

       goto идентификатор ;
       идентификатор : оператор

       список_операторов:
           оператор
           оператор список_операторов

     Заметьте, что  описание  является оператором,  и что нет
операторов присваивания и вызова процедуры.   Присваивание  и
вызов функции обрабатываются как выражения.

                       3.3.1 Проверки

     Проверка значения  может  осуществляться  или оператором
if, или оператором switch:

  if ( выражение ) оператор
  if ( выражение ) оператор else оператор
  switch ( выражение ) оператор

  В С++ нет отдельного булевского типа. Операции сравнения

  == != < <= > >=

     возвращают целое 1,  если сравнение истинно, иначе возв-
ращают 0.  Не так уж непривычно видеть, что ИСТИНА определена
как 1, а ЛОЖЬ определена как 0.

     В операторе if первый (или единственный) оператор выпол-
няется в том случае, если выражение ненулевое, иначе выполня-
ется второй оператор (если он задан).  Отсюда следует,  что в
качестве условия  может использоваться любое целое выражение.
В частности, если a целое, то

  if (a) // ...

эквивалентно

  if (a != 0) // ...

     Логические операции && !! !  наиболее часто используются
в условиях.  Операции && и !! не будут вычислять второй аргу-
мент, если это ненужно. Например:

  if (p && 1<p->count) // ...

     вначале проверяет, является ли p не нулем, и только если
это так, то проверяет 1<p->count.

     Некоторые простые  операторы  if  могут быть с удобством

                                    - 83 -
заменены выражениями арифметического if. Например:

  if (a <= d)
      max = b;
  else
      max = a;

лучше выражается так:

  max = (a<=b) ? b : a;

     Скобки вокруг  условия необязательны,  но я считаю,  что
когда они используются, программу легче читать.

     Некоторые простые операторы switch можно по-другому  за-
писать в виде набора операторов if. Например:

  switch (val) (*
  case 1:
      f();
      break;
  case 2;
      g();
      break;
  default:
      h();
      break;
  *)

иначе можно было бы записать так:

  if (val == 1)
      f();
  else if (val == 2)
      g();
  else
      h();

     Смысл тот же,  однако первый вариант (switch) предпочти-
тельнее, поскольку    в  этом случае явно выражается сущность
действия (сопоставление значения с рядом констант). Поэтому в
нетривиальных случаях оператор switch читается легче.

     Заботьтесь о том,  что switch должен как-то завершаться,
если только вы не хотите,  чтобы выполнялся  следующий  case.
Например:

  switch (val) (* // осторожно
  case 1:
      cout << "case 1\n";
  case 2;
      cout << "case 2\n";
  default:
      cout << "default: case не найден\n";
  *)

при val==1 напечатает

  case 1
  case 2
  default: case не найден

     к великому изумлению непосвященного.  Самый обычный спо-
соб завершить случай - это break, иногда можно даже использо-
вать goto. Например:

  switch (val) (* // осторожно

                                    - 84 -
  case 0:
      cout << "case 0\n";
  case1:
  case 1:
      cout << "case 1\n";
      return;
  case 2;
      cout << "case 2\n";
      goto case1;
  default:
      cout << "default: case не найден\n";
      return;
  *)

  При обращении к нему с val==2 выдаст

  case 2
  case 1

     Заметьте, что метка case не подходит как метка для упот-
ребления в операторе goto:

  goto case 1;       // синтаксическая ошибка

                         3.3.2 Goto

  С++ снабжен имеющим дурную репутацию оператором goto.

  goto идентификатор;
  идентификатор : оператор

     В общем,  в программировании высокого  уровня  он  имеет
очень мало применений,  но он может быть очень полезен, когда
С++ программа генерируется программой,  а не  пишется  непос-
редственно человеком.  Например, операторы goto можно исполь-
зовать в синтаксическом анализаторе,  порождаемом генератором
синтаксических анализаторов.   Оператор goto может быть также
важен в тех редких случаях,  когда важна наилучшая  эффектив-
ность, например,  во внутреннем цикле какой-нибудь программы,
работающей в реальном времени.

     Одно из немногих разумных применений состоит в выходе из
вложенного цикла или переключателя (break лишь прекращает вы-
полнение самого внутреннего охватывающего его цикла  или  пе-
реключателя). Например:

  for (int i = 0; i<n; i++)
      for (int j = 0; j<m; j++)
          if (nm[i][j] == a) goto found // найдено
                                        // не найдено
  // ...

  found:                                // найдено
  // nm[i][j] == a

     Имеется также оператор continue,  который по сути делает
переход на конец оператора цикла, как объясняется в #3.1.5.

               3.4 Комментарии и Выравнивание

     Продуманное использование  комментариев  и согласованное
использование отступов может сделать чтение и понимание прог-
раммы намного более приятным.  Существует несколько различных
стилей согласованного использования отступов.  Автор не видит
никаких серьезных   оснований  предпочесть один другому (хотя
как и у большинства,  у меня есть свои предпочтения). Сказан-
ное относится также и к стилю комментариев.

                                    - 85 -

     Неправильное использование  комментариев  может серьезно
повлиять на удобочитаемость программы, Компилятор не понимает
содержание комментария,  поэтому он никаким способом не может
убедиться в том, что комментарий

  [1] осмыслен,

  [2] описывает программу и

  [3] не устарел.

     Непонятные, двусмысленные и просто неправильные  коммен-
тарии содержатся  в большинстве программ.  Плохой комментарий
может быть хуже, чем никакой.

     Если что-то можно сформулировать средствами самого  язы-
ка, следует  это сделать, а не просто отметить в комментарии.
Данное замечание относится к комментариям вроде:

  // переменная "v" должна быть инициализирована.

  //переменная"v"должна использоваться только функцией "f()".

  // вызвать функцию init() перед вызовом
  // любой другой функции в этом файле.

  // вызовите функцию очистки "cleanup()" в конце вашей
  // программы.

  // не используйте функцию "wierd()".

  // функция "f()" получает два параметра.

     При правильном использовании  С++  подобные  комментарии
как правило становятся ненужными.  Чтобы предыдущие коммента-
рии стали излишними,  можно,  например,  использовать правила
компоновки (#4.2) и видимость, инициализацию и правила очист-
ки для классов (см. #5.5.2).

     Если что-то было ясно сформулировано на  языке,   второй
раз упоминать это в комментарии не следует. Например:

  a = b+c; // a становится b+c
  count++; // увеличить счетчик

     Такие комментарии хуже чем просто излишни,  они увеличи-
вают объем текста,  который надо прочитать, они часто затума-
нивают структуру программы, и они могут быть неправильными.

  Автор предпочитает:

     [1] Комментарий для каждого исходного файла, сообщающий,
для чего в целом предназначены находящиеся в нем комментарии,
дающий ссылки на справочники и руководства,  общие рекоменда-
ции по использованию и т.д.,

     [2] Комментарий для каждой нетривиальной функции,  в ко-
тором сформулировано ее  назначение,   используемый  алгоритм
(если он неочевиден)  и,  быть может,  что-то о принимаемых в
ней предположениях относительно среды выполнения,

     [3] Небольшое число комментариев в тех местах, где прог-
рамма неочевидна и/или непереносима и

     [4] Очень мало что еще.


                                    - 86 -
  Например:

  // tbl.c: Реализация таблицы имен
  /*
      Гауссовское исключение с частичным
      См. Ralston: "A first course ..." стр. 411.
  */

  // swap() предполагает размещение стека AT&T sB20.

  /**************************************

      Copyright (c) 1984 AT&T, Inc.
      All rights reserved

  ****************************************/

     Удачно подобранные и хорошо написанные комментарии - су-
щественная часть   программы.  Написание хороших комментариев
может быть столь же сложным, сколь и написание самой програм-
мы.

     Заметьте также, что если в функции используются исключи-
тельно комментарии //,  то любую часть этой функции можно за-
комментировать с помощью комментариев /* */, и наоборот.

                       3.5 Упражнения

     1. (*1)    Перепишите  следующий  оператор  for  в  виде
эквивалентного оператора while:

       for (i=0; i<max_length; i++)
           if (input_line[i] == '?') quest_count++;

     2. (*1)  Полностью расставьте скобки в следующих выраже-
ниях:

       a = b + c * d << 2 & 8
       a & 077 != 3
       a == b !! a == c && c < 5
       c = x != 0
       0 <= i < 7
       f(1,2)+3
       a = -1 + + b -- - 5
       a = b == c ++
       a = b = c = 0
       a[4][2] *= * b ? c : * d * 2
       a-b,c=d

     3. (*2) Найдите пять различных конструкций С++, значение
которых неопределено.

     4. (*2)  Найдите десять различных примеров непереносимой
С++ программы.

     5. (*1)  Что происходит в вашей системе,  если вы делите
на ноль? Что происходит при переполнении и потере значимости?

     6. (*1)  Полностью расставьте скобки в следующих выраже-
ниях:

       *p++
       *--p
       ++a--
       (int*)p->m
       *p.m
       *a[i]

                                    - 87 -

     7. (*2)  Напишите функции:  strlen(), которая возвращает
длину строки,  strcpy(),  которая копирует одну строку в дру-
гую, и  strcmp(), которая сравнивает две строки. Разберитесь,
какие должны быть типы параметров и типы возвращаемых  значе-
ний, а   потом сравните их со стандартными версиями,  которые
описаны в <string.h> и в вашем руководстве.

     8. (*1)  Посмотрите,  как ваш  компилятор  реагирует  на
ошибки:

       a := b+1;
       if (a = 3) // ...
       if (a&077 == 0) // ...

     Придумайте ошибки попроще,  и посмотрите, как компилятор
на них реагирует.

     9. (*2) Напишите функцию cat(), получающую два строковых
параметра и возвращающую строку,  которая является конкатена-
цией параметров.  Используйте new, чтобы найти память для ре-
зультата. Напишите  функцию rev(),  которая получает строку и
переставляет в ней символы в обратном порядке. То есть, после
вызова rev(p) последний символ p становится первым.

     10. (*2) Что делает следующая программа?

     void send(register* to, register* from, register count)
     // Полезные комментарии несомненно уничтожены.
       (*
           register n=(count+7)/8;
           switch (count%8) (*
               case 0: do (* *to++ = *from++;
               case 7: do (* *to++ = *from++;
               case 6: do (* *to++ = *from++;
               case 5: do (* *to++ = *from++;
               case 4: do (* *to++ = *from++;
               case 3: do (* *to++ = *from++;
               case 2: do (* *to++ = *from++;
               case 1: do (* *to++ = *from++;
                   while (--n>0);
           *)
       *)

     Зачем кто-то мог написать нечто похожее?

     11. (*2) Напишите функцию atoi(), которая получает стро-
ку, содержащую  цифры, и возвращает соответствующее int. Нап-
ример, atoi("123") - это 123. Модифицируйте atoi() так, чтобы
помимо обычной десятичной она обрабатывала еще восьмеричную и
шестнадцатиричную записи С++. Модифицируйте atoi() так, чтобы
обрабатывать запись   символьной константы.  Напишите функцию
itoa(), которая  строит представление целого параметра в виде
строки.

     12. (*2)  Перепишите get_token()  (#3.1.2), чтобы она за
один раз читала строку в буфер,  а затем составляла  лексемы,
читая символы из буфера.

     13. (*2) Добавьте в настольный калькулятор из #3.1 такие
функции, как sqrt(), log() и sin(). Подсказка: предопределите
имена и   вызывайте  функции  с помощью вектора указателей на
функции. Не забывайте проверять параметры в вызове функции.

     14. (*3) Дайте пользователю возможность определять функ-
ции в настольном калькуляторе. Подсказка: определяйте функции
как последовательность действий,  прямо так,  как  их  набрал

                                    - 88 -
пользователь. Такую  последовательность можно хранить или как
символьную строку,  или как список лексем. После этого, когда
функция вызывается,  читайте и выполняйте эти действия.  Если
вы хотите, чтобы пользовательская функция получала параметры,
вы должны придумать форму записи этого.

     15. (*1.5) Преобразуйте настольный калькулятор так, что-
бы вместо статических переменных name_string  и  number_value
использовалась структура символа symbol:

       struct symbol (*
           token_value tok;
           union (*
               double number_value;
               char* name_string;
           *);
       *);

     16. (*2.5)  Напишите программу, которая выбрасывает ком-
ментарии из С++ программы. То есть, читает из cin, удаляет //
и /* */ комментарии и пишет результат в cout. Не заботьтесь о
приятном виде выходного текста (это могло бы быть другим, бо-
лее сложным   упражнением).   Не  беспокойтесь о правильности
программ. Остерегайтесь  // и /* и  */  внутри  комментариев,
строк и символьных констант.

     17. (*2) Посмотрите какие-нибудь программы, чтобы понять
принцип различных стилей комментирования и выравнивания,  ко-
торые используются на практике.

                                    - 89 -

Глава 4
Функции и Файлы

                               Итерация свойственна человеку,
                                        рекурсия божественна.
                                              - Л. Питер Дойч

     Все нетривиальные  программы  собираются  из  нескольких
раздельно компилируемых единиц (их  принято  называть  просто
файлами). В этой главе описано, как раздельно откомпилирован-
ные функции могут обращаться друг к другу,  как такие функции
могут совместно   пользоваться данными (разделять данные),  и
как можно обеспечить согласованность типов, которые использу-
ются в разных файлах программы.  Функции обсуждаются довольно
подробно. Сюда входят передача параметров, параметры по умол-
чанию, перегрузка имен функций, и, конечно же, описание и оп-
ределение функций. В конце описываются макросы.

                        4.1 Введение

     Иметь всю программу в  одном  файле  обычно  невозможно,
поскольку коды   стандартных библиотек и операционной системы
находятся где-то в другом месте.  Кроме того,   хранить  весь
текст пользовательской   программы  в одном файле как правило
непрактично и неудобно.  Способ организации программы в файлы
может помочь   читающему охватить всю структуру программы,  а
также может  дать  возможность  компилятору  реализовать  эту
структуру. Поскольку единицей компиляции является файл, то во
всех случаях,  когда в файл вносится изменение (сколь бы мало
оно ни было),  весь файл нужно компилировать заново. Даже для
программы умеренных размеров время, затрачиваемое на переком-
пиляцию, можно  значительно снизить с помощью разбиения прог-
раммы на файлы подходящих размеров.

     Рассмотрим пример с калькулятором.  Он был представлен в
виде одного исходного файла. Если вы его набили, то у вас на-
верняка были небольшие трудности с расположением  описаний  в
правильном порядке,   и пришлось использовать по меньшей мере
одно "фальшивое" описание,  чтобы компилятор смог  обработать
взаимно рекурсивные функции expr(), term() и prim(). В тексте
уже отмечалось, что программа состоит из четырех частей (лек-
сического анализатора,    программы  синтаксического разбора,
таблицы имен и драйвера),  но это никак не  было  отражено  в
тексте самой программы. По сути дела, калькулятор был написан
по-другому. Так  это не делается; даже если в этой  программе
"на выброс"  пренебречь всеми соображениями методологии прог-
раммирования, эксплуатации  и эффективности компиляции, автор
все равно   разобьет  эту  программу в 200 строк на несколько
файлов, чтобы программировать было приятнее.

     Программа, состоящая из нескольких раздельно компилируе-
мых файлов,  должна быть согласованной в смысле использования
имен и типов, точно так же, как и программа, состоящая из од-
ного исходного файла. В принципе, это может обеспечить и ком-
поновщик*. Компоновщик  - это программа,  стыкующая  отдельно
скомпилированные части вместе.  Компоновщик часто (путая) на-
зывают загрузчиком. В UNIX'е компоновщик называется ld. Одна-
ко компоновщики, имеющиеся в большинстве систем, обеспечивают
очень слабую поддержку проверки согласованности.

--------------------
* или линкер. (прим. перев.)

     Программист может  скомпенсировать  недостаток поддержки
со стороны компоновщика,  предоставив дополнительную информа-
цию о типах (описания). После этого согласованность программы
обеспечивается проверкой согласованности  описаний,   которые

                                    - 90 -
находятся в отдельно компилируемых частях.  Средства, которые
это обеспечивают,  в вашей системе будут. С++ разработан так,
чтобы способствовать такой явной компоновке*.

--------------------
     * C разработан так,  чтобы в большинстве случаев  позво-
лять осуществлять неявную компоновку.  Применение C,  однако,
возросло неимоверно, поэтому случаи, когда можно использовать
неявную линковку,  сейчас составляют незначительное меньшинс-
тво. (прим. автора)

                       4.2 Компоновка

     Если не указано иное,  то имя,  не являющееся  локальным
для функции или класса, в каждой части программы, компилируе-
мой отдельно, должно относиться к одному и тому же типу, зна-
чению, функции  или объекту.  То есть, в программе может быть
только один нелокальный тип,  значение,  функция или объект с
этим именем. Рассмотрим, например, два файла:

  // file1.c:
      int a = 1;
      int f() (* /* что-то делает */ *)

  // file2.c:
      extern int a;
      int f();
      void g() (* a = f(); *)

     a и f(),  используемые g()  в файле file2.c,- те же, что
определены в  файле file1.c.  Ключевое слово extern (внешнее)
указывает, что  описание a в file2.c является (только) описа-
нием, а не определением. Если бы a инициализировалось, extern
было бы просто проигнорировано,  поскольку описание с инициа-
лизацией всегда   является  определением.  Объект в программе
должен определяться только один раз.   Описываться  он  может
много раз, но типы должны точно согласовываться. Например:

  // file1.c:
      int a = 1;
      int b = 1;
      extern int c;

  // file2.c:
      int a;
      extern double b;
      extern int c;

     Здесь три  ошибки:  a определено дважды (int a; является
определением, которое  означает int a=0;), b описано дважды с
разными типами, а c описано дважды, но не определено. Эти ви-
ды ошибок не могут быть обнаружены компилятором,  который  за
один раз видит только один файл.  Компоновщик, однако, их об-
наруживает.

     Следующая программа не является С++ программой  (хотя  C
программой является):

  // file1.c:
      int a;
      int f() (* return a; *)

  // file2.c:
      int a;
      int g() (* return f(); *)

     Во-первых, file2.c не С++, потому что f() не была описа-

                                    - 91 -
на, и  поэтому компилятор будет недоволен.  Во-вторых, (когда
file2.c фиксирован) программа не будет скомпонована, посколь-
ку a определено дважды.

     Имя можно сделать локальным в файле,  описав его static.
Например:

  // file1.c:
      static int a = 6;
      static int f() (* /* ... */ *)

  // file2.c:
      static int a = 7;
      static int f() (* /* ... */ *)

     Поскольку каждое a и f описано как static,  получающаяся
в результате программа является правильной.  В  каждом  файле
своя a и своя f().

     Когда переменные  и  функции  явно  описаны  как static,
часть программы легче понять (вам не надо никуда больше  заг-
лядывать). Использование    static для функций может,  помимо
этого, выгодно влиять на расходы по вызову функции, поскольку
дает оптимизирующему компилятору более простую работу.

  Рассмотрим два файла:

  // file1.c:
      const int a = 6;
      inline int f() (* /* ... */ *)
      struct s (* int a,b; *)

  // file1.c:
      const int a = 7;
      inline int f() (* /* ... */ *)
      struct s (* int a,b; *)

     Раз правило "ровно одно определение" применяется к конс-
тантам, inline-функциям  и определениям функций так же,   как
оно применяется к функциям и переменным, то file1.c и file2.c
не могут быть частями одной С++ программы.  Но если это  так,
то как   же  два файла могут использовать одни и те же типы и
константы? Коротко, ответ таков: типы, константы и т.п. могут
определяться столько раз, сколько нужно, при условии, что они
определяются одинаково.  Полный ответ несколько более  сложен
(это объясняется в следующем разделе).

                   4.3 Заголовочные Файлы

     Типы во  всех  описаниях одного и того же объекта должны
быть согласованными. Один из способов это достичь мог бы сос-
тоять в обеспечении средств проверки типов в компоновщике, но
большинство компоновщиков - образца 1950-х, и их нельзя изме-
нить по  практическим соображениям*.  Другой подход состоит в
обеспечении того,  что исходный текст,  как он передается  на
рассмотрение компилятору, или согласован, или содержит инфор-
мацию, которая позволяет компилятору обнаружить несогласован-
ности. Один несовершенный, но простой способ достичь согласо-
ванности состоит во включении заголовочных файлов, содержащих
интерфейсную информацию,  в исходные файлы,  в которых содер-
жится исполняемый код и/или определения данных.

--------------------
     * Легко изменить один компоновщик, но сделав это и напи-
сав программу,  которая зависит от усовершенствований, как вы
будете переносить эту программу в другое место?  (прим. авто-
ра)

                                    - 92 -
     Механизм включения с помощью #include - это  чрезвычайно
простое средство  обработки текста для сборки кусков исходной
программы в одну единицу (файл)  для ее компиляции. Директива

  #include "to_be_included"

     замещает строку,  в которой встретилось #include, содер-
жимым файла "to_be_included".  Его содержимым должен быть ис-
ходный текст на С++, поскольку дальше его будет читать компи-
лятор. Часто   включение обрабатывается отдельной программой,
называемой C препроцессором,  которую команда CC вызывает для
преобразования исходного  файла,  который дал программист,  в
файл без директив включения перед тем,  как начать собственно
компиляцию. В  другом варианте эти директивы обрабатывает ин-
терфейсная система компилятора по мере того, как они встреча-
ются в исходном тексте.  Если программист хочет посмотреть на
результат директив включения,  можно воспользоваться командой

  CC -E file.c

     для препроцессирования файла file.c точно также, как это
сделала бы   CC  перед  запуском собственно компилятора.  Для
включения файлов из стандартной директории  включения  вместо
кавычек используются угловые скобки < и >. Например:

  #include <stream.h>  //из стандартной директории включения
  #define "myheader.h" // из текущей директории

     Использование <> имеет то преимущество,  что в программу
фактическое имя   директории  включения  не встраивается (как
правило, сначала просматривается /usr/include/CC, а потом usr
/include). К  сожалению,  пробелы в директиве include сущест-
венны:

  #include < stream.h > // не найдет <stream.h>

     Может показаться, что перекомпилировать файл заново каж-
дый раз,   когда он куда-либо включается,  расточительно,  но
время компиляции такого файла обычно слабо отличается от вре-
мени, которое необходимо для чтения его некоторой заранее от-
компилированной формы. Причина в том, что текст программы яв-
ляется довольно компактным представлением программы, и в том,
что включаемые файлы обычно содержат только описания и не со-
держат программ,  требующих от компилятора значительного ана-
лиза.

     Следующее эмпирическое правило относительно  того,   что
следует, а  что не следует помещать в заголовочные файлы, яв-
ляется не требованием языка,  а просто предложением по разум-
ному использованию аппарата #include.

  В заголовочном файле могут содержаться:

    Определения типов struct point (* int x, y; *)
    Описания функций extern int strlen(const char*);
  Определения inline-функ-й inline char get()(*return *p++;*)
    Описания данных extern int a;
    Определения констант const float pi = 3.141593
    Перечисления enum bool (* false, true *);
    Директивы include #include <signal.h>
    Определения макросов #define Case break;case
    Комментарии /* проверка на конец файла */

но никогда

    Определения обычных функций char get() (* return *p++; *)
    Определения данных int a;

                                    - 93 -
    Определения сложных константных объектов const tbl[]=(*/*
    ... */ *)

     В системе UNIX принято,  что  заголовочные  файлы  имеют
суффикс (расширение) .h. Файлы, содержащие определение данных
или функций, должны иметь суффикс .c. Такие файлы часто назы-
вают, соответственно,  ".h файлы" и ".c файлы". В #4.7 описы-
ваются макросы.  Следует заметить,  что в С++ макросы гораздо
менее полезны,   чем в C,  поскольку С++ имеет такие языковые
конструкции, как  const для определения констант и inline для
исключения расходов на вызов функции.

     Причина того,   почему в заголовочных файлах допускается
определение простых констант,  но не допускается  определение
сложных константных   объектов,  прагматическая.  В принципе,
сложность тут только в том, чтобы сделать допустимым дублиро-
вание определений  переменных (даже определения функций можно
было бы дублировать). Однако для компоновщиков старого образ-
ца слишком   трудно  проверять  тождественность нетривиальных
констант и убирать ненужные повторы. Кроме того, простые слу-
чаи гораздо более обиходны и потому более важны для генерации
хорошего кода.

                4.3.1 Один Заголовочный Файл

     Проще всего решить проблему разбиения программы на  нес-
колько файлов  поместив функции и определения данных в подхо-
дящее число исходных файлов и описав типы, необходимые для их
взаимодействия, в одном заголовочном файле, который включает-
ся во все остальные файлы.  Для программы калькулятора  можно
использовать четыре .c файла: lex.c, syn.c, table.c и main.c,
и заголовочный файл dc.h,  содержащий описания всех имен, ко-
торые используются более чем в одном .c файле:

  // dc.h: общие описания для калькулятора

  enum token_value (*
      NAME, NUMBER, END,
      PLUS='+', MINUS='-', MUL='*', DIV='/',
      PRINT=';', ASSIGN='=', LP='(', RP=')'
  *);

  extern int no_of_errors;
  extern double error(char* s);
  extern token_value get_token();
  extern token_value curr_tok;
  extern double number_value;
  extern char name_string[256];

  extern double expr();
  extern double term();
  extern double prim();

  struct name (*
      char* string;
      name* next;
      double value;
  *);

  extern name* look(char* p, int ins = 0);
  inline name* insert(char* s) (* return look(s,1); *)

     Если опустить фактический код,  то lex.c будет выглядеть
примерно так:

  // lex.c: ввод и лексический анализ
  #include "dc.h"

                                    - 94 -
  #include <ctype.h>

  token_value curr_tok;
  double number_value;
  char name_string[256];

  token_value get_token() (* /* ... */ *)

     Заметьте, что  такое  использование  заголовочных файлов
гарантирует, что  каждое описание в заголовочном файле объек-
та, определенного    пользователем,   будет в какой-то момент
включено в файл,  где он определяется. Например, при компиля-
ции lex.c компилятору будет передано:

  extern token_value get_token();
  // ...
  token_value get_token() (* /* ... */ *)

     Это обеспечивает то,  что компилятор обнаружит любую не-
согласованность в типах,  указанных для имени. Например, если
бы get_token()  была описана как возвращающая token_value, но
при этом определена как возвращающая int, компиляция lex.c не
прошла бы изза ошибки несоответствия типов.

  Файл syn.c будет выглядеть примерно так:

  // syn.c: синтаксический анализ и вычисление

  #include "dc.h"

  double prim() (* /* ... */ *)
  double term() (* /* ... */ *)
  double expr() (* /* ... */ *)

  Файл table.c будет выглядеть примерно так:

  // table.c: таблица имен и просмотр

  #include "dc.h"

  extern char* strcmp(const char*, const char*);
  extern char* strcpy(char*, const char*);
  extern int strlen(const char*);

  const TBLSZ = 23;
  name* table[TBLSZ];

  name* look(char* p; int ins) (* /* ... */ *)

     Заметьте, что table.c сам описывает стандартные  функции
для работы со строками,  поэтому никакой проверки согласован-
ности этих описаний нет.  Почти всегда лучше включать заголо-
вочный файл,    чем описывать имя в .c файле как extern.  При
этом может включаться "слишком много",  но это обычно не ока-
зывает серьезного влияния на время,  необходимое для компиля-
ции, и  как правило экономит время программиста.  В  качестве
примера этого,  обратите внимание на то,  как strlen() заново
описывается в main() (ниже). Это лишние нажатия клавиш и воз-
можный источник неприятностей,  поскольку компилятор не может
проверить согласованность этих двух определений. На самом де-
ле, этой  сложности можно было бы избежать, будь все описания
extern помещены в dc.h, как и предлагалось сделать. Эта "неб-
режность" сохранена в программе,  поскольку это очень типично
для C программ, очень соблазнительно для программиста, и чаще
приводит, чем  не приводит, к ошибкам, которые трудно обнару-
жить, и к программам, с которыми тяжело работать. Вас предуп-
редили!

                                    - 95 -
  И main.c, наконец, выглядит так:

  // main.c: инициализация, главный цикл и обработка ошибок

  #include "dc.h"

  int no_of_errors;

  double error(char* s) (* /* ... */ *)

  extern int strlen(const char*);

  main(int argc, char* argv[]) (* /* ... */ *)

     Важный случай,   когда размер заголовочных файлов стано-
вится серьезной   помехой.   Набор  заголовочных   файлов   и
библиотеку можно использовать для расширения языка множеством
обще- и специальноприкладных типов (см.  Главы 5-8).  В таких
случаях не принято осуществлять чтение тысяч строк заголовоч-
ных файлов в начале каждой компиляции. Содержание этих файлов
обычно "заморожено" и изменяется очень нечасто.  Наиболее по-
лезным может оказаться метод затравки компилятора содержанием
этих заголовочных фалов. По сути, создается язык специального
назначения со своим собственным компилятором.  Никакого стан-
дартного метода   создания  такого компилятора с затравкой не
принято.

           4.3.2 Множественные Заголовочные Файлы

     Стиль разбиения программы с  одним  заголовочным  файлом
наиболее пригоден  в тех случаях,  когда программа невелика и
ее части не предполагается использовать отдельно. Поэтому то,
что невозможно   установить,  какие описания зачем помещены в
заголовочный файл,  несущественно.  Помочь могут комментарии.
Другой способ   -  сделать так,  чтобы каждая часть программы
имела свой заголовочный файл,  в котором определяются предос-
тавляемые этой   частью средства.  Тогда каждый .c файл имеет
соответствующий .h файл, и каждый .c файл включает свой собс-
твенный (специфицирующий то,  что в нем задается)  .h файл и,
возможно, некоторые  другие .h файлы (специфицирующие то, что
ему нужно).

     Рассматривая организацию калькулятора,  мы замечаем, что
error() используется  почти каждой функцией программы, а сама
использует только <stream.h>.  Это обычная для функции ошибок
ситуация, поэтому error() следует отделить от main():

  // error.h: обработка ошибок

  extern int no_errors;

  extern double error(char* s);

  // error.c

  #include <stream.h>
  #include "error.h"

  int no_of_errors;

  double error(char* s) (* /* ... */ *)

     При таком  стиле  использования  заголовочных  файлов .h
файл и связанный с ним .c файл можно  рассматривать  как  мо-
дуль, в   котором .h файл задает интерфейс,  а .c файл задает
реализацию.
     Таблица символов не зависит от остальной части калькуля-

                                    - 96 -
тора за  исключением использования функции ошибок.  Это можно
сделать явным:

  // table.h: описания таблицы имен

  struct name (*
      char* string;
      name* next;
      double value;
  *);

  extern name* look(char* p, int ins = 0);
  inline name* insert(char* s) (* return look(s,1); *)

  // table.c: определения таблицы имен

  #include "error.h"
  #include <string.h>
  #include "table.h"

  const TBLSZ = 23;
  name* table[TBLSZ];

  name* look(char* p; int ins) (* /* ... */ *)

     Заметьте, что описания функций работы со строками теперь
включаются из   <string.h>.  Это исключает еще один возможный
источник ошибок.

  // lex.h: описания для ввода и лексического анализа

  enum token_value (*
      NAME, NUMBER, END,
      PLUS='+', MINUS='-', MUL='*', DIV='/',
      PRINT=';', ASSIGN='=', LP='(', RP=')'
  *);

  extern token_value curr_tok;
  extern double number_value;
  extern char name_string[256];

  extern token_value get_token();

     Этот интерфейс лексического анализатора достаточно  бес-
порядочен. Недостаток  в надлежащем типе лексемы обнаруживает
себя в необходимости давать пользователю get_token()   факти-
ческие лексические буферы number_value и name_string.

  // lex.c: определения для ввода и лексического анализа

  #include <stream.h>
  #include <ctype.h>
  #include "error.h"
  #include "lex.h"

  token_value curr_tok;
  double number_value;
  char name_string[256];

  token_value get_token() (* /* ... */ *)

     Интерфейс синтаксического анализатора совершенно прозра-
чен:
  // syn.c: описания для синтаксического анализа и вычисления

  extern double expr();
  extern double term();

                                    - 97 -
  extern double prim();

  // syn.c: определения для синтаксического анализа и
  // вычисления

  #include "error.h"
  #include "lex.h"
  #include "syn.h"

  double prim() (* /* ... */ *)
  double term() (* /* ... */ *)
  double expr() (* /* ... */ *)

  Главная программа, как всегда, тривиальна:

  // main.c: главная программа

  #include <stream.h>
  #include "error.h"
  #include "lex.h"
  #include "syn.h"
  #include "table.h"
  #include <string.h>

  main(int argc, char* argv[]) (* /* ... */ *)

     Сколько заголовочных  файлов  использовать  в программе,
зависит от многих факторов.  Многие из этих факторов  сильнее
связаны с тем, как ваша система работает с заголовочными фай-
лами, нежели  с С++.  Например,  если в вашем  редакторе  нет
средств, позволяющих    одновременно видеть несколько файлов,
использование большого числа файлов становится менее  привле-
кательным. Аналогично,  если открывание и чтение 10 файлов по
50 строк в каждом требует заметно больше времени,  чем чтение
одного файла в 500 строк,  вы можете дважды подумать,  прежде
чем использовать в небольшом проекте стиль множественных  за-
головочных файлов. Слово предостережения: набор из десяти за-
головочных файлов плюс стандартные заголовочные файлы  обычно
легче поддаются управлению. С другой стороны, если вы разбили
описания в большой программе на логически минимальные по раз-
меру заголовочные  файлы (помещая каждое описание структуры в
свой отдельный файл и т.д.), у вас легко может получиться не-
разбериха из сотен файлов.

                    4.3.3 Сокрытие Данных

     Используя заголовочные  файлы пользователь может опреде-
лять явный интерфейс,  чтобы обеспечить согласованное исполь-
зование типов   в программе.  С другой стороны,  пользователь
может обойти интерфейс, задаваемый заголовочным файлом, вводя
в .c файлы описания extern.

  Заметьте, что такой стиль компоновки не рекомендуется:

  // file1.c: // "extern" не используется
      int a = 7;
      const c = 8;
      void f(long) (* /* ... */ *)

  // file2.c: // "extern" в .c файле
      extern int a;
      extern const c;
      extern f(int);
      int g() (* return f(a+c); *)

     Поскольку описания extern в file2.c не включаются вместе
с определениями  в файле file1.c,  компилятор не может прове-

                                    - 98 -
рить согласованность этой  программы.   Следовательно,   если
только загрузчик  не окажется гораздо сообразительнее средне-
го, две  ошибки в этой программе останутся, и их придется ис-
кать программисту.

     Пользователь может  защитить файл от такой недисциплини-
рованной компоновки,  описав имена,  которые не предназначены
для общего пользования,  как static,  чтобы их областью види-
мости был файл,  и они были скрыты от остальных частей  прог-
раммы. Например:

  // table.c: определения таблицы имен

  #include "error.h"
  #include <string.h>
  #include "table.h"

  const TBLSZ = 23;
  static name* table[TBLSZ];

  name* look(char* p; int ins) (* /* ... */ *)

     Это гарантирует,  что любой доступ к table действительно
будет осуществляться именно через look(). "Прятать" константу
TBLSZ не обязательно.

                    4.4 Файлы как Модули

     В предыдущем разделе .c и  .h  файлы  вместе  определяли
часть программы.   Файл .h является интерфейсом,  который ис-
пользуют другие части программы,  .c файл задает  реализацию.
Такой объект   часто  называют  модулем.  Доступными делаются
только те имена,  которые необходимо знать пользователю,  ос-
тальные скрыты. Это качество часто называют сокрытием данных,
хотя данные - лишь часть того,  что может быть скрыто. Модули
такого вида обеспечивают большую гибкость. Например, реализа-
ция может состоять из одного или более .c файлов, и в виде .h
файлов может быть предоставлено несколько интерфейсов. Инфор-
мация, которую  пользователю знать не  обязательно,   искусно
скрыта в  .c файлах.  Если важно,  что пользователь не должен
точно знать,  что содержится в .c файлах,  не надо делать  их
доступными в исходом виде. Достаточно эквивалентных им выход-
ных файлов компилятора (.o файлов).

     Иногда возникает сложность,  состоящая в том, что подоб-
ная гибкость  достигается без формальной структуры.  Сам язык
не распознает такой модуль как объект,  и у  компилятора  нет
возможности отличить  .h файлы,  определяющие имена,  которые
должны использовать другие модули  (экспортируемые),   от  .h
файлов, которые описывают имена из других модулей (импортиру-
емые).

     В других случаях может возникнуть та проблема,  что  мо-
дуль определяет множество объектов, а не новый тип. Например,
модуль table определяет одну таблицу,  и если вам  нужно  две
таблицы, то  нет простого способа задать вторую таблицу с по-
мощью понятия модуля. Решение этой проблемы приводится в Гла-
ве 5.

     Каждый статически размещенный объект по умолчанию иници-
ализируется нулем,      программист   может   задать   другие
(константные) значения. Это только самый примитивный вид ини-
циализации. К  счастью,  с помощью классов можно задать  код,
который выполняется  для инициализации перед тем,  как модуль
какимлибо образом используется, и/или код, который запускает-
ся для   очистки  после последнего использования модуля,  см.
#5.5.2.

                                    - 99 -
                 4.5 Как Создать Библиотеку

     Фразы типа "помещен в библиотеку" и "ищется  в  какой-то
библиотеке" используются часто (и в этой книге,  и в других),
но что это означает для С++ программы? К сожалению, ответ за-
висит от   того,   какая операционная система используется; в
этом разделе объясняется,  как создать библиотеку в 8-ой вер-
сии системы   UNIX.  Другие системы предоставляют аналогичные
возможности.

     Библиотека в своей основе является множеством .o файлов,
полученных в результате компиляции соответствующего множества
.c файлов. Обычно имеется один или более .h файлов, в которых
содержатся описания  для использования этих .o файлов.  В ка-
честве примера рассмотрим  случай,   когда  нам  надо  задать
(обычным способом) набор математических функций для некоторо-
го неопределенного множества пользователей. Заголовочный файл
мог бы выглядеть примерно так:

  extern double sqrt(double); // подмножество <math.h>
  extern double sin(double);
  extern double cos(double);
  extern double exp(double);
  extern double log(double);

     а определения этих функций хранились бы, соответственно,
в файлах sqrt.c, sin.c, cos.c, exp.c и log.c.

  Библиотеку с именем math.h можно создать, например, так:

  $ CC -c sqrt.c sin.c cos.c exp.c log.c
  $ ar cr math.a sqrt.o sin.o cos.o exp.o log.o
  $ ranlib math.a

     Вначале исходные файлы компилируются в эквивалентные  им
объектные файлы. Затем используется команда ar, чтобы создать
архив с именем math.a.  И,  наконец, этот архив индексируется
для ускорения доступа. Если в вашей системе нет ranlib коман-
ды, значит  она вам,  вероятно,  не понадобится.  Подробности
посмотрите, пожалуйста, в вашем руководстве в разделе под за-
головком ar. Использовать библиотеку можно, например, так:

  $ CC myprog.c math.a

     Теперь разберемся,  в чем же преимущества  использования
math.a перед   просто непосредственным использованием .o фай-
лов? Например:

  $ CC myprog.c sqrt.o sin.o cos.o exp.o log.o

     Для большинства программ определить правильный набор  .o
файлов, несомненно,  непросто. В приведенном выше примере они
включались все,  но если функции в myprog.c  вызывают  только
функции sqrt() и cos(), то кажется, что будет достаточно

  $ CC myprog.c sqrt.o cos.o

Но это не так, поскольку cos.c использует sin.c.

     Компоновщик, вызываемый  командой  CC  для  обработки .a
файла (в данном случае, файла math.a) знает, как из того мно-
жества, которое использовалось для создания .a файла, извлечь
только необходимые .o файлы.

     Другими словами,  используя  библиотеку  можно  включать
много определений с помощью одного имени (включения определе-
ний функций и переменных, используемых внутренними функциями,

                                    - 100 -
никогда не видны пользователю),  и,  кроме того,  обеспечить,
что в результате в программу будет включено минимальное коли-
чество определений.

                         4.6 Функции

     Обычный способ  сделать  что-либо  в С++ программе - это
вызвать функцию,  которая это делает. Определение функции яв-
ляется способом   задать  то,   как должно делаться некоторое
действие. Функция не может быть вызвана, пока она не описана.

                   4.6.1 Описания Функций

     Описание функции задает имя функции,  тип  возвращаемого
функцией значения (если таковое есть) и число и типы парамет-
ров, которые должны быть в вызове функции. Например:

  extern double sqrt(double);
  extern elem* next_elem();
  extern char* strcpy(char* to, const char* from);
  extern void exit(int);

     Семантика передачи параметров идентична семантике иници-
ализации. Проверяются типы параметров, и когда нужно произво-
дится неявное преобразование типа. Например, если были заданы
предыдущие определения, то

  double sr2 = sqrt(2);

     будет правильно обращаться к функции sqrt() со значением
с плавающей точкой 2.0. Значение такой проверки типа и преоб-
разования типа огромно.

     Описание функции может содержать имена параметров.   Это
может помочь читателю, но компилятор эти имена просто игнори-
рует.

                  4.6.2 Определения Функций

     Каждая функция, вызываемая в программе, должна быть где-
то определена   (только один раз).  Определение функции - это
описание функции,  в котором приводится тело функции.  Напри-
мер:

  extern void swap(int*, int*); // описание

  void swap(int*, int*) // определение
  (*
      int t = *p;
      *p =*q;
      *q = t;
  *)

     Чтобы избежать расходов на вызов функции,  функцию можно
описать как inline (#1.12),  а чтобы обеспечить более быстрый
доступ к параметрам, их можно описать как register (#2.3.11).
Оба средства  могут использоваться неправильно,  и их следует
избегать везде где есть какие-либо сомнения в их  полезности.

                  4.6.3 Передача Параметров

     Когда вызывается функция,  дополнительно выделяется  па-
мять под  ее формальные параметры,  и каждый формальный пара-
метр инициализируется соответствующим ему  фактическим  пара-
метром. Семантика    передачи  параметров идентична семантике
инициализации. В частности, тип фактического параметра сопос-
тавляется с   типом формального параметра,  и выполняются все

                                    - 101 -
стандартные и определенные пользователем  преобразования  ти-
пов. Есть    особые  правила  для передачи векторов (#4.6.5),
средство передавать  параметр  без  проверки  типа  параметра
(#4.6.8) и    средство  для  задания  параметров по умолчанию
(#4.6.6). Рассмотрим

  void f(int val, int& ref)
  (*
      val++;
      ref++;
  *)

     Когда вызывается f(),  val++ увеличивает локальную копию
первого фактического  параметра,  тогда как ref++ увеличивает
второй фактический параметр. Например:

  int i = 1;
  int j = 1;
  f(i,j);

     увеличивает j,  но не i. Первый параметр - i, передается
по значению,  второй параметр - j,  передается по ссылке. Как
уже отмечалось в #2.3.10,  использование функций, которые из-
меняют переданные по ссылке параметры, могут сделать програм-
му трудно читаемой,  и их следует избегать (но  см.   #6.5  и
#8.4). Однако  передача большого объекта по ссылке может быть
гораздо эффективнее,  чем передача его по значению.   В  этом
случае параметр можно описать как const,  чтобы указать,  что
ссылка применяется по соображениям  эффективности,   а  также
чтобы не  позволить вызываемой функции изменять значение объ-
екта:

  void f(const large& arg)
  (*
      // значение "arg" не может быть изменено
  *)

     Аналогично, описание параметра указателя как const сооб-
щает читателю, что значение объекта, указываемого указателем,
функцией не изменяется. Например:

  extern int strlen(const char*); // из <string.h>
  extern char* strcpy(char* to, const char* from);
  extern int strcmp(const char*, const char*);

  Важность такой практики возрастает с размером программы.

     Заметьте, что  семантика  передачи параметров отлична от
семантики присваивания.  Это важно для const параметров, ссы-
лочных параметров и параметров некоторых типов,  определяемых
пользователем (#6.6).

                   4.6.4 Возврат Значения

     Из функции,  которая не описана как void, можно (и долж-
но) возвращать  значение. Возвращаемое значение задается опе-
ратором return. Например:

  int fac(int n) (*return (n>1) ? n*fac(n-1) : 1; *)

В функции может быть больше одного оператора return:
  int fac(int n)
  (*
      if (n > 1)
          return n*fac(n-1);
      else
          return 1;

                                    - 102 -
  *)

     Как и семантика передачи параметров,  семантика возврата
функцией значения идентична семантике инициализации.  Возвра-
щаемое значение  рассматривается как инициализатор переменной
возвращаемого типа.  Тип возвращаемого выражения  проверяется
на согласованность   с  возвращаемым  типом и выполняются все
стандартные и определенные пользователем  преобразования  ти-
пов. Например:

  double f()
  (*
      // ...
      return 1; // неявно преобразуется к double(1)
  *)

     Каждый раз,   когда вызывается функция,  создается новая
копия ее параметров и автоматических переменных.  После возв-
рата из  функции память используется заново,  поэтому возвра-
щать указатель на локальную переменную неразумно.  Содержание
указываемого места изменится непредсказуемо:

  int* f() (*
      int local = 1;
      // ...
      return &local; // так не делайте
  *)

     Эта ошибка  менее  обычна,  чем эквивалентная ошибка при
использовании ссылок:

  int& f() (*
      int local = 1;
      // ...
      return local; // так не делайте
  *)

     К счастью,  о таких возвращаемых значениях предупреждает
компилятор. Вот другой пример:

  int& f() (* return 1;*) // так не делайте

                  4.6.5 Векторные Параметры

     Если в  качестве  параметра функции используется вектор,
то передается указатель на его первый элемент. Например:

  int strlen(const char*);

  void f()
  (*
      char v[] = "a vector"
      strlen(v);
      strlen("Nicholas");
  *);

     Иначе говоря,   при  передаче как параметр параметр типа
T[] преобразуется к T*.  Следовательно, присваивание элементу
векторного параметра изменяет значение элемента вектора,  ко-
торый является параметром. Другими словами, вектор отличается
от всех  остальных типов тем,  что вектор не передается (и не
может передаваться) по значению.

     Размер вектора недоступен вызываемой функции.  Это может
быть неудобно, но эту сложность можно обойти несколькими спо-
собами. Строки  оканчиваются нулем,  поэтому их размер  можно
легко вычислить.  Для других векторов можно передавать второй

                                    - 103 -
параметр, который задает размер, или определить тип, содержа-
щий указатель   и  индикатор  длины,  и передавать его вместо
просто вектора (см. также #1.11). Например:

  void compute1(int* vec_ptr, int vec_size); // один способ

  struct vec (* // другой способ
      int* ptr;
      int size;
  *);

  void compute2(vec v);

     С многомерными  массивами  все  хитрее,   но часто можно
вместо них использовать векторы указателей, которые не требу-
ют специального рассмотрения. Например:

  char* day[] = (*
      "mon", "tue", "wed", "thu", "fri", "sat", "sun"
  *);

     С другой стороны,  рассмотрим определение функции, кото-
рая работает с двумерными матрицами. Если размерность извест-
на на стадии компиляции, то никаких проблем нет:

  void print_m34(int m[3][4])
  (*
      for (int i = 0; i<3; i++) (*
          for (int j = 0; j<4; j++)
              cout << " " << m[i][j];
          cout << "\n";
      *)
  *)

     Матрица, конечно,  все равно передается как указатель, а
размерности используются просто для удобства записи.

     Первая размерность  массива  не имеет отношения к задаче
поиска положения элемента (#2.3.6).  Поэтому ее можно переда-
вать как параметр:

  void print_mi4(int m[][4], int dim1)
  (*
      for (int i = 0; i<dim1; i++) (*
          for (int j = 0; j<4; j++)
              cout << " " << m[i][j];
          cout << "\n";
      *)
  *)

     Сложный случай возникает,  когда  нужно  передавать  обе
размерности. "Очевидное решение" просто не работает:

  void print_mij(int m[][], int dim1, int dim2) // ошибка
  (*
      for (int i = 0; i<dim1; i++) (*
          for (int j = 0; j<dim2; j++)
              cout << " " << m[i][j]; // сюрприз!
          cout << "\n";
      *)
  *)

     Во-первых, описание параметра m[][]  недопустимо,   пос-
кольку для нахождения положения элемента должна быть известна
вторая размерность многомерного массива. Во-вторых, выражение
m[i][j] интерпретируется (правильно)  как *(*(m+i)+j), но не-
похоже, чтобы это имел в виду программист. Вот правильное ре-

                                    - 104 -
шение:

  void print_mij(int** m, int dim1, int dim2)
  (*
      for (int i = 0; i<dim1; i++) (*
          for (int j = 0; j<dim2; j++)
              cout << " " << (int*)m[i*dim2+j]; // туманно
          cout << "\n";
      *)
  *)

     Выражение, которое применяется для доступа к  элементам,
эквивалентно тому,   которое генерирует компилятор,  когда он
знает последнюю размерность. Чтобы немного прояснить програм-
му, можно ввести дополнительную переменную:

  int* v = (int*)m;
  // ...
  v[i*dim2+j]

                4.6.6 Параметры по Умолчанию

     Часто в  самом общем случае функции требуется больше па-
раметров, чем в самом простом и более употребительном случае.
Например, в  библиотеке потоков есть функция hex(), порождаю-
щая строку с шестнадцатиричным представлением целого.  Второй
параметр используется   для задания числа символов для предс-
тавления первого параметра.  Если число символов слишком мало
для представления целого, происходит усечение, если оно слиш-
ком велико,  то строка дополняется пробелами.  Часто програм-
мист не заботится о числе символов, необходимых для представ-
ления целого, поскольку символов достаточно. Поэтому для нуля
в качестве   второго параметра определено значение "использо-
вать столько символов, сколько нужно". Чтобы избежать засоре-
ния программы   вызовами вроде hex(i,0),  функция описывается
так:

  extern char* hex(long, int =0);

     Инициализатор второго параметра является  параметром  по
умолчанию. То есть, если в вызове дан только один параметр, в
качестве второго используется параметр по умолчанию.   Напри-
мер:

  cout << "**" << hex(31) << hex(32,3) << "**";

интерпретируется как

  cout << "**" << hex(31,0) << hex(32,3) << "**";

и напечатает:

  ** 1f 20**

     Параметр по  умолчанию  проходит  проверку типа во время
описания функции и вычисляется во время ее вызова.   Задавать
параметр по  умолчанию возможно только для последних парамет-
ров, поэтому

  int f(int, int =0, char* =0); // ok
  int g(int =0, int =0, char*); // ошибка
  int f(int =0, int, char* =0); // ошибка

     Заметьте, что в этом контексте пробел между * и =  явля-
ется существенным (*= является операцией присваивания):

  int nasty(char*=0); // синтаксическая ошибка

                                    - 105 -
                4.6.7 Перегрузка Имен Функций

     Как правило, давать разным функциям разные имена - мысль
хорошая, но  когда некоторые функции выполняют одинаковую ра-
боту над объектами разных типов, может быть более удобно дать
им одно и то же имя. Использование одного имени для различных
действий над     различными   типами  называется  перегрузкой
(overloading). Метод уже используется для основных операций С
++: у  сложения существует только одно имя,  +,  но его можно
применять для сложения значений целых, плавающих и указатель-
ных типов.  Эта идея легко расширяется на обработку операций,
определенных пользователем,  то есть,  функций. Чтобы уберечь
программиста от   случайного  повторного использования имени,
имя может использоваться более чем для одной  функции  только
если оно сперва описано как перегруженное имя функции. Напри-
мер:

  overload print;
  void print(int);
  void print(char*);

     Что касается компилятора,  единственное общее, что имеют
функции с одинаковым именем, это имя. Предположительно, они в
каком-то смысле похожи,  но в этом язык ни стесняет  програм-
миста, ни  помогает ему.  Таким образом,  перегруженные имена
функций - это главным образом удобство записи.  Это  удобство
значительно в   случае  функций с общепринятыми именами вроде
sqrt, print  и open.  Когда имя семантически значимо, как это
имеет место  для операций вроде +,  * и << (#6.2)  и в случае
конструкторов (#5.2.4 и #6.3.1),  это удобство становится су-
щественным. Когда   вызывается перегруженная f(),  компилятор
должен понять,  к какой из функций с именем f  следует  обра-
титься. Это  делается путем сравнения типов фактических пара-
метров с типами формальных параметров всех функций  с  именем
f. Поиск функции, которую надо вызвать, осуществляется за три
отдельных шага:

     [1] Искать функцию соответствующую точно, и использовать
ее, если она найдена,

     [2] Искать  соответствующую функцию используя встроенные
преобразования и использовать любую найденную функцию и

     [3] Искать соответствующую функцию используя  преобразо-
вания, определенные   пользователем (#6.3),  и если множество
преобразований единственно, использовать найденную функцию.

  Например:

  overload print(double), print(int);

  void f();
  (*
      print(1);
      print(1.0);
  *)

     Правило точного соответствия гарантирует,  что f напеча-
тает 1   как целое и 1.0 как число с плавающей точкой.  Ноль,
char или short точно  соответствуют  параметру.   Аналогично,
float точно соответствует double.

     К параметрам  функций с перегруженными именами стандарт-
ные С++ правила неявного преобразования типа (#с.6.6)  приме-
няются не полностью.  Преобразования,  могущие уничтожить ин-
формацию, не  выполняются. Остаются int в long, int в double,
ноль в long,  ноль в double и преобразования указателей: пре-

                                    - 106 -
образование ноль в указатель void*,  и указатель на производ-
ный класс в указатель на базовый класс (#7.2.4).

  Вот пример, в котором преобразование необходимо:

  overload print(double), print(long);

  void f(int a);
  (*
      print(a);
  *)

     Здесь a может быть напечатано или как double,   или  как
long. Неоднозначность  разрешается явным преобразованием типа
(или print(long(a)) или print(double(a))).

     При этих правилах можно гарантировать,  что когда эффек-
тивность или   точность вычислений для используемых типов су-
щественно различаются,  будет использоваться простейший алго-
ритм (функция). Например:

  overload pow;
  int pow(int, int);
  double pow(double, double); // из <math.h>
  complex pow(double, complex); // из <complex.h>
  complex pow(complex, int);
  complex pow(complex, double);
  complex pow(complex, complex);

     Процесс поиска  подходящей функции игнорирует unsigned и
const.

              4.6.8 Незаданное Число Параметров

     Для некоторых функций невозможно задать число и тип всех
параметров, которые    можно ожидать в вызове.  Такую функцию
описывают завершая  список  описаний  параметров  многоточием
(...), что  означает "и может быть,  еще какие-то неописанные
параметры". Например:

  int printf(char* ...);

     Это задает,  что в вызове printf должен быть по  меньшей
мере один параметр,  char*, а остальные могут быть, а могут и
не быть. Например:

  printf("Hello, world\n");
  printf("Мое имя %s %s\n", first_name, second_name);
  printf("%d + %d = %d\n",2,3,5);

     Такая функция полагается на информацию,  которая  недос-
тупна компилятору  при интерпретации ее списка параметров.  В
случае printf()  первым параметром является  строка  формата,
содержащая специальные последовательности символов, позволяю-
щие printf()  правильно обрабатывать остальные параметры.  %s
означает "жди параметра char*",  а %d означает "жди параметра
int". Однако,  компилятор этого не знает, поэтому он не может
убедиться в том,  что ожидаемые параметры имеют соответствую-
щий тип. Например:
  printf("Мое имя %s %s\n",2);

     откомпилируется и в лучшем случае приведет  к  какой-ни-
будь странного вида выдаче.
     Очевиднще хуже, каждый вызов функции с
автоматическим объектом  класса включает по меньшей мере один
вызов программ выделения и освобождения свободной памяти. Это
сделало бы   также невозможным реализацию inline-функций чле-

                                    - 107 -
нов, которые  обращаются к данным закрытой части. Более того,
такое изменение сделает невозможным совместную компоновку C и
С++ программ (поскольку C компилятор обрабатывает  struct  не
так, как  это будет делать С++ компилятор).  Для С++ это было
сочтено неприемлемым.

                   5.3.2 Законченный Класс

     Программирование без  сокрытия  данных  (с   применением
структур) требует меньшей продуманности, чем программирование
со сокрытием данных (с  использованием  классов).   Структуру
можно определить не слишком задумываясь о том, как ее предпо-
лагается использовать. А когда определяется класс, все внима-
ние сосредотачивается  на обеспечении нового типа полным мно-
жеством операций;   это  важное  смещение  акцента.    Время,
потраченное на   разработку  нового типа,  обычно многократно
окупается при разработке и тестировании программы.

     Вот пример законченного типа intset,  который  реализует
понятие "множество целых":

  class intset (*
      int cursize, maxsize;
      int *x;
  public:
      intset(int m, int n); // самое большее, m int'ов в 1..n
      ~intset();

      int member(int t); // является ли t элементом?
      void insert(int t); // добавить "t" в множество

      void iterate(int& i) (* i = 0; *)
      int ok(int& i) (* return i<cursize; *)
      int next(int& i) (* return x[i++]; *)
  *);

     Чтобы протестировать этот класс,  можно создать и распе-
чатать множество случайных целых чисел. Такое множество могло
бы быть результатом розыгрыша лотереи.  Это простое множество
можно также  использовать для проверки последовательности це-
лых на повторы.  Но для большинства приложений тип  множество
должен быть немного более проработанным. Как всегда, возможны
ошибки:

  #include <stream.h>

  void error(char* s)
  (*
      cerr << "set: " << s << "\n";
      exit(1);
  *)

     Класс intset используется в main(), которая предполагает
два целых  параметра.  Первый параметр задает число случайных
чисел, которые нужно сгенерировать. Второй параметр указывает
диапазон, в котором должны лежать случайные целые:

  main(int argc, char* argv[])
  (*
      if (argc != 3) error("ожидается два параметра");
      int count = 0;
      int m = atoi(argv[1]); // число элементов множества
      int n = atoi(argv[2]); // в диапазоне 1..n
      intset s(m,n);

      while (count<m) (*
          int t = randint(n);

                                    - 108 -
          if (s.member(t)==0) (*
              s.insert(t);
              count++;
          *)
      *)

      print_in_order(&s);
  *)

     В программе,  для которой требуется два параметра, счет-
чик числа параметров, argc, должен равняться трем, потому что
имя программы всегда передается как argv[0]. Функция

  extern int atoi(char*);

     функция atoi()  это стандартная библиотечная функция для
преобразования представления целого в виде строки в его внут-
реннюю (двоичную)  форму.  Случайные числа генерируются с по-
мощью стандартной функции rand():

  extern int rand(); // Не очень случайные, будьте осторожны

  int randint(int u) // в диапазоне 1..u
  (*
      int r = rand();
      if (r < 0) r = -r;
      return 1 + r%u ;
  *)

     Подробности реализации класса  должны  представлять  для
пользователя весьма незначительный интерес,  но здесь в любом
случае будут функции члены. Конструктор выделяет целый вектор
заданного максимального размера множества, а деструктор осво-
бождает его:

  intset::intset(int m, int n)//самое большее,m int'ов в 1..n
  (*
      if (m<1 !! n<m) error("недопустимый размер intset");
      cursize = 0;
      maxsize = m;
      x = new int[maxsize];
  *)

  intset::~intset()
  (*
      delete x;
  *)

     Целые числа вставляются,  поэтому они хранятся в возрас-
тающем порядке:

  void intset::insert(int t)
  (*
   if (++cursize > maxsize) error("слишком много элементов");
   int i = cursize-1;
   x[i] = t;

   while (i>0 && x[i-1]>x[i]) (*
       int t = x[i]; // переставить x[i] и [i-1]
       x[i] = x[i-1];
       x[i-1] = t;
       i--;
   *)
  *)

     Для нахождения членов используется просто  двоичный  по-
иск:

                                    - 107 -
  int intset::member(int t) // двоичный поиск
  (*
      int l = 0;
      int u = cursize-1;

      while (l <= u) (*
          int m = (l+u)/2;
          if (t < x[m])
              u = m-1;
          else if (t > x[m])
              l = m+1;
          else
              return 1; // найдено
      *)
      return 0; // не найдено
  *)

     И, наконец,  нам нужно  обеспечить  множество  операций,
чтобы пользователь мог осуществлять цикл по множеству в неко-
тором порядке, поскольку представление intset от пользователя
скрыто. Множество внутренней упорядоченности не имеет, поэто-
му мы не можем просто дать возможность обращаться  к  вектору
(завтра я,  наверное, реализую intset по-другому, в виде свя-
занного списка).

     Дается три функции:  iterate()  для инициализации итера-
ции, ok()   для проверки, есть ли следующий элемент, и next()
для того, чтобы взять следующий элемент:

  class intset (*
      // ...
      void iterate(int& i) (* i = 0; *)
      int ok(int& i) (* return i<cursize; *)
      int next(int& i) (* return x[i++]; *)
  *);

     Чтобы дать возможность этим трем операциям работать сов-
местно и чтобы запомнить,  куда дошел цикл, пользователь дол-
жен дать целый параметр. Поскольку элементы хранятся в отсор-
тированном списке,  их реализация тривиальна.   Теперь  можно
определить функцию печати по порядку print_in_order:

  void print_in_order(intset* set)
  (*
      int var;
      set->iterate(var);
      while (set->ok(var)) cout << set->next(var) << "\n";
  *)

Другой способ задать итератор приводится в #6.8.

                  5.4 Друзья и Объединения

     В это разделе описываются еще некоторые особенности, ка-
сающиеся классов. Показано, как предоставить функции не члену
доступ к закрытым членам. Описывается, как разрешать конфлик-
ты имен членов,  как можно делать вложенные описания классов,
и как избежать нежелательной вложенности.  Обсуждается также,
как объекты класса могут совместно использовать члены данные,
и как использовать указатели на члены.  Наконец,   приводится
пример, показывающий, как построить дискриминирующее (эконом-
ное) объединение.

                        5.4.1 Друзья
     Предположим, вы определили два класса,  vector и  matrix
(вектор и матрица). Каждый скрывает свое представление и пре-
доставляет полный набор действий  для  манипуляции  объектами

                                    - 110 -
его типа.    Теперь определим функцию,  умножающую матрицу на
вектор. Для простоты допустим, что в векторе четыре элемента,
которые индексируются 0...3, и что матрица состоит из четырех
векторов, индексированных 0...3. Допустим также, что доступ к
элементам вектора осуществляется через функцию elem(),  кото-
рая осуществляет проверку индекса,  и что  в  matrix  имеется
аналогичная функция.   Один подход состоит в определении гло-
бальной функции multiply()  (перемножить)  примерно следующим
образом:

  vector multiply(matrix& m, vector& v);
  (*
      vector r;
      for (int i = 0; i<3; i++) (* // r[i] = m[i] * v;
          r.elem(i) = 0;
          for (int j = 0; j<3; j++)
              r.elem(i) += m.elem(i,j) * v.elem(j);
      *)
      return r;
  *)

     Это своего рода "естественный" способ, но он очень неэф-
фективен. При  каждом обращении к multiply() elem() будет вы-
зываться 4*(1+4*3) раза.

     Теперь, если мы сделаем multiply() членом класса vector,
мы сможем обойтись без проверки индексов при обращении к эле-
менту вектора,  а если мы сделаем multiply()   членом  класса
matrix, то мы сможем обойтись без проверки индексов при обра-
щении к элементу матрицы.  Однако членом двух классов функция
быть не   может.   Нам нужно средство языка,  предоставляющее
функции право доступа к закрытой части  класса.   Функция  не
член, получившая право доступа к закрытой части класса, назы-
вается другом класса  (friend).   Функция  становится  другом
класса после описания как friend. Например:

  class matrix;

  class vector (*
      float v[4];
      // ...
      friend vector multiply(matrix&, vector&);
  *);

  class matrix (*
      vector v[4];
      // ...
      friend vector multiply(matrix&, vector&);
  *);

     Функция друг не имеет никаких особенностей, помимо права
доступа к закрытой части класса.  В частности, friend функция
не имеет  указателя this (если только она не является полноп-
равным членом функцией).  Описание friend - настоящее  описа-
ние. Оно вводит имя функции в самой внешней области видимости
программы и сопоставляется с другими описаниями этого  имени.
Описание друга может располагаться или в закрытой, или в отк-
рытой части описания класса. Где именно, значения не имеет.

     Теперь можно написать функцию умножения, которая исполь-
зует элементы векторов и матрицы непосредственно:

  vector multiply(matrix& m, vector& v);
  (*
      vector r;
      for (int i = 0; i<3; i++) (* // r[i] = m[i] * v;
          r.v[i] = 0;

                                    - 111 -
          for (int j = 0; j<3; j++)
              r.v[i] += m.v[i][j] * v.v[j];
      *)
      return r;
  *)

     Есть способы преодолеть эту конкретную  проблему  эффек-
тивности не     используя   аппарат  friend  (можно  было  бы
определить операцию   векторного   умножения   и   определить
multiply() с  ее помощью). Однако существует много задач, ко-
торые проще всего решаются,  если есть возможность  предоста-
вить доступ к закрытой части класса функции, которая не явля-
ется членом этого класса.  В  Главе  6  есть  много  примеров
применения friend.  Достоинства функций друзей и членов будут
обсуждаться позже.

     Функция член одного класса может  быть  другом  другого.
Например:

  class x (*
      // ...
      void f();
  *);

  class y (*
      // ...
      friend void x::f();
  *);

     Нет ничего необычного в том, что все функции члены одно-
го класса являются друзьями другого.  Для этого есть даже бо-
лее краткая запись:

  class x (*
      friend class y;
      // ...
  *);

     Такое описание friend делает все функции члены класса  y
друзьями x.

                5.4.2 Уточнение* Имени Члена

--------------------
     * Иногда называется также квалификацией.  (прим. перев.)

     Иногда полезно делать явное различие между именами  чле-
нов класса и прочими именами. Для этого используется операция
::, "разрешения области видимости":
                                      
                                      
                                      
                                      
                                      
                                      
                                      
                                      
                             
                             
                             
                             
                             
                             
                             
                             
                             
                                      

                                    - 112 -
  class x (*
      int m;
  public:
      int readm() (* return x::m; *)
      void setm(int m) (* x::m = m; *)
  *);

     В x::setm()   имя  параметра  m  прячет член m,  поэтому
единственный способ сослаться на член - это использовать  его
уточненное имя   x::m.  Операнд в левой части ::  должен быть
именем класса.

     Имя с префиксом ::  (просто) должно быть глобальным име-
нем. Это  особенно полезно для того, чтобы можно было исполь-
зовать часто употребимые имена вроде read,  put  и  open  как
имена функций членов, не теряя при этом возможности обращать-
ся к той версии функции,  которая не является членом.
Например:

  class my_file (*
      // ...
  public:
      int open(char*, char*);
  *);

  int my_file::open(char* name, char* spec)
  (*
     // ...
     if (::open(name,flag))(*//использовать open() из UNIX(2)
         // ...
     *)
     // ...
  *)

                   5.4.3 Вложенные Классы

  Описание класса может быть вложенным. Например:

  class set (*
      struct setmem (*
          int mem;
          setmem* next;
          setmem(int m, setmem* n) (* mem=m; next=n; *)
      *);
      setmem* first;
  public:
      set() (* first=0; *)
      insert(int m) (* first = new setmem(m,first);*)
      // ...
  *);

     Если только вложенный класс не является очень простым, в
таком описании трудно разобраться. Кроме того, вложение клас-
сов - это не более чем соглашение о записи, поскольку вложен-
ный класс не является скрытым в области видимости  лексически
охватывающего класса:

  class set (*
      struct setmem (*
          int mem;
          setmem* next;
          setmem(int m, setmem* n)
      *);
      // ...
  *);

      setmem::setmem(int m, setmem* n) (* mem=m, next=n*)

                                    - 113 -
      setmem m1(1,0);
     Такая запись,  как set::setmem::setmem(), не является ни
необходимой, ни  допустимой.  Единственный способ скрыть  имя
класса - это сделать это с помощью метода файлы-как-модули (#
4.4). Большую  часть нетривиальных  классов  лучше  описывать
раздельно:

  class setmem (*
  friend class set; // доступ только с помощью членов set
      int mem;
      setmem* next;
      setmem(int m, setmem* n) (* mem=m; next=n; *)
      *);

  class set (*
      setmem* first;
  public:
      set() (* first=0; *)
      insert(int m) (* first = new setmem(m,first);*)
      // ...
  *);

                   5.4.4 Статические Члены

     Класс - это тип,  а не объект данных, и в каждом объекте
класса имеется   своя собственная копия данных,  членов этого
класса. Однако некоторые типы наиболее элегантно реализуются,
если все   объекты  этого  типа  могут совместно использовать
(разделять) некоторые  данные.  Предпочтительно,  чтобы такие
разделяемые данные  были описаны как часть класса.  Например,
для управления задачами в операционной системе или в ее моде-
ли часто бывает полезен список всех задач:

  class task (*
      // ...
      task* next;
      static task* task_chain;
      void shedule(int);
      void wait(event);
      // ...
  *);

     Описание члена task_chain (цепочка  задач)   как  static
обеспечивает, что он будет всего лишь один, а не по одной ко-
пии на каждый объект task.  Он все равно остается  в  области
видимости класса   task,  и "извне" доступ к нему можно полу-
чить, только если он был описан как public. В этом случае его
имя должно уточняться именем его класса:

  task::task_chain

     В функции   члене   на   него   можно  ссылаться  просто
task_chain. Использование статических членов класса может за-
метно снизить потребность в глобальных переменных.

                  5.4.5 Указатели на Члены

     Можно брать адрес члена класса. Получение адреса функции
члена часто бывает полезно,  поскольку те цели и причины, ко-
торые приводились   в #4.6.9 относительно указателей на функ-
ции, в  равной степени применимы и к функциям членам. Однако,
на настоящее время в языке имеется дефект: невозможно описать
выражением тип указателя,  который  получается  в  результате
этой операции.  Поэтому в текущей реализации приходится жуль-
ничать, используя трюки. Что касается примера, который приво-
дится ниже,  то не гарантируется,  что он будет работать. Ис-
пользуемый трюк надо локализовать, чтобы программу можно было

                                    - 114 -
преобразовать с использованием соответствующей языковой конс-
трукции, когда  появится такая возможность. Этот трюк исполь-
зует тот факт,  что в текущей реализации this реализуется как
первый (скрытый) параметр функции члена*:
--------------------
     * Более  поздние  версии С++ поддерживают понятие указа-
тель на член:  cl::* означает "указатель на член класса  cl".
Например:

  typedef void (cl::*PROC)(int);
  PROC pf1 = &cl::print;    // приведение к типу ненужно
  PROC pf2 = &cl::print;

     Для вызовов через указатель на функцию член используются
операции . и ->. Например:

  (z1.*pf1)(2);
  ((&z2)->*pf2)(4);

(прим. автора)

  #include <stream.h>

  struct cl
  (*
      char* val;
      void print(int x) (* cout << val << x << "\n"; *);
      cl(char* v) (* val = v; *)
  *);

  // ``фальшивый'' тип для функций членов:
  typedef void (*PROC)(void*, int);

  main()
  (*
      cl z1("z1 ");
      cl z2("z2 ");
      PROC pf1 = PROC(&z1.print);
      PROC pf2 = PROC(&z2.print);
      z1.print(1);
      (*pf1)(&z1,2);
      z2.print(3);
      (*pf2)(&z2,4);
  *)

     Во многих  случаях  можно  воспользоваться  виртуальными
функциями (см.  Главу 7) там, где иначе пришлось бы использо-
вать указатели на функции.

                5.4.6 Структуры и Объединения

     По определению struct - это просто класс,  все члены ко-
торого открытые, то есть

  struct s (* ...

есть просто сокращенная запись

  class s (* public: ...

     Структуры используются в тех  случаях,   когда  сокрытие
данных неуместно.

     Именованное объединение определяется как struct, в кото-
рой все члены имеют один и тот же адрес (см. #с.8.5.13). Если
известно, что  в каждый момент времени нужно только одно зна-
чение из структуры,  то объединение может  сэкономить  прост-

                                    - 115 -
ранство. Например,  можно определить объединение для хранения
лексических символов C компилятора:
  union tok_val (*
      char* p; // строка
      char v[8]; // идентификатор (максимум 8 char)
      long i; // целые значения
      double d; // значения с плавающей точкой
  *);

     Сложность состоит в том,  что компилятор, вообще говоря,
не знает, какой член используется в каждый данный момент, по-
этому надлежащая проверка типа невозможна. Например:

  void strange(int i)
  (*
      tok_val x;
      if (i)
          x.p = "2";
      else
          x.d = 2;
      sqrt(x.d); // ошибка если i != 0
  *)

     Кроме того,   объединение,   определенное так,  как это,
нельзя инициализировать. Например:

                                    
                                    - 116 -

Глава 5
Классы

                                    Эти типы не "абстрактны",
                       они столь же реальны, как int и float.
                                              - Дуг МакИлрой

     В этой  главе  описываются возможности определения новых
типов в С++,  для которых доступ к данным ограничен  заданным
множеством функций доступа. Объясняются способы защиты струк-
туры данных,  ее инициализации,  доступа к ней и, наконец, ее
уничтожения. Примеры    содержат  простые классы для работы с
таблицей имен, манипуляции стеком, работу с множеством и реа-
лизацию дискриминирующего (то есть, "надежного") объединения.
Две следующие главы дополнят описание возможностей  определе-
ния новых  типов в С++ и познакомят читателя еще с некоторыми
интересными примерами.

               5.1 Знакомство и Краткий Обзор

     Предназначение понятия класса,  которому посвящены эта и
две последующие   главы,   состоит в том,  чтобы предоставить
программисту инструмент для создания новых типов,   столь  же
удобных в обращении сколь и встроенные типы. В идеале тип оп-
ределяемый пользователем, способом использования должен отли-
чаться от встроенных типов, только способом создания.

     Тип есть  конкретное  представление  некоторой концепции
(понятия). Например, имеющийся в С++ тип float с его операци-
ями +,  -,  * и т.д. обеспечивает ограниченную, но конкретную
версию математического понятия действительного числа.   Новый
тип создается  для того,  чтобы дать специальное и конкретное
определение понятия,  которому ничто прямо и  очевидно  среди
встроенных типов не отвечает.  Например, в программе, которая
работает с телефоном,  можно было бы создать тип trunk_module
(элемент линии),    а  в  программе  обработки  текстов - тип
list_of_paragraphs (список параграфов). Как правило, програм-
му, в которой создаются типы, хорошо отвечающие понятиям при-
ложения, понять  легче, чем программу, в которой это не дела-
ется. Хорошо    выбранные  типы,  определяемые пользователем,
делают программу более четкой и короткой. Это также позволяет
компилятору обнаруживать недопустимые использования объектов,
которые в противном случае останутся необнаруженными до  тес-
тирования программы.

     В определении нового типа основная идея - отделить несу-
щественные подробности реализации (например,  формат  данных,
которые используются   для хранения объекта типа)  от тех ка-
честв, которые  существенны для его правильного использования
(например, полный список функций, которые имеют доступ к дан-
ным). Такое  разделение можно описать  так,   что  работа  со
структурой данных и внутренними административными подпрограм-
мами осуществляется через специальный интерфейс  (канализиру-
ется).

     Эта глава  состоит из четырех практически отдельных час-
тей:

     #5.2 Классы и Члены.  Этот раздел  знакомит  с  основным
понятием типа, определяемого пользователем, который называет-
ся класс (class).  Доступ к объектам класса  может  ограничи-
ваться набором функций, которые описаны как часть этого клас-
са. Такие  функции  называются  функциями  членами.   Объекты
класса создаются и инициализируются функциями членами, специ-
ально для этой цели описанными.  Эти функции называются конс-
трукторами. Функция  член может быть специальным образом опи-
сана для   "очистки"  каждого  классового  объекта  при   его

                                    - 117 -
уничтожении. Такая функция называется деструктором.

     #5.3 Интерфейсы и Реализации.  В этом разделе приводится
два примера того,  как класс проектируется, реализуется и ис-
пользуется.

     #5.4 Друзья  и  Объединения.   В этом разделе приводится
много дополнительных подробностей,  касающихся классов. В нем
показано, как    предоставить  доступ к закрытой части класса
функции, которая не является членом этого класса. Такая функ-
ция называется друг (friend).  В этом разделе показано также,
как определить дискриминирующее объединение.

     #5.5 Конструкторы и Деструкторы. Объект может создавать-
ся как автоматический, статический или как объект в свободной
памяти. Объект может также быть членом некоторой совокупности
(типа вектора или класса),  которая в свою очередь может раз-
мещаться одним из этих трех способов.  Довольно подробно объ-
ясняется использование конструкторов и деструкторов.

                     5.2 Классы и Члены

     Класс - это определяемый пользователем тип.  Этот раздел
знакомит с основными средствами определения класса,  создания
объекта класса, работы с такими объектами и, наконец, уничто-
жения таких объектов после использования.

                     5.2.1 Функции Члены

     Рассмотрим реализацию  понятия  даты  с   использованием
struct для  того,  чтобы определить представление даты date и
множества функций для работы с переменными этого типа:

  struct date (* int month, day, year; *);
      // дата: месяц, день, год *)
  date today;
  void set_date(date*, int, int, int);
  void next_date(date*);
  void print_date(date*);
  // ...

     Никакой явной связи между функциями и типом данных  нет.
Такую связь можно установить, описав функции как члены:

  struct date (*
      int month, day, year;

  void set(int, int, int);
  void get(int*, int*, int*);
  void next();
  void print();
  *);

     Функции, описанные таким образом,  называются  функциями
членами и  могут вызываться только для специальной переменной
соответствующего типа с использованием стандартного синтакси-
са для доступа к членам структуры. Например:

  date today; // сегодня
  date my_burthday; // мой день рождения

  void f()
  (*
      my_burthday.set(30,12,1950);
      today.set(18,1,1985);

      my_burthday.print();

                                    - 118 -
      today.next();
  *)

     Поскольку разные  структуры  могут иметь функции члены с
одинаковыми именами, при определении функции члена необходимо
указывать имя структуры:

  void date::next()
  (*
      if ( ++day > 28 ) (*
          // делает сложную часть работы
      *)
  *)

     В функции члене имена членов  могут  использоваться  без
явной ссылки  на объект.  В этом случае имя относится к члену
того объекта, для которого функция была вызвана.

                        5.2.2 Классы

     Описание date в  предыдущем  подразделе  дает  множество
функций для работы с date,  но не указывает,  что эти функции
должны быть единственными для доступа к объектам  типа  date.
Это ограничение можно наложить используя вместо struct class:

  class date (*
      int month, day, year;
  public:
      void set(int, int, int);
      void get(int*, int*, int*);
      void next();
      void print();
  *);

     Метка public:  делит тело класса на две части.  Имена  в
первой, закрытой части, могут использоваться только функциями
членами. Вторая,  открытая часть, составляет интерфейс к объ-
екту класса.  Struct - это просто class, у которого все члены
классы открытые, поэтому функции члены определяются и исполь-
зуются точно так же, как в предыдущем случае. Например:

  void date::ptinr() // печатает в записи, принятой в США
  (*
      cout << month << "/" << day << "/" year;
  *)

     Однако функции не члены отгорожены от использования зак-
рытых членов класса date. Например:

  void backdate()
  (*
      today.day--; // ошибка
  *)

     В том, что доступ к структуре данных ограничен явно опи-
санным списком   функций,  есть несколько преимуществ.  Любая
ошибка, которая  приводит к тому, что дата принимает недопус-
тимое значение (например,  Декабрь 36, 1985) должна быть выз-
вана кодом функции члена,  поэтому первая стадия отладки, ло-
кализация, выполняется    еще  до  того,  как программа будет
запущена. Это  частный случай общего утверждения,  что  любое
изменение в поведении типа date может и должно вызываться из-
менениями в его членах. Другое преимущество - это то, что по-
тенциальному пользователю  такого типа нужно будет только уз-
нать определение   функций  членов,    чтобы   научиться   им
пользоваться.


                                    - 119 -
     Защита закрытых  данных связана с ограничением использо-
вания имен членов класса.  Это можно обойти с помощью манипу-
ляции адресами, но это уже, конечно, жульничество.

                    5.2.3 Ссылки на Себя

     В функции члене на члены объекта,  для которого она была
вызвана, можно ссылаться непосредственно. Например:

  class x (*
     int m;
     public:
     int readm() (* return m; *)
  *);

  x aa;
  x bb;

  void f()
     (*
     int a = aa.readm();
     int b = bb.readm();
     // ...
  *)

     В первом вызове члена member()  m относится к aa.m, а во
втором - к bb.m.

     Указатель на объект,  для которого вызвана функция член,
является скрытым параметром функции. На этот неявный параметр
можно ссылаться  явно как на this.  В каждой функции класса x
указатель this неявно описан как

     x* this;

     и инициализирован так,  что он указывает на объект,  для
которого была вызвана функция член. this не может быть описан
явно, так как это ключевое слово. Класс x можно эквивалентным
образом описать так:

     class x (*
     int m;
     public:
     int readm() (* return this->m; *)
     *);

     При ссылке на члены использование this излишне.  Главным
образом this используется при написании функций членов, кото-
рые манипулируют непосредственно указателями. Типичный пример
этого - функция, вставляющая звено в дважды связанный список:

  class dlink (*
     dlink* pre;         // предшествующий
     dlink* suc;         // следующий
     public:
     void append(dlink*);
     // ...
  *);

  void dlink::append(dlink* p)
     (*
     p->suc = suc;       // то есть, p->suc = this->suc
     p->pre = this;      // явное использование this
     suc->pre = p;       // то есть, this->suc->pre = p
     suc = p;            // то есть, this->suc = p
  *)


                                    - 120 -
  dlink* list_head;

  void f(dlink*a, dlink *b)
     (*
     // ...
     list_head->append(a);
     list_head->append(b);
  *)

     Цепочки такой общей природы являются основой для списко-
вых классов,  которые описываются в Главе 7.  Чтобы присоеди-
нить звено  к списку необходимо обновить объекты,  на которые
указывают указатели this,  pre и suc (текущий,  предыдущий  и
последующий). Все    они  типа  dlink,   поэтому функция член
dlink::append() имеет к ним доступ. Единицей защиты в С++ яв-
ляется class, а не отдельный объект класса.

                     5.2.4 Инициализация

     Использование для   обеспечения   инициализации  объекта
класса функций вроде set_date() (установить дату) неэлегантно
и чревато ошибками. Поскольку нигде не утверждается, что объ-
ект должен быть инициализирован,  то программист может забыть
это сделать,  или (что приводит, как правило, к столь же раз-
рушительным последствиям)  сделать это дважды. Есть более хо-
роший подход:  дать возможность программисту описать функцию,
явно предназначенную для инициализации  объектов.   Поскольку
такая функция конструирует значения данного типа, она называ-
ется конструктором.  Конструктор распознается по  тому,   что
имеет то же имя, что и сам класс.
Например:

  class date (*
     // ...
     date(int, int, int);
  *);

     Когда класс имеет конструктор,  все объекты этого класса
будут инициализироваться.   Если для конструктора нужны пара-
метры, они должны даваться:

  date today = date(23,6,1983);
  date xmas(25,12,0);    // сокращенная форма
                         // (xmas - рождество)
  date my_burthday;      // недопустимо,опущена инициализация

     Часто бывает хорошо обеспечить несколько способов иници-
ализации объекта класса.  Это можно сделать,  задав несколько
конструкторов.
Например:

  class date (*
     int month, day, year;
     public:
     // ...
     date(int, int, int); // день месяц год
     date(char*);         // дата в строковом представлении
     date(int);           // день, месяц и год сегодняшние
     date();              // дата по умолчанию: сегодня
  *);

     Конструкторы подчиняются  тем  же  правилам относительно
типов параметров,  что и перегруженные функции (#4.6.7). Если
конструкторы существенно  различаются по типам своих парамет-
ров, то  компилятор при каждом  использовании  может  выбрать
правильный:


                                    - 121 -
  date today(4);
  date july4("Июль 4, 1983");
  date guy("5 Ноя");
  date now;                 // инициализируется по умолчанию

     Заметьте, что функции члены могут быть  перегружены  без
явного использования ключевого слова overload. Поскольку пол-
ный список функций членов находится в описании класса  и  как
правило короткий,  то нет никакой серьезной причины требовать
использования слова overload  для  предотвращения  случайного
повторного использования имени.

     Размножение конструкторов в примере с date типично.  При
разработке класса всегда есть соблазн обеспечить "все",  пос-
кольку кажется  проще обеспечить какое-нибудь средство просто
на случай,  что оно кому-то понадобится или потому,  что  оно
изящно выглядит, чем решить, что же нужно на самом деле. Пос-
леднее требует больших размышлений,   но  обычно  приводит  к
программам, которые  меньше по размеру и более понятны.  Один
из способов сократить число родственных функций  -  использо-
вать параметры  со значением по умолчанию,  пример.  В случае
date для каждого параметра можно задать значение  по  умолча-
нию, интерпретируемое    как "по умолчанию принимать:  today"
(сегодня).

  class date (*
      int month, day, year;
  public:
      // ...
      date(int d =0, int m =0, int y =0);
      date(char*); // дата в строковом представлении
  *);

  date::date(int d, int m, int y)
  (*
      day = d ? d : today.day;
      month = m ? m : today.month;
      year = y ? y : today.year;
      // проверка, что дата допустимая
      // ...
  *)

     Когда используется   значение   параметра,   указывающее
"брать по умолчанию",  выбранное значение должно  лежать  вне
множества возможных значений параметра.  Для дня day и месяца
mounth ясно,  что это так, но для года year выбор нуля неоче-
виден. К счастью, в европейском календаре нет нулевого года .
Сразу после 1 г. до н.э. (year==-1) идет 1 г. н.э. (year==1),
но для  реальной программы это может оказаться слишком тонко.

     Объект класса  без  конструкторов можно инициализировать
путем присваивания ему другого объекта этого класса. Это мож-
но делать и тогда, когда конструкторы описаны. Например:

  date d = today; // инициализация посредством присваивания

     По существу,  имеется конструктор по умолчанию,  опреде-
ленный как побитовая копия объекта того же класса.  Если  для
класса X такой конструктор по умолчанию нежелателен, его мож-
но переопределить конструктором с именем X(X&). Это будет об-
суждаться в #6.6.

                        5.2.5 Очистка

     Определяемый пользователем тип чаще имеет, чем не имеет,
конструктор, который  обеспечивает надлежащую  инициализацию.
Для многих типов также требуется обратное действие,  деструк-

                                    - 122 -
тор, чтобы  обеспечить соответствующую очистку объектов этого
типа. Имя    деструктора для класса X есть ~X()  ("дополнение
конструктора"). В частности, многие типы используют некоторый
объем памяти из свободной памяти (см.  #3.2.6), который выде-
ляется конструктором и освобождается деструктором.  Вот, нап-
ример, традиционный  стековый тип,  из которого для краткости
полностью выброшена обработка ошибок:

  class char_stack (*
      int size;
      char* top;
      char* s;
  public:
      char_stack(int sz) (* top=s=new char[size=sz]; *)
      ~char_stack() (* delete s; *) // деструктор
      void push(char c) (* *top++ = c; *)
      char pop() (* return *--top;*)
  *)

     Когда char_stack выходит из области видимости, вызывает-
ся деструктор:

  void f()
  (*
      char_stack s1(100);
      char_stack s2(200);
      s1.push('a');
      s2.push(s1.pop());
      char ch = s2.pop();
      cout << chr(ch) << "\n";
  *)

     Когда вызывается f(),  конструктор char_stack вызывается
для s1, чтобы выделить вектор из 100 символов, и для s2, что-
бы выделить вектор из 200 символов.  При возврате из f()  эти
два вектора будут освобождены.

                        5.2.6 Inline

     При программировании с использованием классов очень час-
то используется много маленьких функций.  По сути, везде, где
в программе традиционной структуры стояло бы просто какое-ни-
будь обычное использование структуры данных,  дается функция.
То, что было соглашением, стало стандартом, который распозна-
ет компилятор.  Это может страшно понизить эффективность, по-
тому что стоимость вызова функции (хотя и вовсе не высокая по
сравнению с другими языками) все равно намного выше, чем пара
ссылок по памяти, необходимая для тела функции.

     Чтобы справиться с этой проблемой,  был разработан аппа-
рат inline-функций.  Функция,  определенная (а не просто опи-
санная) в описании класса, считается inline. Это значит, нап-
ример, что  в функциях,  которые используют приведенные  выше
char_stack, нет   никаких вызовов функций кроме тех,  которые
используются для реализации операций вывода! Другими словами,
нет никаких  затрат времени выполнения,  которые стоит прини-
мать во внимание при разработке класса. Любое, даже самое ма-
ленькое действие,   можно задать эффективно.  Это утверждение
снимает аргумент,  который чаще всего приводят чаще  всего  в
пользу открытых членов данных.

     Функцию член можно также описать как inline вне описания
класса.
Например:
char char_stack (*
    int size;
    char* top;

                                    - 123 -
    char* s;
public:
    char pop();
    // ...
*);

inline char char_stack::pop()
(*
    return *--top;
*)

                 5.3 Интерфейсы и Реализации

     Что представляет собой хороший класс? Нечто, имеющее не-
большое и хорошо определенное множество действий.  Нечто, что
можно рассматривать как "черный ящик",  которым  манипулируют
только посредством этого множества действий.  Нечто, чье фак-
тическое представление можно любым  мыслимым  способом  изме-
нить, не  повлияв на способ использования множества действий.
Нечто, чего можно хотеть иметь больше одного.

     Для всех видов контейнеров существуют очевидные примеры:
таблицы, множества,   списки,  вектора,  словари и т.д. Такой
класс имеет операцию "вставить", обычно он также имеет опера-
ции для проверки того,  был ли вставлен данный элемент. В нем
могут быть действия для осуществления проверки всех элементов
в определенном  порядке,  и кроме всего прочего,  в нем может
иметься операция для удаления элемента.  Обычно  контейнерные
(то есть, вмещающие) классы имеют конструкторы и деструкторы.

     Сокрытие данных  и продуманный интерфейс может дать кон-
цепция модуля (см.  например #4.4:  файлы как модули). Класс,
однако, является  типом.  Чтобы использовать его,  необходимо
создать объекты этого класса,  и таких объектов можно  созда-
вать столько, сколько нужно. Модуль же сам является объектом.
Чтобы использовать его,  его надо только инициализировать,  и
таких объектов ровно один.

               5.3.1 Альтернативные Реализации

     Пока описание  открытой  части класса и описание функций
членов остаются неизменными,  реализацию класса можно модифи-
цировать не влияя на ее пользователей. Как пример этого расс-
мотрим таблицу имен,   которая  использовалась  в  настольном
калькуляторе в Главе 3. Это таблица имен:

struct name (*
    char* string;
    char* next;
    double value;
*);

     Вот вариант класса table:

// файл table.h

class table (*
    name* tbl;
public:
    table() (* tbl = 0; *)

name* look(char*, int = 0);
name* insert(char* s) (* return look(s,1); *)
*);

   Эта таблица отличается от той, которая определена в Гла-
ве 3 тем, что это настоящий тип. Можно описать более чем одну

                                    - 124 -
table, можно иметь указатель на table и т.д.
Например:

#include "table.h"

table globals;
table keywords;
table* locals;

main() (*
    locals = new table;
    // ...
*)

     Вот реализация table::look(),  которая использует линей-
ный поиск в связанном списке имен name в таблице:

#include <string.h>

name* table::look(char* p, int ins)
(*
    for (name* n = tbl; n; n=n->next)
        if (strcmp(p,n->string) == 0) return n;

    if (ins == 0) error("имя не найдено");

    name* nn = new name;
    nn->string = new char[strlen(p)+1];
    strcpy(nn->string,p);
    nn->value = 1;
    nn->next = tbl;
    tbl = nn;
    return nn;
*)

     Теперь рассмотрим класс table, усовершенствованный таким
образом, чтобы  использовать хэшированный просмотр,  как  это
делалось в   примере с настольным калькулятором.  Сделать это
труднее из-за того ограничения, что уже написанные программы,
в которых использовалась только что определенная версия клас-
са table, должны оставаться верными без изменений:

class table (*
    name** tbl;
    int size;
public:
    table(int sz = 15);
    ~table();

name* look(char*, int = 0);
name* insert(char* s) (* return look(s,1); *)
*);

     В структуру данных и конструктор внесены изменения,  от-
ражающие необходимость того,  что при использовании хэширова-
ния таблица    должна  иметь  определенный  размер.   Задание
конструктора с параметром по умолчанию обеспечивает, что ста-
рая программа,  в которой не указывался размер таблицы, оста-
нется правильной.  Параметры по умолчанию очень полезны в си-
туации, когда    нужно  изменить  класс  не повлияв на старые
программы. Теперь  конструктор и деструктор создают и уничто-
жают хэш-таблицы:

table::table(int sz)
(*
    if (sz < 0) error("отрицательный размер таблицы");
    tbl = new name*[size=sz];

                                    - 125 -
    for (int i = 0; i<sz; i++) tbl[i] = 0;
*)

table::~table()
(*
    for (int i = 0; i<size; i++)
 for (name* n = tbl[i]; n; n=n->next) (*
     delete n->string;
     delete n;
 *)
 delete tbl;
*)

     Описав деструктор для класса name можно  получить  более
простой и   ясный вариант table::~table().  Функция просмотра
практически идентична той,  которая использовалась в  примере
настольного калькулятора (#3.1.3):

  #include <string.h>

  name* table::look(char* p, int ins)
  (*
      int ii = 0;
      char* pp = p;
      while (*pp) ii = ii<<1 ^ *pp++;
      if (ii < 0) ii = -ii;
      ii %= size;

      for (name* n=tbl[ii]; n; n=n->next)
          if (strcmp(p,n->string) == 0) return n;

      if (ins == 0) error("имя не найдено");

      name* nn = new name;
      nn->string = new char[strlen(p)+1];
      strcpy(nn->string,p);
      nn->value = 1;
      nn->next = tbl[ii];
      tbl[ii] = nn;
      return nn;

  *)

     Очевидно, что функции члены класса должны заново  компи-
лироваться всегда, когда вносится какое-либо изменение в опи-
сание класса.  В идеале такое изменение никак не должно отра-
жаться на пользователях класса.  К сожалению, это не так. Для
размещения переменной классового типа компилятор должен знать
размер объекта класса. Если размер этих объектов меняется, то
файлы, в  которых класс используется, нужно компилировать за-
ново. Можно    написать такую программу (и она уже написана),
которая определяет множество (минимальное)  файлов,   которое
необходимо компилировать   заново  после  изменения  описания
класса, но пока что широкого распространения она не получила.

     Почему, можете вы спросить, С++ разработан так, что пос-
ле изменения закрытой части необходима новая компиляция поль-
зователей класса?  И действительно,  почему  вообще  закрытая
часть должна   быть  представлена в описании класса?  Другими
словами, раз пользователям класса не разрешается обращаться к
закрытым членам,  почему их описания должны приводиться в за-
головочных файлах,  которые, как предполагается, пользователь
читает? Ответ  - эффективность.  Во многих системах и процесс
компиляции, и  последовательность операций, реализующих вызов
функции, проще,  когда размер автоматических объектов (объек-
тов в стеке) известен во время компиляции.


                                    - 126 -
     Этой сложности можно избежать,  представив каждый объект
класса как  указатель на "настоящий" объект.  Так как все эти
указатели будут иметь одинаковый размер, а размещение "насто-
ящих" объектов можно определить в файле,  где доступна закры-
тая часть,  то это может решить проблему. Однако решение под-
разумевает дополнительные   ссылки  по памяти при обращении к
членам класса,  а также, что еще хуже, каждый вызов функции с
автоматическим объектом  класса включает по меньшей мере один
вызов программ выделения и освобождения свободной памяти. Это
сделало бы   также невозможным реализацию inline-функций чле-
нов, которые  обращаются к данным закрытой части. Более того,
такое изменение сделает невозможным совместную компоновку C и
С++ программ (поскольку C компилятор обрабатывает  struct  не
так, как  это будет делать С++ компилятор).  Для С++ это было
сочтено неприемлемым.

                   5.3.2 Законченный Класс

     Программирование без  сокрытия  данных  (с   применением
структур) требует меньшей продуманности, чем программирование
со сокрытием данных (с  использованием  классов).   Структуру
можно определить не слишком задумываясь о том, как ее предпо-
лагается использовать. А когда определяется класс, все внима-
ние сосредотачивается  на обеспечении нового типа полным мно-
жеством операций;   это  важное  смещение  акцента.    Время,
потраченное на   разработку  нового типа,  обычно многократно
окупается при разработке и тестировании программы.

     Вот пример законченного типа intset,  который  реализует
понятие "множество целых":

  class intset (*
      int cursize, maxsize;
      int *x;
  public:
      intset(int m, int n); // самое большее, m int'ов в 1..n
      ~intset();

      int member(int t); // является ли t элементом?
      void insert(int t); // добавить "t" в множество

      void iterate(int& i) (* i = 0; *)
      int ok(int& i) (* return i<cursize; *)
      int next(int& i) (* return x[i++]; *)
  *);

     Чтобы протестировать этот класс,  можно создать и распе-
чатать множество случайных целых чисел. Такое множество могло
бы быть результатом розыгрыша лотереи.  Это простое множество
можно также  использовать для проверки последовательности це-
лых на повторы.  Но для большинства приложений тип  множество
должен быть немного более проработанным. Как всегда, возможны
ошибки:

  #include <stream.h>

  void error(char* s)
  (*
      cerr << "set: " << s << "\n";
      exit(1);
  *)

     Класс intset используется в main(), которая предполагает
два целых  параметра.  Первый параметр задает число случайных
чисел, которые нужно сгенерировать. Второй параметр указывает
диапазон, в котором должны лежать случайные целые:


                                    - 127 -
  main(int argc, char* argv[])
  (*
      if (argc != 3) error("ожидается два параметра");
      int count = 0;
      int m = atoi(argv[1]); // число элементов множества
      int n = atoi(argv[2]); // в диапазоне 1..n
      intset s(m,n);

      while (count<m) (*
          int t = randint(n);
          if (s.member(t)==0) (*
              s.insert(t);
              count++;
          *)
      *)

      print_in_order(&s);
  *)

     В программе,  для которой требуется два параметра, счет-
чик числа параметров, argc, должен равняться трем, потому что
имя программы всегда передается как argv[0]. Функция

  extern int atoi(char*);

     функция atoi()  это стандартная библиотечная функция для
преобразования представления целого в виде строки в его внут-
реннюю (двоичную)  форму.  Случайные числа генерируются с по-
мощью стандартной функции rand():

  extern int rand(); // Не очень случайные, будьте осторожны

  int randint(int u) // в диапазоне 1..u
  (*
      int r = rand();
      if (r < 0) r = -r;
      return 1 + r%u ;
  *)

     Подробности реализации класса  должны  представлять  для
пользователя весьма незначительный интерес,  но здесь в любом
случае будут функции члены. Конструктор выделяет целый вектор
заданного максимального размера множества, а деструктор осво-
бождает его:

  intset::intset(int m, int n)//самое большее,m int'ов в 1..n
  (*
      if (m<1 !! n<m) error("недопустимый размер intset");
      cursize = 0;
      maxsize = m;
      x = new int[maxsize];
  *)

  intset::~intset()
  (*
      delete x;
  *)

     Целые числа вставляются,  поэтому они хранятся в возрас-
тающем порядке:

  void intset::insert(int t)
  (*
   if (++cursize > maxsize) error("слишком много элементов");
   int i = cursize-1;
   x[i] = t;


                                    - 128 -
   while (i>0 && x[i-1]>x[i]) (*
       int t = x[i]; // переставить x[i] и [i-1]
       x[i] = x[i-1];
       x[i-1] = t;
       i--;
   *)
  *)

     Для нахождения членов используется просто  двоичный  по-
иск:

  int intset::member(int t) // двоичный поиск
  (*
      int l = 0;
      int u = cursize-1;

      while (l <= u) (*
          int m = (l+u)/2;
          if (t < x[m])
              u = m-1;
          else if (t > x[m])
              l = m+1;
          else
              return 1; // найдено
      *)
      return 0; // не найдено
  *)

     И, наконец,  нам нужно  обеспечить  множество  операций,
чтобы пользователь мог осуществлять цикл по множеству в неко-
тором порядке, поскольку представление intset от пользователя
скрыто. Множество внутренней упорядоченности не имеет, поэто-
му мы не можем просто дать возможность обращаться  к  вектору
(завтра я,  наверное, реализую intset по-другому, в виде свя-
занного списка).

     Дается три функции:  iterate()  для инициализации итера-
ции, ok()   для проверки, есть ли следующий элемент, и next()
для того, чтобы взять следующий элемент:

  class intset (*
      // ...
      void iterate(int& i) (* i = 0; *)
      int ok(int& i) (* return i<cursize; *)
      int next(int& i) (* return x[i++]; *)
  *);

     Чтобы дать возможность этим трем операциям работать сов-
местно и чтобы запомнить,  куда дошел цикл, пользователь дол-
жен дать целый параметр. Поскольку элементы хранятся в отсор-
тированном списке,  их реализация тривиальна.   Теперь  можно
определить функцию печати по порядку print_in_order:

  void print_in_order(intset* set)
  (*
      int var;
      set->iterate(var);
      while (set->ok(var)) cout << set->next(var) << "\n";
  *)

Другой способ задать итератор приводится в #6.8.

                  5.4 Друзья и Объединения

     В это разделе описываются еще некоторые особенности, ка-
сающиеся классов. Показано, как предоставить функции не члену
доступ к закрытым членам. Описывается, как разрешать конфлик-

                                    - 129 -
ты имен членов,  как можно делать вложенные описания классов,
и как избежать нежелательной вложенности.  Обсуждается также,
как объекты класса могут совместно использовать члены данные,
и как использовать указатели на члены.  Наконец,   приводится
пример, показывающий, как построить дискриминирующее (эконом-
ное) объединение.

                        5.4.1 Друзья

     Предположим, вы определили два класса,  vector и  matrix
(вектор и матрица). Каждый скрывает свое представление и пре-
доставляет полный набор действий  для  манипуляции  объектами
его типа.    Теперь определим функцию,  умножающую матрицу на
вектор. Для простоты допустим, что в векторе четыре элемента,
которые индексируются 0...3, и что матрица состоит из четырех
векторов, индексированных 0...3. Допустим также, что доступ к
элементам вектора осуществляется через функцию elem(),  кото-
рая осуществляет проверку индекса,  и что  в  matrix  имеется
аналогичная функция.   Один подход состоит в определении гло-
бальной функции multiply()  (перемножить)  примерно следующим
образом:

  vector multiply(matrix& m, vector& v);
  (*
      vector r;
      for (int i = 0; i<3; i++) (* // r[i] = m[i] * v;
          r.elem(i) = 0;
          for (int j = 0; j<3; j++)
              r.elem(i) += m.elem(i,j) * v.elem(j);
      *)
      return r;
  *)

     Это своего рода "естественный" способ, но он очень неэф-
фективен. При  каждом обращении к multiply() elem() будет вы-
зываться 4*(1+4*3) раза.

     Теперь, если мы сделаем multiply() членом класса vector,
мы сможем обойтись без проверки индексов при обращении к эле-
менту вектора,  а если мы сделаем multiply()   членом  класса
matrix, то мы сможем обойтись без проверки индексов при обра-
щении к элементу матрицы.  Однако членом двух классов функция
быть не   может.   Нам нужно средство языка,  предоставляющее
функции право доступа к закрытой части  класса.   Функция  не
член, получившая право доступа к закрытой части класса, назы-
вается другом класса  (friend).   Функция  становится  другом
класса после описания как friend. Например:

  class matrix;

  class vector (*
      float v[4];
      // ...
      friend vector multiply(matrix&, vector&);
  *);

  class matrix (*
      vector v[4];
      // ...
      friend vector multiply(matrix&, vector&);
  *);

     Функция друг не имеет никаких особенностей, помимо права
доступа к закрытой части класса.  В частности, friend функция
не имеет  указателя this (если только она не является полноп-
равным членом функцией).  Описание friend - настоящее  описа-
ние. Оно вводит имя функции в самой внешней области видимости

                                    - 130 -
программы и сопоставляется с другими описаниями этого  имени.
Описание друга может располагаться или в закрытой, или в отк-
рытой части описания класса. Где именно, значения не имеет.

     Теперь можно написать функцию умножения, которая исполь-
зует элементы векторов и матрицы непосредственно:

  vector multiply(matrix& m, vector& v);
  (*
      vector r;
      for (int i = 0; i<3; i++) (* // r[i] = m[i] * v;
          r.v[i] = 0;
          for (int j = 0; j<3; j++)
              r.v[i] += m.v[i][j] * v.v[j];
      *)
      return r;
  *)

     Есть способы преодолеть эту конкретную  проблему  эффек-
тивности не     используя   аппарат  friend  (можно  было  бы
определить операцию   векторного   умножения   и   определить
multiply() с  ее помощью). Однако существует много задач, ко-
торые проще всего решаются,  если есть возможность  предоста-
вить доступ к закрытой части класса функции, которая не явля-
ется членом этого класса.  В  Главе  6  есть  много  примеров
применения friend.  Достоинства функций друзей и членов будут
обсуждаться позже.

     Функция член одного класса может  быть  другом  другого.
Например:

  class x (*
      // ...
      void f();
  *);

  class y (*
      // ...
      friend void x::f();
  *);

     Нет ничего необычного в том, что все функции члены одно-
го класса являются друзьями другого.  Для этого есть даже бо-
лее краткая запись:

  class x (*
      friend class y;
      // ...
  *);

     Такое описание friend делает все функции члены класса  y
друзьями x.

                5.4.2 Уточнение* Имени Члена

--------------------
     * Иногда называется также квалификацией.  (прим. перев.)

     Иногда полезно делать явное различие между именами  чле-
нов класса и прочими именами. Для этого используется операция
::, "разрешения области видимости":

  class x (*
      int m;
  public:
      int readm() (* return x::m; *)
      void setm(int m) (* x::m = m; *)

                                    - 131 -
  *);

     В x::setm()   имя  параметра  m  прячет член m,  поэтому
единственный способ сослаться на член - это использовать  его
уточненное имя   x::m.  Операнд в левой части ::  должен быть
именем класса.

     Имя с префиксом ::  (просто) должно быть глобальным име-
нем. Это  особенно полезно для того, чтобы можно было исполь-
зовать часто употребимые имена вроде read,  put  и  open  как
имена функций членов, не теряя при этом возможности обращать-
ся к той версии функции,  которая не является членом.
Например:

  class my_file (*
      // ...
  public:
      int open(char*, char*);
  *);

  int my_file::open(char* name, char* spec)
  (*
     // ...
     if (::open(name,flag))(*//использовать open() из UNIX(2)
         // ...
     *)
     // ...
  *)

                   5.4.3 Вложенные Классы

  Описание класса может быть вложенным. Например:

  class set (*
      struct setmem (*
          int mem;
          setmem* next;
          setmem(int m, setmem* n) (* mem=m; next=n; *)
      *);
      setmem* first;
  public:
      set() (* first=0; *)
      insert(int m) (* first = new setmem(m,first);*)
      // ...
  *);

     Если только вложенный класс не является очень простым, в
таком описании трудно разобраться. Кроме того, вложение клас-
сов - это не более чем соглашение о записи, поскольку вложен-
ный класс не является скрытым в области видимости  лексически
охватывающего класса:

  class set (*
      struct setmem (*
          int mem;
          setmem* next;
          setmem(int m, setmem* n)
      *);
      // ...
  *);

      setmem::setmem(int m, setmem* n) (* mem=m, next=n*)
      setmem m1(1,0);

     Такая запись,  как set::setmem::setmem(), не является ни
необходимой, ни  допустимой.  Единственный способ скрыть  имя
класса - это сделать это с помощью метода файлы-как-модули (#

                                    - 132 -
4.4). Большую  часть нетривиальных  классов  лучше  описывать
раздельно:

  class setmem (*
  friend class set; // доступ только с помощью членов set
      int mem;
      setmem* next;
      setmem(int m, setmem* n) (* mem=m; next=n; *)
      *);

  class set (*
      setmem* first;
  public:
      set() (* first=0; *)
      insert(int m) (* first = new setmem(m,first);*)
      // ...
  *);

                   5.4.4 Статические Члены

     Класс - это тип,  а не объект данных, и в каждом объекте
класса имеется   своя собственная копия данных,  членов этого
класса. Однако некоторые типы наиболее элегантно реализуются,
если все   объекты  этого  типа  могут совместно использовать
(разделять) некоторые  данные.  Предпочтительно,  чтобы такие
разделяемые данные  были описаны как часть класса.  Например,
для управления задачами в операционной системе или в ее моде-
ли часто бывает полезен список всех задач:

  class task (*
      // ...
      task* next;
      static task* task_chain;
      void shedule(int);
      void wait(event);
      // ...
  *);

     Описание члена task_chain (цепочка  задач)   как  static
обеспечивает, что он будет всего лишь один, а не по одной ко-
пии на каждый объект task.  Он все равно остается  в  области
видимости класса   task,  и "извне" доступ к нему можно полу-
чить, только если он был описан как public. В этом случае его
имя должно уточняться именем его класса:

  task::task_chain

     В функции   члене   на   него   можно  ссылаться  просто
task_chain. Использование статических членов класса может за-
метно снизить потребность в глобальных переменных.

                  5.4.5 Указатели на Члены

     Можно брать адрес члена класса. Получение адреса функции
члена часто бывает полезно,  поскольку те цели и причины, ко-
торые приводились   в #4.6.9 относительно указателей на функ-
ции, в  равной степени применимы и к функциям членам. Однако,
на настоящее время в языке имеется дефект: невозможно описать
выражением тип указателя,  который  получается  в  результате
этой операции.  Поэтому в текущей реализации приходится жуль-
ничать, используя трюки. Что касается примера, который приво-
дится ниже,  то не гарантируется,  что он будет работать. Ис-
пользуемый трюк надо локализовать, чтобы программу можно было
преобразовать с использованием соответствующей языковой конс-
трукции, когда  появится такая возможность. Этот трюк исполь-
зует тот факт,  что в текущей реализации this реализуется как
первый (скрытый) параметр функции члена*:

                                    - 133 -

--------------------
     * Более  поздние  версии С++ поддерживают понятие указа-
тель на член:  cl::* означает "указатель на член класса  cl".
Например:

  typedef void (cl::*PROC)(int);
  PROC pf1 = &cl::print;    // приведение к типу ненужно
  PROC pf2 = &cl::print;

     Для вызовов через указатель на функцию член используются
операции . и ->. Например:

  (z1.*pf1)(2);
  ((&z2)->*pf2)(4);

(прим. автора)

  #include <stream.h>

  struct cl
  (*
      char* val;
      void print(int x) (* cout << val << x << "\n"; *);
      cl(char* v) (* val = v; *)
  *);

  // ``фальшивый'' тип для функций членов:
  typedef void (*PROC)(void*, int);

  main()
  (*
      cl z1("z1 ");
      cl z2("z2 ");
      PROC pf1 = PROC(&z1.print);
      PROC pf2 = PROC(&z2.print);
      z1.print(1);
      (*pf1)(&z1,2);
      z2.print(3);
      (*pf2)(&z2,4);
  *)

     Во многих  случаях  можно  воспользоваться  виртуальными
функциями (см.  Главу 7) там, где иначе пришлось бы использо-
вать указатели на функции.

                5.4.6 Структуры и Объединения

     По определению struct - это просто класс,  все члены ко-
торого открытые, то есть

  struct s (* ...

есть просто сокращенная запись

  class s (* public: ...

     Структуры используются в тех  случаях,   когда  сокрытие
данных неуместно.

     Именованное объединение определяется как struct, в кото-
рой все члены имеют один и тот же адрес (см. #с.8.5.13). Если
известно, что  в каждый момент времени нужно только одно зна-
чение из структуры,  то объединение может  сэкономить  прост-
ранство. Например,  можно определить объединение для хранения
лексических символов C компилятора:


                                    - 134 -
  union tok_val (*
      char* p; // строка
      char v[8]; // идентификатор (максимум 8 char)
      long i; // целые значения
      double d; // значения с плавающей точкой
  *);

     Сложность состоит в том,  что компилятор, вообще говоря,
не знает, какой член используется в каждый данный момент, по-
этому надлежащая проверка типа невозможна. Например:

  void strange(int i)
  (*
      tok_val x;
      if (i)
          x.p = "2";
      else
          x.d = 2;
      sqrt(x.d); // ошибка если i != 0
  *)

     Кроме того,   объединение,   определенное так,  как это,
нельзя инициализировать. Например:

  tok_val curr_val = 12; //ошибка:int присваивается tok_val'у

     является недопустимым.  Для того,  чтобы это преодолеть,
можно воспользоваться конструкторами:

  union tok_val (*
      char* p; // строка
      char v[8]; // идентификатор (максимум 8 char)
      long i; // целые значения
      double d; // значения с плавающей точкой

      tok_val(char*); // должна выбрать между p и v
      tok_val(int ii) (* i = ii; *)
      tok_val() (* d = dd; *)
  *);

     Это позволяет справляться с теми ситуациями,  когда типы
членов могут  быть разрешены по правилам для перегрузки имени
функции (см. #4.6.7 и #6.3.3). Например:

  void f()
  (*
      tok_val a = 10; // a.i = 10
      tok_val b = 10.0; // b.d = 10.0
  *)

     Когда это невозможно (для  таких  типов,   как  char*  и
char[8], int  и char,  и т.п.), нужный член может быть найден
только посредством анализа инициализатора в  ходе  выполнения
или с помощью задания дополнительного параметра. Например:

  tok_val::tok_val(char* pp)
  (*
      if (strlen(pp) <= 8)
          strncpy(v,pp,8); // короткая строка
      else
          p = pp; // длинная строка
  *)

     Таких ситуаций вообще-то лучше избегать.

     Использование конструкторов  не  предохраняет  от такого
случайного неправильного употребления tok_val,  когда сначала

                                    - 135 -
присваивается значение  одного типа,  а потом рассматривается
как другой тип.  Эта проблема решается встраиванием объедине-
ния в класс,  который отслеживает, какого типа значение поме-
щается:

  class tok_val (*
      char tag;
  union (*
      char* p;
      char v[8];
      long i;
      double d;
      *);
      int check(char t, char* s)
        (* if (tag!=t) (* error(s); return 0; *) return 1; *)
  public:
      tok_val(char* pp);
      tok_val(long ii) (* i=ii; tag='I'; *)
      tok_val(double dd) (* d=dd; tag='D'; *)

      long& ival() (* check('I',"ival"); return i; *)
      double& fval() (* check('D',"fval"); return d; *)
      char*& sval() (* check('S',"sval"); return p; *)
      char* id() (* check('N',"id"); return v; *)
  *);

     Конструктор, получающий  строковый параметр,  использует
для копирования коротких строк strncpy(). strncpy() похожа на
strcpy(), но    получает третий параметр,  который указывает,
сколько символов должно копироваться:

  tok_val::tok_val(char* pp)
  (*
      if (strlen(pp) <= 8) (* // короткая строка
          tag = 'N'
          strncpy(v,pp,8);   // скопировать 8 символов
      *)
      else (*            // длинная строка
          tag = 'S';
          p = pp;            // просто сохранить указатель
      *)
  *)

     Тип tok_val можно использовать так:

  void f()
  (*
      tok_val t1("short"); // короткая, присвоить v
      tok_val t2("long string"); //длинная строка,присвоить p
      char s[8];
      strncpy(s,t1.id(),8); // ok
      strncpy(s,t2.id(),8); // проверка check() не пройдет
  *)

               5.5 Конструкторы и Деструкторы

     Если у класса есть конструктор, то он вызывается всегда,
когда создается объект класса. Если у класса есть деструктор,
то он   вызывается всегда,  когда объект класса уничтожается.
Объекты могут создаваться как:

     [1] Автоматический объект:  создается каждый раз,  когда
его описание встречается при выполнении программы,  и уничто-
жается каждый раз при выходе из блока,  в котором оно  появи-
лось;

     [2] Статический объект:  создается один раз, при запуске

                                    - 136 -
программы, и уничтожается один раз, при ее завершении;

     [3] Объект в свободной памяти:  создается с помощью опе-
рации new и уничтожается с помощью операции delete;

     [4] Объект член:  как объект другого класса или как эле-
мент вектора.

     Объект также может быть построен с помощью явного приме-
нения конструктора в выражении (см.  #6.4),  в этом случае он
является автоматическим объектом.   В  следующих  подразделах
предполагается, что    объекты  принадлежат классу,  имеющему
конструктор и деструктор.  Примером может служить класс table
из #5.3.

                    5.5.1 Предостережение

     Если x  и  y  - объекты класса cl,  то x=y в стандартном
случае означает побитовое копирование y в x (см. #2.3.8). Та-
кая интерпретация   присваивания может привести к изумляющему
(и обычно нежелательному)  результату, если оно применяется к
объектам класса,  для которого определены конструктор и дест-
руктор.
Например:

  class char_stack (*
      int size;
      char* top;
      char* s;
  public:
      char_stack(int sz) (* top=s=new char[size=sz]; *)
      ~char_stack() (* delete s; *) // деструктор
      void push(char c) (* *top++ = c; *)
      char pop() (* return *--top; *)
  *);

  void h()
  (*
      char_stack s1(100);
      char_stack s2 = s1; // неприятность
      char_stack s3(99);
      s3 = s2; // неприятность
  *)

     Здесь char_stack::char_stack() вызывается дважды: для s1
и для s3.  Для s2 он не вызывается,  поскольку эта переменная
инициализируется присваиванием.         Однако     деструктор
char_stack::~char_stack() вызывается трижды: для s1, s2 и s3!
Кроме того, по умолчанию действует интерпретация присваивания
как побитовое копирование,  поэтому в конце h() каждый из s1,
s2 и s3 будет содержать указатель на вектор символов,  разме-
щенный в свободной памяти при создании s1. Не останется ника-
кого указателя на вектор символов,  выделенный  при  создании
s3. Таких отклонений можно избежать: см. Главу 6.

                  5.5.2 Статическая Память

     Рассмотрим следующее:

  table tbl1(100);

  void f() (*
      static table tbl2(200);
  *)

  main()
  (*

                                    - 137 -
      f();
  *)

     Здесь конструктор table::table(), определенный в #5.3.1,
будет вызываться   дважды:   один раз для tbl1 и один раз для
tbl2. Деструктор  table::~table()  также будет вызван дважды:
для уничтожения tbl1 и tbl2 после выхода из main(). Конструк-
торы для глобальных статических объектов в файле  выполняются
в том   порядке,  в котором встречаются описания; деструкторы
вызываются в обратном порядке.  Неопределено,  вызывается  ли
конструктор для  локального статического объекта,  если функ-
ция, в  которой этот объект описан, не вызывается. Если конс-
труктор для локального статического объекта вызывается, то он
вызывается после того, как вызваны конструкторы для лексичес-
ки предшествующих ему глобальных статических объектов.

     Параметры конструкторов  для статических объектов должны
быть константными выражениями:

  void g(int a)
  (*
      static table t(a); // ошибка
  *)

     Традиционно выполнением  программы  считалось выполнение
main(). Так  никогда не было,  даже в C, но только размещение
статических объектов  класса с конструктором и/или деструкто-
ром дают программисту простой и очевидный способ задания  то-
го, что будет выполняться до и/или после вызова main().

     Вызов конструкторов  и деструкторов для статических объ-
ектов играет в  С++  чрезвычайно  важную  роль.   Это  способ
обеспечить надлежащую инициализацию и очистку структур данных
в библиотеках.  Рассмотрим <stream.h>.  Откуда  берутся  cin,
cout и  cerr?  Где они получают инициализацию?  И,  что самое
главное, поскольку потоки вывода имеют внутренние буферы сим-
волов, как же эти буферы заполняются? Простой и очевидный от-
вет таков,  что эта  работа  осуществляется  соответствующими
конструкторами и  деструкторами до и после выполнения main().
Для инициализации и очистки библиотечных средств есть возмож-
ности, альтернативные  использованию конструкторов и деструк-
торов. Все они или очень специальные, или очень уродливые.

     Если программа завершается с помощью функции exit(),  то
деструкторы для   статических объектов будут вызваны,  а если
она завершается с помощью abort(), то не будут. Заметьте, что
это подразумевает, что exit() не завершает программу мгновен-
но. Вызов  exit()  в деструкторе может привести к бесконечной
рекурсии.

     Иногда, когда  вы разрабатываете библиотеку,  необходимо
или просто удобно создать тип с конструктором и деструктором,
предназначенными только для одного:  инициализировать и очис-
тить. Такой тип обычно используется только с одной целью, для
размещения статического  объекта так,  чтобы вызывались конс-
труктор и деструктор.

                   5.5.3 Свободная Память

     Рассмотрим:

  main() (*
      table* p = new table(100);
      table* q = new table(200);
      delete p;
      delete p; // возможно, ошибка
  *)

                                    - 138 -

     Конструктор table::table()   будет вызван дважды,  как и
деструктор table::~table().  То,  что С++ не дает никаких га-
рантий, что для объекта, созданного с помощью new, когда-либо
будет вызван деструктор, ничего не значит. В предыдущей прог-
рамме q не уничтожается, а p уничтожается дважды! Программист
может счесть это ошибкой,  а может и не счесть, в зависимости
от типа p и q. Обычно то, что объект не уничтожается, являет-
ся не ошибкой,  а просто лишней тратой памяти.  Уничтожение p
дважды будет,  как правило, серьезной ошибкой. Обычно резуль-
татом применения delete дважды к одному указателю приводит  к
бесконечному циклу   в  подпрограмме управления свободной па-
мятью, но  определение языка не задает поведение в таком слу-
чае, и оно зависит от реализации.

     Пользователь может  определить новую реализацию операций
new и delete (см. #3.2.6). Можно также определить способ вза-
имодействия конструктора   или деструктора с операциями new и
delete (см. #5.5.6)

               5.5.4 Объекты Класса как Члены

     Рассмотрим

  class classdef (*
      table members;
      int no_of_members;
      // ...
      classdef(int size);
      ~classdef();
  *);

     Очевидное намерение состоит в том,  что classdef  должен
содержать таблицу длиной size из членов members,  а сложность
- в том,  как сделать так,  чтобы конструктор  table::table()
вызывался с параметром size. Это делается так:

  classdef::classdef(int size)
  : members(size)
  (*
      no_of_members = size;
      // ...
  *)

     Параметры для конструктора члена (здесь это table::table
()) помещаются    в определение (не в описание)  конструктора
класса, вмещающего его (здесь это classdef::classdef()). Пос-
ле этого конструктор члена вызывается перед телом конструкто-
ра, задающего его список параметров.

     Если есть еще члены, которым нужны списки параметров для
конструкторов, их можно задать аналогично. Например:

  class classdef (*
      table members;
      table friends;
      int no_of_members;
      // ...
      classdef(int size);
      ~classdef();
  *);

     Список параметров для членов разделяется запятыми (а  не
двоеточиями), и    список  инициализаторов  для  членов может
представляться в произвольном порядке:

  classdef::classdef(int size)

                                    - 139 -
  : friends(size), members(size)
  (*
      no_of_members = size;
      // ...
  *)

     Порядок, в котором вызываются конструкторы, неопределен,
поэтому не рекомендуется делать списки параметров с побочными
эффектами:

  classdef::classdef(int size)
  : friends(size=size/2), members(size); // дурной стиль
  (*
      no_of_members = size;
      // ...
  *)

     Если конструктору для члена не нужно ни одного  парамет-
ра, то никакого списка параметров задавать не надо. Например,
поскольку table::table был определен с параметром по  умолча-
нию 15, следующая запись является правильной:

  classdef::classdef(int size)
  : members(size)
  (*
      no_of_members = size;
      // ...
  *)

     и размер size таблицы friends будет равен 15.

     Когда объект класса,  содержащий объект класса,  (напри-
мер, classdef)   уничтожается,  первым выполняется тело собс-
твенного деструктора объекта, а затем выполняются деструкторы
членов.

     Рассмотрим традиционную  альтернативу тому,  чтобы иметь
объекты класса как члены, - иметь члены указатели и инициали-
зировать их в конструкторе:

  class classdef (*
      table* members;
      table* friends;
      int no_of_members;
      // ...
      classdef(int size);
      ~classdef();
  *);

  classdef::classdef(int size)
  (*
      members = new table(size);
      friends = new table; // размер таблицы по умолчанию
      no_of_members = size;
      // ...
  *)

     Так как таблицы создавались с помощью new,   они  должны
уничтожаться с помощью delete:

  classdef::~classdef()
  (*
      // ...
      delete members;
      delete friends;
  *)


                                    - 140 -
     Раздельно создаваемые объекты вроде этих могут оказаться
полезными, но  учтите, что members и friends указывают на от-
дельные объекты,  что требует для каждого из них действие  по
выделению памяти   и ее освобождению.  Кроме того,  указатель
плюс объект в свободной памяти занимают  больше  места,   чем
объект член.

                5.5.5 Вектора Объектов Класса

     Чтобы описать вектор объектов класса, имеющего конструк-
тор, этот класс должен иметь конструктор, который может вызы-
ваться без списка параметров.  Нельзя использовать даже пара-
метры по умолчанию. Например:

  table tblvec[10];

     будет ошибкой,  так как  для  table::table()   требуется
целый параметр.   Нет способа задать параметры конструктора в
описании вектора.  Чтобы можно было описывать  вектор  таблиц
table, можно  модифицировать описание table (#5.3.1),  напри-
мер, так:

  class table (*
      // ...
      void init(int sz); // как старый конструктор
  public:
      table(int sz) // как раньше, но без по умолчанию
          (* init(sz); *)
      table() // по умолчанию
          (* init(15); *)
  *)

     Когда вектор уничтожается,  деструктор должен вызываться
для каждого элемента этого вектора.  Для векторов, которые не
были размещены с помощью new, это делается неявно. Однако для
векторов в свободной памяти это не может быть сделано неявно,
поскольку компилятор не может отличить указатель на один объ-
ект от  указателя на первый элемент вектора объектов.
Например:

  void f()
  (*
      table* t1 = new table;
      table* t2 = new table[10];
      delete t1; // одна таблица
      delete t2; // неприятность: 10 таблиц
  *)

     В этом случае длину вектора должен задавать программист:

  void g(int sz)
  (*
      table* t1 = new table;
      table* t2 = new table[sz];
      delete t1;
      delete[] t2;
  *)

     Но почему же компилятор не может найти  число  элементов
вектора из объема выделенной памяти?  Потому, что распредели-
тель свободной памяти не является частью языка и  может  быть
задан программистом.

                   5.5.6 Небольшие Объекты

     Когда вы используете много небольших объектов, размещае-
мых в свободной памяти,  то вы можете обнаружить,   что  ваша

                                    - 141 -
программа тратит   много  времени выделяя и освобождая память
под эти объекты.  Первое решение - это обеспечить более хоро-
ший распределитель памяти общего назначения,  второе для раз-
работчика классов состоит в том, чтобы взять под контроль уп-
равление свободной   памятью для объектов некоторого класса с
помощью подходящих конструкторов и деструкторов.

     Рассмотрим класс name,  который использовался в примерах
table. Его можно было бы определить так:

  struct name (*
      char* string;
      name* next;
      double value;

      name(char*, double, name*);
      ~name();
  *);

     Программист может воспользоваться тем,  что размещение и
освобождение объектов  заранее известного размера можно обра-
батывать гораздо эффективнее (и по памяти, и по времени), чем
с помощью общей реализации new и delete. Общая идея состоит в
том, чтобы  предварительно  разместить  "куски"  из  объектов
name, а  затем сцеплять их, чтобы свести выделение и освобож-
дение к простым операциям над связанным списком.   Переменная
nfree является вершиной списка неиспользованных name:

  const NALL = 128;
  name* nfree;

     Распределитель, используемый операцией new,  хранит раз-
мер объекта   вместе с объектом,  чтобы обеспечить правильную
работу операции delete. С помощью распределителя, специализи-
рованного для  типа,  можно избежать этих накладных расходов.
Например, на  моей машине следующий распределитель использует
для хранения name 16 байт, тогда как для стандартного распре-
делителя свободной памяти нужно 20 байт.  Вот как  это  можно
сделать:

  name::name(char* s, double v, name* n)
  (*
      register name* p = nfree; // сначала выделить

      if (p)
          nfree = p->next;
      else (* // выделить и сцепить
          name* q = (name*)new char[ NALL*sizeof(name) ];
          for (p=nfree=&q[NALL-1]; q<p; p--) p->next = p-1;
          (p+1)->next = 0;
      *)

      this = p; // затем инициализировать
      string = s;
      value = v;
      next = n;
  *)

     Присвоение указателю  this информирует компилятор о том,
что программист взял себе управление, и что не надо использо-
вать стандартный  механизм распределения памяти.  Конструктор
name::name() обрабатывает  только тот случай, когда name раз-
мещается посредством   new,   но  для большей части типов это
всегда так.  В #5.5.8 объясняется,  как написать  конструктор
для обработки как размещения в свободной памяти, так и других
видов размещения.


                                    - 142 -
  Заметьте, что просто как

  name* q = new name[NALL];

     память выделять нельзя,  поскольку это приведет к беско-
нечной рекурсии, когда new вызовет name::name().

  Освобождение памяти обычно тривиально:

  name::~name()
  (*
      next = nfree;
      nfree = this;
      this = 0;
  *)

     Присваивание указателю this 0 в деструкторе  обеспечива-
ет, что стандартный распределитель памяти не используется.

                    5.5.7 Предостережение

     Когда в конструкторе производится указателю this, значе-
ние this до этого присваивания неопределено.  Таким  образом,
ссылка на   член  до этого присваивания неопределена и скорее
всего приведет к катастрофе. Имеющийся компилятор не пытается
убедиться в  том,  что присваивание указателю this происходит
на всех траекториях выполнения:

  mytype::mytype(int i)
  (*
      if (i) this = mytype_alloc();
      // присваивание членам
  *);

     откомпилируется, и при i==0 никакой объект  размещен  не
будет.

     Конструктор может определить, был ли он вызван операцией
new, или  нет. Если он вызван new, то указатель this на входе
имеет нулевое значение,  в противном случае this указывает на
пространство, уже выделенное для объекта (например, на стек).
Поэтому можно  просто написать конструктор,  который выделяет
память, если  (и только если) он был вызван через new. Напри-
мер:

  mytype::mytype(int i)
  (*
      if (this == 0) this = mytype_alloc();
      // присваивание членам
  *);

     Эквивалентного средства,   которое позволяет деструктору
решить вопрос,  был ли его объект создан с помощью  new,   не
имеется, как нет и средства, позволяющего ему узнать, вызвала
ли его delete,  или он вызван объектом,  выходящим из области
видимости. Если для пользователя это существенно, то он может
сохранить где-то соответствующую информацию для  деструктора.
Другой способ - когда пользователь обеспечивает,  что объекты
этого класса размещаются только соответствующим образом. Если
удается справиться с первой проблемой, то второй способ инте-
реса не представляет.

     Если тот,  кто реализует класс,  является одновременно и
его единственным   пользователем,   то  имеет смысл упростить
класс, исходя  из предположений о его  использовании.   Когда
класс разрабатывается для более широкого использования, таких
допущений, как правило, лучше избегать.

                                    - 143 -

              5.5.8 Объекты Переменного Размера

     Когда пользователь берет управление распределением и ос-
вобождением памяти,  он может конструировать объекты размеры,
которых во время компиляции недетерминирован.   В  предыдущих
примерах вмещающие (или контейнерные - перев.) классы vector,
stack, intset  и table реализовывались как структуры  доступа
фиксированного размера,  содержащие указатели на реальную па-
мять. Это  подразумевает,  что для создания таких объектов  в
свободной памяти необходимо две операции по выделению памяти,
и что любое обращение к хранимой информации  будет  содержать
дополнительную косвенную адресацию. Например:

  class char_stack (*
      int size;
      char* top;
      char* s;
  public:
      char_stack(int sz) (* top=s=new char[size=sz]; *)
      ~char_stack() (* delete s; *) // деструктор
      void push(char c) (* *top++ = c; *)
      char pop() (* return *--top; *)
  *);

     Если каждый объект класса размещается в свободной  памя-
     ти, это делать не нужно. Вот другой вариант:

  class char_stack (*
      int size;
      char* top;
      char s[1];
  public:
      char_stack(int sz);
      void push(char c) (* *top++ = c; *)
      char pop() (* return *--top; *)
  *);

  char_stack::char_stack(int sz)
  (*
      if (this) error("стек не в свободной памяти");
      if (sz < 1) error("размер стека < 1");
      this = (char_stack*) new char[sizeof(char_stack)+sz-1];
      size = sz;
      top = s;
  *)

     Заметьте, что деструктор больше не нужен,  поскольку па-
мять, которую  использует char_stack, может освободить delete
без всякого содействия со стороны программиста.

                       5.6 Упражнения

  1.    (*1) Модифицируйте настольный калькулятор из Главы 3,
     чтобы использовать класс table.

  2.    (*1)   Разработайте tnode (#с.8.5)  как класс с конс-
     трукторами, деструкторами  и т.п.  Определите дерево  из
     tnode'ов как   класс  с конструкторами,  деструкторами и
     т.п.

  3.    (*1)  Преобразуйте класс intset (#5.3.2)  в множество
     строк.

  4.    (*1)   Преобразуйте  класс  intset  в множество узлов
     node, где node - определяемая вами структура.


                                    - 144 -
  5.    (*3) Определите класс для анализа, хранения, вычисле-
     ния и печати простых арифметических выражений, состоящих
     из целых констант и операций +,  -,  * и /. Открытый ин-
     терфейс должен выглядеть примерно так:

       class expr (*
           // ...
       public:
           expr(char*);
           int eval();
           void print();
       *)

     Параметр строка конструктора expr::expr() является выра-
     жением. Функция expr::eval() возвращает значение выраже-
     ния, а  expr::print() печатает представление выражения в
     cout. Программа может выглядеть, например, так:

       expr x("123/4+123*4-3");
       cout << "x = " << x.eval() << "\n";
       x.print();

     Определите класс expr два раза: один раз используя в ка-
     честве представления связанный список узлов,   а  другой
     раз -  символьную строку.  Поэкспериментируйте с разными
     способами печати выражения:  с полностью  расставленными
     скобками,в постфиксной записи,в ассемблерном коде и т.д.

  6.    (*1) Определите класс char_queue (символьная очередь)
     таким образом,    чтобы открытый интерфейс не зависел от
     представления. Реализуйте  char_queue как (1)  связанный
     список и  как (2)  вектор.  О согласованности не заботь-
     тесь.

  7.    (*2)  Определите класс histogram (гистограмма), в ко-
     тором ведется   подсчет чисел в определенных интервалах,
     которые задаются как параметры  конструктора  histogram.
     Обеспечьте функцию вывода гистограммы на печать. Сделай-
     те обработку значений,  выходящих за границы. Подсказка:
     <task.h>.

  8.    (*2)   Определите несколько классов,  предоставляющих
     случайные числа с определенными распределениями.  Каждый
     класс имеет конструктор,  задающий параметры распределе-
     ния, и функцию draw, которая возвращает "следующее" зна-
     чение. Подсказка:     <task.h>.   Посмотрите также класс
     intset.

  9.   (*2)   Перепишите  пример  date   (#5.8.2),    пример
     char_stack (#5.2.5)  и пример intset (#5.3.2) не исполь-
     зуя функций членов (даже конструкторов и  деструкторов).
     Используйте только class и friend.  Сравните с версиями,
     в которых использовались функции члены.

  10.    (*3)  Для какого-нибудь  языка  спроектируйте  класс
     таблица имен   и  класс вхождение в таблицу имен.  Чтобы
     посмотреть, как  на самом деле  выглядит  таблица  имен,
     посмотрите на компилятор этого языка.

  11.    (*2)   Модифицируйте класс выражение из Упражнения 5
     так, чтобы обрабатывать переменные и операцию присваива-
     ния =.  Используйте класс таблица имен из Упражнения 10.

  12.    (*1) Дана программа:

       #include <stream.h>


                                    - 145 -
       main()
       (*
           cout << "Hello, world\n";
       *)

              модифицируйте ее, чтобы получить выдачу

                Initialize
                Hello, world
                Clean up

              Не делайте никаких изменений в main().

                                    - 146 -

Глава 6
Перегрузка Операций

                                       Здесь водятся Драконы!
                                            - старинная карта

     В этой главе описывается аппарат,  предоставляемый в С++
для перегрузки  операций.  Программист может определять смысл
операций при их применении к объектам  определенного  класса.
Кроме арифметических,  можно определять еще и логические опе-
рации, операции  сравнения,  вызова () и индексирования [], а
также можно переопределять присваивание и инициализацию. Мож-
но определить явное и неявное преобразование между определяе-
мыми пользователем и основными типами.  Показано, как опреде-
лить класс,   объект  которого  не  может  быть  никак  иначе
скопирован или уничтожен кроме как специальными определенными
пользователем функциями.

                        6.1 Введение

     Часто программы работают с объектами,  которые  являются
конкретными представлениями   абстрактных понятий.  Например,
тип данных int в С++ вместе с операциями +,  -,  *,  / и т.д.
предоставляет реализацию (ограниченную) математического поня-
тия целых чисел.  Такие понятия обычно включают в  себя  мно-
жество операций,  которые кратко, удобно и привычно представ-
ляют основные действия над  объектами.   К  сожалению,   язык
программирования может    непосредственно  поддерживать  лишь
очень малое число таких понятий. Например, такие понятия, как
комплексная арифметика, матричная алгебра, логические сигналы
и строки не получили прямой поддержки  в  С++.   Классы  дают
средство спецификации в С++ представления неэлементарных объ-
ектов вместе с множеством действий,  которые могут над  этими
объектами выполняться. Иногда определение того, как действуют
операции на объекты классов,  позволяет программисту  обеспе-
чить более общепринятую и удобную запись для манипуляции объ-
ектами классов,  чем та, которую можно достичь используя лишь
основную функциональную запись. Например:

  class complex (*
      double re, im;
  public:
      complex(double r, double i) (* re=r; im=i; *)
      friend complex operator+(complex, complex);
      friend complex operator*(complex, complex);
  *);

     определяет простую  реализацию понятия комплексного чис-
ла, в  которой число представляется парой чисел  с  плавающей
точкой двойной   точности,   работа с которыми осуществляется
посредством операций + и * (и  только).   Программист  задает
смысл операций  + и * с помощью определения функций с именами
operator+ и operator*.  Если,  например,  даны  b  и  c  типа
complex, то b+c означает (по определению) operator+(b,c). Те-
перь есть возможность приблизить  общепринятую  интерпретацию
комплексных выражений. Например:

  void f()
  (*
      complex a = complex(1, 3.1);
      complex b = complex(1.2, 2);
      complex c = b;

      a = b+c;
      b = b+c*a;
      c = a*b+complex(1,2);
  *)

                                    - 147 -
     Выполняются обычные правила приоритетов,  поэтому второй
оператор означает b=b+(c*a), а не b=(b+c)*a.

                    6.2 Функции Операции

     Можно описывать функции, определяющие значения следующих
операций:

  + - * / % ^ & ! ~ !
  = < > += -= *= /= %= ^= &=
  != << >> >>= <<= == != <= >= &&
  !! ++ -- [] () new delete

     Последние четыре  -  это  индексирование  (#6.7),  вызов
функции (#6.8),  выделение свободной  памяти  и  освобождение
свободной памяти (#3.2.6).  Изменить приоритеты перечисленных
операций невозможно,  как невозможно изменить и синтаксис вы-
ражений. Нельзя,  например, определить унарную операцию % или
бинарную !.  Невозможно определить новые лексические  символы
операций, но в тех случаях, когда множество операций недоста-
точно, вы  можете использовать запись вызова функции. Исполь-
зуйте например,  не **,  а pow(). Эти ограничения могут пока-
заться драконовскими,  но более гибкие  правила  могут  очень
легко привести к неоднозначностям. Например, на первый взгляд
определение операции **, означающей возведение в степень, мо-
жет показаться очевидной и простой задачей,  но подумайте еще
раз. Должна  ли ** связываться влево (как  в  Фортране)   или
вправо (как   в Алголе)?  Выражение a**p должно интерпретиро-
ваться как a*(*p) или как (a)**(p)?

     Имя функции операции есть ключевое  слово  operator  (то
есть, операция),  за которым следует сама операция, например,
operator<<. Функция  операция описывается и может  вызываться
так же,   как любая другая функция.  Использование операции -
это лишь сокращенная запись явного вызова  функции  операции.
Например:

  void f(complex a, complex b)
  (*
      complex c = a + b; // сокращенная запись
      complex d = operator+(a,b); // явный вызов
  *)

     При наличии предыдущего описания complex оба инициализа-
тора являются синонимами.

              6.2.1 Бинарные и Унарные Операции

     Бинарная операция может быть определена или как  функция
член, получающая один параметр, или как функция друг, получа-
ющая два параметра.  Таким образом, для любой бинарной опера-
ции @       aa@bb    может    интерпретироваться    или   как
aa.operator@(bb), или  как operator@(aa,bb).  Если определены
обе, то  aa@bb является ошибкой. Унарная операция, префиксная
или постфиксная,  может быть определена или как функция член,
не получающая  параметров,  или как функция друг,  получающая
один параметр. Таким образом, для любой унарной операции @ aa
@ или   @aa  может интерпретироваться или как aa.operator@(),
или как operator@(aa).  Если определено и то,  и другое, то и
aa@, и @aa являются ошибками. Рассмотрим следующие примеры:

  class X (*
  // друзья

      friend X operator-(X);     // унарный минус
      friend X operator-(X,X);   // бинарный минус
      friend X operator-();      // ошибка: нет операндов

                                    - 148 -
      friend X operator-(X,X,X); // ошибка: тернарная

  // члены (с неявным первым параметром: this)

      X* operator&();            // унарное & (взятие адреса)
      X operator&(X);            // бинарное & (операция И)
      X operator&(X,X);          // ошибка: тернарное

  *);

     Когда операции ++ и -- перегружены, префиксное использо-
вание и постфиксное различить невозможно.

            6.2.2 Предопределенный Смысл Операций

     Относительно смысла операций,  определяемых  пользовате-
лем, не делается никаких предположений. В частности, посколь-
ку не   предполагается,   что   перегруженное   =   реализует
присваивание ее первому операнду, не делается никакой провер-
ки, чтобы  удостовериться,  является ли этот  операнд  lvalue
(#с.6).

     Значения некоторых  встроенных  операций  определены как
равносильные определенным комбинациям других операций над те-
ми же аргументами.  Например, если a является int, то ++a оз-
начает a+=1, что в свою очередь означает a=a+1. Такие соотно-
шения для определяемых пользователем операций не выполняются,
если только не случилось так,  что пользователь сам определил
их таким образом. Например, определение operator+= () для ти-
па complex    не   может   быть   выведено   из   определений
complex::operator+() и complex::operator=().

     По историческому совпадению операции = и & имеют опреде-
ленный смысл для объектов классов.  Никакого элегантного спо-
соба "не определить" эти две операции не существует.  Их мож-
но, однако,   сделать недееспособными для класса  X.   Можно,
например, описать   X::operator&(),  не задав ее определения.
Если где-либо будет браться адрес объекта класса X, то компо-
новщик обнаружит отсутствие определения*. Или, другой способ,
можно определить X::operator&() так, чтобы она вызывала ошиб-
ку во время выполнения.

____________________
     * В некоторых системах компоновщик настолько "умен", что
ругается, даже   если неопределена неиспользуемая функция.  В
таких системах этим методом воспользоваться нельзя. (прим ав-
тора)

      6.2.3 Операции и Определяемые Пользователем Типы

     Функция операция должна или быть членом,  или получать в
качестве параметра по меньшей мере один объект класса  (функ-
циям, которые  переопределяют операции new и delete,  это де-
лать необязательно).  Это правило гарантирует,  что пользова-
тель не     может  изменить  смысл  никакого  выражения,   не
включающего в себя определенного пользователем типа.  В част-
ности, невозможно  определить функцию, которая действует иск-
лючительно на указатели.

     Функция операция,  первым параметром которой предполага-
ется основной встроенный тип,  не может быть функцией членом.
Рассмотрим, например,   сложение комплексной переменной aa  с
целым 2:  aa+2, при подходящим образом описанной функции чле-
не, может  быть проинтерпретировано как aa.operator+(2), но с
2+aa это не может быть сделано,  потому что нет такого класса
int, для  которого можно было бы определить + так,  чтобы это
означало 2.operator+(aa).  Даже если бы такой тип был, то для

                                    - 149 -
того, чтобы  обработать и 2+aa и aa+2,  понадобилось  бы  две
различных функции  члена.  Так как компилятор не знает смысла
+, определяемого пользователем, то не может предполагать, что
он коммутативен,    и интерпретировать 2+aa как aa+2.  С этим
примером могут легко справиться функции друзья.

     Все функции операции по определению перегружены. Функция
операция задает  новый смысл операции в дополнение к встроен-
ному определению, и может существовать несколько функций опе-
раций с   одним  и тем же именем,  если в типах их параметров
имеются отличия,  различимые для компилятора,  чтобы  он  мог
различать их при обращении (см. #4.6.7).

     6.3 Определяемое Пользователем Преобразование Типа

     Приведенная во  введении  реализация  комплексных  чисел
слишком ограничена,  чтобы она могла устроить кого-либо, поэ-
тому ее   нужно  расширить.  Это будет в основном повторением
описанных выше методов. Например:

  class complex (*
      double re, im;
  public:
      complex(double r, double i) (* re=r; im=i; *)


      friend complex operator+(complex, complex);
      friend complex operator+(complex, double);
      friend complex operator+(double, complex);

      friend complex operator-(complex, complex);
      friend complex operator-(complex, double);
      friend complex operator-(double, complex);
      complex operator-()                        // унарный -

      friend complex operator*(complex, complex);
      friend complex operator*(complex, double);
      friend complex operator*(double, complex);

      // ...
  *);

  Теперь, имея описание complex, мы можем написать:

  void f()
  (*
      complex a(1,1), b(2,2), c(3,3), d(4,4), e(5,5);
      a = -b-c;
      b = c*2.0*c;
      c = (d+e)*a;
  *)

     Но писать   функцию  для  каждого  сочетания  complex  и
double, как  это делалось выше для  operator+(),   невыносимо
нудно. Кроме  того, близкие к реальности средства комплексной
арифметики должны предоставлять по меньшей мере дюжину  таких
функций. Посмотрите,   например,  на тип complex, описанный в
<complex.h>.

                     6.3.1 Конструкторы

     Альтернативу использованию нескольких функций  (перегру-
женных) составляет описание конструктора, который по заданно-
му double создает complex. Например:
                                           
                                           
                                           

                                    - 150 -
                                           
  class complex (*
      // ...
      complex(double r) (* re=r; im=0; *)
  *);

     Конструктор, требующий  только  один параметр,  необяза-
тельно вызывать явно:

  complex z1 = complex(23);
  complex z2 = 23;

     И z1, и z2 будут инициализированы вызовом complex(23).

     Конструктор -  это  предписание,  как создавать значение
данного типа.  Когда требуется значение типа,  и когда  такое
значение может быть создано конструктором,  тогда, если такое
значение дается для  присваивания,   вызывается  конструктор.
Например, класс complex можно было бы описать так:

  class complex (*
      double re, im;
  public:
      complex(double r, double i = 0) (* re=r; im=i; *)

      friend complex operator+(complex, complex);
      friend complex operator*(complex, complex);
  *);

     и действия, в которые будут входить переменные complex и
целые константы,   стали бы допустимы.  Целая константа будет
интерпретироваться как complex с нулевой мнимой частью.  Нап-
ример, a=b*2 означает:

  a=operator*( b, complex( double(2), double(0) ) )

     Определенное пользователем  преобразование типа применя-
ется неявно только тогда, когда оно является единственным.

     Объект, сконструированный с помощью явного или  неявного
вызова конструктора,  является автоматическим и будет уничто-
жен при первой возможности,  обычно сразу же после оператора,
в котором он был создан.

                6.3.2 Операции Преобразования

     Использование конструктора  для  задания  преобразования
типа является удобным, но имеет следствия, которые могут ока-
заться нежелательными:

  [1]    Не  может быть неявного преобразования из определен-
     ного пользователем типа в основной тип (поскольку основ-
     ные типы не являются классами)

  [2]    Невозможно  задать  преобразование  из нового типа в
     старый, не изменяя описание старого

  [3]    Невозможно иметь конструктор с одним параметром,  не
     имея при этом преобразования.

     Последнее не  является серьезной проблемой,  а с первыми
двумя можно справиться, определив для исходного типа операцию
преобразования. Функция член X::operator T(), где T - имя ти-
па, определяет преобразование из X в T. Например, можно опре-
делить тип   tiny  (крошечный),  который может иметь значение
только в диапазоне 0...63,  но все равно может свободно соче-
таться в целыми в арифметических операциях:

                                    - 151 -

  class tiny (*
      char v;
      int assign(int i)
      (*return v=(i&~63) ? (error("ошибка диапазона"),0):i;*)
  public:
      tiny(int i) (* assign(i); *)
      tiny(tiny& i) (* v = t.v; *)
      int operator=(tiny& i) (* return v = t.v; *)
      int operator=(int i) (* return assign(i); *)
      operator int() (* return v; *)
  *)

     Диапазон значения проверяется всегда, когда tiny инициа-
лизируется int,  и всегда,  когда ему присваивается int. Одно
tiny может присваиваться другому без проверки диапазона. Что-
бы разрешить выполнять над  переменными  tiny  обычные  целые
операции, определяется tiny::operator int(), неявное преобра-
зование из tiny в int.  Всегда, когда в том месте, где требу-
ется int,  появляется tiny,  используется соответствующее ему
int. Например:

  void main()
  (*
      tiny c1 = 2;
      tiny c2 = 62;
      tiny c3 = c2 - c1; // c3 = 60
      tiny c4 = c3; // нет проверки диапазона (необязательна)
      int i = c1 + c2; // i = 64
      c1 = c2 + 2 * c1; // ошибка диапазона: c1 = 0 (а не 66)
      c2 = c1 -i; // ошибка диапазона: c2 = 0
      c3 = c2; // нет проверки диапазона (необязательна)
  *)

     Тип вектор из tiny может оказаться более полезным,  пос-
кольку он экономит пространство. Чтобы сделать этот тип более
удобным в обращении, можно использовать операцию индексирова-
ния.

     Другое применение определяемых операций преобразования -
это типы,  которые предоставляют нестандартные  представления
чисел (арифметика по основанию 100,  арифметика, арифметика с
фиксированной точкой,    двоично-десятичное  представление  и
т.п.). При этом обычно переопределяются такие операции, как +
и *.

     Функции преобразования  оказываются  особенно  полезными
для работы со структурами данных, когда чтение (реализованное
посредством операции преобразования)  тривиально,  в то время
как присваивание и инициализация заметно более сложны.

     Типы istream и ostream опираются на функцию преобразова-
ния, чтобы сделать возможными такие операторы, как

  while (cin>>x) cout<<x;

     Действие ввода cin>>x выше возвращает istream&. Это зна-
чение неявно преобразуется к значению, которое указывает сос-
тояние cin,  а уже это значение может проверяться  оператором
while (см. #8.4.2). Однако определять преобразование из оного
типа в другой так,  что при этом теряется информация,  обычно
не стоит.

                    6.3.3 Неоднозначности

     Присваивание объекту (или инициализация объекта)  класса
X является допустимым,  если или присваиваемое значение явля-

                                    - 152 -
ется X, или существует единственное преобразование присваива-
емого значения в тип X.
     В некоторых случаях значение  нужного  типа  может  быть
построено с   помощью нескольких применений конструкторов или
операций преобразования.  Это должно делаться явно;  допустим
только один   уровень  неявных  преобразований,  определенных
пользователем. Иногда  значение нужного типа может быть пост-
роено более  чем одним способом.  Такие случаи являются недо-
пустимыми. Например:

  class x (* /* ... */ x(int); x(char*); *);
  class y (* /* ... */ y(int); *);
  class z (* /* ... */ z(x); *);

  overload f;
  x f(x);
  y f(y);

  z g(z);

  f(1); // недопустимо: неоднозначность f(x(1)) или
  f(y(1))
  f(x(1));
  f(y(1));
  g("asdf"); // недопустимо: g(z(x("asdf"))) не пробуется
  g(z("asdf"));

     Определяемые пользователем преобразования рассматривают-
ся только в том случае,  если без них вызов разрешить нельзя.
Например:

  class x (* /* ... */ x(int); *)
  overload h(double), h(x);
  h(1);

     Вызов мог    бы    быть   проинтерпретирован   или   как
h(double(1)), или как h(x(1)), и был бы недопустим по правилу
единственности. Но    первая  интерпретация использует только
стандартное преобразование и она будет выбрана  по  правилам,
приведенным в #4.6.7.

     Правила преобразования  не  являются  ни самыми простыми
для реализации и документации, ни наиболее общими из тех, ко-
торые можно   было бы разработать.  Возьмем требование единс-
твенности преобразования. Более общий подход разрешил бы ком-
пилятору применять   любое преобразование,  которое он сможет
найти; таким образом, не нужно было бы рассматривать все воз-
можные преобразования  перед тем,  как объявить выражение до-
пустимым. К  сожалению,  это означало бы, что смысл программы
зависит от того, какое преобразование было найдено. В резуль-
тате смысл программы неким образом зависел бы от порядка опи-
сания преобразований.  Поскольку они часто находятся в разных
исходных файлах (написанных разными людьми),  смысл программы
будет зависеть от порядка компоновки этих частей вместе. Есть
другой вариант - запретить все неявные  преобразования.   Нет
ничего проще,   но такое правило приведет либо к неэлегантным
пользовательским интерфейсам,  либо к бурному росту  перегру-
женных функций,  как это было в предыдущем разделе с complex.

  Самый общий подход учитывал бы всю имеющуюся информацию о
типах и рассматривал бы все возможные преобразования. Напри-
мер, если использовать предыдущее описание, то можно было бы
обработать aa=f(1), так как тип aa определяет единственность
толкования. Если aa является x, то единственное, дающее в ре-
зультате x, который требуется присваиванием, - это f(x(1)), а
если aa - это y, то вместоэтого будет использоваться f(y(1)).
Самый общий подход справился бы и с g("asdf"), поскольку еди-

                                    - 153 -
нственной интерпретацией этого может быть g(z(x("asdf"))).
Сложность этого подхода в том, что он требует расширенного а-
нализа всего выражения для того, чтобы определить интерпрета-
цию каждой операции и вызова функции. Это приведет к замедле-
нию компиляции, а также к вызывающим удивление интерпретация-
м и сообщениям об ошибках, если компилятор рассмотрит преоб-
разования, определенные в библиотеках и т.п. При таком подхо-
де компилятор будет принимать во внимание больше, чем, как
можно ожидать, знает пишущий программу программист!

                        6.4 Константы

     Константы классового  типа  определить  невозможно в том
смысле, в  каком 1.2 и 12e являются константами типа  double.
Вместо них, однако, часто можно использовать константы основ-
ных типов,  если их реализация обеспечивается с помощью функ-
ций членов.  Общий аппарат для этого дают конструкторы, полу-
чающие один    параметр.    Когда   конструкторы   просты   и
подставляются inline,    имеет  смысл  рассмотреть в качестве
константы вызов конструктора.  Если,  например, в <comlpex.h>
есть описание         класса     comlpex,     то    выражение
zz1*3+zz2*comlpex(1,2) даст  два вызова функций, а не пять. К
двум вызовам функций приведут две операции *,  а операция + и
конструктор, к  которому обращаются для создания comlpex(3) и
comlpex(1,2), будут расширены inline.

                     6.5 Большие Объекты

     При каждом  применении  для  comlpex  бинарных операций,
описанных выше,  в функцию,  которая реализует операцию,  как
параметр передается копия каждого операнда.  Расходы на копи-
рование каждого double заметны, но с ними вполне можно прими-
риться. К  сожалению, не все классы имеют небольшое и удобное
представление. Чтобы  избежать ненужного копирования,   можно
описать функции  таким образом,  чтобы они получали ссылочные
параметры. Например:

  class matrix (*
      double m[4][4];
  public:
      matrix();
      friend matrix operator+(matrix&, matrix&);
      friend matrix operator*(matrix&, matrix&);
  *);

     Ссылки позволяют  использовать  выражения,    содержащие
обычные арифметические  операции над большими объектами,  без
ненужного копирования. Указатели применять нельзя, потому что
невозможно для  применения к указателю смысл операции переоп-
ределить невозможно. Операцию плюс можно определить так:

  matrix operator+(matrix&, matrix&);
  (*
      matrix sum;
      for (int i=0; i<4; i++)
          for (int j=0; j<4; j++)
              sum.m[i][j] = arg1.m[i][j] + arg2.m[i][j];
      return sum;
  *)

     Эта operator+()   обращается к операндам + через ссылки,
но возвращает значение объекта. Возврат ссылки может оказать-
ся более эффективным:

  class matrix (*
      // ...
      friend matrix& operator+(matrix&, matrix&);

                                    - 154 -
      friend matrix& operator*(matrix&, matrix&);
  *);

     Это является допустимым, но приводит к сложности с выде-
лением памяти.  Поскольку ссылка на результат  будет  переда-
ваться из функции как ссылка на возвращаемое значение, оно не
может быть автоматической переменной.  Поскольку часто опера-
ция используется в выражении больше одного раза, результат не
может быть и статической переменной.  Как правило, его разме-
щают в свободной памяти. Часто копирование возвращаемого зна-
чения оказывается дешевле (по времени выполнения, объему кода
и объему данных) и проще программируется.

              6.6 Присваивание и Инициализация

     Рассмотрим очень простой класс строк string:

  struct string (*
      char* p;
      int size; // размер вектора, на который указывает p

      string(int sz) (* p = new char[size=sz]; *)
      ~string() (* delete p; *)
  *);

     Строка - это структура данных, состоящая из вектора сим-
волов и длины этого вектора. Вектор создается конструктором и
уничтожается деструктором.  Однако, как показано в #5.10, это
может привести к неприятностям. Например:

  void f()
  (*
      string s1(10);
      string s2(20);
      s1 = s2;
  *)

     будет размещать два вектора символов, а присваивание s1=
s2 будет портить указатель на один из них и дублировать  дру-
гой. На выходе из f() для s1 и s2 будет вызываться деструктор
и уничтожать один и тот же вектор с  непредсказуемо  разруши-
тельными последствиями.  Решение этой проблемы состоит в том,
чтобы соответствующим образом определить присваивание  объек-
тов типа string:

  struct string (*
      char* p;
      int size; // размер вектора, на который указывает p

      string(int sz) (* p = new char[size=sz]; *)
      ~string() (* delete p; *)
      void operator=(string&)
  *);

  void string::operator=(string& a)
  (*
      if (this == &a) return; // остерегаться s=s;
      delete p;
      p=new char[size=a.size];
      strcpy(p,a.p);
  *)

     Это определение string гарантирует,и что предыдущий при-
мер будет работать как предполагалось. Однако небольшое изме-
нение f()  приведет к  появлению  той  же  проблемы  в  новом
облике:


                                    - 155 -
  void f()
  (*
      string s1(10);
      s2 = s1;
  *)

     Теперь создается только одна строка, а уничтожается две.
К неинициализированному  объекту  определяемая  пользователем
операция присваивания   не  применяется.   Беглый  взгляд  на
string::operator=() объясняет,   почему было бы неразумно так
делать: указатель   p будет содержать неопределенное и совер-
шенно случайное значение. Часто операция присваивания полага-
ется на то, что ее аргументы инициализированы. Для такой ини-
циализации, как    здесь,   это  не   так   по   определению.
Следовательно, нужно  определить похожую, но другую, функцию,
чтобы обрабатывать инициализацию:

  struct string (*
      char* p;
      int size; // размер вектора, на который указывает p

      string(int sz) (* p = new char[size=sz]; *)
      ~string() (* delete p; *)
      void operator=(string&);
      string(string&);
  *);

  void string::string(string& a)
  (*
      p=new char[size=a.size];
      strcpy(p,a.p);
  *)

     Для типа X инициализацию тем  же  типом  X  обрабатывает
конструктор X(X&). Нельзя не подчеркнуть еще раз, что присва-
ивание и инициализация - разные действия.  Это  особенно  су-
щественно при описании деструктора.  Если класс X имеет конс-
труктор X(X&),    выполняющий  нетривиальную   работу   вроде
освобождения памяти, то скорее всего потребуется полный комп-
лект функций, чтобы полностью избежать побитового копирования
объектов:

  class X (*
    // ...
    X(something);    // конструктор: создает объект
    X(&X);           // конструктор: копирует в инициализации
    operator=(X&);   // присваивание: чистит и копирует
    ~X();            // деструктор: чистит
  *);

     Есть еще два случая,  когда объект копируется: как пара-
метр функции и как возвращаемое значение.   Когда  передается
параметр, инициализируется  неинициализированная до этого пе-
ременная - формальный параметр. Семантика идентична семантике
инициализации. То   же самое происходит при возврате из функ-
ции, хотя  это менее очевидно. В обоих случаях будет применен
X(X&), если он определен:

  string g(string arg)
  (*
      return arg;
  *)

  main()
  (*
      string s = "asdf";
      s = g(s);

                                    - 156 -
  *)
     Ясно, что после вызова  g()   значение  s  обязано  быть
"asdf". Копирование    значения s в параметр arg сложности не
представляет: для  этого надо взывать  string(string&).   Для
взятия копии  этого значения из g()  требуется еще один вызов
string(string&); на этот раз инициализируемой  является  вре-
менная переменная, которая затем присваивается s. Такие пере-
менные, естественно,   уничтожаются как  положено  с  помощью
string::~string() при первой возможности.

                     6.7 Индексирование

     Чтобы задать смысл индексов для объектов класса, исполь-
зуется функция operator[].  Второй параметр (индекс)  функции
operator[] может  быть любого типа.  Это позволяет определять
ассоциативные массивы и т.п. В качестве примера давайте пере-
пишем пример из #2.3.10, где при написании небольшой програм-
мы для подсчета числа вхождений слов в файле применялся ассо-
циативный массив.      Там   использовалась  функция.   Здесь
определяется надлежащий тип ассоциативного массива:

  struct pair (*
      char* name;
      int val;
  *);

  class assoc (*
      pair* vec;
      int max;
      int free;
  public:
      assoc(int);
      int& operator[](char*);
      void print_all();
  *);

     В assoc хранится вектор пар pair длины max.  Индекс пер-
вого неиспользованного элемента  вектора  находится  в  free.
Конструктор выглядит так:

  assoc::assoc(int s)
  (*
      max = (s<16) ? s : 16;
      free = 0;
      vec = new pair[max];
  *)

     При реализации применяется все тот же простой и неэффек-
тивный метод поиска,  что использовался в #2.3.10. Однако при
переполнении assoc увеличивается:

  #include <string.h>

  int assoc::operator[](char* p)
  /*
      работа с множеством пар "pair":
      поиск p,
      возврат ссылки на целую часть его "pair"
      делает новую "pair", если p не встречалось
  */
  (*
      register pair* pp;

      for (pp=&vec[free-1]; vec<=pp; pp--)
          if (strcmp(p,pp->name)==0) return pp->val;

      if (free==max) (* // переполнение: вектор увеличивается

                                    - 157 -
          pair* nvec = new pair[max*2];
          for ( int i=0; i<max; i++) nvec[i] = vec[i];
          delete vec;
          vec = nvec;
          max = 2*max;
  *)

      pp = &vec[free++];
      pp->name = new char[strlen(p)+1];
      strcpy(pp->name,p);
      pp->val = 0; // начальное значение: 0
      return pp->val;
  *)

     Поскольку представление assoc скрыто,  нам нужен  способ
его печати.  В следующем разделе будет показано,  как опреде-
лить подходящий итератор, а здесь мы используем простую функ-
цию печати:

  vouid assoc::print_all()
  (*
      for (int i = 0; i<free; i++)
          cout << vec[i].name << ": " << vec[i].val << "\n";
  *)

     Мы можем, наконец, написать простую главную программу:

  main() // считает вхождения каждого слова во вводе
  (*
      const MAX = 256; // больше самого большого слова
      char buf[MAX];
      assoc vec(512);
      while (cin>>buf) vec[buf]++;
      vec.print_all();
  *)

                      6.8 Вызов Функции

     Вызов функции,  то есть запись  выражение(список_выраже-
ний), можно    проинтерпретировать  как бинарную операцию,  и
операцию вызова можно перегружать так же, как и другие опера-
ции. Список  параметров функции operator() вычисляется и про-
веряется в соответствие с обычными правилами  передачи  пара-
метров. Перегружающая     функция  может  оказаться  полезной
главным образом для определения типов с единственной операци-
ей и для типов,  у которых одна операция настолько преоблада-
ет, что  другие в большинстве ситуаций можно не принимать  во
внимание.

     Для типа  ассоциативного  массива assoc мы не определили
итератор. Это  можно сделать, определив класс assoc_iterator,
работа которого  состоит в том,  чтобы в определенном порядке
поставлять элементы из assoc.  Итератору нужен доступ к  дан-
ным, которые хранятся в assoc, поэтому он сделан другом:

  class assoc (*
  friend class assoc_iterator;
      pair* vec;
      int max;
      int free;
  public:
      assoc(int);
      int& operator[](char*);
  *);

     Итератор определяется как


                                    - 158 -
  class assoc_iterator(*
      assoc* cs; // текущий массив assoc
      int i; // текущий индекс
  public:
      assoc_iterator(assoc& s) (* cs = &s; i = 0; *)
      pair* operator()()
	  (* return (i<cs->free)? &cs->vec[i++] : 0; *)
  *);

     Надо инициализировать assoc_iterator для массива  assoc,
после чего   он  будет  возвращать указатель на новую pair из
этого массива всякий раз, когда его будут активизировать опе-
рацией (). По достижении конца массива он возвращает 0:

  main() // считает вхождения каждого слова во вводе
  (*
      const MAX = 256; // больше самого большого слова
      char buf[MAX];
      assoc vec(512);
      while (cin>>buf) vec[buf]++;
      assoc_iterator next(vec);
      pair* p;
      while ( p = next() )
          cout << p->name << ": " << p->val << "\n";
  *)

0     Итераторный тип вроде этого имеет преимущество перед на-
бором функций,  которые выполняют ту же работу:  у него  есть
собственные закрытые данные для хранения хода итерации. К то-
му же обычно существенно,  чтобы одновременно могли  работать
много итераторов этого типа.

     Конечно, такое  применение  объектов  для  представления
итераторов никак особенно с перегрузкой операций не  связано.
Многие любят использовать итераторы с такими операциями,  как
first(), next() и last() (первый, следующий и последний).

                      6.9 Класс String

     Вот довольно реалистичный пример класса строк string.  В
нем производится учет ссылок на строку с целью минимизировать
копирование и в  качестве  констант  применяются  стандартные
символьные строки С++.

  #include <stream.h>
  #include <string.h>

  class string (*
      struct srep (*
          char* s;      // указатель на данные
          int n;        // счетчик ссылок
  *);
      srep *p;

 
 public:
      string(char *);   // string x = "abc"
      string();         // string x;
      string(string &); // string x = string ...
      string& operator=(char *);
      string& operator=(string &);
      ~string();
      char& operator[](int i);

      friend ostream& operator<<(ostream&, string&);
      friend istream& operator>>(istream&, string&);


                                    - 159 -
      friend int operator==(string& x, char* s)
	  (*return strcmp(x.p->s, s) == 0; *)

      friend int operator==(string& x, string& y)
	  (*return strcmp(x.p->s, y.p->s) == 0; *)

      friend int operator!=(string& x, char* s)
	  (*return strcmp(x.p->s, s) != 0; *)

      friend int operator!=(string& x, string& y)
	  (*return strcmp(x.p->s, y.p->s) != 0; *)

  *);

     Конструкторы и деструкторы просты (как обычно):

  string::string()
  (*
      p = new srep;
      p->s = 0;
      p->n = 1;
  *)

  string::string(char* s)
  (*
      p = new srep;
      p->s = new char[ strlen(s)+1 ];
      strcpy(p->s, s);
      p->n = 1;
  *)

  string::string(string& x)
  (*
      x.p->n++;
      p = x.p;
  *)

  string::~string()
  (*
      if (--p->n == 0) (*
          delete p->s;
          delete p;
      *)
  *)

     Как обычно,  операции присваивания очень похожи на конс-
трукторы. Они должны обрабатывать очистку своего первого (ле-
вого) операнда:

  string& string::operator=(char* s)
  (*
      if (p->n > 1) (* // разъединить себя
          p->n--;
          p = new srep;
      *)
      else if (p->n == 1)
          delete p->s;

      p->s = new char[ strlen(s)+1 ];
      strcpy(p->s, s);
      p->n = 1;
      return *this;
  *)

     Благоразумно обеспечить,  чтобы присваивание объекта са-
мому себе работало правильно:


                                    - 160 -
  string& string::operator=(string& x)
  (*
      x.p->n++;
      if (--p->n == 0) (*
          delete p->s;
          delete p;
      *)
      p = x.p;
      return *this;
  *)

     Операция вывода  задумана так,  чтобы продемонстрировать
применение учета ссылок. Она повторяет каждую вводимую строку
(с помощью операции <<, которая определяется позднее):

  ostream& operator<<(ostream& s, string& x)
  (*
      return s << x.p->s << " [" << x.p->n << "]\n";
  *)

     Операция ввода использует стандартную функцию ввода сим-
вольной строки (#8.4.1).

  istream& operator>>(istream& s, string& x)
  (*
      char buf[256];
      s >> buf;
      x = buf;
      cout << "echo: " << x << "\n";
      return s;
  *)

     Для доступа к отдельным символам предоставлена  операция
индексирования. Осуществляется проверка индекса:

  void error(char* p)
  (*
      cerr << p << "\n";
      exit(1);
  *)

  char& string::operator[](int i)
  (*
     if (i<0 !! strlen(p->s)<i) error("индекс за границами");
     return p->s[i];
  *)

     Головная программа  просто немного опробует действия над
строками. Она  читает слова со ввода в строки,  а  потом  эти
строки печатает.  Она продолжает это делать до тех пор,  пока
не распознает строку done,  которая завершает сохранение слов
в строках,  или пока не встретит конец файла. После этого она
печатает строки в обратном порядке и завершается.

  main()
  (*
      string x[100];
      int n;

      cout << "отсюда начнем\n";
      for (n = 0; cin>>x[n]; n++) (*
          string y;
          if (n==100) error("слишком много строк");
          cout << (y = x[n]);
          if (y=="done") break;
      *)
      cout << "отсюда мы пройдем обратно\n";

                                    - 161 -
      for (int i=n-1; 0<=i; i--) cout << x[i];
  *)

                     6.10 Друзья и Члены

     Теперь, наконец,  можно обсудить,  в каких  случаях  для
доступа к закрытой части определяемого пользователем типа ис-
пользовать члены,  а в каких -  друзей.   Некоторые  операции
должны быть членами:  конструкторы, деструкторы и виртуальные
функции (см. следующую главу), но обычно это зависит от выбо-
ра.

  Рассмотрим простой класс X:

  class X (*
      // ...
      X(int);
      int m();
      friend int f(X&);
  *);

     Внешне не видно никаких причин делать f(X&)  другом  до-
полнительно к члену X::m()  (или наоборот), чтобы реализовать
действия над классом X.  Однако член X::m()   можно  вызывать
только для "настоящего объекта",  в то время как друг f() мо-
жет вызываться для объекта,  созданного  с  помощью  неявного
преобразования типа. Например:

  void g()
  (*
      1.m(); // ошибка
      f(1); // f(x(1));
  *)

     Поэтому операция,  изменяющая состояние объекта,  должна
быть членом,  а не другом. Для определяемых пользователем ти-
пов операции,   требующие в случае фундаментальных типов опе-
ранд lvalue (=,  *=, ++, *= и т.д.), наиболее естественно оп-
ределяются как члены.

     И наоборот,  если нужно иметь неявное преобразование для
всех операндов операции,  то реализующая  ее  функция  должна
быть другом,  а не членом. Это часто имеет место для функций,
которые реализуют операции,  не требующие  при  применении  к
фундаментальным типам lvalue в качестве операндов (+, -, !! и
т.д.).

     Если никакие преобразования типа не определены,  то ока-
зывается, что    нет  никаких существенных оснований в пользу
члена, если есть друг, который получает ссылочный параметр, и
наоборот. В  некоторых случаях программист может предпочитать
один синтаксис вызова другому.  Например,  оказывается,   что
большинство предпочитает для обращения матрицы m запись m.inv
(). Конечно,   если inv() действительно обращает матрицу m, а
не просто  возвращает новую матрицу,  обратную m,  ей следует
быть членом.

     При прочих равных условиях выбирайте, чтобы функция была
членом: никто  не знает,  вдруг когда-нибудь кто-то определит
операцию преобразования. Невозможно предсказать, потребуют ли
будущие изменения изменять состояние объекта. Синтаксис вызо-
ва функции члена ясно указывает пользователю, что объект мож-
но изменить; ссылочный параметр является далеко не столь оче-
видным. Кроме  того,  выражения в члене  могут  быть  заметно
короче выражений  в друге.  В функции друге надо использовать
явный параметр,  тогда как в члене можно использовать неявный
this. Если    только не применяется перегрузка,  имена членов

                                    - 162 -
обычно короче имен друзей.

                    6.11 Предостережение

     Как и большую часть возможностей в языках программирова-
ния, перегрузку    операций можно использовать как правильно,
так и неправильно.  В частности,  можно  так  воспользоваться
возможностью определять  новые значения старых операций,  что
они станут почти совсем непостижимы. Представьте, например, с
какими сложностями столкнется человек,  читающий программу, в
которой операция + была переопределена для обозначения  вычи-
тания.

     Изложенный аппарат  должен уберечь программиста/читателя
от худших крайностей применения перегрузки,  потому что прог-
раммист предохранен от изменения значения операций для основ-
ных типов данных вроде int, а также потому, что синтаксис вы-
ражений и приоритеты операций сохраняются.

     Может быть,    разумно   применять  перегрузку  операций
главным образом так, чтобы подражать общепринятому применению
операций. В  тех случаях, когда нет общепринятой операции или
имеющееся в С++ множество операций не подходит  для  имитации
общепринятого применения,    можно использовать запись вызова
функции.

                       6.12 Упражнения

  1. (*2) Определите  итератор для класса string.  Определите
     операцию конкатенации + и операцию  "добавить  в  конец"
     +=. Какие    еще  операции над string вы хотели бы иметь
     возможность осуществлять?

  2. (*1.5) Задайте с помощью перегрузки ()  операцию выделе-
     ния подстроки для класса строк.

  3. (*3) Постройте класс string так,  чтобы операция выделе-
     ния подстроки могла использоваться в левой части присва-
     ивания. Напишите  сначала версию, в которой строка может
     присваиваться подстроке той же длины,  а  потом  версию,
     где эти длины могут быть разными.

  4. (*2) Постройте класс string так, чтобы для присваивания,
     передачи параметров и т.п.  он имел семантику по  значе-
     нию, то  есть, когда копируется строковое представление,
     а не просто управляющая структура данных класса sring.

  5. (*3) Модифицируйте класс string из  предыдущего  примера
     таким образом,    чтобы строка копировалась только когда
     это необходимо.  То есть, храните совместно используемое
     представление двух строк, пока одна из этих строк не бу-
     дет изменена.  Не пытайтесь одновременно  с  этим  иметь
     операцию выделения   подстроки,  которая может использо-
     ваться в левой части.

  6. (*4) Разработайте класс string с семантикой по значению,
     копированием с задержкой и операцией подстроки,  которая
     может стоять в левой части.

  7. (*2) Какие преобразования используются в каждом  выраже-
     нии следующей программы:

       struct X (*
          int i;
          X(int);
          operator+(int);
       *);

                                    - 163 -
       struct Y (*
          int i;
          Y(X);
          operator+(X);
          operator int();
       *);

       X operator* (X,Y);
       int f(X);

       X x = 1;
       Y y = x;
       int i = 2;

       main()
       (*
          i + 10;
          y + 10;
          y + 10 * y;
          x + y + i;
          x * x + i;
          f(7);
          f(y);
          y + y;
          106 + y;
       *)

     Определите X и Y так,  чтобы они оба были целыми типами.
     Измените программу так,  чтобы она работала  и  печатала
     значения всех допустимых выражений.

  8. (*2) Определите класс INT, который ведет себя в точности
     как int. Подсказка: определите INT::operator int().

  9. (*1) Определите класс RINT, который ведет себя в точнос-
     ти как int за исключением того, что единственные возмож-
     ные операции - это + (унарный и бинарный),  - (унарный и
     бинарный), *,     /,   %.   Подсказка:   не  определяйте
     INT::operator int().

  10.(*3) Определите  класс LINT,  ведущий себя как RINT,  за
     исключением того, что имеет точность не менее 64 бит.

  11.(*4) Определите класс,  который реализует  арифметику  с
     произвольной точностью.   Подсказка:  вам надо управлять
     памятью аналогично тому,  как это  делалось  для  класса
     string.

  12.(*2) Напишите программу,  доведенную до нечитаемого сос-
     тояния с помощью макросов и  перегрузки  операций.   Вот
     идея: определите  для INT + так,  чтобы он означал -,  и
     наоборот, а  потом с помощью макроопределения определите
     int как  INT.  Переопределение часто употребляемых функ-
     ций, использование параметров ссылочного типа и несколь-
     ко вводящих  в заблуждение комментариев помогут устроить
     полную неразбериху.

  13.(*3) Поменяйтесь со своим другом программами,  которые у
     вас получились  в предыдущем упражнении.  Не запуская ее
     попытайтесь понять,  что делает программа вашего  друга.
     После выполнения этого упражнения вы будете знать,  чего
     следует избегать.

  14.(*2) Перепишите  примеры  с  comlpex   (#6.3.1),    tiny
     (#6.3.2) и   string (#6.9)  не используя friend функций.
     Используйте только функции члены.  Протестируйте  каждую
     из новых версий.  Сравните их с версиями,  в которых ис-

                                    - 164 -
     пользуются функции друзья. Еще раз посмотрите Упражнение
     5.3.

  15.(*2) Определите  тип  vec4  как вектор их четырех float.
     Определите operator[] для vec4.  Определите операции  +,
     -, *,  /, =, +=, -=, *=, /= для сочетаний векторов и чи-
     сел с плавающей точкой.

  16.(*3) Определите класс mat4 как вектор из  четырех  vec4.
     Определите для mat4 operator[], возвращающий vec4. Опре-
     делите для этого типа обычные  операции  над  матрицами.
     Определите функцию,  выполняющие для mat4 исключение Га-
     усса.

  17.(*2) Определите класс vector,  аналогичный vec4,   но  с
     длиной, которая    задается  как  параметр  конструктора
     vector::vector(int).

  18.(*3) Определите класс matrix,  аналогичный mat4,   но  с
     размерностью, задаваемой      параметрами   конструктора
     matrix::matrix(int,int).

                                    - 165 -

Глава 7
Производные Классы

                 Не надо размножать объекты без необходимости
                                                   - У. Оккам

     В этой главе описывается понятие производного класса в С
++. Производные классы дают простой, гибкий и эффективный ап-
парат задания для класса альтернативного интерфейса и опреде-
ления класса  посредством добавления возможностей к уже имею-
щемуся классу без перепрограммирования или перекомпиляции.  С
помощью производных  классов можно также обеспечить общий ин-
терфейс для нескольких различных классов так,   чтобы  другие
части программы  могли работать с объектами этих классов оди-
наковым образом.  При этом обычно в каждый объект  помещается
информация о типе, чтобы эти объекты могли обрабатываться со-
ответствующим образом в ситуациях, когда их тип нельзя узнать
во время компиляции.  Для элегантной и надежной обработки та-
ких динамических зависимостей типов имеется понятие виртуаль-
ной функции.  По своей сути производные классы существуют для
того, чтобы облегчить программисту формулировку общности.

                        7.1 Введение

     Представим себе процесс написания некоторого универсаль-
ного средства (например,  тип связанный список,  таблица имен
или планировщик для системы моделирования),  которое предназ-
начается для использования многими разными людьми в различных
обстоятельствах. Очевидно,   что в кандидатах на  роль  таких
средств недостатка нет,  и выгоды от их стандартизации огром-
ны. Кажется,   любой опытный программист написал (и  отладил)
дюжину вариантов типов множества,  таблицы имен,  сортирующей
функции и т.п., но оказывается, что каждый программист и каж-
дая программа используют свою версию этих понятий, из-за чего
программы слишком трудно читать,  тяжело отлаживать и  сложно
модифицировать. Более  того, в большой программе вполне может
быть несколько копий идентичных (почти) частей кода для рабо-
ты с такими фундаментальными понятиями.

     Причина этого хаоса частично состоит в том, что предста-
вить такие общие понятия в языке  программирования  сложно  с
концептуальной точки зрения,  а частично в том, что средства,
обладающие достаточной  общностью,   налагают  дополнительные
расходы по памяти и/или по времени,  что делает их неудобными
для самых простых и наиболее напряженно используемых  средств
(связанные списки,  вектора и т.п.), где они были бы наиболее
полезны. Понятие  производного класса в С++,   описываемое  в
#7.2, не   обеспечивают общего решения всех этих проблем,  но
оно дает способ справляться с довольно небольшим числом  важ-
ных случаев. Будет, например, показано, как определить эффек-
тивный класс обобщенного  связанного  списка  таким  образом,
чтобы все его версии разделяли код.

     Написание общецелевых средств - задача непростая, и час-
то основной акцент в их разработке другой, чем при разработке
программ специального назначения. Конечно, нет четкой границы
между средствами общего и специального назначения,  и к мето-
дам и  языковым средствам,  которые описываются в этой главе,
можно относиться так,  что они становятся все более полезны с
ростом объема и сложности создаваемых программ.

                   7.2 Производные Классы

     Чтобы разделить  задачи понимания аппарата языка и мето-
дов его применения, знакомство с понятием производных классов
делается в  три этапа.  Вначале с помощью небольших примеров,
которые не надо воспринимать как реалистичные,  будут описаны

                                    - 166 -
сами средства языка (запись и семантика). После этого демонс-
трируются некоторые неочевидные применения производных  клас-
сов, и, наконец, приводится законченная программа.

            7.2.1 Построение Производного Класса

     Рассмотрим построение  программы,   которая имеет дело с
людьми, служащими  в некоторой фирме. Структура данных в этой
программе может быть например такой:

  struct employee (* // служащий
      char* name; // имя
      short age; // возраст
      short department; // подразделение
      int salary; // жалование
      employee* next;
      // ...
  *);

     Список аналогичных служащих будет связываться через поле
next. Теперь давайте определим менеджера:

  struct manager (* // менеджер
      employee emp; // запись о менеджере как о служащем
      employee* group; // подчиненные люди
      // ...
  *);

     Менеджер также является служащим; относящиеся к служаще-
му employee данные хранятся в члене emp объекта manager.  Для
читающего это человека это,  может быть, очевидно, но нет ни-
чего выделяющего член emp для компилятора.  Указатель на  ме-
неджера (manager*)    не  является  указателем  на  служащего
(employee*), поэтому просто использовать один там, где требу-
ется другой,  нельзя. В частности, нельзя поместить менеджера
в список служащих, не написав для этого специальный код. Мож-
но либо применить к manager* явное преобразование типа,  либо
поместить в список служащих адрес члена emp, но и то и другое
мало элегантно и довольно неясно. Корректный подход состоит в
том, чтобы установить, что менеджер является служащим с неко-
торой добавочной информацией:

  struct manager : employee (*
      employee* group;
      // ...
  *);

     manager является производным от  employee  и,   обратно,
employee есть базовый класс для manager. Класс manager допол-
нительно к члену group имеет члены класса employee (name, age
и т.д.).

     Имея определения employee и manager мы можем теперь соз-
дать список служащих,  некоторые из которых являются менедже-
рами. Например:

  void f()
  (*
      manager m1, m2;
      employee e1, e2;
      employee* elist;
      elist = &m1; // поместить m1, e1, m2 и e2 в elist
      m1.next = &e1;
      e1.next = &m2;
      m2.next = &e2;
      e2.next = 0;
  *)

                                    - 167 -

     Поскольку менеджер является служащим, manager* может ис-
пользоваться как employee*.   Однако  служащий  необязательно
является менеджером,    поэтому  использовать  employee*  как
manager* нельзя.

                     7.2.2 Функции Члены

     Просто структуры данных вроде employee и manager на  са-
мом деле не столь интересны и часто не особенно полезны, поэ-
тому рассмотрим, как добавить в них функции. Например:

  class employee (*
      char* name;
      // ...
  public:
      employee* next;
      void print();
      // ...
  *);

  class manager : public employee (*
      // ...
  public:
      void print();
      // ...
  *);

     Надо ответить на некоторые вопросы.  Как  может  функция
член производного класса manager использовать члены его базо-
вого класса employee?  Как члены базового класса employee мо-
гут использовать   функции члены производного класса manager?
Какие члены базового класса employee может использовать функ-
ция не  член на объекте типа manager?  Каким образом програм-
мист может повлиять на ответы на эти вопросы,  чтобы удовлет-
ворить требованиям приложения?

  Рассмотрим:

  void manager::print()
  (*
      cout << " имя " << name << "\n";
      // ...
  *)

     Член производного класса может использовать открытое имя
из своего базового класса так же, как это могут делать другие
члены последнего, то есть без указания объекта. Предполагает-
ся, что  на объект указывает this, поэтому (корректной) ссыл-
кой на имя name является this->name. Однако функция manager::
print компилироваться не будет,  член производного класса  не
имеет никакого   особого  права доступа к закрытым членам его
базового класса, поэтому для нее name недоступно.

     Это многим покажется удивительным,  но представьте  себе
другой вариант: что функция член могла бы обращаться к закры-
тым членам своего базового класса.  Возможность,  позволяющая
программисту получать доступ к закрытой части класса просто с
помощью вывода из него другого класса, лишила бы понятие зак-
рытого члена всякого смысла.  Более того,  нельзя было бы уз-
нать все использования закрытого имени, посмотрев на функции,
описанные как члены и друзья этого класса. Пришлось бы прове-
рять каждый исходный файл во всей программе на наличие в  нем
производных классов,    потом исследовать каждую функцию этих
классов, потом  искать все классы,  производные от этих клас-
сов, и   т.д.  Это по меньшей мере утомительно и скорее всего
нереально.

                                    - 168 -

     С другой  стороны,   можно  ведь  использовать  механизм
friend, чтобы предоставить такой доступ или отдельным функци-
ям, или  всем функциям отдельного класса (как  описывается  в
#5.3). Например:

  class employee (*
      friend void manager::print();
      // ...
  *);

решило бы проблему с manager::print(), и

  class employee (*
  friend class manager;
      // ...
  *);

     сделало бы доступным каждый член employee для всех функ-
ций класса manager.  В частности,  это сделает name доступным
для manager::print().

     Другое, иногда более прозрачное решение для производного
класса - использовать  только  открытые  члены  его  базового
класса. Например:

  void manager::print()
  (*
      employee::print();  // печатает информацию о служащем
      // ...              // печатает информацию о менеджере
  *)

     Заметьте, что  надо использовать ::,  потому что print()
была переопределена в manager.  Такое повторное использование
имен типично. Неосторожный мог бы написать так:

  void manager::print()
  (*
      print(); // печатает информацию о служащем
      // ... // печатает информацию о менеджере
  *)

     и обнаружить,      что     программа     после    вызова
manager::print() неожиданно попадает в последовательность ре-
курсивных вызовов.

                       7.2.3 Видимость

     Класс employee  стал  открытым (public)  базовым классом
класса manager в результате описания:

  class manager : public employee (*
      // ...
  *);

     Это означает, что открытый член класса employee является
также и открытым членом класса manager. Например:

  void clear(manager* p)
  (*
      p->next = 0;
  *)

     будет компилироваться,  так как next - открытый  член  и
employee и manager'а.  Альтернатива - можно определить закры-
тый (private)  класс,  просто опустив в описании класса слово
public:

                                    - 169 -

  class manager : employee (*
      // ...
  *);

     Это означает, что открытый член класса employee является
закрытым членом класса manager. То есть, функции члены класса
manager могут как и раньше использовать открытые члены класса
employee, но  для пользователей класса manager эти члены  не-
доступны. В    частности,   при таком описании класса manager
функция clear() компилироваться не будет. Друзья производного
класса имеют к членам базового класса такой же доступ,  как и
функции члены.

     Поскольку, как оказывается,  описание  открытых  базовых
классов встречается чаще описания закрытых, жалко, что описа-
ние открытого базового  класса  длиннее  описания  закрытого.
Это, кроме  того, служит источником запутывающих ошибок у на-
чинающих.

     Когда описывается производная struct,  ее базовый  класс
по умолчанию является public базовым классом. То есть,

  struct D : B (* ...

означает

  class D : public B (* public: ...

     Отсюда следует,  что если вы не сочли полезным то сокры-
тие данных,  которое дают class,  public и friend,  вы можете
просто не   использовать  эти ключевые слова и придерживаться
struct. Такие средства языка, как функции члены, конструкторы
и перегрузка операций,  не зависят от механизма сокрытия дан-
ных.

     Можно также объявить некоторые, но не все, открытые чле-
ны базового   класса  открытыми  членами производного класса.
Например:

  class manager : employee (*
      // ...
  public:
      // ...
      employee::name;
      employee::department;
  *);

Запись

  имя_класса :: имя_члена ;

     не вводит новый член,  а просто делает открытый член ба-
зового класса открытым для производного класса. Теперь name и
department могут использоваться для manager'а, а salary и age
- нет. Естественно, сделать закрытый член базового класса от-
крытым членом производного класса невозможно.   Невозможно  с
помощью этой   записи  также  сделать открытыми перегруженные
имена.

     Подытоживая, можно сказать, что вместе с предоставлением
средств дополнительно к имеющимся в базовом классе, производ-
ный класс можно использовать для того, чтобы сделать средства
(имена) недоступными для пользователя. Другими словами, с по-
мощью производного класса можно обеспечивать прозрачный,  по-
лупрозрачный и непрозрачный доступ к его базовому классу.


                                    - 170 -
                       7.2.4 Указатели

     Если производный  класс  derived  имеет открытый базовый
класс base,  то указатель на derived можно присваивать  пере-
менной типа указатель на base не используя явное преобразова-
ние типа. Обратное преобразование, указателя на base в указа-
тель на derived, должно быть явным. Например:

  class base (* /* ... */ *);
  class derived : public base (* /* ... */ *);

  derived m;
  base* pb = &m; // неявное преобразование
  derived* pd = pb; // ошибка: base* не является derived*
  pd = (derived*)pb; // явное преобразование

     Иначе говоря,   объект  производного класса при работе с
ним через указатель и можно рассматривать как объект его  ба-
зового класса. Обратное неверно.

     Будь base закрытым базовым классом класса derived, неяв-
ное преобразование derived* в base* не делалось бы.   Неявное
преобразование не может в этом случае быть выполнено,  потому
что к открытому члену класса base можно обращаться через ука-
затель на base, но нельзя через указатель на derived:

  class base (*
      int m1;
  public:
      int m2; // m2 - открытый член base
  *);

  class derived : base (*
      // m2 - НЕ открытый член derived
  *);

  derived d;
  d.m2 = 2; // ошибка: m2 из закрытой части класса
  base* pb = &d; // ошибка: (закрытый base)
  pb->m2 = 2; // ok
  pb = (base*)&d; // ok: явное преобразование
  pb->m2 = 2; // ok

     Помимо всего прочего,  этот пример показывает,  что  ис-
пользуя явное приведение к типу можно сломать правила защиты.
Ясно, делать это не рекомендуется, и это приносит программис-
ту заслуженную "награду".  К несчастью , недисциплинированное
использование явного преобразования может создать адские  ус-
ловия для невинных жертв,  эксплуатирующих программу, в кото-
рой это делается.  Но, к счастью, нет способа воспользоваться
приведением для получения доступа к закрытому имени m1.  Зак-
рытый член  класса  может  использоваться  только  членами  и
друзьями этого класса.

                    7.2.5 Иерархия Типов

     Производный класс сам может быть базовым классом.
Например:

  class employee (* ... *);
  class secretary : employee (* ... *);
  class manager : employee (* ... *);
  class temporary : employee (* ... *);
  class consultant : temporary (* ... *);
  class director : manager (* ... *);
  class vice_president : manager (* ... *);
  class president : vice_president (* ... *);

                                    - 171 -

     Такое множество родственных классов принято называть ие-
рархией классов. Поскольку можно выводить класс только из од-
ного базового   класса,  такая иерархия является деревом и не
может быть графом более общей структуры. Например:

  class temporary (* ... *);
  class employee { ... *);
  class secretary : employee (* ... *);

  // не С++:
  class temporary_secretary : temporary : secretary(* ... *);
  class consultant : temporary : employee (* ... *);

     И этот факт вызывает сожаление,  потому что направленный
ациклический граф   производных классов был бы очень полезен.
Такие структуры описать нельзя,  но можно смоделировать с по-
мощью членов соответствующих типов. Например:

  class temporary (* ... *);
  class employee (* ... *);
  class secretary : employee (* ... *);

  // Альтернатива:
  class temporary_secretary : secretary
  (* temporary temp; ... *);
  class consultant : employee
  (* temporary temp; ... *);

     Это выглядит неэлегантно и страдает как раз от тех проб-
лем, для  преодоления  которых  были  изобретены  производные
классы. Например,  поскольку consultant не является производ-
ным от temporary,  consultant'а нельзя помещать с список вре-
менных служащих (temporary employee),  не написав специальный
код. Однако  во многих полезных программах этот метод успешно
используется.

              7.2.6 Конструкторы и Деструкторы

     Для некоторых  производных  классов  нужны конструкторы.
Если у базового класса есть конструктор,  он должен вызывать-
ся, и   если для этого конструктора нужны параметры,  их надо
предоставить. Например:

  class base (*
      // ...
  public:
      base(char* n, short t);
      ~base();
  *);

  class derived : public base (*
      base m;
  public:
      derived(char* n);
      ~derived();
  *);

     Параметры конструктора базового класса специфицируются в
определении конструктора  производного класса.  В этом смысле
базовый класс работает точно также,  как  неименованный  член
производного класса (см. #5.5.4). Например:

  derived::derived(char* n) : (n,10), m("member",123)
  (*
      // ...
  *)

                                    - 172 -

     Объекты класса конструируются снизу вверх: сначала базо-
вый, потом члены, а потом сам производный класс. Уничтожаются
они в обратном порядке:  сначала сам производный класс, потом
члены а потом базовый.

                       7.2.7 Поля Типа

     Чтобы использовать  производные  классы  не  просто  как
удобную сокращенную запись в описаниях, надо разрешить следу-
ющую проблему: Если задан указатель типа base*, какому произ-
водному типу в действительности принадлежит указываемый  объ-
ект? Есть три основных способа решения этой проблемы:

     [1] Обеспечить,  чтобы всегда указывались только объекты
         одного типа (#7.3.3),

     [2] Поместить в базовый класс поле типа,  которое смогут
         просматривать функции и

     [3] Использовать виртуальные функции (#7.2.8).

     Обыкновенно указатели на базовые классы используются при
разработке контейнерных (или вмещающих)  классов:  множество,
вектор, список и т.п. В этом случае решение 1 дает однородные
списки, то  есть списки объектов одного типа.  Решения 2 и  3
можно использовать   для построения неоднородных списков,  то
есть списков объектов (указателей на объекты) нескольких раз-
личных типов. Решение 3 - это специальный вариант решения 2 с
гарантией типа.

     Давайте сначала исследуем простое решение с помощью поля
типа, то   есть решение 2.  Пример со служащими и менеджерами
можно было бы переопределить так:

  enum empl_type (* M, E *);

  struct employee (*
      empl_type type;
      employee* next;
      char* name;
      short department;
      // ...
  *);

  struct manager : employee (*
      employee* group;
      short level; // уровень
  *);

     Имея это,  мы можем теперь написать функцию, которая пе-
чатает информацию о каждом служащем:

  void print_employee(employee* e)
  (*
      switch (e->type) (*
      case E:
          cout << e->name << "\t" << e->department << "\n";
          // ...
          break;
      case M:
          cout << e->name << "\t" << e->department << "\n";
          // ...
          manager* p = (manager*)e;
          cout << " уровень " << p->level << "\n";
          // ...
          break;

                                    - 173 -
      *)
  *)

     и воспользоваться  ею для того,  чтобы напечатать список
служащих:

  void f()
  (*
      for (; ll; ll=ll->next) print_employee(ll);
  *)

     Это прекрасно  работает,особенно  в небольшой программе,
написанной одним человеком, но имеет тот коренной недостаток,
что неконтролируемым   компилятором  образом зависит от того,
как программист работает с типами.  В больших программах  это
обычно приводит к ошибкам двух видов. Первый - это невыполне-
ние проверки поля типа, второй - когда не все случаи case по-
мещаются в   переключатель switch,  как в предыдущем примере.
Оба избежать достаточно легко , когда программу сначала пишут
на бумаге,  но при модификации нетривиальной программы,  осо-
бенно написанной другим человеком,  очень трудно избежать как
того, так    и  другого.  Часто от этих сложностей становится
труднее уберечься из-за того, что функции вроде print() часто
бывают организованы  так,  чтобы пользоваться общностью клас-
сов, с которыми они работают. Например:

  void print_employee(employee* e)
  (*
      cout << e->name << "\t" << e->department << "\n";
      // ...
      if (e->type == M) (*
          manager* p = (manager*)e;
          cout << " уровень " << p->level << "\n";
          // ...
      *)
  *)

     Отыскание всех таких операторов if, скрытых внутри боль-
шой функции,  которая работает с большим  числом  производных
классов, может   оказаться сложной задачей,  и даже когда все
они найдены, бывает нелегко понять, что же в них делается.

                  7.2.8 Виртуальные Функции

     Виртуальные функции преодолевают сложности решения с по-
мощью полей  типа,  позволяя программисту описывать в базовом
классе функции,  которые можно переопределять в любом  произ-
водном классе. Компилятор и загрузчик обеспечивают правильное
соответствие между объектами и применяемыми к ним  функциями.
Например:

  struct employee (*
      employee* next;
      char* name;
      short department;
      // ...
      virtual void print();
  *);

     Ключевое слово virtual указывает, что могут быть различ-
ные варианты функции print()  для разных производных классов,
и что   поиск среди них подходящей для каждого вызова print()
является задачей компилятора. Тип функции описывается в базо-
вом классе   и не может переописываться в производном классе.
Виртуальная функция должна быть определена для класса,  в ко-
тором она описана впервые. Например:


                                    - 174 -
  void employee::print()
  (*
      cout << e->name << "\t" << e->department << "\n";
      // ...
  *)

     Виртуальная функция может, таким образом, использоваться
даже в том случае,  когда нет производных классов от ее клас-
са, и   в производном классе,  в котором не нужен специальный
вариант виртуальной функции,   ее  задавать  не  обязательно.
Просто при   выводе класса соответствующая функция задается в
том случае, если она нужна. Например:

  struct manager : employee (*
      employee* group;
      short level;
      // ...
      void print();
  *);

  void manager::print()
  (*
      employee::print();
      cout << "\tуровень" << level << "\n";
      // ...
  *)

     Функция print_employee()  теперь не нужна,  поскольку ее
место заняли функции члены print(),  и теперь со списком слу-
жащих можно работать так:

  void f(employee* ll)
  (*
      for (; ll; ll=ll->next) ll->print();
  *)

     Каждый служащий  будет  печататься  в соответствии с его
типом. Например:

  main()
  (*
      employee e;
          e.name = "Дж.Браун";
          e.department = 1234;
          e.next = 0;
      manager m;
          m.name = "Дж.Смит";
          e.department = 1234;
          m.level = 2;
          m.next = &e;
      f(&m);
  *)

выдаст

  Дж.Смит 1234
          уровень 2
  Дж.Браун 1234

     Заметьте, что это будет работать даже в том случае, если
f() была  написана и откомпилирована еще до того,  как произ-
водный класс manager был задуман!  Очевидно,  при  реализации
этого в  каждом объекте класса employee сохраняется некоторая
информация о типе.  Занимаемого для этого пространства (в те-
кущей реализации) как раз хватает для хранения указателя. Это
пространство занимается только в объектах классов с виртуаль-
ными функциями,    а не во всех объектах классов и даже не во

                                    - 175 -
всех объектах производных классов.  Вы  платите  эту  пошлину
только за те классы, для которых описали виртуальные функции.

     Вызов функции  с помощью операции разрешения области ви-
димости ::, как это делается в manager::print(), гарантирует,
что механизм виртуальных функций применяться не будет.  Иначе
manager::print() подвергалось бы бесконечной рекурсии. Приме-
нение уточненного имени имеет еще один эффект,  который может
оказаться полезным: если описанная как virtual функция описа-
на еще   и как inline (в чем ничего необычного нет),  то там,
где в вызове применяется ::, может применяться inline-подста-
новка. Это дает программисту эффективный способ справляться с
теми важными специальными случаями,  когда  одна  виртуальная
функция вызывает   другую для того же объекта.  Поскольку тип
объекта был определен при вызове первой виртуальной  функции,
обычно его не надо снова динамически определять другом вызове
для того же объекта.

                7.3 Альтернативные Интерфейсы

     После того, как описаны средства языка, которые относят-
ся к производным классам,  обсуждение снова может вернуться к
стоящим задачам. В классах, которые описываются в этом разде-
ле, основополагающая  идея состоит в том, что они однажды на-
писаны, а  потом их используют программисты, которые не могут
изменить их  определение.  Физически классы состоят из одного
или более заголовочных файлов,  определяющих интерфейс, и од-
ного или более файлов,  определяющих реализацию. Заголовочные
файлы будут помещены куда-то туда,  откуда пользователь может
взять их копии с помощью директивы #include. Файлы, определя-
ющие реализацию,  обычно компилируют и помещают в библиотеку.

                       7.3.1 Интерфейс

     Рассмотрим такое написание класса slist  для  однократно
связанного списка, с помощью которого можно создавать как од-
нородные, так и неоднородные списки объектов тех типов, кото-
рые еще должны быть определены. Сначала мы определим тип ent:

  typedef void* ent;

     Точная сущность типа ent несущественна,  но нужно, чтобы
в нем мог храниться указатель.  Тогда мы определим тип slink:

  class slink (*
  friend class slist;
  friend class slist_iterator;
      slink* next;
      ent e;
      slink(ent a, slink* p) (* e=a; next=p;*)
  *);

     В одном звене может храниться один ent, и с помощью него
реализуется класс slist:

  class slist (*
  friend class slist_iterator;
      slink* last; // last->next - голова списка
  public:
      int insert(ent a); // добавить в голову списка
      int append(ent a); // добавить в хвост списка
      ent get(); // вернуться и убрать голову списка
      void clear(); // убрать все звенья

      slist() (* last=0; *)
      slist(ent a) (* last=new slink(a,0); last->next=last; *)
      ~slist() (* clear(); *)

                                    - 176 -
  *);

     Хотя список  очевидным образом реализуется как связанный
список, реализацию  можно изменить так,  чтобы  использовался
вектор из  ent'ов,  не повлияв при этом на пользователей.  То
есть, применение slink'ов никак не видно в описаниях открытых
функций slist'ов, а видно только в закрытой части и определе-
ниях функций.

                      7.3.2 Реализация

     Реализующие slist функции в основном просты.  Единствен-
ная настоящая  сложность - что делать в случае ошибки,  если,
например, пользователь попытается get() что-нибудь из пустого
списка. Мы обсудим это в #7.3.4. Здесь приводятся определения
членов slist.  Обратите внимание,  как хранение указателя  на
последний элемент   кругового  списка дает возможность просто
реализовать оба действия append() и insert():

  int slist::insert(ent a)
  (*
      if (last)
          last->next = new slink(a,last->next);
      else (*
          last = new slink(a,0);
          last->next = last;
      *)
      return 0;
  *)

  int slist::append(ent a)
  (*
      if (last)
          last = last->next = new slink(a,last->next);
      else (*
          last = new slink(a,0);
          last->next = last;
      *)
      return 0;
  *)

  ent slist::get()
  (*
      if (last == 0) slist_handler("get fromempty list");
                                 // взять из пустого списка
      slink* f = last->next;
      ent r f->e;
      if (f == last)
          last = 0;
      else
          last->next = f->next;
      delete f;
      return f;
  *)

     Обратите внимание,  как  вызывается  slist_handler  (его
описание можно найти в #7.3.4). Этот указатель на имя функции
используется точно так же, как если бы он был именем функции.
Это является краткой формой более явной записи вызова:

  (*slist_handler)("get fromempty list");

И slist::clear(), наконец, удаляет из списка все элементы:

  void slist::clear()
  (*
      slink* l = last;

                                    - 177 -
      if (l == 0) return;
      do (*
          slink* ll = l;
          l = l->next;
          delete ll;
      *) while (l!=last);
  *)

     Класс slist не обеспечивает способа заглянуть в  список,
но только средства для вставления и удаления элементов. Одна-
ко оба   класса,   и  slist,   и  slink,    описывают   класс
slist_iterator как друга, поэтому мы можем описать подходящий
итератор. Вот один, написанный в духе #6.8:

  class slist_iterator (*
      slink* ce;
      slist* cs;
  public:
      slist_iterator(slist& s) (* cs = &s; ce = cs->last; *)

      ent operator()() (*
          // для индикации конца итерации возвращает 0
          // для всех типов не идеален, хорош для указателей
          ent ret = ce ? (ce=ce->next)->e : 0;
          if (ce == cs->last) ce= 0;
          return ret;
      *)
  *);

                 7.3.3 Как Этим Пользоваться

     Фактически класс  slist в написанном виде бесполезен.  В
конечном счете,  зачем можно использовать  список  указателей
void*? Штука  в том,  чтобы вывести класс из slist и получить
список тех объектов,  которые представляют интерес в конкрет-
ной программе.  Представим компилятор языка вроде С++.  В нем
широко будут использоваться списки имен; имя name - это нечто
вроде

  struct name (*
      char* string;
      // ...
  *);

     В список будут помещаться указатели на имена,  а не сами
объекты имена.  Это позволяет использовать небольшое информа-
ционное поле e slist'а,  и дает возможность имени  находиться
одновременно более чем в одном списке. Вот определение класса
nlist, который очень просто выводится из класса slist:

  #include "slist.h"
  #include "name.h"

  struct nlist : slist (*
      void insert(name* a) (* slist::insert(a); *)
      void append(name* a) (* slist::append(a); *)
      name* get() (**)
      nlist(name* a) : (a) (**)
  *);

     Функции нового класса или наследуются  от  slist  непос-
редственно, или   ничего не делают кроме преобразования типа.
Класс nlist - это ничто иное,  как  альтернативный  интерфейс
класса slist.  Так как на самом деле тип ent есть void*,  нет
необходимости явно преобразовывать указатели name*,   которые
используются в качестве фактических параметров (#2.3.4).


                                    - 178 -
     Списки имен можно использовать в классе,  который предс-
тавляет определение класса:

  struct classdef (*
      nlist friends;
      nlist constructors;
      nlist destructors;
      nlist members;
      nlist operators;
      nlist virtuals;
      // ...
      void add_name(name*);
      classdef();
      ~classdef();
  *);

     и имена  могут добавляться к этим спискам приблизительно
так:

  void classdef::add_name(name* n)
  (*
      if (n->is_friend()) (*
          if (find(&friends,n))
              error("friend redeclared");
                  // friend переописан
          else if (find(&members,n))
              error("friend redeclared as member");
                  // friend переописан как member
          else
              friends.append(n);
      *)
      if (n->is_operator()) operators.append(n);
      // ...
  *)

     где is_operator()  и is_friend() являются функциями чле-
нами класса name. Функцию find() можно написать так:

  int find(nlist* ll, name* n)
  (*
      slist_iterator ff(*(slist*)ll);
      ent p;
      while ( p=ff() ) if (p==n) return 1;
      return 0;
  *)

     Здесь применяется явное преобразование типа,  чтобы при-
менить slist_iterator к nlist. Более хорошее решение, сделать
итератор для nlist'ов, приведено в #7.3.5. Печатать nlist мо-
жет, например, такая функция:

  void print_list(nlist* ll, char* list_name)
  (*
      slist_iterator count(*(slist*)ll);
      name* p;
      int n = 0;
      while ( count() ) n++;
      cout << list_name << "\n" << n << "members\n";
      slist_iterator print(*(slist*)ll);
      while ( p=(name*)print() ) cout << p->string << "\n";
  *)

                   7.3.4 Обработка Ошибок

     Есть четыре подхода к проблеме,  что же делать, когда во
время выполнения универсальное средство вроде slist сталкива-
ется с   ошибкой (в С++ нет никаких специальных средств языка

                                    - 179 -
для обработки ошибок):

     [1] Возвращать недопустимое значение и позволить пользо-
         вателю его проверять

     [2] Возвращать  дополнительное значение состояния и раз-
         решить пользователю проверять его

     [3] Вызывать функцию ошибок,  заданную как часть  класса
         slist или

     [4] Вызывать  функцию  ошибок,  которую предположительно
         предоставляет пользователь.

     Для небольшой  программы,   написанной  ее  единственным
пользователем, нет  фактически никаких особенных причин пред-
почесть одно из этих решений другим. Для средства общего наз-
начения ситуация совершенно иная.

     Первый подход,  возвращать недопустимое значение, неосу-
ществим. Нет    совершенно  никакого  способа  узнать,    что
некоторое конкретное значение будет недопустимым во всех при-
менениях slist.

     Второй подход,  возвращать значение состояния, можно ис-
пользовать в некоторых классах (один из вариантов этого плана
применяется в  стандартных  потоках  ввода/вывода  istream  и
ostream; как - объясняется в #8.4.2).  Здесь, однако, имеется
серьезная проблема,  вдруг пользователь не позаботится прове-
рить значение состояния,  если средство не слишком часто под-
водит. Кроме того, средство может использоваться в сотнях или
даже тысячах мест программы. Проверка значения в каждом месте
сильно затруднит чтение программы.

     Третьему подходу, предоставлять функцию ошибок, недоста-
ет гибкости.  Тот,  кто реализует универсальное средство,  не
может узнать,  как пользователи захотят, чтобы обрабатывались
ошибки. Например,   пользователь может предпочитать сообщения
на датском или венгерском.

     Четвертый подход,  позволить пользователю задавать функ-
цию ошибок,    имеет некоторую привлекательность при условии,
что разработчик предоставляет класс в виде библиотеки (#4.5),
в которой содержатся стандартные функции обработки ошибок.

     Решения 3 и 4 можно сделать более гибкими (и по сути эк-
вивалентными), задав указатель на функцию, а не саму функцию.
Это позволит разработчику такого средства, как slist, предос-
тавить функцию ошибок,  действующую по умолчанию,  и при этом
программистам, которые будут использовать списки, будет легко
задать свои собственные функции ошибок,  когда нужно,  и там,
где нужно. Например:

  typedef void (*PFC)(char*); // указатель на тип функция
  extern PFC slist_handler;
  extern PFC set_slist_handler(PFC);

     Функция set_slist_hanlder() позволяет пользователю заме-
нить стандартную функцию.  Общепринятая реализация предостав-
ляет действующую по умолчанию функцию обработки ошибок, кото-
рая сначала пишет сообщение об ошибке  в  cerr,   после  чего
завершает программу с помощью exit():

  #include "slist.h"
  #include <stream.h>

  void default_error(char* s)

                                    - 180 -
  (*
      cerr << s << "\n";
      exit(1);
  *)

     Она описывает также указатель на функцию ошибок и,   для
удобства записи, функцию для ее установки:

  PFC slist_handler = default_error;

  PFC set_slist_handler(PFC handler);
  (*
      PFC rr = slist_handler;
      slist_handler = handler;
      return rr;
  *)

     Обратите внимание,  как set_slist_hanlder()   возвращает
предыдущий slist_hanlder().    Это делает удобным установку и
переустановку обработчиков ошибок на манер стека.  В основном
это может быть полезным в больших программах, в которых slist
может использоваться в нескольких разных ситуациях,  в каждой
из которых могут,  таким образом, задаваться свои собственные
подпрограммы обработки ошибок. Например:

  (*
  PFC old = set_slist_handler(my_handler);

      // код, в котором в случае ошибок в slist
      // будет использоваться мой обработчик my_handler

      set_slist_handler(old); // восстановление
  *)

     Чтобы сделать  управление  более изящным,  slist_hanlder
мог бы быть сделан членом класса slist, что позволило бы раз-
личным спискам иметь одновременно разные обработчики.

                   7.3.5 Обобщенные Классы

     Очевидно, можно  было  бы определить списки других типов
(classdef*, int,  char* и т.д.) точно так же, как был опреде-
лен класс nlist: простым выводом из класса slist. Процесс оп-
ределения таких новых типов утомителен (и потому чреват ошиб-
ками), но   с помощью макросов его можно "механизировать".  К
сожалению, если  пользоваться  стандартным  C  препроцессором
(#4.7 и #с.11.1),  это тоже может оказаться тягостным. Однако
полученными в   результате  макросами  пользоваться  довольно
просто.

     Вот пример того,  как обобщенный (generic)  класс slist,
названный gslist,  может быть задан как макрос.  Сначала  для
написания такого   рода макросов включаются некоторые инстру-
менты из <generic.h>:

  #include "slist.h"

  #ifndef GENERICH
  #include <generic.h>
  #endif

     Обратите внимание на  использование  #ifndef  для  того,
чтобы гарантировать,    что <generic.h> в одной компиляции не
будет включен дважды. GENERICH определен в <generic.h>.

     После этого с помощью name2(),  макроса  из  <generic.h>
для конкатенации   имен,  определяются имена новых обобщенных

                                    - 181 -
классов:

  #define gslist(type) name2(type,gslist)
  #define gslist_iterator(type) name2(type,gslist_iterator)

     И, наконец,    можно   написать  классы  gslist(тип)   и
gslist_iterator(тип):

  #define gslistdeclare(type)                              \
  struct gslist(type) : slist (*                            \
      int insert(type a)                                   \
          (* return slist::insert( ent(a) ); *)       \
      int append(type a)                                   \
          (* return slist::append( ent(a) ); *)       \
      type get() (* return type( slist::get() ); *)       \
      gslist(type)() (* *)                                 \
      gslist(type)(type a) : (ent(a)) (* *)               \
      ~gslist(type)() (* clear(); *)                     \
  *);                                                       \
                                                           \
  struct gslist_iterator(type) : slist_iterator (*        \
      gslist_iterator(type)(gslist(type)& a)               \
          : ( (slist&)s ) (**)                         \
      type operator()()                                    \
          (* return type( slist_iterator::operator()() ); *)\
  *)

     \ на конце строк указывает ,  что следующая строка явля-
ется частью определяемого макроса.

     С помощью этого макроса список указателей на имя, анало-
гичный использованному раньше классу nlist,  можно определить
так:

  #include "name.h"

  typedef name* Pname;
  declare(gslist,Pname); // описывает класс gslist(Pname)

  gslist(Pname) nl; // описывает один gslist(Pname)

     Макрос declare  (описать)   определен в <generic.h>.  Он
конкатинирует свои параметры и вызывает макрос с этим именем,
в данном случае gslistdeclare,  описанный выше.  Параметр имя
типа для declare должен быть простым именем. Используемый ме-
тод макроопределения  не может обрабатывать имена типов вроде
name*, поэтому применяется typedef.

     Использование вывода класса гарантирует, что все частные
случаи обобщенного   класса  разделяют код.  Этот метод можно
применять только для создания классов объектов того же разме-
ра или меньше, чем базовый класс, который используется в мак-
росе. gslist применяется в #7.6.2.

                7.3.6 Ограниченные Интерфейсы

     Класс slist - довольно общего характера. Иногда подобная
общность не требуется или даже нежелательна. Ограниченные ви-
ды списков, такие как стеки и очереди, даже более обычны, чем
сам обобщенный  список.  Такие структуры данных можно задать,
не описав базовый класс как открытый. Например, очередь целых
можно определить так:

  #include "slist.h"

  class iqueue : slist (*
                 //предполагается sizeof(int)<=sizeof(void*)

                                    - 182 -
  public:
      void put(int a) (* slist::append((void*)a); *)
      int det() (* return int(slist::get()); *)
      iqueue() (**)
  *);

     При таком  выводе осуществляются два логически разделен-
ных действия:  понятие списка ограничивается понятием очереди
(сводится к нему),  и задается тип int,  чтобы свести понятие
очереди к типу данных очередь целых, iqueue. Эти два действия
можно выполнять и раздельно. Здесь первая часть - это список,
ограниченный так,  что он  может  использоваться  только  как
стек:

  #include "slist.h"

  class stack : slist (*
  public:
      slist::insert;
      slist::get;
      stack() (**)
      stack(ent a) : (a) (**)
  *);

     который потом  используется для создания типа "стек ука-
зателей на символы":

  #include "stack.h"

  class cp : stack (*
  public:
      void push(char* a) (* slist::insert(a); *)
      char* pop() (* return (char*)slist::get(); *)
      nlist() (**)
  *);

                   7.4 Добавление к Классу

     В предыдущих примерах производный класс ничего не добав-
лял к базовому классу.  Для производного класса функции опре-
делялись только чтобы обеспечить преобразование типа.  Каждый
производный класс просто задавал альтернативный  интерфейс  к
общему множеству программ.  Этот специальный случай важен, но
наиболее обычная причина определения новых классов как произ-
водных классов в том,  что кто-то хочет иметь то, что предос-
тавляет базовый класс, плюс еще чуть-чуть.

     Для производного класса можно определить данные и  функ-
ции дополнительно к тем,  которые наследуются из его базового
класса. Это  дает альтернативную стратегию того,  как обеспе-
чить средства связанного списка. Заметьте, когда в тот slist,
который определялся выше,  помещается элемент,  то  создается
slink, содержащий два указателя. На их создание тратится вре-
мя, а ведь без одного из указателей можно обойтись, при усло-
вии, что    нужно  только чтобы объект мог находиться в одном
списке. Так что указатель next на следующий можно поместить в
сам объект,  вместо того, чтобы помещать его в отдельный объ-
ект slink.  Идея состоит в том,  чтобы создать класс olink  с
единственным полем next, и класс olist, который может обраба-
тывать указатели на такие звенья olink.  Тогда  olist  сможет
манипулировать объектами   любого  класса,   производного  от
olink. Буква "o" в названиях стоит для того, чтобы напоминать
вам, что  объект может находиться одновременно только в одном
списке olist:

  struct olink (*
      olink* next;

                                    - 183 -
  *);

     Класс olist очень напоминает класс slist. Отличие состо-
ит в том, что пользователь класса olist манипулирует объекта-
ми класса olink непосредственно:

  class olist (*
      olink* last;
  public:
      void insert(olink* p);
      void append(olink* p);
      olink* get();
      // ...
  *);

     Мы можем вывести из класса olink класс name:

  class name : public olink (*
      // ...
  *);

     Теперь легко сделать список,  который можно использовать
без накладных расходов времени на размещение или памяти.

     Объекты, помещаемые в olist,  теряют свой тип. Это озна-
чает, что  компилятор знает только то,  что они olink'и. Пра-
вильный тип можно восстановить с помощью явного  преобразова-
ния типа объектов, вынутых из olist. Например:

  void f()
  (*
      olist ll;
      name nn;
      ll.insert(&nn); // тип &nn потерян
      name* pn = (name*)ll.get(); // и восстановлен
  *)

     Другой способ:  тип можно восстановить,  выводя еще один
класс из olist для обработки преобразования типа:

  class onlist : public olist (*
      // ...
      name* get() (* return (name*)olist::get(); *)
  *);

     Имя name  может  одновременно  находиться только в одном
olist. Для имен это, может быть, и не подходит, но в классах,
для которых это подойдет полностью, недостатка нет. Например,
класс фигур shape использует для поддержки списка всех  фигур
именно этот метод. Обратите внимание, что можно было бы опре-
делить slist как производный от olist,  объединяя таким обра-
зом оба  понятия.  Однако использование базовых и производных
классов на таком микроскопическом уровне может  очень  сильно
исказить код.

                   7.5 Неоднородные Списки

     Предыдущие списки  были однородными.  То есть,  в список
помещались только объекты одного типа. Это обеспечивалось ап-
паратом производных   классов.   Списки не обязательно должны
быть однородными.  Список,  заданный  в  виде  указателей  на
класс, может содержать объекты любого класса, производного от
этого класса.  То есть, список может быть неоднородным. Веро-
ятно, это единственный наиболее важный и полезный аспект про-
изводных классов, и он весьма существенно используется в сти-
ле программирования, который демонстрируется приведенным выше
примером. Этот стиль программирования часто называют объектно

                                    - 184 -
-основанным или объектно-ориентированным. Он опирается на то,
что действия над объектами неоднородных  списков  выполняются
одинаковым образом.  Смысл этих действий зависит от фактичес-
кого типа объектов,  находящихся в списке (что становится из-
вестно только на стадии выполнения), а не просто от типа эле-
ментов списка (который компилятору известен).

                  7.6 Законченная Программа

     Разберем процесс написания программы  для  рисования  на
экране геометрических фигур.  Она естественным образом разде-
ляется на три части:

  [1]  Администратор экрана:   подпрограммы  низкого уровня и
       структуры данных,  определяющие экран;он ведает только
       точками и прямыми линиями,

  [2]  Библиотека фигур:   набор  определений  основных фигур
       вроде прямоугольника и круга и  стандартные  программы
       для работы с ними и

  [3]  Прикладная программа: множество определений, специали-
       зированных для данного приложения,  и код,  который их
       использует.

     Эти три части скорее всего будут писать разные  люди  (в
разных организациях  и в разное время).  При этом части будут
скорее всего писать именно в указанном порядке с тем осложня-
ющим обстоятельством,   что у разработчиков нижнего уровня не
будет точного представления, для чего их код в конечном счете
будет использоваться. Это отражено в приводимом примере. Что-
бы пример был короче,  графическая  библиотека  предоставляет
только весьма ограниченный сервис, а сама прикладная програм-
ма очень проста. Чтобы читатель смог испытать программу, даже
если у него нет совсем никаких графических средств, использу-
ется чрезвычайно простая концепция экрана.  Не должно  соста-
вить труда   заменить эту экранную часть программы чем-нибудь
подходящим, не  изменяя код  библиотеки  фигур  и  прикладной
программы.

                 7.6.1 Администратор Экрана

     Вначале было  намерение написать администратор экрана на
C (а не на С++),  чтобы подчеркнуть разделение уровней реали-
зации. Это  оказалось слишком утомительным,  поэтому пришлось
пойти на компромисс:  используется стиль C (нет функций  чле-
нов, виртуальных функций, определяемых пользователем операций
и т.п.),  однако применяются конструкторы, надлежащим образом
описываются и проверяются параметры функций и т.д.  Оглядыва-
ясь назад,  можно сказать, что администратор экрана очень по-
хож на C программу,  которую потом модифицировали, чтобы вос-
пользоваться средствами С++ не переписывая все полностью.

     Экран представляется  как  двумерный  массив   символов,
работу с     которым   осуществляют  функции  put_point()   и
put_line(), использующие  при обращении с  экраном  структуру
point:

  // файл screen.h

  const XMAX=40, YMAX=24;

  struct point (*
      int x,y;
      point() (**)
      point(int a, int b) (* x=a; y=b; *)
  *);

                                    - 185 -

  overload put_point;
  extern void put_point(int a, int b);
  inline void put_point(point p) (* put_point(p.x,p.y); *)

  overload put_line;
  extern void put_line(int, int, int, int);
  inline void put_line(point a, point b)
      (* put_line(a.x,a.y,b.x,b.y); *)

  extern void screen_init();
  extern void screen_refresh();
  extern void screen_clear();

  #include <stream.h>

     Перед первым использованием функции put экран надо  ини-
циализировать с помощью screen_init(), а изменения в структу-
ре данных экрана отображаются на экране только  после  вызова
screen_refresh(). Как  увидит пользователь,  это "обновление"
("refresh") осуществляется  просто посредством  печати  новой
копии экрана под его предыдущим вариантом.  Вот функции и оп-
ределения данных для экрана:

  #include "screen.h"
  #include <stream.h>

  enum color (* black='*', white=' ' *);

  char screen[XMAX][YNAX];

  void screen_init()
  (*
      for (int y=0; y<YMAX; y++)
          for (int x=0; x<XMAX; x++)
              screen[x][y] = white;
  *)

     Точки печатаются, только если они есть на экране:

  inline int on_screen(int a, int b)
  (*
      return 0<=a && a<XMAX && 0<=b && b<YMAX;
  *)

  void put_point(int a, int b)
  (*
      if (on_screen(a,b)) screen[a][b] = black;
  *)

     Для рисования линий используется функция put_line():

  void put_line(int x0, int y0, int x1, int y1)
  /*
      Строит линию от (x0,y0) до (x1,y1).
      Строится линия b(x-x0) + a(y-y0) = 0.
      Минимизирует abs(eps), где eps = 2*(b(x-x0)+ a(y-y0)).
      См. Newman and Sproull:
      ``Principles of Interactive Computer Graphics''
      McGraw-Hill, New York, 1979, pp 33-44.
  */
  (*
      register dx = 1;
      int a = x1 - x0;
      if (a < 0) dx = -1, a = -a;
      register dy = 1;
      int b = y1 - y0;

                                    - 186 -
      if (b < 0) dy = -1, b = -b;
      int two_a = 2*a;
      int two_b = 2*b;
      int xcrit = -b + two_a;
      register eps = 0;
      for (;;) (*
          put_point(x0,y0);
          if(x0==x1 && y0==y1) break;
          if(eps <= xcrit) x0 += dx, eps += two_b;
          if(eps>=a !! a<=b) y0 += dy, eps -= two_a;
      *)
  *)

     Предоставляются функции для очистки экрана и его  обнов-
ления:

  void screen_clear() (* screen_init(); *) // очистка

  void screen_refresh() // обновление
  (*
      for (int y=YMAX-1; 0<=y; y--) (* // сверху вниз
          for (int x=0; x<XMAX; x++) // слева направо
              cout.put(screen[x][y]);
          cout.put('\n');
      *)
  *)

     Функция ostream::put()  применяется для печати  символов
как символов; ostream::operator<<()  печатает символы как ма-
лые целые. Пока что вы может представлять себе, что эти опре-
деления доступны только в откомпилированном виде,  который вы
изменить не можете.

                   7.6.2 Библиотека Фигур

     Нам нужно определить общее понятие фигуры (shape).   Это
надо сделать таким образом, чтобы оно использовалось (как ба-
зовый класс)  всеми конкретными фигурами (например, кругами и
квадратами), и  так, чтобы любой фигурой можно было манипули-
ровать исключительно через интерфейс, предоставляемый классом
shape:

  struct shape (*
    shape() (* shape_list.append(this); *)

    virtual point north() (*return point(0,0);*) // север
    virtual point south() (*return point(0,0);*) // юг
    virtual point east()  (*return point(0,0);*) // восток
    virtual point neast() (*return point(0,0);*)//северо-восток
    virtual point seast() (*return point(0,0);*) // юго-восток

    virtual void draw() (**); // нарисовать
    virtual void move(int, int) (**); // переместить
  *);

     Идея состоит в том,  что расположение фигуры задается  с
помощью move(),    и  фигура  помещается  на  экран с помощью
draw(). Фигуры можно располагать относительно друг друга, ис-
пользуя понятие точки соприкосновения, и эти точки перечисля-
ются после точек компаса (сторон света).   Каждая  конкретная
фигура определяет свой смысл этих точек,  и каждая определяет
способ, которым она рисуется. Для экономии места здесь на са-
мом деле  определяются только необходимые в этом примере сто-
роны света.  Конструктор shape::shape()  добавляет  фигуру  в
список фигур   shape_list.   Этот список является gslist,  то
есть, одним  из вариантов обобщенного односвязанного  списка,
определенного в   #7.3.5.  Он и соответствующий итератор были

                                    - 187 -
                                     
сделаны так:

  typedef shape* sp;
  declare(gslist,sp);

  typedef gslist(sp) shape_lst;
  typedef gslist_iterator(sp) sp_iterator;

поэтому shape_list можно описать так:

  shape_lst shape_list;

     Линию можно построить либо по двум точкам, либо по точке
и целому.  В последнем случае создается горизонтальная линия,
длину которой определяет целое.  Знак целого указывает, каким
концом является точка: левым или правым. Вот определение:

  class line : public shape (*
  /*
      линия из 'w' в 'e'
      north() определяется как ``выше центра
      и на север как до самой северной точки''
  */
      point w,e;
  public:
      point north()
          (* return point((w.x+e.x)/2,e.y<w.y?w.y:e.y); *)

      point south()
          (* return point((w.x+e.x)/2,e.y<w.y?e.y:w.y); *)

      void move(int a, int b)
          (* w.x += a; w.y += b; e.x += a; e.x += b; *)
      void draw() (* put_line(w,e); *)

      line(point a, point b) (* w = a; e = b; *)
      line(point a, int l)
          (* w = point(a.x+l-1,a.y); e = a; *)
  *);

     Аналогично определяется прямоугольник rectangle:

  class rectangle : public shape (*
  /*
      nw ---- n ---- ne
      ! !
      ! !
      w c e
      ! !
      ! !
      sw ---- s ---- se
  */
      point sw,ne;
  public:
      point north() (* return point((sw.x+ne.x)/2,ne.y); *)
      point south() (* return point((sw.x+ne.x)/2,sw.y); *)
      point neast() (* return ne; *)
      point swest() (* return sw; *)
      void move (int a, int b)
          (* sw.x+=a; sw.y+=b; ne.x+=a; ne.y+=b; *)
      void draw();
      rectangle(point, point);
  *);

     Прямоугольник строится по двум точкам.  Код  усложняется
из-за необходимости выяснять относительное положение этих то-
чек:

                                    - 188 -

  rectangle::rectangle(point a, point b);
  (*
      if (a.x <= b.x) (*
           (*
              sw = a;
              ne = b;
          *)
          else (*
              sw = point(a.x,b.y);
              ne = point(b.x,a.y);
          *)
      *)
      else (*
          if (a.y <= b.y) (*
              sw = point(b.x,a.y);
              ne = point(a.x,b.y);
          *)
          else (*
              sw = b;
              ne = a;
          *)
      *)
  *)

     Чтобы построить прямоугольник,  строятся четыре его сто-
роны:

  void rectangle::draw();
  (*
      point nw(sw.x,ne.y);
      point se(ne.x,sw.y);
      put_line(nw,ne);
      put_line(ne,se);
      put_line(se,sw);
      put_line(sw,nw);
  *)

     Помимо определений  фигур  в библиотеке фигур содержатся
функции для работы с ними. Например:

  void shape_refresh(); // рисует все фигуры
  void stack(shape* p, shape* q); // ставит p на верх q

     Чтобы справиться с нашим наивным экраном, нужна обновля-
ющая функция.  Она просто рисует все фигуры заново.  Обратите
внимание, что   она совершенно не представляет,  какие фигуры
рисует:

  void shape_refresh()
  (*
      screen_clear();
      sl_iterator next(shape_list);
      shape* p;
      while ( p=next() ) p->draw();
      screen_refresh();
  *)

     И вот,  наконец,  настоящая сервисная функция (утилита).
Она кладет одну фигуру на верх другой,  задавая,  что south()
одной должен быть сразу над north() другой:

  void stack(shape* q, shape* p) // ставит p на верх q
  (*
      point n = p->north();
      point s = q->south();
      q->move(n.x-s.x,n.y-s.y+1);

                                    - 189 -
  *)

     Теперь представим себе,  что  эта  библиотека  считается
собственностью некой   компании,  которая продает программное
обеспечение, и  что они продают вам только заголовочный файл,
содержащий определения фигур, и откомпилированный вариант оп-
ределений функций. И у вас все равно остается возможность оп-
ределять новые   фигуры  и использовать для ваших собственных
фигур сервисные функции.

                 7.6.3 Прикладная Программа

     Прикладная программа  чрезвычайно  проста.  Определяется
новая фигура myshape (на печати она немного похожа  на  рожи-
цу), а  потом пишется главная программа,  которая надевает на
нее шляпу. Вначале описание myshape:

  #include "shape.h"

  class myshape : public rectangle (*
      line* l_eye; // левый глаз
      line* r_eye; // правый глаз
      line* mouth; // рот
  public:
      myshape(point, point);
      void draw();
      void move(int, int);
  *);

     Глаза и рот - отдельные и независимые объекты,   которые
создает конструктор myshape:

  myshape::myshape(point a, point b) : (a,b)
  (*
      int ll = neast().x-swest().x+1;
      int hh = neast().y-swest().y+1;
      l_eye = new line(
          point(swest().x+2,swest().y+hh*3/4),2);
      r_eye = new line(
          point(swest().x+ll-4,swest().y+hh*3/4),2);
      mouth = new line(
          point(swest().x+2,swest().y+hh/4),ll-4);
  *)

     Объекты глаза  и  рот  порознь  рисуются заново функцией
shape_refresh(), и в принципе могут обрабатываться независимо
из объекта myshape, которому они принадлежат. Это один способ
определять средства  для  иерархически  построенных  объектов
вроде myshape. Другой способ демонстрируется на примере носа.
Никакой нос не определяется,  его просто добавляет к картинке
функция draw():

  void myshape::draw()
  (*
      rectangle::draw();
      put_point(point(
          (swest().x+neast().x)/2,(swest().y+neast().y)/2));
  *)

     myshape передвигается посредством  перемещения  базового
прямоугольника rectangle и вторичных объектов l_eye,  r_eye и
mouth (левого глаза, правого глаза и рта):

  void myshape::move()
  (*
      rectangle::move();
      l_eye->move(a,b);

                                    - 190 -
      r_eye->move(a,b);
      mouth->move(a,b);
  *)

     Мы можем,  наконец,  построить несколько фигур и немного
их подвигать:

  main()
  (*
      shape* p1 = new rectangle(point(0,0),point(10,10));
      shape* p2 = new line(point(0,15),17);
      shape* p3 = new myshape(point(15,10),point(27,18));
      shape_refresh();
      p3->move(-10,-10);
      stack(p2,p3);
      stack(p1,p2);
      shape_refresh();
      return 0;
  *)

     Еще раз   обратите   внимание,    как   функции    вроде
shape_refresh() и stack() манипулируют объектами типов, опре-
деляемых гораздо позже, чем были написаны (и, может быть, от-
компилированы) сами эти функции.

     ***********
     * *
     * *
     * *
     * *
     * *
     * *
     * *
     * *
     * *
     ***********
  *****************
    *************
    * *
    * ** ** *
    * *
    * * *
    * *
    * ********* *
    * *
    *************

                    7.7 Свободная Память

     Если вы пользовались классом slist, вы могли обнаружить,
что ваша программа тратит на заметное время на  размещение  и
освобождение объектов класса slink. Класс slink - это превос-
ходный пример класса,  который может значительно выиграть  от
того, что программист возьмет под контроль управление свобод-
ной памятью.  Для этого вида объектов идеально подходит опти-
мизирующий метод,  который описан в #5.5.6.  Поскольку каждый
slink создается с помощью new и уничтожается с помощью delete
членами класса   slist,   другой  способ  выделения памяти не
представляет никаких проблем.

     Если производный класс осуществляет присваивание  указа-
телю this, то конструктор его базового класса будет вызывать-
ся только после этого присваивания, и значение указателя this
в конструкторе  базового класса будет тем,  которое присвоено
конструктором производного класса. Если базовый класс присва-
ивает указателю this, то будет присвоено то значение, которое
использует конструктор производного класса. Например:

                                    - 191 -

  #include <stream.h>

  struct base (* base(); *);

  struct derived : base (* derived(); *)

  base::base()
  (*
      cout << "\tbase 1: this=" << int(this) << "\n";
      if (this == 0) this = (base*)27;
      cout << "\tbase 2: this=" << int(this) << "\n";
  *)

  derived::derived()
  (*
      cout << "\tderived 1: this=" << int(this) << "\n";
      this = (this == 0) ? (derived*)43 : this;
      cout << "\tderived 2: this=" << int(this) << "\n";
  *)

  main()
  (*
  cout << "base b;\n";
  base b;
  cout << "new base b;\n";
  new base;
  cout << "derived d;\n";
  derived d;
  cout << "new derived d;\n";
  new derived;
  cout << "at the end\n";

  *)

порождает вывод

  base b;
          base 1: this=2147478307
          base 2: this=2147478307
  new base;
          base 1: this=0
          base 2: this=27
  derived d;
          derived 1: this=2147478306
          base 1: this=2147478306
          base 2: this=2147478306
          derived 1: this=2147478306
  new derived;
          derived 1: this=0
          base 1: this=43
          base 2: this=43
          derived 1: this=43
  at the end

     Если деструктор производного класса осуществляет присва-
ивание указателю this,  то будет присвоено то значение, кото-
рое встретил деструктор его базового класса.  Когда  кто-либо
делает в   конструкторе  присваивание указателю this,  важно,
чтобы присваивание указателю this встречалось на всех путях в
конструкторе*.

--------------------
     * К сожалению, об этом присваивании легко забыть. Напри-
мер, в первом издании этой книги (английском - перев.) вторая
строка конструктор derived::derived() читалась так:


                                    - 192 -
  if (this == 0) this = (derived*)43;

     И следовательно,   для  d  конструктор  базового  класса
base::base() не  вызывался.  Программа была допустимой и кор-
ректно выполнялась,  но, очевидно, делала не то, что подразу-
мевал автор. (прим. автора)

                       7.8 Упражнения

  1. (*1) Определите

       class base (*
       public:
           virtual void iam() (* cout << "base\n"; *)
       *);

     Выведите из base два класса и для каждого определите iam
     () ("я    есть"),  которая выводит имя класса на печать.
     Создайте объекты этих классов и вызовите для них  iam().
     Присвойте адреса объектов производных классов указателям
     base* и вызовите iam() через эти указатели.

  2. (*2) Реализуйте примитивы экрана (#7.6.1) подходящим для
     вашей системы образом.

  3. (*2) Определите класс triangle  (треугольник)   и  класс
     circle (круг).

  4. (*2) Определите функцию, которая рисует линию, соединяю-
     щую две фигуры, отыскивая две ближайшие "точки соприкос-
     новения" и соединяя их.

  5. (*2) Модифицируйте пример с фигурами так, чтобы line бы-
     ла rectangle и наоборот.

  6. (*2) Придумайте и реализуйте  дважды  связанный  список,
     который можно использовать без итератора.

  7. (*2) Придумайте  и  реализуйте  дважды связанный список,
     которым можно пользоваться только посредством итератора.
     Итератор должен иметь действия для движения вперед и на-
     зад, действия  для вставления и удаления элементов спис-
     ка, и способ доступа к текущему элементу.

  8. (*2) Постройте   обобщенный  вариант  дважды  связанного
     списка.

  9. (*4) Сделайте список,  в котором вставляются и удаляются
     сами объекты (а не просто указатели на объекты).  Проде-
     лайте это   для  класса  X,   для  которого   определены
     X::X(X&), X::~X() X::operator=(X&).

  10.(*5) Придумайте  и  реализуйте  библиотеку для написания
     моделей, управляемых  прерываниями. Подсказка: <task.h>.
     Только это   - старая программа,  а вы могли бы написать
     лучше. Должен  быть класс task - задача.  Объект  класса
     task должен мочь сохранять свое состояние и восстанавли-
     ваться в     это   состояние   (вы   можете   определить
     task::save() и  task::restore()),  чтобы он мог действо-
     вать как сопрограмма.  Отдельные задачи можно определять
     как объекты классов,  производных от класса task.  Прог-
     рамма, которую должна исполнять задача, может задаваться
     как виртуальная функция. Должна быть возможность переда-
     вать новой задаче ее параметры как  параметры  ее  конс-
     труктора(ов). Там  должен быть планировщик,  реализующий
     концепцию виртуального времени.  Обеспечьте функцию  за-
     держки task::delay(),  которая "тратит" виртуальное вре-

                                    - 193 -
     мя. Будет  ли планировщик отдельным  или  частью  класса
     task -  это один из основных вопросов,  которые надо ре-
     шить при проектировании.  Задача должна передавать  дан-
     ные. Для  этого разработайте класс queue (очередь). При-
     думайте способ, чтобы задача ожидала ввода из нескольких
     очередей. Ошибки   в ходе выполнения обрабатывайте одно-
     родным образом. Как бы вы отлаживали программы, написан-
     ные с помощью такой библиотеки?

                                    - 194 -

Глава 8
Потоки

                                            ``bad input char:
           .Ppm(*=P!..*@Z9A*)5!!!!!"syui!!!"!Mp#V6P?p8`;!4lf&
                          - сообщение об ошибке (сокращенное)

     Язык С++  не обеспечивает средств для ввода/вывода.  Ему
это и не нужно.  Такие средства легко и элегантно можно  соз-
дать с помощью самого языка. Описанная здесь стандартная биб-
лиотека потокового ввода/вывода обеспечивает гибкий и  эффек-
тивный, с  гарантией типа,  метод обработки символьного ввода
целых чисел,  чисел с плавающей точкой и символьных строк,  а
также простую модель ее расширения для обработки типов, опре-
деляемых пользователем.  Ее пользовательский интерфейс  нахо-
дится в <stream.h>. В этой главе описывается сама библиотека,
некоторые способы ее применения и методы, которые использова-
лись при ее реализации.

                        8.1 Введение

     Разработка и реализация стандартных средств ввода/вывода
для языка программирования зарекомендовала себя как  заведомо
трудная работа.  Традиционно средства ввода/вывода разрабаты-
вались исключительно для небольшого  числа  встроенных  типов
данных. Однако в С++ программах обычно используется много ти-
пов, определяемых  пользователем, и нужно обрабатывать ввод и
вывод также  и значений этих типов.  Очевидно,  средство вво-
да/вывода должно быть простым, удобным, надежным в употребле-
нии, эффективным  и гибким,  и ко всему прочему полным. Ничье
решение еще не смогло угодить всем,  поэтому  у  пользователя
должна быть возможность задавать альтернативные средства вво-
да/вывода и расширять стандартные средства ввода/вывода  при-
менительно к требованиям приложения.

     С++ разработан  так,   чтобы у пользователя была возмож-
ность определять новые типы столь же эффективные  и  удобные,
сколь и встроенные типы. Поэтому обоснованным является требо-
вание того,  что средства ввода/вывода для С++ должны обеспе-
чиваться в С++ с применением только тех средств, которые дос-
тупны каждому программисту. Описываемые здесь средства ввода/
вывода представляют собой попытку ответить на этот вызов.

     Средства ввода/вывода <stream.h> связаны исключительно с
обработкой преобразования типизированных объектов в  последо-
вательности символов и обратно. Есть и другие схемы ввода/вы-
вода, но  эта является основополагающей в  системе  UNIX,   и
большая часть видов двоичного ввода/вывода обрабатывается че-
рез рассмотрение символа просто как набора бит,  при этом его
общепринятая связь с алфавитом игнорируется.  Тогда для прог-
раммиста ключевая проблема заключается в задании соответствия
между типизированным  объектом и принципиально нетипизирован-
ной строкой.

     Обработка и встроенных и определяемых пользователем  ти-
пов однородным   образом и с гарантией типа достигается с по-
мощью одного перегруженного имени функции для набора  функций
вывода. Например:

  put(cerr,"x = "); // cerr - поток вывода ошибок
  put(cerr,x);
  put(cerr,"\n");

     Тип параметра определяет то,  какая из функций put будет
вызываться для каждого параметра.  Это решение применялось  в
нескольких языках.  Однако ему недостает лаконичности. Перег-
рузка операции << значением "поместить в" дает более  хорошую

                                    - 195 -
запись и   позволяет программисту выводить ряд объектов одним
оператором. Например:

  cerr << "x = " << x << "\n";

     где cerr - стандартный поток вывода ошибок. Поэтому, ес-
ли x является int со значением 123,  то этот оператор напеча-
тает в стандартный поток вывода ошибок

  x = 123

     и символ новой строки.  Аналогично,  если X  принадлежит
определенному пользователем типу complex и имеет значение (1,
2.4), то приведенный выше оператор напечатает в cerr

  x = (1,2.4)

     Этот метод можно применять всегда, когда для x определе-
на операция  <<,  и пользователь может определять операцию <<
для нового типа.

                          8.2 Вывод

     В этом разделе сначала обсуждаются средства форматного и
бесформатного вывода встроенных типов, потом приводится стан-
дартный способ спецификации действий вывода для  определяемых
пользователем типов.

                8.2.1 Вывод Встроенных Типов

     Класс ostream  определяется  вместе с операцией << ("по-
местить в") для обработки вывода встроенных типов:

  class ostream (*
      // ...
  public:
      ostream& operator<<(char*);
      ostream& operator<<(int i) (* return *this<<long(i); *)
      ostream& operator<<(long);
      ostream& operator<<(double);

      ostream& put(char);
  *);

     Функция operator<< возвращает ссылку на ostream, для ко-
торого она была вызвана,  чтобы к ней  можно  было  применять
другой ostream. Например:

  cerr << "x = " << x;

     где x является int, будет интерпретироваться как:

  (cerr.operator<<("x = ")).operator<<(x);

     В частности, отсюда следует, что когда один оператор вы-
вода печатает несколько элементов,  они  будут  печататься  в
ожидаемом порядке: слева направо. Наличие operator<<, которая
получает int, является избыточным, поскольку int может неявно
преобразовываться в long.  С другой стороны, int может преоб-
разовываться также         и     в      double.       Наличие
ostream::operator<<(int) позволяет  избежать этой неоднознач-
ности. Для  печати символов в виде  символов  предоставляется
функция ostream::put(char),  а ostream::operator<<(int) печа-
тает их целые значения.

        8.2.2 Вывод Определяемых Пользователем Типов


                                    - 196 -
     Рассмотрим определяемый пользователем тип:

  class complex (*
      double re, im;
  public:
      complex(double r = 0, double i = 0) (* re=r; im=i; *)

      friend double real(complex& a) (* returna.re; *)
      friend double real(complex& a) (* returna.re; *)

      friend complex operator+(complex, complex);
      friend complex operator-(complex, complex);
      friend complex operator*(complex, complex);
      friend complex operator/(complex, complex);
      // ...
  *);

     Операцию <<  для  нового  типа  complex можно определить
так:

  ostream& operator<<(ostream&s, complex z)
  (*
      return s << "(" << real(z) << "," << imag(z) << ")";
  *)

     и использовать точно так же, как для встроенного типа:

  complex x(1,2);
  // ...
  cout << "x = " << x << "\n";

     получая при этом

  x = (1,2)

     Определение действия  вывода для определяемого пользова-
телем типа не требует ни модификации описания класса ostream,
ни доступа  к структуре данных (скрытой),  которую этот класс
поддерживает. Очень  удачно,  что имеет место первое,  потому
что описание   класса ostream находится в стандартных заголо-
вочных файлах,  к которым у обычного пользователя нет доступа
на запись. Последнее также важно, потому что обеспечивает за-
щиту от случайной порчи структуры данных. Это также позволяет
менять реализацию  ostream не влияя на пользовательские прог-
раммы.

           8.2.3 Некоторые Подробности Разработки

     Операция вывода используется, чтобы избежать той многос-
ловности, которую   дало бы использование функции вывода.  Но
почему <<?

     Возможности изобрести  новый  лексический   символ   нет
(#6.2). Операция  присваивания была кандидатом одновременно и
на ввод,  и на вывод, но оказывается, большинство людей пред-
почитают, чтобы операция ввода отличалась от операции вывода.
Кроме того, = не в ту сторону связывается (ассоциируется), то
есть cout=a=b означает cout=(a=b).

     Делались попытки использовать операции < и >,  но значе-
ния "меньше" и "больше" настолько прочно  вросли  в  сознание
людей, что  новые операции ввода/вывода во всех реальных слу-
чаях оказались нечитаемыми.  Помимо этого,  "<" находится  на
большинстве клавиатур   как раз на ",",  и у людей получаются
операторы вроде такого:

  cout < x , y , z;

                                    - 197 -

     Для таких операторов непросто выдавать хорошие сообщения
об ошибках.

     Операции <<  и  >>  к такого рода проблемам не приводят,
они асимметричны в том смысле,  что их можно проассоциировать
с "в"  и "из",  а приоритет << достаточно низок,  чтобы можно
было не использовать скобки для  арифметических  выражений  в
роли операндов. Например:

  cout << "a*b+c=" << a*b+c << "\n";

     Естественно, при  написании выражений,  которые содержат
операции с более низкими приоритетами,   скобки  использовать
надо. Например:

  cout << "a^b!c=" << (a^b!c) << "\n";

     Операцию левого  сдвига тоже можно применять в операторе
вывода:

  cout << "a<<b=" << (a<<b) << "\n";

     В С++ нет выражений с символьными значениями, в частнос-
ти, '\n'  является целым (со значением 10,  если используется
набор символов ASCII), поэтому

  cout << "x = " << x << '\n';

     напечатает число 10, а не ожидаемый символ новой строки.
Эту и аналогичные проблемы можно сгладить, определив несколь-
ко макросов (в которых используются стандартные имена  симво-
лов ASСII):

  #define sp << " "
  #define ht << "\t"
  #define nl << "\n"

     Теперь предыдущий пример запишется в виде:

  cout << "x = " << x nl;

     Для печати символов предоставляются функции ostream::put
(char) и  chr(int)  (см. #8.2.4). Хотя в некоторых кругах не-
синтаксические макросы  считаются худшим видом макросов,  мне
они нравятся.

     Рассмотрим примеры:

  cout << x << " " << y << " " << z << "\n";
  cout << "x = " << x << ", y = " << y << "\n";

     Люди находят  их  трудно  читаемыми из-за большого числа
кавычек и того,  что операция вывода внешне выглядит  слишком
непривычно. Здесь    могут  помочь приведенные выше макросы и
несколько отступов:

  cout << x sp << y sp << z nl;
  cout << "x = " << x
       << ", y = " << y nl;

                 8.2.4 Форматированный Вывод

     Пока << применялась только для неформатированного  выво-
да, и на самом деле в реальных программах она именно для это-
го главным образом и применяется.   Помимо  этого  существует
также несколько форматирующих функций,  создающих представле-

                                    - 198 -
ние своего параметра в виде строки,  которая используется для
вывода. Их второй (необязательный) параметр указывает, сколь-
ко символьных позиций должно использоваться.

  char* oct(long, int=0);  // восьмеричное представление
  char* dec(long, int=0);  // десятичное представление
  char* hex(long, int=0);  // шестнадцатиричное представление
  char* chr(int, int=0);   // символ
  char* str(char*, int=0); // строка

     Если не задано поле нулевой длины, то будет производить-
ся усечение или дополнение; иначе будет использоваться столь-
ко символов (ровно), сколько нужно. Например:

  cout << "dec(" << x
       << ") = oct(" << oct(x,6)
       << ") = hex(" << hex(x,4)
       << ")";

  Если x==15, то в результате получится:

  dec(15) = oct( 17) = hex( f);

     Можно также использовать строку в общем формате:

  char* form(char* format ...);

     cout<<form() эквивалентно применению стандартной функции
вывода языка C printf()*.  form() возвращает строку, получае-
мую в  результате преобразования и форматирования ее парамет-
ров, которые  стоят после первого  управляющего  параметра  -
строки формата   format.   Строка формата состоит из объектов
двух типов: обычных символов, которые просто копируются в по-
ток вывода,  и спецификаций преобразования, каждая из которых
влечет преобразование и печать следующего из параметров. Каж-
дая спецификация преобразования начинается с символа %.  Нап-
ример:

--------------------
     * Объяснение того, как применяются строки формата, - это
слегка отредактированный   вариант   спецификации   printf().
(прим. автора)

  cout<<form("there were %d members present",no_of_members);

     Здесь %d указывает,  что no_of_members должно рассматри-
ваться как int и печататься в виде соответствующей последова-
тельности десятичных цифр. Если no_of_members==127, вывод бу-
дет такой:

     there were 127 members present

     Множество спецификаций преобразования довольно велико  и
обеспечивает высокую степень гибкости.  После % может стоять:

  -  необязательный знак минус,  который задает  выравнивание
     преобразованного значения влево в указанном поле;

  d  необязательная строка цифр,  задающая ширину поля.  Если
     преобразованное значение имеет меньше цифр,  чем  ширина
     поля, оно будет дополняться пробелами слева (или справа,
     если был задан индикатор выравнивания влево) до заполне-
     ния всей  ширины поля; если ширина поля начинается с ну-
     ля, то вместо дополнения пробелами будет делаться допол-
     нение нулями;

  .  необязательная точка,   для  отделения  ширины  поля  от

                                    - 199 -
     следующей строки цифр;

  d  необязательная строка цифр,   специфицирующая  точность,
     которая задает   число  цифр  после десятичной точки для
     преобразований e и f или печатаемых символов для строки;

  *  в ширине поля или точности вместо строки цифр может сто-
     ять *. В этом случае ширина поля и точность задается це-
     лым параметром;

  h  необязательный символ h; указывает на то,  что идущие за
     ним d,  o,  x или y соответствуют параметру короткое це-
     лое;

  l  необязательный символ h; указывает на то,  что идущие за
     ним d, o, x или y соответствуют параметру длинное целое;

  %  указывает, что  должен быть напечатан символ %,  никакие
     параметры при этом не затрагиваются;

  c  символ, указывающий,  какой  тип  преобразования  должен
     применяться. Символы  преобразования и их значения тако-
     вы:

   d целый параметр преобразуется в десятичную запись;

   o целый параметр преобразуется в восьмеричную запись;

   x целый параметр преобразуется в шестнадцатиричную запись;

     f параметр  float  или double преобразуется в десятичную
     запись вида [-]ddd.ddd,  где число, задаваемое цифрами d
     после десятичной  точки,  эквивалентно спецификации точ-
     ности для параметра. Если точность опущена, дается шесть
     цифр; если точность явно задана как 0,  то не печатается
     десятичная точка и не печатается ни одной цифры;

     e параметр float или double преобразуется  в  десятичную
     запись вида   [-]d.ddde+dd,  где перед десятичной точкой
     стоит одна цифра,  а число, задаваемое цифрами после де-
     сятичной точки,   эквивалентно спецификации точности для
     параметра; когда точность опущена,  выдается шесть цифр;

     g параметр float или double печатается в том из видов d,
     f или e,  который обеспечивает полную точность при мини-
     мальной затрате места;

     c печатается символьный параметр, пустые символы игнори-
     руются;

     s параметр  воспринимается как строка (указатель на сим-
     вол), и  печатаются символы из строки до пустого символа
     или до тех пор, пока не будет достигнуто число символов,
     указанное спецификацией точности; но если точность равна
     нулю, печатаются все символы до пустого;

     u беззнаковый  целый параметр преобразуется в десятичную
     запись.

     Несуществующая или недостаточная ширина поля никогда  не
     приводит к  обрезанию поля; дополнение поля записи имеет
     место только в том случае,  если указанная  ширина  поля
     превышает фактическую ширину.

  Вот более сложный пример:

  char* src_file_name;

                                    - 200 -
  int line;
  char* line_format = "\n#line %d \"%s\"\n";
  //...
  cout << "int a;\n";
  cout << form(line_format,line,src_file_name);
  cout << "int b;\n";

который печатает

  int a;

  #line 13 "С++/main.c"
  int b;

     Применение form()  небезопасно в смысле того, что не вы-
полняется проверка типа. Вот, например, хорошо хорошо извест-
ный способ получить непредсказуемый вывод  и/или  дамп  (core
dump):

  char x;
  // ...
  cout<<form("bad input char: %s",x);

     Правда, она  дает  большую гибкость в том виде,  который
хорошо знаком программистам на C.  Потоковый вывод можно сме-
шивать с выводом в стиле printf().

     В настоящее   время   нет  полностью  удовлетворительных
средств, обеспечивающих  форматированный вывод типов, опреде-
ляемых пользователем* В частности, вероятно нужно будет найти
стандартный способ передавать функции вывода для определяемо-
го пользователем типа информацию, которая позволит ей опреде-
лить пространственные ограничения,  вид заполнения, левое или
правое выравнивание и т.п.  такими, какими они определяются в
ее вызове. Вполне осуществимый, но не идеальный подход состо-
ит в том, чтобы снабжать определяемый пользователем тип функ-
циями, которые  порождают соответствующее строковое представ-
ление объекта,    для  которого  они  вызываются,  аналогично
форматирующим функциям oct(), hex() и т.д. Например:

  class complex (*
      float re,im;
  public:
      // ...
      char* string(char* format)
          (* return form(format,re,im); *)
  *);
  // ...
  cout << z.string("(%.3f,%.3f)");

     Память для хранения строк,  которые  возвращают  form(),
hex() и  т.п., берется из одного статически размещаемого цик-
лического буфера,  поэтому не имеет смысла  сохранять  указа-
тель, возвращаемый любой из этих функций, для дальнейшего ис-
пользования. Указываемые символы будут меняться.

              8.2.5 Виртуальная Функция Вывода

     Иногда функция вывода должна быть  virtual.   Рассмотрим
пример класса shape, который дает понятие фигуры (#1.18):

  class shape (*
      // ...
  public:
      // ...
      virtual void draw(ostream& s); // рисует "this" на "s"
  *);

                                    - 201 -

  class circle : public shape (*
      int radius;
  public:
      // ...
      void draw(ostream&);
  *);

     То есть,  круг имеет все признаки фигуры и может обраба-
тываться как фигура,  но имеет также и некоторые  специальные
свойства, которые должны учитываться при его обработке.

     Чтобы поддерживать  для  таких классов стандартную пара-
дигму вывода, операция << определяется так:

  ostream& operator<<(ostream& s, shape* p)
  (*
      p->draw(s);
      return s;
  *)

     Если next - итератор типа определенного  в  #7.3.3,   то
список фигур распечатывается например так:

  while ( p = next() ) cout << p;

                     8.3 Файлы и Потоки

     Потоки обычно связаны с файлами. Библиотека потоков соз-
дает стандартный поток ввода cin,  стандартный  поток  вывода
cout и стандартный поток ошибок cerr.  Программист может отк-
рывать другие файлы и создавать для них потоки.

             8.3.1 Инициализация Потоков Вывода

  ostream имеет конструкторы:

  class ostream (*
      // ...
      ostream(streambuf* s); // связывает с буфером потока
      ostream(int fd); // связывание для файла
      ostream(int size, char* p); // связывает с вектором
  *);

     Главная работа  этих конструкторов - связывать с потоком
буфер. streambuf - класс, управляющий буферами; он описывает-
ся в   #8.6,  как и класс filebuf,  управляющий streambuf для
файла. Класс    filebuf  является   производным   от   класса
streambuf.

     Описание стандартных потоков вывода cout и cerr, которое
находится в исходных кодах библиотеки  потоков  ввода/вывода,
выглядит так:

  // описать подходящее пространство буфера
  char cout_buf[BUFSIZE]

  // сделать "filebuf" для управления этим пространством
  //связать его с UNIX'овским потоком вывода 1 (уже открытым)
  filebuf cout_file(1,cout_buf,BUFSIZE);

  // сделать ostream, обеспечивая пользовательский интерфейс
  ostream cout(&cout_file);

  char cerr_buf[1];

  // длина 0, то есть, небуферизованный

                                    - 202 -
  // UNIX'овский поток вывода 2 (уже открытый)
  filebuf cerr_file(2,cerr_buf,0);

  ostream cerr(&cerr_file);

     Примеры двух  других конструкторов ostream можно найти в
#8.3.3 и #8.5.

                8.3.2 Закрытие Потоков Вывода

     Деструктор для ostream сбрасывает буфер с помощью откры-
того члена функции ostream::flush():

  ostream::~ostream()
  (*
      flush(); // сброс
  *)

     Сбросить буфер можно также и явно. Например:

  cout.flush();

                    8.3.3 Открытие Файлов

     Точные детали того, как открываются и закрываются файлы,
различаются в   разных операционных системах и здесь подробно
не описываются.  Поскольку после включения <stream.h>  стано-
вятся доступны cin,  cout и cerr, во многих (если не во всех)
программах не нужно держать код для открытия файлов. Вот, од-
нако, программа,   которая открывает два файла,  заданные как
параметры командной строки, и копирует первый во второй:

  #include <stream.h>

  void error(char* s, char* s2)
  (*
      cerr << s << " " << s2 << "\n";
      exit(1);
  *)

  main(int argc, char* argv[])
  (*
      if (argc != 3) error("неверное число параметров","");

      filebuf f1;
      if (f1.open(argv[1],input) == 0)
          error("не могу открыть входной файл",argv[1]);
      istream from(&f1);

      filebuf f2;
      if (f2.open(argv[2],output) == 0)
          error("не могу создать выходной файл",argv[2]);
      ostream to(&f2);

      char ch;
      while (from.get(ch)) to.put(ch);

      if (!from.eof() !! to.bad())
          error("случилось нечто странное","");
  *)

     Последовательность действий  при  создании  ostream  для
именованного файла та же,  что используется  для  стандартных
потоков: (1) сначала создается буфер (здесь это делается пос-
редством описания filebuf); (2)  затем к нему  подсоединяется
файл (здесь это делается посредством открытия файла с помощью
функции filebuf::open()); и,  накрнец,   (3)   создается  сам

                                    - 203 -
ostream с filebuf в качестве параметра.  Потоки ввода обраба-
тываются аналогично.

  Файл может открываться в одной из двух мод:

  enum open_mode (* input, output *);

     Действие filebuf::open() возвращает 0, если не может от-
крыть файл   в соответствие с требованием.  Если пользователь
пытается открыть файл,  которого не существует для output, он
будет создан.

     Перед завершением программа проверяет,  находятся ли по-
токи в приемлемом состоянии (см.   #8.4.2).   При  завершении
программы открытые файлы неявно закрываются.

     Файл можно также открыть одновременно для чтения и запи-
си, но в тех случаях, когда это оказывается необходимо, пара-
дигма потоков редко оказывается идеальной.  Часто лучше расс-
матривать такой файл как вектор (гигантских размеров).  Можно
определить тип, который позволяет программе обрабатывать файл
как вектор, см. Упражнения 8- 10.

                  8.3.4 Копирование Потоков

     Есть возможность копировать потоки. Например:

  cout = cerr;

     В результате этого получаются две переменные, ссылающие-
ся на один и тот же поток.  Гавным образом это бывает полезно
для того, чтобы сделать стандартное имя вроде cin ссылающимся
на что-то другое (пример этого см. в #3.1.6)

                          8.4 Ввод

     Ввод аналогичен выводу.  Имеется класс istream,  который
предоставляет операцию >> ("взять из")  для  небольшого  мно-
жества стандартных   типов.  Функция operator>> может опреде-
ляться для типа, определяемого пользователем.

                 8.4.1 Ввод Встроенных Типов

     Класс istream определяется так:

  class istream (*
      // ...
  public:
      istream& operator>>(char*); // строка
      istream& operator>>(char&); // символ
      istream& operator>>(short&);
      istream& operator>>(int&);
      istream& operator>>(long&);
      istream& operator>>(float&);
      istream& operator>>(double&);
      // ...
  *);

     Функции ввода определяются в таком духе:

  istream& istream::operator>>(char& c);
  (*
          // пропускает пропуски
      int a;
          // неким образом читает символ в "a"
      c = a;
  *)

                                    - 204 -

     Пропуск определяется как стандартнчй пропуск в C,  через
вызов isspase()  в том виде,  как она определена в  <ctype.h>
(пробел, табуляция,   символ новой строки,  перевод формата и
возврат каретки).

     В качестве  альтернативы  можно   использовать   функции
get():

  class istream (*
      // ...
      istream& get(char& c); // char
      istream& get(char* p, int n, int ='\n'); // строка
  *);

     Они обрабатывают символы пропуска так же,  как остальные
символы. Функция istream::get(char) читает один символ в свой
параметр; другая   istream::get  читает не более n символов в
вектор символов,  начинающийся в p. Необязательный третий па-
раметр используется   для  задания  символа остановки (иначе,
терминатора или ограничителя),  то есть этот символ  читаться
не будет.  Если будет встречен символ ограничитель,  он оста-
нется как первый символ потока.  По умолчанию вторая  функция
get будет  читать самое большее n символов,  но не больше чем
одну строку, '\n' является ограничителем по умолчанию. Необя-
зательный третий параметр задает символ,  который читаться не
будет. Например:

  cin.get(buf,256,'\t');

     будет читать в buf не более 256 символов,  а если встре-
тится табуляция ('\t'),  то это приведет к возврату из get. В
этом случае следующим символом,  который будет считан из cin,
будет '\t'.

     Стандартный заголовочный  файл <ctype.h> определяет нес-
колько функций,  которые могут оказаться полезными  при  осу-
ществлении ввода:

 int isalpha(char) // 'a'..'z' 'A'..'Z'
 int isupper(char) // 'A'..'Z'
 int islower(char) // 'a'..'z'
 int isdigit(char) // '0'..'9'
 int isxdigit(char) // '0'..'9' 'a'..'f' 'A'..'F'
 int isspase(char) // ' ' '\t' возврат новая строка
                      // перевод формата
 int iscntrl(char) // управляющий символ
                      // (ASCII 0..31 и 127)
 int ispunct(char) // пунктуация:ни один из вышеперечисленных
 int isalnum(char) // isalpha() ! isdigit()
 int isprint(char) // печатаемый: ascii ' '..'-'
 int isgraph(char) // isalpha() ! isdigit() ! ispunct()
 int isascii(char c) (* return 0<=c && c<=127; *)

     Все кроме isascii() реализуются внешне одинаково, с при-
менением символа   в  качестве  индекса  в  таблице атрибутов
символов. Поэтому такие выражения, как

  (('a'<=c && c<='z') !! ('A'<=c && c<='Z')) // алфавитный

     не только утомительно пишутся и чреваты ошибками (на ма-
шине с набором символов EBCDIC оно будет принимать неалфавит-
ные символы),  они также и менее эффективны,  чем  применение
стандартной функции:

  isalpha(c)


                                    - 205 -
                   8.4.2 Состояния Потока

     Каждый поток (istream или ostream) имеет ассоциированное
с ним состояние,  и обработка ошибок и нестандартных  условий
осуществляется с помощью соответствующей установки и проверки
этого состояния.

     Поток может находиться в одном из следующих состояний:

  enum stream_state (* _good, _eof, _fail, _bad *);

     Если состояние _good или _eof, значит последняя операция
ввода прошла успешно. Если состояние _good, то следующая опе-
рация ввода может пройти успешно,  в противном случае она за-
кончится неудачей. Другими словами, применение операции ввода
к потоку,  который не находится в состоянии _good,   является
пустой операцией.   Если делается попытка читать в переменную
v, и  операция оканчивается неудачей,  значение v должно  ос-
таться неизменным (оно будет неизменным, если v имеет один из
тех типов,  которые обрабатываются функциями членами  istream
или ostream).    Отличие между состояниями _fail и _bad очень
незначительно и предсавляет интерес только для  разработчиков
операций ввода.  В состоянии _fail предполагается,  что поток
не испорчен и никакие символы не потеряны.  В состоянии  _bad
может быть все что угодно.

     Состояние потока можно проверять например так:

  switch (cin.rdstate()) (*
  case _good:
      // последняя операция над cin прошла успешно
      break;
  case _eof:
      // конец файла
      break;
  case _fail:
      // некоего рода ошибка форматирования
      // возможно, не слишком плохая
      break;
  case _bad:
      // возможно, символы cin потеряны
      break;
  *)

     Для любой  переменной  z  типа,  для которого определены
операции << и >>, копирующий цикл можно написать так:

  while (cin>>z) cout << z << "\n";

     Например, если z - вектор  символов,   этот  цикл  будет
брать стандартный  ввод и помещать его в стандартный вывод по
одному слову (то есть, последовательности символов без пробе-
ла) на строку.

     Когда в качестве условия используется поток,  происходит
проверка состояния потока,  и эта проверка  проходит  успешно
(то есть,    значение условия не ноль)  только если состояние
_good. В  частности, в предыдущем цикле проверялось состояние
istream, которое  возвращает cin>>z. Чтобы обнаружить, почему
цикл или проверка закончились  неудачно,   можно  исследовать
состояние. Такая проверка потока реализуется операцией преоб-
разования (#6.3.2).

     Делать проверку на наличие ошибок  после  каждого  ввода
или вывода действительно не очень удобно, и обычно источником
ошибок служит программист,  не сделавший этого в  том  месте,
где это существенно. Например, операции вывода обычно не про-

                                    - 206 -
веряются, но они могут случайно не сработать. Парадигма пото-
ка ввода/вывода   построена  так,  чтобы когда в С++ появится
(если это произойдет) механизм обработки исключительных ситу-
аций (как средство языка или как стандартная библиотека), его
будет легко применить для упрощения и стандартизации обработ-
ки ошибок в потоках ввода/вывода.

        8.4.3 Ввод Типов, Определяемых Пользователем

     Ввод для пользовательского типа может определяться точно
так же, как вывод, за тем исключением, что для операции ввода
важно, чтобы второй параметр был ссылочного типа. Например:

  istream& operator>>(istream& s, complex& a)
  /*
      форматы ввода для complex; "f" обозначает float:
      f
      ( f )
      ( f , f )
  */
  (*
      double re = 0, im = 0;
      char c = 0;

      s >> c;
      if (c == '(') (*
          s >> re >> c;
          if (c == ',') s >> im >> c;
          if (c != ')') s.clear(_bad); // установить state
      *)
      else (*
          s.putback(c);
          s >> re;
      *)

      if (s) a = complex(re,im);
      return s;
  *)

     Несмотря на  то,   что не хватает кода обработки ошибок,
большую часть видов ошибок это на самом деле обрабатывать бу-
дет. Локальная переменная c инициализируется, чтобы ее значе-
ние не оказалось случайно '(' после того,  как операция окон-
чится неудачно.      Завершающая  проверка  состояния  потока
гарантирует, что значение параметра a будет изменяться только
в том случае, если все идет хорошо.

     Операция установки состояния названа clear() (очистить),
потому что она чаще всего используется для установки  состоя-
ния потока  заново как _good.  _good является значением пара-
метра по   умолчанию   и   для   istream::clear(),    и   для
ostream::clear().

     Над операциями  ввода  надо поработать еще.  Было бы,  в
частности, замечательно,   если бы можно было задавать ввод в
терминах образца (как в языках Snobol и Icon), а потом прове-
рять, прошла  ли успешно вся операция ввода.  Такие  операции
должны были бы,  конечно, обеспечивать некоторую дополнитель-
ную буферизацию, чтобы они могли воссанавливать поток ввода в
его исходное состояние после неудачной попытки распознавания.

              8.4.4 Инициализация Потоков Ввода

     Естественно, тип istream,  так же как и ostream, снабжен
конструктором:

  class istream (*

                                    - 207 -
      // ...
      istream(streambuf* s, int sk =1, ostream* t =0);
      istream(int size, char* p, int sk =1);
      istream(int fd, int sk =1, ostream* t =0);
  *);

     Параметр sk  задает,   должны  пропускаться пропуски или
нет. Параметр t (необязательный) задает указатель на ostream,
к которому   прикреплен istream.  Например,  cin прикреплен к
cout; это значит, что перед тем, как попытаться читать симво-
лы из своего файла, cin выполняет

  cout.flush(); // пишет буфер вывода

     С помощью  функции istream::tie()  можно прикрепить (или
открепить, с  помощью tie(0)) любой ostream к любому istream.
Например:

  int y_or_n(ostream& to, istream& from)
  /*
       "to", получает отклик из "from"
  */
  (*
      ostream* old = from.tie(&to);
      for (;;) (*
          cout << "наберите Y или N: ";
          char ch = 0;
          if (!cin.get(ch)) return 0;

          if (ch != '\n') (* // пропускает остаток строки
              char ch2 = 0;
              while (cin.get(ch2) && ch2 != '\n') ;
          *)
          switch (ch) (*
          case 'Y':
          case 'y':
          case '\n':
              from.tie(old); // восстанавливает старый tie
              return 1;
          case 'N':
          case 'n':
              from.tie(old); // восстанавливает старый tie
              return 0;
          default:
              cout << "извините, попробуйте еще раз: ";
          *)
      *)
  *)

     Когда используется буферизованный ввод (как это происхо-
дит по  умолчанию),  пользователь не может набрав только одну
букву ожидать отклика.  Система ждет появления символа  новой
строки. y_or_n() смотрит на первый символ строки, а остальные
игноирует.

     Символ можно вернуть в поток с помощью функции istream::
putback(char). Это позволяет программе "заглядывать вперед" в
поток ввода.

                   8.5 Работа со Строками

     Можно осуществлять действия,  подобные вводу/выводу, над
символьным вектором,   прикрепляя к нему istream или ostream.
Например, если  вектор содержит обычную строку, завершающуюся
нулем, для    печати слов из этого вектора можно использовать
приведенный выше копирующий цикл:


                                    - 208 -
  void word_per_line(char v[], int sz)
  /*
      печатет "v" размера "sz" по одному слову на строке
  */
  (*
      istream ist(sz,v); // сделать istream для v
      char b2[MAX]; // больше наибольшего слова
      while (ist>>b2) cout << b2 << "\n";
  *)

     Завершающий нулевой символ в этом случае интерпретирует-
ся как символ конца файла.

     В помощью ostream можно отформатировать сообщения, кото-
рые не нужно печатать тотчас же:

  char* p = new char[message_size];
  ostream ost(message_size,p);
  do_something(arguments,ost);
  display(p);

     Такая операция,  как do_something,  может писать в поток
ost, передавать ost своим подоперациям и т.д. с помощью стан-
дартных операций вывода. Нет необходимости делать проверку на
переполнение, поскольку ost знает свою длину и когда он будет
переполняться, он  будет переходить в состояние _fail. И, на-
конец, display может писать сообщения в "настоящий" поток вы-
вода. Этот    метод может оказаться наиболее полезным,  чтобы
справляться с ситуациями, в которых окончательное отображение
данных включает в себя нечто более сложное, чем работу с тра-
диционным построчным устройством вывода.  Например,  текст из
ost мог  бы помещаться в располагающуюся где-то на экране об-
ласть фиксированного размера.

                       8.6 Буферизация

     При задании операций ввода/вывода мы никак  не  касались
типов файлов,   но ведь не все устройства можно рассматривать
одинаково с точки зрения стратегии буферизации. Например, для
ostream, подключенного к символьной строке, требуется буфери-
зация другого вида,  нежели для ostream, подключенного к фай-
лу. С этими пробемами можно справиться, задавая различные бу-
ферные типы   для  разных  потоков  в  момент   инициализации
(обратите внимание на три конструктора класса ostream).  Есть
только один набор операций над этими буферными типами, поэто-
му в функциях ostream нет кода, их различающего. Однако функ-
ции, которые обрабатывают переполнение сверху и снизу, вирту-
альные. Этого  достаточно,  чтобы справляться с необходимой в
данное время стратегией буферизации. Это также служит хорошим
примером применения виртуальных функций для того,  чтобы сде-
лать возможной однородную обработку  логически  эквивалентных
средств с   различной  реализацией.  Описание буфера потока в
<stream.h> выглядит так:

  struct streambuf (* // управление буфером потока

      char* base; // начало буфера
      char* pptr; // следующий свободный char
      char* qptr; // следующий заполненный char
      char* eptr; // один из концов буфера
      char alloc; // буфер, выделенный с помощью new

          // Опустошает буфер:
          // Возвращает EOF при ошибке и 0 в случае успеха
      virtual int overflow(int c =EOF);

          // Заполняет буфер

                                    - 209 -
          // Возвращет EOF при ошибке или конце ввода,
          // иначе следующий char
      virtual int underflow();

      int snextc() // берет следующий char
      (*
          return (++qptr==pptr) ? underflow() : *qptr&0377;
      *)

      // ...

      int allocate() //выделяет некоторое пространство буфера

      streambuf() (* /* ... */*)
      streambuf(char* p, int l) (* /* ... */*)
      ~streambuf() (* /* ... */*)
  *);

     Обратите внимание, что здесь определяются указатели, не-
обходимые для работы с буфером,  поэтому обычные посимвольные
действия можно определить (только один раз) в виде максималь-
но эффективных inline- функций. Для каждой конкретной страте-
гии буферизации необходимо определять только функции перепол-
нения overflow() и underflow(). Например:

  struct filebuf : public streambuf (*

      int fd; // дескриптор файла
      char opened; // файл открыт

      int overflow(int c =EOF);
      int underflow();

      // ...

          // Открывает файл:
          // если не срабатывает, то возвращет 0,
          // в случае успеха возвращает "this"
      filebuf* open(char *name, open_mode om);
      int close() (* /* ... */ *)

      filebuf() (* opened = 0; *)
      filebuf(int nfd) (* /* ... */ *)
      filebuf(int nfd, char* p, int l) : (p,l) (* /*...*/ *)
      ~filebuf() (* close(); *)
  *);

  int filebuf::underflow() // заполняет буфер из fd
  (*
      if (!opened !! allocate()==EOF) return EOF;

      int count = read(fd, base, eptr-base);
      if (count < 1) return EOF;

      qptr = base;
      pptr = base + count;
      return *qptr & 0377;
  *)

                      8.7 Эффективность

     Можно было бы ожидать,  что  раз  ввод/вывод  <stream.h>
определен с помощью общедоступных средств языка, он будет ме-
нее эффективен, чем встроенное средство. На самом деле это не
так. Для  действий вроде "поместить символ в поток" использу-
ются inline-функции,  единственные необходимые на этом уровне
вызовы функций   возникают из-за переполнения сверху и снизу.

                                    - 210 -
Для простых объектов (целое,  строка и т.п.) требуется по од-
ному вызову на каждый.  Как выясняется,  это не отличается от
прочих средств ввода/вывода,  работающих с объектами на  этом
уровне.

                       8.8 Упражнения

  1. (*1.5) Считайте файл чисел с плавающей точкой, составьте
     из пар   считанных  чисел  комплексные  числа и выведите
     комплексные числа.

  2. (*1.5) Определите  тип  name_and_address  (имя_и_адрес).
     Определите для  него << и >>.  Скопируйте поток объектов
     name_and_address.

  3. (*2) Постройте несколько функций для  запроса  и  чтения
     различного вида информации.  Простейший пример - функция
     y_or_n() в  #8.4.4.  Идеи: целое, число с плавающей точ-
     кой, имя файла, почтовый адрес, дата, личные данные и т.
     д. Постарайтесь сделать их защищенными от дурака.

  4. (*1.5) Напишите программу, которая печатает (1) все бук-
     вы в нижнем регистре,  (2)  все буквы,  (3)  все буквы и
     цифры, (4)   все символы,  которые могут  встречаться  в
     идентификаторах С++  на вашей системе,  (5)  все символы
     пунктуации, (6)   целые значения всех управляющих симво-
     лов, (7)   все символы пропуска, (8) целые значения всех
     символов пропуска, и (9) все печатаемые символы.

  5. (*4) Реализуйте стандартную  библиотеку  ввода/вывода  C
     (<stdio.h>) с помощью стандартной библиотеки ввода/выво-
     да С++ (<stream.h>).

  6. (*4) Реализуйте стандартную библиотеку ввода/вывода  С++
     (<stream.h>) с  помощью стандартной библиотеки ввода/вы-
     вода C (<stdio.h>).

  7. (*4) Реализуйте стандартные библиотеки C и С++ так, что-
     бы они могли использоваться одновременно.

  8. (*2) Реализуйте  класс,  для которого [] перегружено для
     реализации случайного чтения символов из файла.

  9. (*3) Как Упражнение 8, только сделайте, чтобы [] работа-
     ло и для чтения, и для записи. Подсказка: сделайте, что-
     бы [] возвращало объект "дескрипторного типа", для кото-
     рого присваивание   означало  бы  присвоить  файлу через
     дескриптор, а  неявное преобразование в char означало бы
     чтение из файла через дескриптор.

  10.(*2) Как Упражнение 9, только разрешите [] индексировать
     записи некоторого вида, а не символы.

  11.(*3) Сделайте обобщенный вариант класса, определенного в
     Упражнении 10.

  12.(*3.5) Разработайте  и  реализуйте операцию ввода по со-
     поставлению с образцом. Для спецификации образца исполь-
     зуйте строки формата в духе printf.  Должна быть возмож-
     ность попробовать   сопоставить  со   вводом   несколько
     образцов для нахождения фактического формата. Можно было
     бы вывести класс ввода по образцу из istream.

  13.(*4) Придумайте (и реализуйте)  вид  образцов,   которые
     намного лучше.

                                    - 211 -
                   
                   Справочное Руководство

                         1. Введение

     Язык программирования С++ - это C*, расширенный введени-
ем классов,  inline-функций, перегруженных операций, перегру-
женных имен функций,  константных типов, ссылок, операций уп-
равления свободной   памятью,   проверки  параметров функций.
Коротко различия между С++ и "старым С" приведены в  #15.   В
этом руководстве описывается язык на Июнь 1985.

--------------------
     * "Язык программирования Си" Брайэна В. Кернигана и Ден-
ниса М. Ритчи. Это руководство было построено на основе Спра-
вочного Руководства по Языку C  ("C  Programming  Language  -
Reference Manual")    системы  UNIX  V с разрешения AT&T Bell
Laboratories. (прим. автора)

                 2. Договоренности о Лексике

     Есть шесть классов лексем: идентификаторы, ключевые сло-
ва, константы, строки, операторы и прочие разделители. Симво-
лы пробела,  табуляции и новой строки,  а  также  комментарии
(собирательно - "белые места"), как описано ниже, игнорируют-
ся, за исключением тех случаев, когда они служат разделителя-
ми лексем. Некое пустое место необходимо для разделения иден-
тификаторов, ключевых  слов и констант,  которые в  противном
случае окажутся соприкасающимися.

     Если входной поток разобран на лексемы до данного симво-
ла, принимается,   что следующая  лексема  содержит  наиболее
длинную строку символов из тех,  что могут составить лексему.

                       2.1 Комментарии

     Символы /*  задают начало комментария,  заканчивающегося
символами */. Комментарии не могут быть вложенными. Символы /
/ начинают комментарий, который заканчивается в конце строки,
на которой они появились.

                 2.2 Идентификаторы (Имена)

     Идентификатор - последовательность букв  и  цифр  произ-
вольной длины.  Первый символ обязан быть буквой. Подчерк '_'
считается за букву.  Буквы в верхнем и нижнем регистрах явля-
ются различными.


                     2.3 Ключевые Слова

     Следующие идентификаторы зарезервированы для использова-
ния в   качестве ключевых слов и не могут использоваться иным
образом:

  asm auto break case char
  class const continue default delete
  do double else enum extern
  float for friend goto if
  inline int long new operator
  overload public register return short
  sizeof static struct switch this
  typedef union unsigned virtual void
  while

     Идентификаторы signed  и  volatile  зарезервированы  для
применения в будущем.


                                    - 212 -
                        2.4 Константы

     Как описано ниже,  есть несколько видов констант. В #2.6
приводится краткая сводка аппаратных характеристик,   которые
влияют на их размеры.

                    2.4.1 Целые Константы

     Целая константа,   состоящая из последовательности цифр,
считается восьмиричной, если она начинается с 0 (цифры ноль),
и десятичной   в  противном  случае.  Цифры 8 и 9 не являются
восьмиричными цифрами. Последовательность цифр, которой пред-
шествует 0х или 0Х,  воспринимается как шестнадцатиричное це-
лое. В  шестнадцатеричные цифры входят буквы от а или А до  f
или F,   имеющие значения от 10 до 15.  Десятичная константа,
значение которой превышает наибольшее машинное целое со  зна-
ком, считается длинной (long); восьмеричная и шестнадцатерич-
ная константа, значение которой превышает наибольшее машинное
целое со   знаком,  считается long; в остальных случаях целые
константы считаются int.

            2.4.2 Явно Заданные Длинные Константы

     Десятичная, восьмиричная или шестнадцатиричная  констан-
та, за    которой  непосредственно  стоит  l (латинская буква
"эль") или L, считается длинной константой.

                 2.4.3 Символьные Константы

     Символьная константа состоит из символа,  заключенного в
одиночные кавычки (апострофы),  как, например, 'х'. Значением
символьной константы является численное  значение  символа  в
машинном наборе   символов  (алфавите).  Символьные константы
считаются данными типа int.

     Некоторые неграфические символы,  одиночная кавычка '  и
обратная косая  \,  могут быть представлены в соответствие со
следующей таблицей escape-последовательностей:

   символ новой строки NL(LF) \n
   горизонтальная табуляция NT \t
   вертикальная табуляция VT \v
   возврат на шаг BS \b
   возврат каретки CR \r
   перевод формата FF \f
   обратная косая \ \\
   одиночная кавычка (апостроф) ' \'
   набор битов 0ddd \ddd
   набор битов 0xddd \xddd

     Escape-последовательность \ddd  состоит  из обратной ко-
сой, за которой следуют 1, 2 или 3 восьмеричных цифры, задаю-
щие значение   требуемого символа.  Специальным случаем такой
консрукции является \0 (не следует ни одной цифры),  задающая
пустой символ  NULL.  Escape-последовательность \xddd состоит
из обратной косой, за которой следуют 1, 2 или 3 шестнадцати-
ричных цифры, задающие значение требуемого символа. Если сле-
дующий за обратной косой символ не является одним из перечис-
ленных, то обратная косая игнорируется.

             2.4.4 Константы с Плавающей Точкой

     Константа с  плавающей  точкой  состоит  из целой части,
десятичной точки,  мантиссы, е или Е и целого показателя сте-
пени (возможно,  но не обязательно, со знаком). Целая часть и
мантисса обе состоят из последовательности цифр.  Целая часть
или мантисса (но не обе сразу)  может быть опущена; или деся-

                                    - 213 -
тичная точка, или е(Е) вместе с целым показателем степени (но
не обе  части одновременно)  может быть опущена.  Константа с
плавающей точкой имеет тип double.

                2.4.5 Перечислимые Константы

     Имена, описанные как перечислители,  (см. #8.5) являются
константами типа int.

                  2.4.6 Описанные Константы

     Объект (#5) любого типа может быть определен как имеющий
постоянное значение во всей области видимости (#4.1) его име-
ни. В    случае  указателей для достижения этого используется
декларатор *const; для объектов,  не являющихся  указателями,
используется описатель const (#8.2).

                         2.5 Строки

     Строка есть  последовательность символов,  заключенная в
двойные кавычки:  "...". Строка имеет тип "массив символов" и
класс памяти static (см.  #4 ниже),  она инициализируется за-
данными символами.  Все строки, даже если они записаны одина-
ково, различны.  Компилятор располагает в конце каждой строки
нулевой (пустой)  байт \0 с тем,   чтобы  сканируюшая  строку
программа могла найти ее конец. В строке перед символом двой-
ной кавычки " обяэательно должен стоять \; кроме того,  могут
использоваться те же escape-последовательности, что были опи-
саны для символьных констант. И, наконец, символ новой строки
может появляться только сразу после \, тогда оба,- \ и символ
новой строки,- игнорируются.

          2.6 Харктеристики Аппаратного Обеспечения

     В нижеследующей таблице собраны некоторые  харктеристики
аппаратного обеспечения, различающиеся от машины к машине.

============================================================
          !DEC VAX-11 !   Motorola  !  IBM 370  !  AT&T 3B
          !  ASCII    ! ASCII       ! EBCDIC    ! ASCII
============================================================
 char     ! 8 бит     ! 8 бит       ! 8 бит     ! 8 бит
 int      ! 32 бит    ! 16 бит      ! 32 бит    ! 16 бит
 short    ! 16 бит    ! 16 бит      ! 16 бит    ! 16 бит
 long     ! 32 бит    ! 32 бит      ! 32 бит    ! 32 бит
 float    ! 32 бит    ! 32 бит      ! 32 бит    ! 32 бит
 double   ! 64 бит    ! 64 бит      ! 64 бит    ! 64 бит
 указатель!  32 бит   ! 32 бит      ! 24 бит    ! 32 бит
 диапазон !           !             !           !
 float    ! √10e√38   ! √10e√38     ! √10e√76   ! √10e√38
 диапазон !           !             !           !
 double   ! √10e√38   ! √10e√38     ! √10e√76   ! √10e√308
 тип char ! знаковый  ! без знака   ! без знака ! без знака
 тип поля ! знаковый  ! без знака   ! без знака ! без знака
 порядок  ! справа    ! слева       ! слева     ! слева
 полей    ! налево    ! направо     ! направо   ! направо
============================================================

                    3. Запись Синтаксиса

     По используемым в данном руководстве синтаксическим пра-
вилам записи   синтаксические категории выделяются курсивом а
литеральные слова и символы шрифтом постоянной ширины.   Аль-
тернативные категории записываются на разных строках.  Необя-
зательный терминальный или нетерминальный символ обозначается
нижним индексом "opt", так что


                                    - 214 -
   (* выражение opt *)

     указывает на необязательность выражения в фигурных скоб-
ках. Синтаксис кратко изложен в #14.

                       4. Имена и Типы

     Имя обозначает(денотирует)  объект, функцию, тип, значе-
ние или метку.  Имя вводится в программе описанием (#8).  Имя
может использоваться только внутри области текста  программы,
называемой его областью видимости.  Имя имеет тип, определяю-
щий его использование.  Объект - это область памяти.   Объект
имеет класс памяти,  определяющий его время жизни. Смысл зна-
чения, обнаруженного в объекте, определяется типом имени, ис-
пользованного для доступа к нему.

                    4.1 Область Видимости

     Есть четыре  вида областей видимости:  локальная,  файл,
программа и класс.

     Локальная: Имя,  описанное в блоке (#9.2),   локально  в
этом блоке   и  может использоваться только в нем после места
описания и в охватываемых блоках. Исключение составляют метки
(#9.12), которые  могут использоваться в любом месте функции,
в которой они описаны.  Имена формальных  параметров  функции
рассматриваются так,    как  если бы они были описаны в самом
внешнем блоке этой функции.

     Файл: Имя,  описанное вне любого блока (#9.2) или класса
(#8.5), может  использоваться в файле, где оно описано, после
места описания.

     Класс: Имя члена класса локально для его класса и  может
использоваться только  в функции члене этого класса (#8.5.2),
после примененной к объекту его класса (#7.1)  операции . или
после примененной   к  указателю  на объект его класса (#7.1)
операции ->.  На статические члены класса (#8.5.1)  и функции
члены можно  также ссылаться с помощью операции ::  там,  где
имя их класса находится в области видимости. Класс, описанный
внутри класса (#8.5.15),  не считается членом, и его имя при-
надлежит охватывающей области видимости.

     Имя может быть скрыто посредством явного  описания  того
же имени   в  блоке или классе.  Имя в блоке или классе может
быть скрыто только именем, описанным в охватываемом блоке или
классе. Скрытое   нелокальное имя также может использоваться,
когда его область видимости указана операцией ::  (#7.1). Имя
класса, скрытое  именем, которое не является именем типа, все
равно может использоваться,   если  перед  ним  стоит  class,
struct или union (#8.2).  Имя перечисления enum, скрытое име-
нем, которое не является именем типа, все равно может исполь-
зоваться, если перед ним стоит enum (#8.2).

                       4.2 Определения

     Описание (#8)  является определением, за исключением тех
случаев, когда  оно описывает функци, не задавая тела функции
(#10), когда оно содержит спецификатор extern (1) и в нем нет
инициализатора или тела функции,  или когда оно является опи-
санием класса (#8.8).

                       4.3 Компоновка

     Имя в файловой области видимости,  не описанное явно как
static, является  общим для каждого файла многофайловой прог-
раммы. Таковым  же является имя функции. О таких именах гово-

                                    - 215 -
рится, что  они внешние.  Каждое описание  внешнего  имени  в
программе относится  к тому же объекту (#5),  функции (#8.7),
классу (#8.5), перечислению (#8.10) или значению перечислите-
ля (#8.10).

     Типы, специфицированные во всех описаниях внешнего имени
должны быть идентичны.  Может быть больше одного  определения
типа, перечисления,   inline-функции (#8.1)  или несоставного
const (#8.2),  при условии, что определения идентичны, пояля-
ются в  разных файлах и все инициализаторы являются констант-
ными выражениями (#12). Во всех остальных случаях должно быть
ровно одно определение для внешнего имени в программе.

     Реализация может потребовать, чтобы составное const, ис-
пользованное там, где не всречено никакого определения const,
должно быть явно описано extern и иметь в программе ровно од-
но определение. Это же ограничение может налагаться на inline
-функции.

                      4.4 Классы Памяти

     Есть два  описываемых  класса  памяти:  автоматический и
статический.

     Автоматические объекты локальны для каждого вызова блока
и сбрасываются по выходе из него.

     Статические объекты существуют и сохраняют свое значение
в течение выполнения всей програмы.

     Некоторые объекты не связаны с именами и их времена жиз-
ни явно   управляются  операторами new и delete,  см.  #7.2 и
#9.14

                      4.5 Основные Типы

     Объекты, описанные как символы (char),   достаточны  для
хранения любого   элемента машинного набора символов,  и если
принадлежащий этому набору символ хранится в символьной пере-
менной, то ее значение равно целому коду этого символа.

     В настоящий момент имеются целые трех размеров, описыва-
емые как short int, int и long int. Более длинные целые (long
int) предоставляют не меньше памяти, чем более короткие целые
(short int), но при реализации или длинные, или короткие, или
и те   и  другие  могут  стать  эквивалентными обычным целым.
"Обычные" целые имеют естественный размер,  задаваемый  архи-
тектурой центральной мащины; остальные размеры делаются таки-
ми, чтобы они отвечали специальным потребностям.

     Каждое перечисление (#8.9)  является набором именованных
констант. Свойства enum идентичны свойствам int.

     Целые без знака,  описываемые как unsigned,  подчиняются
правилам арифметики по модулю 2n,  где n -  число  бит  в  их
представлении.

     Числа с  плавающей  точкой  одинарной (float)  и двойной
(double) точности в некоторых машинных реализациях могут быть
синонимами.

     Поскольку объекты  перечисленных выше типов вполне можно
интерпретировать как числа,  мы будем говорить о них  как  об
арифметических типах. Типы char, int всех размеров и enum бу-
дут собирательно называться целочисленными типами. Типы float
и double будут собирательно называться плавающими типами.


                                    - 216 -
     Тип данных  void  (пустой)   определяет пустое множество
значений. Значение  (несуществующее)  объекта void нельзя ис-
пользовать никаким образом, не могут применяться ни явное, ни
неявное преобразования. Поскольку пустое выражение обозначает
несуществующее значение,  такое выражение такое выражение мо-
жет использоваться только как оператор выражение (#9.1)   или
как левый   операнд в выражении с запятой (#7.15).  Выражение
может явно преобразовываться к типу void (#7.2).

                    4.4 Производные Типы

     Кроме основных арифметических  типов  концептуально  су-
ществует бесконечно много производных типов,  сконструирован-
ных из основных типов следующим образом:

     массивы объектов данного типа;

     функции, получающие аргументы данного типа и  возвращаю-
     щие объекты данного типа;

     указатели на объекты данного типа;

     ссылки на объекты данного типа;

     константы, являющиеся значениями данного типа;

     классы, содержащие последовательность объектов различных
     типов, множество  функций для работы с этими объектами и
     набор ограничений  на доступ к этим объектам и функциям;
     структуры, являющиеся  классами без ограничений доступа;

     объединения, являющиеся структурами,   которые  могут  в
     разное время содержать объекты разных типов.

     В целом  эти способы конструирования объектов могут при-
меняться рекурсивно.

     Объект типа void* (указатель на void) можно использовать
для указания на объекты неизвестного типа.

                5. Объекты и Lvalue (Адреса)

     Объект есть область памяти.  lvalue (адрес) есть выраже-
ние, ссылающееся  на объект. Очевидный пример адресного выра-
жения - имя объекта.  Есть операции,  дающие адресные выраже-
ния: например,   если Е - выражение типа указатель,  то *Е  -
адресное выражение,  ссылающееся на объект, на который указы-
вает Е.  Термин "lvalue" происходит из выражения присваивания
Е1=Е2, в    котором  левый  операнд  Е1  должен быть адресным
(value) выражением.   Ниже при обсуждении  каждого  оператора
указывается, требует  ли он адресные операнды и возвращает ли
он адресное значение.

                      6. Преобразования

     Определенные операции могут в зависимости от их  операн-
дов вызывать  преобразование значения операнда от одного типа
к другому.  В этой части объясняется, каков ожидаемый резуль-
тат таких преобразований.  В #6.6 содержится краткое описание
преобразований, требуемых  наиболее стандартными  операциями;
оно будет  дополняться по мере надобности в процессе обсужде-
ния каждой операции. В #8.5.6 описываются преобразования, оп-
ределяемые пользователем.

                     6.1 Символы и Целые

     Символ или короткое целое могут использоваться, если мо-

                                    - 217 -
жет использоваться   целое.    Во   всех   случаях   значение
преобразуется к   целому.   Преобразование короткого целого к
длинному всегда включает в себя  знаковое  расширение;  целые
являются величинами со знаком. Содержат символы знаковый раз-
ряд или нет,  является машинно зависимым, см. #2.6. Более яв-
ный тип unsigned char ограничивает изменение значения от 0 до
машинно зависимого максимума.

     В машинах,  где символы рассматриваются как имеющие знак
(знаковые), символы множества кода ASCII являются положитель-
ными. Однако,   символьная константа,  заданная  восьмеричной
escпоследовательностью подвергается   знаковому  расширению и
может стать отрицательным числом; так например,  '\377' имеет
значение -1.

     Когда длинное целое преобразуется в короткое или в char,
оно урезается влево; избыточные биты просто теряются.

                     6.2 Float и Double

     Для выражений float могут выполняться действия арифмети-
ки с плавающей точкой одинарной точности. Преобразования меж-
ду числами одинарной и двойной точности выполняются настолько
математически корректно, насколько позволяет аппаратура.

                    6.3 Плавающие и Целые

     Преобразования плавающих  значений  в  целочисленный тип
имеет склонность быть машинно зависимым. В частности, направ-
ление усечения   отрицательных  чисел различается от машины к
машине. Если  предоставляемого пространства для  значения  не
хватает, то результат неопределен.

     Преобразование целочисленного  значения  в плавающий тип
выполняются хорошо. При нехватке в аппаратной реализации тре-
буемых бит возникает некоторая потеря точности.

                    6.4 Указатели и Целые

     Выражение целого  типа  можно  прибавить к указателю или
вычесть из него.  В таком случае первый  преобразуется,   как
указывается при обсуждении операции сложения.

     Можно производить  вычитание  над  двумя  указателями на
объекты одного типа; в этом случае результат преобразуется  к
типу int или long в зависимости от машины, см. #7.4.

                        6.5 Unsigned

     Всегда при  сочетании целого без знака и обычного целого
обычное целое преобразуется к типу unsigned и результат имеет
тип unsigned.  Значением является наименьшее целое без знака,
равное целому со знаком (mod 2**(размер слова))  (т.е. по мо-
дулю 2**(размер слова)).  В дополнительном двоичном представ-
лении это преобразование является пустым,  и никаких реальных
изменений в двоичном представлении не происходит.

     При преобразовании  целого  без знака в длинное значение
результата численно совпадает со значением целого без  знака.
Таким образом,    преобразование сводится к дополнению нулями
слева.

              6.6 Арифметические Преобразования

     Большое количество операций  вызывают  преобразования  и
дают тип результата одинаковым образом.  Этот стереотип будет
называться "обычным арифметическим преобразованием".

                                    - 218 -
     Во-первых, любые операнды типа char,  unsigned char  или
     short преобразуются к типу int.

     Далее, если один из операндов имеет тип double,  то дру-
     гой преобразуется к типу double и тот же тип  имеет  ре-
     зультат.

     Иначе, если  один  из операндов имеет тип unsigned long,
     то другой преобразуется к типу unsigned long и таков  же
     тип результата.

     Иначе, если один из операндов имеет тип long,  то другой
     преобразуется к типу long и таков же тип результата.

     Иначе, если один из операндов имеет  тип  unsigned,   то
     другой преобразуется  к типу unsigned и таков же тип ре-
     зультата.

     Иначе оба операнда должны иметь тип int и таков  же  тип
     результата.

                6.7 Преобразования Указателей

     Везде, где  указатели  присваиваются,  инициализируются,
сравниваются и т.д.  могут выполняться следующие преобразова-
ния.

     Константа 0  может преобразовываться в указатель,  и га-
     рантируется, что  это значение породит указатель, отлич-
     ный от указателя на любой объект.

     Указатель любого типа может преобразовываться в void*.

     Указатель на  класс  может преобразовываться в указатель
     на открытый базовый класс этого класса, см. #8.5.3.

     Имя вектора может преобразовываться в указатель  на  его
     первый элемент.

     Идентификатор, описанный   как  "функция,   возвращающая
     ...", всегда,   когда он не используется в позиции имени
     функции в вызове, преобразуется в "указатель на функцию,
     возвращающую ...".

                    6.8 Преобразования Ссылок

     Везде, где инициализируются ссылки,   может  выполняться
следующее преобразование.

     Ссылка на класс может преобразовываться в ссылку на отк-
рытый базовый класс этого класса, см. #8.6.3.

                        7. Выражения

     Приоритет операций в выраженях такой же,  как и  порядок
главных подразделов   в этом разделе,  наибольший приоритет у
первого. Так  например, выражения, о которых говорится как об
операндах операции + (#7.4) - это те выражения, которые опре-
делены в ##7.1-7.4.  Внутри каждого подраздела операции имеют
одинаковый приоритет. В каждом подразделе для рассматриваемых
в нем операций определяется их левая или  правая  ассоциатив-
ность (порядок обработки операндов).  Приоритет и ассоциатив-
ность всех операций собран вместе  в  описании  грамматики  в
#14.

     В остальных случаях порядок вычисления выражения неопре-
делен. Точнее,  компилятор волен вычислять подвыражения в том

                                    - 219 -
порядке, который он считает более эффективным, даже если под-
выражения вызывают побочные эффекты.   Порядок  возникновения
побочных эффектов неопределен.  Выражения,  включающие в себя
коммутативные и асссоциативные операции (*,  +, &, !, ^), мо-
гут быть реорганизованы произвольным образом,  даже при нали-
чии скобок; для задания определенного порядка вычисления  вы-
ражения необходимо использовать явную временную переменную.

     Обработка переполнения и контроль деления при вычислении
выражения машинно зависимы. В большинстве существующих реали-
заций С++ переполнение целого игнорируется; обработка деления
на 0 и всех исключительных ситуаций  с  числами  с  плавающей
точкой различаются  от машины к машине и обычно могут регули-
роваться библиотечными функциями.

     Кроме стандартного значения,   описанного  в  #7.2-7.15,
операции могут быть перегружены*,  то есть, могут быть заданы
их значения для случая их применения к  типам,   определяемым
пользователем, см. #7.16.

 --------------------
     * Этот термин применяется для описания  использования  в
языке одной и той же лексемы для обозначения различных проце-
дур; вид процедуры выбирается компилятором на  основании  до-
полнительной информации в виде числа и типа аргументов и т.п.
(прим.перев.)

                   7.1 Основные Выражения

     Основные выражения,  включающие в себя . , -> , индекси-
рование и вызовы функций, группируются слева направо.

   список_выражений:
       выражение
       список_выражений , выражение

   id:
       идентификатор
       имя_функции_операции
       typedef-имя :: идентификатор
       typedef-имя :: имя_функции_операции

   первичное_выражение:
       id
       :: идентификатор
       константа
       строка
       this
       ( выражение )
       первичное_выражение [ выражение ]
       первичное_выражение ( список_выражений opt )
       первичное_выражение . id
       первичное_выражение -> id

     Идентификатор есть первичное выражение, причем соответс-
твенно описанное (#8).  Имя_функции_операции есть идентифика-
тор со специальным значением, см. #7.16 и #8.5.1.

     Операция ::,    за   которой  следует  идентификатор  из
файловой области видимости,  есть то же, что и идентификатор.
Это позволяет   ссылаться на объект даже в том случае,  когда
его идентификатор скрыт (#4.1).

     Typedef-имя (#8.8)  ,  за которым следует ::, после чего
следует идентификатор, является первичным выражением. Typedef
-имя должно обозначать класс (#8.5),  и идентификатор  должен
обозначать член этого класса.  Его тип специфицируется описа-

                                    - 220 -
нием идентификатора.  Typedef-имя может быть  скрыто  именем,
которое не   является именем типа.  В этом случае typedef-имя
все равно может быть найдено и его можно использовать.

     Константа является первичным выражением.  Ее тип  должен
быть int, long или double в зависимости от ее формы.

     Строка является  первичным выражением.  Ее тип - "массив
символов". Обычно он сразу же преобразуется в указатель на ее
первый символ (#6.7).

     Ключевое слово this является локальной переменной в теле
функции члена (см. #8.5) . Оно является указателем на объект,
для которого функция была вызвана.

     Выражение, заключенное  в круглые скобки,  является пер-
вичным выражением, чей тип и значение те же, что и у незаклю-
ченного в  скобки выражения.  Наличие скобок не влияет на то,
является выражение lvalue или нет.

     Первичное выражение,  за  которым  следует  выражение  в
квадратных скобках,  является первичным выражением. Интуитив-
ный смысл - индекс.  Обычно  первичное  выражение  имеет  тип
"указатель на  ...",  индексирующее выражение имеет тип int и
тип результата есть "...". Выражение Е1[Е2] идентично (по оп-
ределению) выражению  *((E1)+(E2)). Все тонкие места, необхо-
димые для понимания этой записи,  содержатся в  этом  разделе
вместе с   обсуждением в ## 7.1,  7.2 и 7.4,  соответственно,
идентификаторов, *  и + ; ниже, в #8.4.2 приводятся следствия
из этого.

     Вызов функции является первичным выражением,  за которым
следуют скобки,  содержащие список (возможно,  пустой) разде-
ленных запятыми выражений, составляющих фактические параметры
для функции.  Первичное выражение должно иметь тип  "функция,
возвращающая ..."   или  "указатель на функцию,  возвращающую
...", и результат вызова функции имеет тип "...".

     Каждый формальный параметр инициализируется  фактическим
параметром (#8.6). Выполняются стандартные (#6.6-8) и опреде-
ляемые пользователем преобразования (#8.5.6).  Функция  может
изменять значения своих формальных параметров, но эти измене-
ния не могут повлиять на значения фактических  параметров  за
исключением случая, когда формальный параметр имеет ссылочный
тип.

     Функция может быть описана  как  получающая  меньше  или
больше параметров,    чем  специфицировано в описании функции
(#8.4). Каждый  фактический параметр типа float, для которого
нет формального   параметра,  преобразуются к типу double; и,
как обычно,  имена массивов преобразуются к указателям. Поря-
док вычисления  параметров не определен языком; имейте в виду
различия между компиляторами.

     Допустимы рекурсивные вызовы любых функций.

     Первичное выражение,  после которого стоит точка, за ко-
торой следует   идентификатор (или идентификатор,  уточненный
typedef-именем с помощью операции ::)   является  выражением.
Первое выражение должно быть объектом класса, а идентификатор
должен именовать член этого класса. Значением является имено-
ванный член объекта, и оно является адресным, если первое вы-
ражение является адресным.  Следует отметить,  что "классовые
объекты" могут  быть структурами (#8.5.12)  или объединениями
(#8.5.13).

     Первичное выражение,  после которого стоит стрелка (  ->

                                    - 221 -
), за которой следует идентификатор (или идентификатор, уточ-
ненный typedef-именем с помощью операции ::) является выраже-
нием. Первое выражение должно быть указателем на объект клас-
са, а  идентификатор  должен  именовать  член  этого  класса.
Значение является   адресом,  ссылающимся на именованный член
класса, на который указывает указательное выражение. Так, вы-
ражение E1->MOS есть то же,  что и (*E1).MOS. Классы обсужда-
ются в #8.5.

     Если первичное выражение дает значение  типа  "указатель
на ..." (см.  #8.4 and #8.6.3),  значением выражения был объ-
ект, обозначаемый ссылкой. Ссылку можно считать именем объек-
та, см. #8.6.3.

                    7.2 Унарные Операции

     Выражения с  унарными операциями группируют справа нале-
во:

   унарное_выражение:
       унарная_операция выражение
       выражение ++
       выражение --
       sizeof выражение
       sizeof ( имя_типа )
       ( имя_типа ) выражение
       простое_имя_типа ( список_выражений )
       new имя_типа инициализатор opt
       new ( имя_типа )
       delete выражение
       delete [ выражение ] выражение
   унарная_операция: одна из
       * & - ! ~ ++ --

     Унарная операция   *   означает   косвенное   обращение:
выражение должно быть указателем и результатом будет  lvalue,
ссылающееся на объект,  на который указывает выражение.  Если
выражение имеет тип "указатель на ...",   то  тип  результата
есть "...".

     Результатом унарной  операции  &  является  указатель на
объект, на  который ссылается операнд.  Операнд  должен  быть
lvalue. Если    выражение имеет тип "...",  то тип результата
есть "указатель на ...".

     Результатом унарной операции + является значение ее опе-
ранда после выполнения обычных арифметических преобразований.
Операнд должен быть арифметического типа.

     Результатом унарной операции  -  является  отрицательное
значение ее операнда.  Операнд должен иметь целый тип. Выпол-
няются обычные арифметические  преобразования.   Отрицательое
значение беззнаковой  величины вычислятся посредством вычита-
ния ее значения из 2n, где n -число битов в целом типа int.

     Результатом операции логического отрицания ! является 1,
если значение операнда 0,  и 0,  если значение операнда не 0.
Результат имеет тип int.  Применима к любому  арифметическому
типу или к указателям.

     Операция ~ дает дополнение значения операнда до единицы.
Выполняются обычные арифметические  преобразования.   Операнд
должен иметь целочисленный тип.
                                           
                                           
                                           
                                           

                                    - 222 -
                7.2.1 Увеличение и Уменьшение

     Операнд префиксного ++ получает приращение. Операнд дол-
жен быть адресным . Значением является новое значение операн-
да, но  оно не адресное.  Выражение ++x эквивалентно x+=1. По
поводу данных о преобразованиях см.  обсуждение операций сло-
жения (#7.4) и присваивания (#7.14).

     Операнд префиксного  --  уменьшается аналогично действию
префиксной операции ++.

     Значение, получаемое при использовании постфиксного  ++,
есть значение операнда.  Операнд должен быть адресным.  После
того, как результат отмечен, объект увеличивается так же, как
и в префиксной операции ++.  Тип результата тот же, что и тип
операнда.

     Значение, получаемое при использовании  постфиксной  --,
есть значение операнда.  Операнд должен быть адресным.  После
того, как результат отмечен, объект увеличивается так же, как
и в префиксной операции ++.  Тип результата тот же, что и тип
операнда.

                        7.2.2 Sizeof

     Операция sizeof дает размер операнда в байтах.  (Байт не
определяется языком иначе, чем через значение sizeof. Однако,
во всех существующих реализациях байт есть пространтсво,  не-
обходимое для   хранения char.)  При применении к массиву ре-
зультатом является полное количество байтов в массиве. Размер
определяется из описаний объектов,  входящих в выражение. Се-
мантически это выражение является  беззнаковой  константой  и
может быть использовано в любом месте, где требуется констан-
та.

     Операцию sizeof можно также применять к  заключенному  в
скобки имени типа.  В этом случае она дает размер,  в байтах,
объекта указанного типа.

               7.2.3 Явное Преобразование Типа

     Простое_имя_типа (#8.2), возможно, заключенное в скобки,
за которым   идет  заключенное  в  скобки выражение (или спи-
сок_выражений, если  тип является классом  с  соответствующим
образом описанным конструктором #8.5.5) влечет преобразование
значения выражения в названный тип. Чтобы записать преобразо-
вание в тип, не имеющий простого имени, имя_типа (#8.7) долж-
но быть заключено в скобки. Если имя типа заключено в скобки,
выражение заключать в скобки необязательно.  Такая запись на-
зывается приведением к типу.

     Указатель может быть явно преобразован к любому из цело-
численных типов, достаточно по величине для его хранения. То,
какой из int и long требуется,  является  машинно  зависимым.
Отобразующая функция   также  является машинно зависимой,  но
предполагается, что  она не содержит сюрпризов для того,  кто
знает структуру адресации в машине. Подробности для некоторых
конкретных машин были приведены в #2.6.

     Объект целочисленного типа может быть явно  преобразован
в указатель.    Отображающая функция всегда превращает целое,
полученное из указателя, обратно в тот же указатель, но в ос-
тальных случаях является машинно зависимой.

     Указатель на  один  тип  может  быть явно преобразован в
указатель на другой тип.  Использование полученного в резуль-
тате указателя может привести к исключительной ситуации адре-

                                    - 223 -
сации, если  исходный указатель не указывает на объект, соот-
ветствующим образом выравненный в памяти.  Гарантируется, что
указатель на объект данного размера может быть преобразован в
указатель на объект меньшего размера и обратно без изменений.
Различные машины могут различаться по числу бит в  указателях
и требованиям к выравниванию объектов.  Составные объекты вы-
равниваются по самой строгой границе, требуемой каким-либо из
его составляющих.

     Объект может  преобразовываться  в  объект класса только
если был описан соответствующий конструктор или операция пре-
образования (#8.5.6).

     Объект может  явно преобразовываться в ссылочный тип &X,
если указатель на этот объект может явно преобразовываться  в
X*.

                   7.2.4 Свободная Память

     Операция new создает объект типа имя_типа (см.  #8.7), к
которому он применен.  Время жизни объекта,  созданного с по-
мощью new,    не ограничено областью видимости,  в которой он
создан. Операция  new возвращает указатель  на  созданный  ей
объект. Когда  объект является массивом,  возвращается указа-
етль на его первый элемент. Например, и new int и new int[10]
возвращают int*.  Для объектов некоторых классов надо предос-
тавлять инициализатор (#8.6.2). Операция new (#7.2) для полу-
чения памяти вызывает функцию

   void* operator new (long);

     Параметр задает  требуемое  число  байтов.  Память будет
инициализирована. Если  operator new() не может найти требуе-
мое количество памяти, то она возвращает ноль.

     Операция delete  уничтожает объект,  созданный операцией
new. Ее  результат является void.  Операнд delete должен быть
указателем, возвращенным  new.  Результат применения delete к
указателю, который не был получен с помощью операции new. Од-
нако уничтожение с помощью delete указателя со значением ноль
безвредно.

     Чтобы освободить указанную память, операция delete вызы-
вает функцию

    void operator delete (void*);

   В форме

   delete [ выражение ] выражение

     второй параметр указывает на вектор,  а первое выражение
задает число элементов этого вектора. Задание числа элементов
является избыточным за исключением случаев уничтожения векто-
ров некоторых классов, см. #8.5.8.

               7.3 Мультипликативные Операции

     Мультипликативные операции  *,   /  и % группируют слева
направо. Выполняются обычные арифметические преобразования.

  мультипликативное_выражение:
      выражение * выражение
      выражение / выражение
      выражение % выражение

     Бинарная операция * определяет умножение. Операция * ас-

                                    - 224 -
социативна и выражения с  несколькими  умножениями  на  одном
уровне могут быть реорганизованы компилятором.
     Бинарная операция / определяет деление.  При делении по-
ложительных целых округление осуществляется в сторону 0,   но
если какой-либо из операндов отрицателен, то форма округления
является машинно зависимой.  На всех  машинах,   охватываемых
данным руководством,  остаток имеет тот же знак,  что и дели-
мое. Всегда  истиинно,  что (a/b)*b + a%b равно a (если b  не
0).

     Бинарная операция  % дает остаток от деления первого вы-
ражения на второе.  Выполняются обычные арифметические преоб-
разования. Операнды   не должны быть числами с плавающей точ-
кой.

                   7.4 Аддитивные Операции

     Аддитивные операции +  и  -  группируют  слева  направо.
Выполняюься обычные   арифметические  преобразования.  Каждая
операция имеет некоторые дополнительные возможности,  связан-
ные с типами.

  аддитивное_выражение:
      выражение + выражение
      выражение - выражение

     Результатом операции  + является сумма операндов.  Можно
суммировать указатель на объект массива и значение целого ти-
па. Последнее во всех случаях преобразуется к смещению адреса
с помощью умножения его на длину объекта, на который указыва-
ет указатель.    Результатом является указатель того же типа,
что и исходный указатель, уазывающий на другой объект того же
массива и соответствующим образом смещенный от первоначально-
го объекта.  Так, если P есть указатель на объект массива, то
выражение P+1 есть указатель на следующий объект массива.

     Никакие другие комбинации типов для указателей не допус-
тимы.

     Операция + ассоциативна и выражение с несколькими  умно-
жениями на  одном уровне может быть реорганизовано компилято-
ром.

     Результатом операции  -  является  разность   операндов.
Выполняюься обычные арифметические преобразования.  Кроме то-
го, значение  любого целого типа может вычитаться из указате-
ля, в  этом случае применяются те же преобразования,  что и к
сложению.

     Если вычитаются указатели на объекты одного типа, то ре-
зультат преобразуется  (посредством деления на длину объекта)
к целому,  представляющему собой число объектов,  разделяющих
объекты, указанные  указателями.  В засисимости от машины ре-
зультирующее целое может быть или типа int,  или  типа  long,
см. #2.6.  Вообще говоря, это преобразование будет давать не-
определенный результат кроме тех  случаев,   когда  указатели
указывают на объекты одного массива, поскольку указатели, да-
же на объекты одинакового типа, не обязательно различаются на
величину, кратную длине объекта.

                     7.5 Операции Сдвига

     Операции сдвига  <<  и >> группируют слева направо.  Обе
выполняют одно обычное арифметическое преобразование над сво-
ими операндами,  каждый из которых должен быть целым.  В этом
случае правый операнд преобразуется к типу int; тип результа-
та совпадает с типом левого операнда.  Результат неопределен,

                                    - 225 -
если правый операнд отрицателен или больше  или  равен  длине
объекта в битах.

  сдвиговое_выражение:
      выражение << выражение
      выражение >> выражение

     Значением Е1  << Е2 является Е1 (рассматриваемое как би-
товое представление), сдвинутое влево на Е2 битов; освободив-
шиеся биты заполняются нулями. Значением Е1 >> Е2 является Е1
, сдвинутое  вправо на Е2 битовых позиций. Гарантируется, что
сдвиг вправо является логическим (заполнение нулями), если Е1
является unsigned; в противном случае он может быть арифмети-
чевким (заполнение копией знакового бита).

                   7.6 Операции Отношения

     Операции отношения (сравнения) группируют слева направо,
но этот факт не очень-то полезен:  a < b < c не означает  то,
чем кажется.

  выражение_отношения:
      выражение < выражение
      выражение > выражение
      выражение <= выражение
      выражение >= выражение

     Операции < (меньше чем), > (больше чем), <= и >= все да-
ют 0, если заданное соотношение ложно, и 1, если оно истинно.
Тип результата int. Выполняются обычные арифметические преоб-
разования. Могут  сравниваться два указателя; результат зави-
сит от относительного положения объектов, на которые указыва-
ют указатели,  в адресном пространстве.  Сравнение указателей
переносимо только  если указатели указывают на объекты одного
массива.

                   7.7 Операции Равенства

  выражение_равенства:
      выражение == выражение
      выражение != выражение

     Операции == и != в точности аналогичны операциям сравне-
ния за  исключением их низкого приоритета.  (Так,  a<b == c<d
есть 1 всегда,  когда a<b и c<d имеют одинаковое истинностное
значение.)

     Указатель может сравниваться с 0.

                  7.8 Операция Побитовое И

  И-выражение:
      выражение & выражение

     Операция & ассоциативна,  и выражения, содержащие &, мо-
гут реорганизовываться.    Выполняются обычные арифметические
преобразования; результатом является побитовая функция И опе-
рандов. Операция применяется только к целым операндам.

           7.9 Операция Побитовое Исключающее ИЛИ

  исключающее_ИЛИ_выражение:
      выражение ^ выражение

     Операция ^ ассоциативна,  и выражения, содержащие ^, мо-
гут реорганизовываться.    Выполняются обычные арифметические
преобразования; результатом является побитовая функция исклю-

                                    - 226 -
чающее ИЛИ   операндов.   Операция применяется только к целым
операндам.

           7.10 Операция Побитовое Включающее ИЛИ

     включающее_ИЛИ_выражение:
          выражение ! выражение

     Операция ! ассоциативна,  и выражения, содержащие !, мо-
гут реорганизовываться.  Выполняются  обычные  арифметические
преобразования; результатом  является побитовая функция вклю-
чающее ИЛИ операндов.  Операция применяется  только  к  целым
операндам.

                 7.11 Операция Логическое И

  логическое_И_выражение:
      выражение && выражение

     Операция && группирует слева направо.  Она возвращает 1,
если оба операнда ненулевые, и 0 в противном случае. В проти-
воположность операции & операция  &&  гарантирует  вычисление
слева направо; более того, второй операнд не вычисляется, ес-
ли первый операнд есть 0.

     Операнды не обязаны иметь один и тот же тип,  но  каждый
из них  должен иметь один из основных типов или быть указате-
лем. Результат всегда имеет тип int.

                7.12 Операция Логическое ИЛИ

  логическое_ИЛИ_выражение:
      выражение !! выражение

     Операция !! группирует слева направо.  Она возвращает 1,
если хотя бы один из ее операндов ненуелвой,  и 0 в противном
случае. В противоположность операции ! операция !! гарантиру-
ет вычисление слева направо; более того,  второй  операнд  не
вычисляется, если первый операнд не есть 0.

     Операнды не  обязаны иметь один и тот же тип,  но каждый
из них должен иметь один из основных типов или быть  указате-
лем. Результат всегда имеет тип int.

                   7.13 Условная Операция

  условное_выражение:
      выражение ? выражение : выражение

     Условная операция группирует слева направо.  Вычисляется
первое выражение,   и если оно не 0,  то результатом является
значение второго  выражения,   в  противном  случае  значение
третьего выражения. Если это возможно, то выполняются обычные
арифметические преобразования для приведения второго и треть-
его выражения к общему типу. Если это возможно, то выполняют-
ся преобразования указателей для приведения второго и  треть-
его выражения   к  общему  типу.   Вычисляется только одно из
второго и третьего выражений.

                 7.14 Операции Присваивания

     Есть много операций присваивания,  все группируют  слева
направо. Все в качестве левого операнда требуют lvalue, и тип
выражения присваивания тот же,  что и у его левого  операнда.
Это lvalue не может ссылаться на константу (имя массива,  имя
функции или const). Значением является значение, хранящееся в
левом операнде просле выполнения присваивания.

                                    - 227 -
  выражение_присваивания:

      выражение операция_присваивания выражение

  операция_присваивания: одна из

      = += -= *= /= %= >>= <<= &= ~= !=

     В простом  присваивании  с = значение выражения замещает
собой значение объекта,  на который ссылается операнд в левой
части. Если    оба операнда имеют арифметический тип,  то при
подготовке к присваиванию правый операнд преобразуется к типу
левого. Если   аргумент в левой части имеет указательный тип,
аргумент в правой части должен быть того же  типа  или  типа,
который может быть преобразован к нему, см. #6.7. Оба операн-
да могут быть объектами одного класса.   Могут  присваиваться
объекты некоторых производных классов, см. #8.5.3.

     Присваивание объекту  типа  "указатель  на ..." выполнит
присваивание объекту, денотируемому ссылкой.

     Выполнение выражения вида E1 op=  E2  можно  представить
себе как   эквивалентное  E1  = E1 op (E2); но E1 вычисляется
только один раз.  В += и -= левый операнд может быть указате-
лем, и  в этом случае (целочисленный) правый операнд преобра-
зуется так,  как объяснялось в #7.4; все правые операнды и не
являющиеся указателями левые должны иметь арифметический тип.

                    7.15 Операция Запятая

  запятая_выражение:
      выражение , выражение

     Пара выражений,  разделенных запятой,  вычисляется слева
направо, значение  левого выражения теряется.  Тип и значение
результата являются типом и значением правого операнда.   Эта
операция группирует слева направо.  В контексте,  где запятая
имеет специальное значение, как например в списке фактических
параметров функции (#7.1)  и в списке инициализаторов (#8.6),
операция запятая, как она описана в этом разделе, может появ-
ляться только в скобках; например,

  f (a,(t=3,t+2),c)

  имеет три параметра, вторым из которых является значение 5.

                 7.16 Перегруженные Операции

     Большинство операций  может  быть перегружено,  то есть,
описано так,  чтобы они получали в качестве операндов объекты
классов (см.  #8.5.11). Изменить приоритет операций невозмож-
но. Невозможно  изменить смысл операций при применении  их  к
неклассовым объектам.   Предопределенный смысл операций = и &
(унарной) при применении их к объектам классов может быть из-
менен.

     Эквивалентность операций,   применяемых к основным типам
(например, ++a эквивалентно a+=1), не обязательно выполняется
для операций, применяемых к классовым типам. Некоторые опера-
ции, например,   присваивание, в случае применения к основным
типам требуют, чтобы операнд был lvalue; это не требуется для
операций, описанных для классовых типов.

                   7.16.1 Унарные Операции

     Унарная операция, префиксная или постфиксная, может быть
определена или с помощью функции члена (см. #8.5.4), не полу-

                                    - 228 -
чающей параметров, или с помощью функции друга (см. #8.5.10),
получающей один параметр, но не двумя способами одновременно.
Так, для  любой унарной операции @, x@ и @x могут интерпрети-
роваться как x.операция@()  или операция@(x).  При перегрузке
операций ++ и -- невозможно различить префиксное и  постфикс-
ное использование.

                  7.16.2 Бинарные Операции

     Бинарная операция  может  быть  определена или с помощью
функции члена (см.  #8.5.4),  получающей один параметр, или с
помощью функции друга (см. #8.5.9), получающей два параметра,
но не двумя способами одновременно.  Так,  для любой бинарной
операции @, x@y может быть проинтерпретировано как x.operator
@(y) или operator@(x,y).

                   7.16.3 Особые Операции

  Вызов функции
  первичное_выражение ( список_выражений opt )

и индексирование

  первичное_выражение [ выражение ]

     считаются бинарными  операциями.   Именами  определяющей
функции являются соответсвенно operator() и operator[]. Обра-
щение x(arg) интерпретируется как x.operator()(arg) для клас-
сового объекта x. Индексирование x[y] интерпретируется как x.
operator[](y).

                         8. Описания

     Описания используются для определения интерпретации, да-
ваемой каждому идентификатору. Они не обязательно резервируют
память, связанную с идентификатором. Описания имеют вид:

  описание:
      спецификаторы_описания opt список_описателей opt ;
      описание_имени
      asm_описание

     Описатели в списке_описателей  содержат  идентификаторы,
подлежащие описанию. Спецификаторы_описания могут быть опуще-
ны только в определениях внешних функций (#10) или в описани-
ях внешних функций. Список описателей может быть пустым толь-
ко при описании класса (#8.5)  или перечисления (#8.10),   то
есть, когда   спецификаторы_описания - это class_спецификатор
или enum_спецификатор. Описания имен описываются в #8.8; опи-
сания asm описаны в #8.11.

  спецификатор_описания:
      спецификатор_класса_памяти
      спецификатор_типа
      спецификатор_функции
      friend
      typedef

  спецификаторы_описания:
      спецификатор_описания спецификатор_описания opt

     Список должен  быть внутренне непротиворечив в описывае-
мом ниже смысле.

               8.1 Спецификаторы Класса Памяти

  Спецификаторы - это:

                                    - 229 -
  спецификатор_класса_памяти:
      auto
      static
      extern
      register

     Описания, использующие  спецификаторы  auto,   static  и
register также служат определениями тем, что они вызывают ре-
зервирование соответствующего объема памяти.   Если  описание
extern не является определением (#4.2),  то где-то еще должно
быть определение для данных идентификаторов.

     Описание register лучше всего представить  как  описание
auto (автоматический) с подсказкой компилятору, что описанные
переменные усиленно используются. Подсказка может быть проиг-
норирована. К ним не может применяться операция получения ад-
реса &.

     Спецификаторы auto или register могут применяться только
к именам,    описанным в блоке,  или к формальным параметрам.
Внутри блока не может быть описаний ни  статических  функций,
ни статических формальных параметров.

     В описании  может быть задан максимум один sc_специфика-
тор. Если  в описании отсутсвует  спецификатор_класса_памяти,
то класс   памяти принимается автоматическим внутри функции и
статическим вне.  Исключение: функции не могут быть автомати-
ческими.

     Спецификаторы static и extern могут использоваться толь-
ко для имен объектов и функций.

     Некоторые спецификаторы могут  использоваться  только  в
описаниях функций:

  спецификатор_функции:
      overload
      inline
      virtual

     Спецификатор перегрузки overload  делает  возможным  ис-
пользование одного  имени для обозначения нескольких функций,
см. #8.9.

     Спецификатор inline является только подсказкой  компиля-
тору, не  влияет на смысл программы и может быть проигнориро-
ван. Он  используется,  чтобы указать на то,  что при  вызове
функции inline-подстановка    тела  функции  предпочтительнее
обычной реализацци   вызова  функции.   Функция   (#8.5.2   и
#8.5.10), определенная    внутри  описания  класса,  является
inline по умолчанию.

     Спецификатор virtual может использоваться только в  опи-
саниях членов класса, см. #8.5.4.

     Спецификатор friend  используется для отмены правил сок-
рытия имени для членов класса и может  использоваться  только
внутри описаний классов, см. #8.5.9.

     С помощью  спецификатора  typedef вводится имя для типа,
см. #8.8.

                   8.2 Спецификаторы Типа

     Спецификаторами типов (спецификатор_типа) являются:

  спецификатор_типа:

                                    - 230 -
      простое_имя_типа
      спецификатор_класса
      enum-спецификатор
      сложный_спецификатор_типа
      const

     Слово const  можно добавлять к любому допустимому специ-
фикатору_типа. В остальных случаях в описании может быть дано
не более одного спецификатора_типа.  Объект типа const не яв-
ляется lvalue.  Если в описании опущен спецификатор типа,  он
принимается int.

  простое_имя_типа:
      char
      short
      int
      long
      unsigned
      float
      double
      const
      void

     Слова long,  short и unsigned  можно  рассматривать  как
прилагательные. Они    могут применяться к типу int; unsigned
может также применяться к типам char, short и long.

     Спецификаторы класса и перечисления обсуждаются в #8.5 и
#8.10 соответственно.

  сложный_спецификатор_типа:
      ключ typedef-имя
      ключ идентификатор

  ключ:
      class
      struct
      union
      enum

     Сложный спецификатор  типа можно использовать для ссылки
на имя класса или перечисления там, где имя может быть скрыто
локальным именем. Например:

  class x (* ... *);

  void f(int x)
  (*
      class x a;
      // ...
  *)

     Если имя  класса или перечисления ранее описано не было,
сложный_спецификатор_типа работает как  описание_имени,   см.
#8.8.

                        8.3 Описатели

     Список_описателей, появляющийся в описании,  есть разде-
ленная запятыми последовательность описателей,  каждый из ко-
торых может иметь инициализатор.

  список_описателей:
      иниц_описатель
      иниц_описатель , список_описателей

  иниц_описатель:

                                    - 231 -
      описатель инициализатор opt

     Инициализаторы обсуждаются в #8.6. Спецификатор в описа-
нии указывает   тип  и  класс  памяти  объектов,   к  которым
относятся описатели. Описатели имеют синтаксис:

  описатель:
      оп_имя
      ( описатель )
      * const opt описатель
      & const opt описатель
      описатель ( список_описаний_параметров )
      описатель [ константное_выражение opt ]

  оп-имя:
      простое_оп_имя
      typedef-имя :: простое_оп_имя

  простое_оп_имя:
      идентификатор
      typedef-имя
      ~ typedef-имя
      имя_функции_операции
      имя_функции_преобразования

     Группировка та же, что и в выражениях.

                    8.4 Смысл описателей

     Каждый описатель считается утверждением того, что если в
выражении возникает конструкция,  имеющаяя ту же форму, что и
описатель, то  она дает объект указанного типа и класса памя-
ти. Каждый  описатель содержит ровно одно оп_имя; оно опреде-
ляет описываемый идентификатор. За исключением описаний неко-
торых специальных функций (см. #8.5.2) , оп_имя будет простым
идентификатором.

     Если в  качестве описателя возникает ничем не снабженный
идентификатор, то  он имеет тип,   указанный  спецификатором,
возглавляющим описание.

     Описатель в  скобках  эквивалентен описателю без скобок,
но связку сложных описателей скобки могут изменять.

     Теперь представим себе описание

  T D1

     где T - спецификатор типа (как int и т.д.),  а D1 - опи-
сатель. Допустим,   что это описание заставляет идентификатор
иметь тип "...  T",  где "..." пусто,  если идентификатор  D1
есть просто   обычый  идентификатор  (так что тип x в "int x"
есть просто int). Тогда, если D1 имеет вид

  *D

то тип содержащегося идентификатора есть "...указатель на T."

  Если D1 имеет вид

  * const D

     то тип содержащегося идентификатора есть "...  констант-
ный указатель на T",  то есть,  того же типа, что и *D, но не
lvalue.

  Если D1 имеет вид

                                    - 232 -
  &D

или

  & const D

     то тип содержащегося идентификатора есть "...  ссылка на
T." Поскольку ссылка по определению не может быть lvalue, ис-
пользование const излишне.  Невозможно иметь ссылку  на  void
(void&).

  Если D1 имеет вид

  D (список_описаний_параметров)

     то содержащийся  идентификатор  имеет тип "...  функция,
принимающая параметр типа список_описаний_параметров и  возв-
ращающая T."

  список_описаний_параметров:
      список_описаний_парам opt ... opt

  список_описаний_парам:
      список_описаний_парам , описание_параметра
      описание_параметра

  описание_параметра:
      спецификаторы_описания описатель
      спецификаторы_описания описатель = выражение
      спецификаторы_описания абстракт_описатель
      спецификаторы_описания абстракт_описатель = выражение

     Если список_описаний_параметров заканчивается многоточи-
ем, то   о числе параметров известно лишь,  что оно равно или
больше числа  специфицированных  типов  параметров;  если  он
пуст, то  функция не получает ни одного параметра. Все описа-
ния для функции должны согласовываться и в типе возвращаемого
значения, а также в числе и типе параметров.

     Список_описаний_параметров используется  для  проверки и
преобразования фактических параметров и для контроля присваи-
вания указателю на функцию. Если в описании параметра указано
выражение, то  это выражение  используется  как  параметр  по
умолчанию. Параметры  по умолчанию будут использоваться в вы-
зовах, где  опущены стоящие в хвосте параметры.  Параметр  по
умолчанию не  может переопределяться более поздними описания-
ми. Однако,  описание может добавлять параметры по умолчанию,
не заданные в предыдущих описаниях.

     По желанию можно задать идентификатор как имя параметра.
Если он присутствует в описании  функции,   его  использовать
нельзя, поскольку он сразу выходит из области видимости. Если
он присутствует в определении функции (#10),  то  он  именует
фармальный параметр.

  Если D1 имеет вид

  D[ константное_выражение ]

или

  D[]

     то тип  содержащегося  идентификатора  есть "...  массив
объектов типа T".  В первом случае константное выражение есть
выражение, значение   которого может быть определено во время
компиляции, и  тип которого int. (Константные выражения опре-

                                    - 233 -
делены в #12.)  Если подряд идут несколько спецификаций "мас-
сив из", то создается многомерный массив; константное выраже-
ние, определяющее  границы массива, может быть опущено только
для первого члена последовательности.  Этот пропуск  полезен,
когда массив является внешним, и настоящее определение, кото-
рое резервирует память,  находится в  другом  месте.   Первое
константное выражение может также быть опущено, когда за опи-
сателем следует инициализация.  В  этом  случае  используется
размер, вычисленный исходя из числа начальных элементов.

     Массив может  быть построен из одного из основных типов,
из указателей,  из структуры или объединения или  из  другого
массива (для получения многомерного массива).

     Не все  возможности,  которые позволяет приведенный выше
синтаксис, допустимы. Ограничения следующие: функция не может
возвращать массив или функцию, хотя она может возвращать ука-
затели на эти объекты; не существует массивов функций,   хотя
могут быть массивы указателей на функции.

                        8.4.1 Примеры

  Описание

  int i; int *pi; int f (); int *fpi (); int (*pif) ();

     описывает целое  i,   указатель pi на целое,  функцию f,
возвращающую целое,  функцию fpi ,  возвращающую указатель на
целое, и  указатель pif на функцию,  возвращающую целое. Осо-
бенно полезно сравнить последние две.  Цепочка  *fpi()   есть
*(fpi()), как  предполагается в описании, и та же конструкция
требуется в выражении, вызов функции fpi, и затем использова-
ние косвенного обращения через (указательный)  результ, чтобы
получить целое.  В описателе (*pif)()  дополнительные  скобки
необходимы для указания того, что косвенность через указатель
на функцию дает функцию,  которая затем вызывается. Функции f
и fpi описаны как не получающие параметров,  а pif как указы-
вающая на функцию, не получающую параметров.

  Описание

  const a = 10, *pc = &a, *const cpc = pc;
  int b, *const cp = &b;

     описывает a:   целую константу,  pc:  указатель на целую
константу, cpc:  константный указатель на целую константу, b:
целое и cp: константный указатель на целое. Значения a, cpc и
cp не могут быть изменены после инициализации.   Значение  pc
может быть изменено,  как и объект,  указываемый cp.  Примеры
недопустимых выражений:

  a = 1;
  a++;
  *pc = 2;
  cp = &a;
  cpc++;

  Примеры допустимых выражений:

  b = a;
  *cp = a;
  pc++;
  pc = cpc;
                                           
                                           
                                           
  Описание

                                    - 234 -
  fseek (FILE*,long,int);

     описывает функцию,   получающую  три параметра указанных
типов. Поскольку тип возвращаемого значения не задан, он при-
нимается int (#8.2). Описание

  point (int = 0,int = 0);

     описывает функцию, которая может вызываться без парамет-
ров, с одним или с двумя параметрами типа int. Ее можно вызы-
вать одним из следующих способов:

  point (1,2);
  point (1); point ();

  Описание

  printf (char* ... );

     описывает функцию, которая может вызываться с различными
числом и типами параметров. Например

  printf ("hello, world");
  printf ("a=%d b=%d",a,b);

  Однако, всегда ее первым параметром должен быть char*.

  Описание

  float fa[17], *afp[17];

     описывает массив чисел с плавающей точкой и массив  ука-
зателей на числа с плавающей точкой. И, наконец,

  static int x3d[3][5][7];

     описывает массив целых, размером 3x6x7. Совсем подробно:
x3d является массивом из трех  элементов  данных;  каждый  из
элементов данных   является массивом из пяти массивов; каждый
из последних массивов является массивом из семи целых.  Появ-
ление каждое     из   выражений   x3d,   x3d[i],   x3d[i][j],
x3d[i][j][k] может быть приемлемо в выражении.

          8.4.2 Массивы, Указатели и Индексирование

     Всякий раз,  когда в выражении появляется  идентификатор
типа массива,  он преобразуется в указатель на первый элемент
массива. Из-за  преобразований массивы не являются lvalue. По
определению операция индексирования [] интерпретируется таким
образом, что  E1[E2] идентично *((E1)+(E2)).  В  силу  правил
преобразования, применяемых  к +,  если E1 массив и E2 целое,
то E1[E2] отностится к E2-ому члену E1.  Поэтому, несмотря на
такое проявление асимметрии, индексирование является коммута-
тивной операцией.

     Это правило сообразным образом применяется в случае мно-
гомерного массива. Если E является n-мерным массивом ранга i*
j*...*k, то  возникающее в выражении E преобразуется в указа-
тель на (n-1)-мерный массив ранга j*...*k.  Если к этому ука-
зателю, явно или неявно, как результат индексирования, приме-
няется операция   *,   ее  результатом  является (n-1)-мерный
массив, на который указывалось, который сам тут же преобразу-
ется в указатель.

  Рассмотрим, например,

  int x[3][5];

                                    - 235 -
     Здесь x - массив целых размером 3*5. Когда x возникает в
выражении, он преобразуется в указатель на (первый из трех) 5
- элементный массив из целых. В выражении x[i], которое экви-
валентно *(x+i), x сначала преобразуется, как было сказано, в
указатель, затем i преобразуется к типу x, что включает в се-
бя умножение i на длину объекта,  на который указывает указа-
тель, а  именно объект из 5 целых. Результаты складываются, и
используется косвенная адресация для получения массива (из  5
целых), который   в свою очередь преобразуется в указатель на
первое из целых. Если есть еще один индекс, снова использует-
ся тот же параметр; на этот раз результатом является целое.

     Именно из всего этого проистекает то,  что массивы в С++
хранятся строкообразно (быстрее  всего  изменяется  последний
индекс), и   что в описании первый индекс помогает определить
объем памяти, поглощаемый массивом, но не играет никакой дру-
гой роли в вычислениях индекса.

                    8.5 Описания Классов

     Класс есть  тип.   Его  имя  становится typedef-имя (см.
#8.8), которое  может быть использовано  даже  внутри  самого
спецификатора класса.    Объекты класса состоят из последова-
тельности членов.

  спецификатор_класса:
      заголовок_класса (* список_членов opt *)
      заголовок_класса (* список_членов opt public : спи-
  сок_членов opt *)

  заголовок_класса:
      сост идентификатор opt
      сост идентификатор opt : public opt typedef-имя

  сост:
      class
      struct
      union

     Объекты классов могут присваиваться,   передаваться  как
параметры и   возвращаться функциями (за исключением объектов
некоторых производных типов,  см.  #8.5.3).  Прочие действия,
которые могут быть удобны, может определить пользователь, см.
#8.5.11.

     Структура является классом,  все члены  которого  общие,
см. #8.5.9.    Объединение является структурой,  содержащей в
каждый момент только один член,  см.  #8.5.13.  Список_членов
может описывать друзей (8.5.10)  и члены вида:  данные, функ-
ция, класс,  перечисление, поле(#8.5.13). Список_членов может
также содержать описания, регулирующие видимость имен членов,
см. #8.5.9.

  список_членов:
      описание_члена список_членов opt
  описание_члена:
      спецификаторы_описания opt описатель_члена ;
      определение_функции ; opt
  описатель_члена:
      описатель
      идентификатор opt : константное_выражение

     Члены, являющиеся классовыми объектами, должны быть объ-
ектами предварительно описанных классов.  В частности,  класс
cl не может содержать объект класса cl, но он может содержать
указатель на объект класса cl.
  Вот простой пример описания структуры:

                                    - 236 -
  struct tnode
      (*
        char tword[20];
        int count;
        tnode *left;
        tnode *right;
      *);

     содержащей массив из 20 символов,  целое и два указателя
на такие же структуры. Если было дано такое описание, то опи-
сание

  tnode s, *sp

описывает s как структуру данного сорта и sp как указатель на
структуру данного сорта. При наличии этих описаний выражение

  sp->count

ссылается на поле count структуры, на которую указывает sp;

  s.left

ссылается на указатель левого поддерва структуры s; а

  s.right->tword[0]

ссылается на первый символ члена tword правого поддерва стру-
ктуры s.

                   8.5.1 Статические Члены

     Член данные класса может быть static; члены  функции  не
могут. Члены  не могут быть auto,  register или extern.  Есть
единственная копия статического члена, совместно используемая
всеми членами   класса  в программе.  На статический член mem
класса cl можно ссылаться cl:mem,  то есть без ссылки на объ-
ект. Он  существует, даже если не было создано ни одного объ-
екта класса cl.  Для статического члена не  может  задаваться
никакой инициализатор,    и  он не может быть членом класса с
конструктором.

                     8.5.2 Функции Члены

     Функция, описанная как член,  (без спецификатора  friend
(#8.5.10)) называется  функцией членом и вызывается с исполь-
зованием синтаксиса члена класса (#7.1). Например:

  struct tnode
    (*
      char tword[20];
      int count;
      tnode *left;
      tnode *right;
      void set (char* w,tnode* l,tnode* r);
    *);

  tnode n1, n2;
  n1.set ("asdf",&n2,0);
  n2.set ("ghjk",0,0);

     Определение функции члена рассматривается как находящее-
ся в области видимости ее класса.  Это значит,  что она может
непосредственно использовать имена ее класса.  Если определе-
ние функции члена лексически находится вне  описания  класса,
то имя функции члена должно быть уточнено именем класса с по-
мощью операции ::.  Определения функций  обсуждаются  в  #10.

                                    - 237 -
Например:

  void tnode.set (char* w,tnode* l,tnode* r) (*
      count = strlen (w);
      if (sizeof (tword)<=count)
          error ("tnode string too long");
      strcpy (tword,w);
      left = l;
      right = r;
  *)

     Запись tnode.set определяет то, что функция set является
членом класса tnode и принадлежит его области видисости. Име-
на членов tword, count, left и right относятся к объекту, для
которого была       вызвана    функция.    Так,    в   вызове
n1.set("abc",0,0) tword ссылается на n1.tword, а в вызове n2.
set("def",0,0) оно ссылается на n2.tword. Предполагается, что
функции strlen, error и strcpy описаны где-то в другом месте,
см. #10.

     В функции  члене ключевое слово this является указателем
на объект, для которого вызвана функция.

     Функция член может быть  определена  (#10)   в  описании
класса, и в этом случак она является inline (#8.1). Например:

  int b;
  struct x
    (*
      int f () (* return b; *)
      int f () (* return b; *)
      int b;
    *);

 означает

  int b;
  struct x
    (*
      int f ();
      int b;
    *);
  inline x::f () (* return b; *)

     Применение операции  получения  адреса к функциям членам
допустимо. Однако, тип параметра результирующего указателя на
функцию неопределн,  поэтому любое использование его является
зависимым от реализации.

                  8.5.3 Производные Классы

  В конструкции

  сост идентификатор : public opt typedef-имя

     typedef-имя должно означать ранее описанный класс, назы-
ваемый базовым   классом для описываемого класса.  Говорится,
что последний выводится из предшествующего  (является  произ-
водным от него). По поводу смысла public см. #8.5.9. На члены
базового класса можно ссылаться так,  как если  бы  они  были
членами производного класса, за исключением тех случаев, ког-
да имя базового члена было переопределено в производном клас-
се; в   этом случае для ссылки на скрытое имя можно использо-
вать операцию   ::   (#7.1).   Производный  класс  сам  может
использоваться в  качестве базового класса.  Невозможно стро-
исть производные от union (#8.5.13). Указатель на производный
класс может  неявно преобразовываться в указатель на открытый

                                    - 238 -
базовый класс (#6.7).

     Для объектов класса, производного от класса, для которо-
го была  определена operator= (#8.5.11),  присваивание неявно
не определено (#7.14 и #8.5)

  Например:

  class base
    (*
      int a, b;
    *);

  class derived : public base
    (*
      int b, c;
    *);

  derived d;

  d.a = 1;
  d.base::b = 2;
  d.b = 3;
  d.c = 4;

осуществляет присваивание четырем членам d.

                  8.5.4 Виртуальные Функции

     Если базовый  класс  base содержит virtual (виртуальную)
(#8.1) функцию vf, а производный класс derived также содержит
функцию vf,  то обе функции должны иметь один и тот же тип, и
вызов vf для объекта  класса  derived  вызывает  derived::vf.
Например:

  struct base
    (*
      virtual void vf ();
              void f ();
    *);

   class derived : public base
    (*
      void vf ();
      void f ();
    *);

  derived d;
  base* bp = &d;
  bp->vf();
  bp->f();

     Вызовы вызывают,  соответственно,  derived::vf и base::f
для объекта класса derived, именованного d. Так что интерпре-
тация вызова виртуальной функции зависит от типа объекта, для
которого она вызвана, в то время как интерпретация вызова не-
виртуальной функции зависит только от типа указателя, обозна-
чающего объект.

     Виртуальная функция не может быть другом (friend) (#8.5.
10). Функция  f в классе, выведенном из класса, который имеет
виртуальную функцию f,  сама считается виртуальной. Виртуаль-
ная функция в базовом классе должна быть определена.   Вирту-
альная функция,  которая была определена в базовом классе, не
обязательно должна определяться в производном классе.  В этом
случае во всех вызовах используется функция, определенная для
базового класса.

                                    - 239 -
                     8.5.5 Конструкторы

     Функция член с именем,  совпадающим с именем ее  класса,
называется конструктором. Если класс имеет конструктор, то он
вызывается для каждого объекта этого класса перед  тем,   как
этот объект будет как- либо использован, см. #8.6.

  Конструктор не может быть virtual или friend.

     Если класс имеет базовый класс или объекты члены с конс-
трукторами, их конструкторы вызываются до конструктора произ-
водного класса.  Первым вызывается конструктор базового клас-
са. Объяснение  того,   как  для  таких  конструктороу  могут
специфицироваться параметры ,  см.  в #10,  а того, как конс-
трукторы могут использоваться для  управления  свободной  па-
мятью, см. в #8.5.8.

     Объект класса  с конструктором не может быть членом объ-
единения.

     Для конструктора нельзя  задать  возвращаемое  значение,
как нельзя  использовать оператор return в теле конструктора.

     Конструктор может  явно  применяться  для создания новых
объектов его типа используя синтаксис

  typedef-имя ( список_параметров opt )

  Например,

  complex zz = complex (1,2.3);
  cprint (complex (7.8,1.2));

     Объекты, созданные  таким образом,  не имеют имени (если
только конструктор не использован как инициализатор,  как это
было с  zz выше),  и их время жизни ограничено областью види-
мости, в которой они созданы.

                    8.5.6 Преобразования

     Конструктор, получающий один параметр, определяет преоб-
разование из типа своего параметра в тип своего класса. Такие
преобразования неявно применяются дополнительно к стандартным
пробразованиям (#6.6-7).    Поэтому  присваивание  объекту из
класса X допустимо,  если тип T присваиваемого значения  есть
X, или  если было описано преобразование из T в X. Аналогично
конструкторы используются для преобразования  инициализаторов
(#8.6), параметров    функции (#7.1)  и возвращаемых функцией
значений (#9.10). Например:

  class X (* ... X (int); *);
  f (X arg) (*
      X a = 1; // a = X (1)
      a = 2;   // a = X (2)
      f (3);   // f (X (3))
  *)

     Если ни  один конструктор для класса X не получает прис-
ваиваемый тип, то не делается никаких попыток отыскать другие
конструкторы для   преобразования  присваиваемого  значения в
тип, который мог бы быть приемлем для конструкторов класса X.
Например:
  class X (* ... X (int); *);
  class X (* ... Y (X); *);
  Y a = 1; // недопустимо: Y (X (1)) не пробуется
  Функция член класса X с именем вида
  имя_функции_преобразования:

                                    - 240 -
      operator тип

     задает преобразование из X в тип. Тип не может содержать
описания [] "вектор из" или ()  "функция,  возвращающая". Оно
будет применяться неявно аналогично конструкторам выше (толь-
ко если оно единственно:  #8.9), или его можно вызвать явно с
помощью записи приведения к типу. Например:

  class X (*
      // ...
      operator int();
  *);

  X a;
  int i = int(a);
  i = (int)a;
  i = a;

     Во всех  трех  случаях  значене  будет преобразовываться
функцией X::operator int(). Применение определяемых пользова-
телем преобразований   не  сводится  только к присваиваниям и
инициализациям. Например:

  X a, b;
  // ...
  int i = (a) ? 1+a : 0;
  int j = (a&&b) ? a+b : i;

                      8.5.7 Деструкторы

     Функция член  класса cl с именем ~cl называется деструк-
тором. Деструктор  не возвращает никакого значения и не полу-
чает никаких параметров; он используется для уничтожения зна-
чений типа cl непосредственно перед уничтожением  содержащего
их объекта. Деструктор не может быть вызван явно.

     Деструктор для  базового  класса выполняется после дест-
руктора производного от него класса. Деструкторы для объектов
членов выполняются после деструктора для объекта,  членом ко-
торого они являются. Как деструкторы используютя для управле-
ния свободной памятью, см. объяснение в #8.5.8.

     Объект класса  с  деструктором не может быть членом объ-
единения.

                   8.5.8 Свободная Память

     Когда с помощью операции new создается классовый объект,
то для получения необходимой памяти конструктор будет  (неяв-
но) использовать  operator new (#7.1). Конструктор может осу-
ществить свое собственное резервирование  памяти  посредством
присваивания указателю  this до каких-либо использований чле-
на. С  помощью присваивания this значения ноль деструктор мо-
жет избежать стандартной операции дерезервирования памяти для
объекта его класса. Например:

  class cl (*
      int v[10];
      cl () (* this = my_own_allocator (sizeof (cl)); *)
      ~cl () (* my_own_deallocator (this); this = 0; *)
  *)
     На входе в конструктор this являеется не-нулем, если ре-
зервирование памяти  уже имело место (как это имеет место для
auto, static объектов и объектов членов), и нулем в остальных
случаях.
     Вызовы конструкторов для базового класса и объектов чле-
нов будут иметь место после присваивания указателю this. Если

                                    - 241 -
конструктор базового   класса осуществляет присваивание this,
то новое значение также  будет  использоваться  конструктором
производного класса (если таковой есть).

     При уничтожении  вектора  объектов класса с деструктором
необходимо указывать число элементов. Например:

  class X (* ... ~X(); *);
  X* p = new X [size];
  delete[size] p;

                 8.5.9 Видимость Имен Членов

     Члены класса, описанные с ключевым словом class, являют-
ся закрытыми,  то есть,  их имена могут использоваться только
функциями членами (#8.5.2) и друзьями (см. #8.5.10), если они
не стоят   после метки "public:".  В этом случае они являются
открытыми. Открытый член может использоваться любой функцией.
Struct является   классом,   все  члены  которого общие,  см.
#8.5.12.

     Если производный класс описан как struct или если  перед
именем базового   класса в описании производного класса стоит
ключевое слово public, то общие члены базового класса являют-
ся общими для производного класа; в остальных случаях они яв-
ляются закрытыми. Открытый член mem закрытого базового класса
base может   быть  описан как общий для производного класса с
помощью опиисания вида

     typedef-имя :: идентификатор ;

     в котором typedef-имя обозначает базовый класс,  а иден-
тификатор есть   имя  члена  базового класса.  Такое описание
должно стоять в открытой части производного класса.  Рассмот-
рим

  class base (*
      int a;
  public:
      int b, c;
      int bf();
  *);

  class derived : base (*
      int d;
  public:
      base::c;
      int e;
      int df();
  *);

  int ef(derived&);

     Внешняя функция ef может использовать только имена c,  e
и df.  Являясь членом производного derived,  функция df может
использовать имена b, c, bf, d, e и df, но не a. Являясь чле-
ном базового base,  функция bf может использовать члены a, b,
c и bf.










                                    - 242 -
                        8.5.10 Друзья
     Друг класса - это функция не-член, которая может исполь-
зовать имена закрытых членов. Друг не принадлежит области ви-
димости класса и не вызывается с  помощью  синтаксиса  выбора
члена (если он не является членом другого класса).  Следующий
пример иллюстрирует различия между членами и друзьями:

  class private (*
      int a;
      friend void friend_set(private*, int);
  public:
      void member_set(int);
  *);

  void friend_set (private* p, int i) (* p->a = i; *)

  void private::member_set (int i) (* a = i; *)

  private obj;
  friend_set (&obj,10);
  obj.member_set (10);

     Если описание  friend  отностися  к перегруженному имени
или операции, то другом становится только функция, задаваемая
типами параметров.   Член класса cl1 может быть другом класса
cl2. Например:

  class cl2 (*
      friend char* cl1::foo(int);
      // ...
  *);

     Все функции класса cl1 могут быть сделаны друзьями клас-
са cl2 с помощью одного описания

  class cl2 (*
      friend class cl1 ;
      // ...
  *);

     Функция член,  определенная (#10) в описании класса, яв-
ляется inline.

                   8.5.11 Функция Операция

     Большинство операций могут быть перегружены с тем, чтобы
они могли получать в качестве операндов объекты класса.

  имя_функции_операции:
      operator операция

  операция: одна из
      new delete
      + - * / % ^ & ! ~
      ! = < > += -= *= /= %=
      ^= &= != << >> <<= >>= == !=
      <= >= && !! ++ -- () []

     Последние две  операции - это вызов функции и индексиро-
вание. Функция   операция  (за  исключением  operator  new  и
operator delete; см.  #7.2)  должна быть или функцией членом,
или получать по меньшей мере один  классовый  параметр.   См.
также #7.16.
                      8.5.12 Структуры

     Структура есть класс, все члены которого общие. Это зна-
чит, что

                                    - 243 -
  struct s (* ... *);
эквивалентно

  class s (* public: ... *);

     Структура может иметь функции члены (включая конструкто-
ры и  деструкторы).  Базовй класс производной struct является
открытым. Это значит, что

  struct s : d (* ... *);

эквиволентно

  class s : public b (* public: ... *);

                     8.5.13 Объединения

     Объединение можно считать структурой,  все объекты члены
которой начинаются со смещения 0, и размер которой достаточен
для содержания любого из ее объектов членов.  В каждый момент
времени в объединеии может храниться не больше одного из объ-
ектов членов.  Объединение может иметь функции члены (включая
конструкторы и деструкторы). Из объединения невозможно вывес-
ти класс.  Объект класса с конструктором или деструктором  не
может быть членом объединения.

  Объединение вида

  union (* список_членов *);

     называется безымянным  объединением; оно определяет неи-
менованный объект. Имена членов безымянного объединения долж-
ны отличаться  от других имен в области видимости,  в которой
объединение описано; в этой области видимости они  могут  ис-
пользоваться непосредственно, без обычного синтаксиса доступа
к членам (#8.5). Например:

  union (* int a; char* p; *);
  a = 1;
  // ...
  p = "asdf";

     Здесь a и p используются как простые переменные (не-чле-
ны), но  так как они являются членами объединения,  они имеют
один и тот же адрес.

                       8.5.14 Поля Бит

     Описатель_члена вида

  идентификатор opt : константное_выражение

     определяет поле; его длина отделяется от имени поля дво-
еточием. Поля упаковываются в машинные целые; они не являются
альтернативой слов.  Поле , не влезающее в оставшееся в целом
место, помещается  в следующее слово. Поле не может быть шире
слова. На  некоторых машинах они размещаются справа налево, а
на некоторых слева направо, см. #2.6.

     Неименованные поля полезны при заполнении для согласова-
ния внешне предписанных размещений (форматов).  В особых слу-
чаях неименованные поля длины 0 задают выравнивание следующе-
го поля  по границе слова.  Не требуется аппаратной поддержки
любых полей,  кроме целых.  Более того, даже целые поля могут
рассматриваться как unsigned.  По этим причинам рекомендуется
описывать поля как unsigned.  К полям  не  может  применяться
операция получения адреса &,  поэтому нет указателей на поля.

                                    - 244 -
     Поля не могут быть членами объединения.

                   8.5.15 Вложенные Классы

     Класс может быть описан внутри другого класса.  Это, од-
нако, лишь  соглашение о записи,  поскольку внутренний  класс
принадлежит охватывающей области видимости. Например:

  int x;

  class enclose (* // охватывающий
      int x;
      class inner (* // внутренний
          int y;
          void f(int);
      *);
      int g(inner*);
  *);

  inner a;
  void inner::f(int i) (* x = i; *)       // присваивает ::x
  int enclose::g(inner* p) (* return p->y; *) // ошибка

                      8.6 Инициализация

     Описатель может задавать начальное значение описываемого
идентификатора.

  инициализатор:
      = выражение
      = (* список_инициализаторов , opt *)
      ( список_выражений )
  список_инициализаторов:
      выражение
      список_инициализаторов , список_инициализаторов
      (* список_инициализаторов *)

     Все выражения в инициализаторе статической  или  внешней
переменной должны быть константными выражениями, которые опи-
саны в #12, или выражениями, которые сводятся к адресам ранее
описанных переменных,    возможно со смещением на константное
выражение. Автоматические и регистровые переменные могут ини-
циализироваться любыми выражениями, включащими константы, ра-
нее описанные переменные и функции.

     Гарантируется, что  неинициализированные  статические  и
внешние переменные получают в качестве начального значения 0.
Гарантируется, что  неинициализированные автоматические и ре-
гистровые переменные  получают в качестве начального значения
"пустое место"*.

--------------------
     * В  английском  - "garbage",  означающее затертое место
[памяти], т.е.   если переменная целая,  то 0,  если char, то
'\0', если указатель на Т, то (Т*) NULL. (прим. перев.)

     Когда инициализатор применяется к скаляру (указатель или
объект арифметического типа), он состоит из одного выражения,
возможно, заключенного  в фигурные скобки. Начальное значение
объекта находится из выражения; выполняются те же  преобразо-
вания, что и при присваивании.

     Заметьте, что поскольку ()  не является инициализатором,
то X a(); является не описанием объекта класса X, а описанием
функции, не получающей значений и возвращающей X.

                8.6.1 Список Инициализаторов

                                    - 245 -
     Когда описанная переменная является составной (класс или
массив), то  инициализатор может состоять из  заключенного  в
фигурные скобки, разделенного запятыми списка инициализаторов
для членов составного объекта,  в порядке возрастания индекса
или по порядку членов. Если массив содерхит составные подобъ-
екты, то  это правило рекурсивно применяется к членам состав-
ного подобъекта.   Если инициализаторов в списке меньше,  чем
членов в составном подобъекте,  то составной подобъект допол-
няется нулями.

     Фигурные скобки могут опускаться следующим образом. Если
инициализатор начинается с левой фигурной скобки,  то следую-
щий за   ней список инициализаторов инициализирует члены сос-
тавного объекта; наличие числа инициализаторов, большего, чем
число членов,  считается ошибочным. Если, однако, инициализа-
тор не начинается с левой фигурной скобки,  то из списка  бе-
рутся только элементы,  достаточные для сопоставления элемен-
там составного объекта; все остающиеся  элементы  оставляются
для инициализации   следующего  элемента  составного объекта,
частью которого является текущий составной объект.

  Например,

  int x[] = (* 1, 3, 5 *);

     описывает и инициализирует x как одномерный массив, име-
ющий три элемента,  поскольку размер не был указан и дано три
инициализатора.

  float y[4][3] = (*
        (* 1, 3, 5 *),
        (* 2, 4, 6 *),
        (* 3, 5, 7 *)
  *);

     является полностью снабженной квадратными скобками  ини-
циализацией: 1,3  и 5 инициализируют первый ряд массива y[0],
а именно,  y[0][0],  y[0][1] и y[0][2]. Аналогично, следующие
две строки инициализируют y[1] и y[2]. Инициализатор заканчи-
вается раньше,  поэтому y[3] инициализируется 0-ями.  В  точ-
ноcти тот же эффект может быть достигнут с помощью

  float y[4][3] = (*
      1, 3, 5, 2, 4, 6, 3, 5, 7
  *);

     Инициализатор для  y начинается с левой фигурной скобки,
но не начинается с нее инициализатор для y[0],   поэтому  ис-
пользуется три значения из списка.  Аналогично, следующие три
успешно используются для y[1] и следующие три для y[2].   Так
же

  float y[4][3] = (* (* 1 *), (* 2 *), (* 3 *), (* 4 *) *);

     инициализирует первый  столбец  y  (рассматриваемого как
двумерный массив) и оставляет остальные элементы нулями.

                    8.6.2 Объекты Классов
     Объект с закрытыми членами не может  быть  инициализован
списком инициализаторов; это же относится к объекту объедине-
ние. Объект класса с конструктором должен инициализироваться.
Если класс  имеет конструктор,  не получающий параметров,  то
этот конструктор используется для объектов,  которые явно  не
инициализированы. Список    параметров для конструктора можно
добавлять к имени в описании или к типу в выражении new. Сле-
дующие инициализации все дают одно и тоже значение (#8.4):
  struct complex (*

                                    - 246 -
      float re;
      float im;
      complex (float r,float i = 0) (* re=r; im=i; *)
  *);

  complex zz1(1,0);
  complex zz2(1);
  complex* zp1 = new complex (1,0);
  complex* zp1 = new complex (1);

     Объекты класса могут также инициализироваться с  помощью
явного использования операции =. Например:

  complex zz3 = complex (1,0);
  complex zz4 = complex (1);
  complex zz5 = 1;
  complex zz6 = zz3;

     Если есть конструктор, получающий ссылку на объект свое-
го собственного класса,  то он будет вызываться при инициали-
зации объекта другим объектом этого класса, но не при инициа-
лизации объекта конструктором.

     Объект может  быть  членом составного объекта только (1)
если класс объекта не имеет конструктора,  или (2)  если  его
конструкторы не имеют параметров, или (3) если составной объ-
ект является классом с конструктором,  который задает  список
инициализации члена (см. #10). В случае 2 конструктор вызыва-
ется при создании составного объекта.  Если составной  объект
является классом   (но не тогда,  когда он является вектором)
для вызова конструктора  могут  использоваться  параметры  по
умолчанию. Если член составного объекта является членом клас-
са с деструкторами, то этот деструктор вызывается при уничто-
жении составного объекта.

     Конструкторы для  нелокальных статических объектов вызы-
ваются в  порядке  их  появления  в  файле;  деструкторы  для
вызываются в обратном порядке.  Вызывается ли конструктор или
деструктор для локального статического объекта в случае  если
функция, в которой объект описан, не вызывается, не определе-
но. Если  конструктор для локального статического объекта вы-
зывается, то он вызывается после конструкторов для глобальных
объектов, лексически  ему предшествующих. Если для локального
статического объекта вызывается деструктор,  то он вызывается
до деструкторов для глобальных объектов, лексически ему пред-
шествующих.

                        8.6.3 Ссылки

     Когда переменная описана как T&,  то есть "ссылка на тип
T", она должна быть инициализирована или объектом типа T, или
объектом объектом, который может быть преобразован в T. Ссыл-
ка становится другим именем объекта. Например:

  int i;
  int& r = i;
  r = 1; // значение i становится 1
  int* p = &r; // p указывает на i

     Значение ссылки не может быть изменено после инициализа-
ции. Заметьте, что обработка инициализации ссылки очень силь-
но зависит от того, что ей присваивается.
     Если инициализатор  для  ссылки  на  тип  T  не является
lvalue, то  будет создан и инициализован инициализатором объ-
ект типа   T.   Тогда ссылка станет именем для этого объекта.
Время жизни объекта, созданного таким способом, будет область
видимости, в которой он создан. Например:

                                    - 247 -
  double& rr = 1;

     допустимо, и  rr  будет указывать на объект типа double,
содержащий значение 1.0.

     Заметьте, что ссылка на класс B может быть инициализиро-
вана объектом  класса D при условии,  что B является открытым
базовым классом класса D (в этом случае D есть B).

     Ссылки особенно полезны  в  качестве  типов  параметров.
Например:

  struct B (* ... *);
  struct D : B (* ... *);
  int f(B&);
  D a;
  f(a);

                   8.6.4 Массивы Символов

     Массив char  можно инициализировать строкой.  Последова-
тельные символы строки инициализируют члены массива.   Напри-
мер:

  char msg[] = "Syntax error on line %d\n";

     демонстрирует массив символов,  члены которого инициали-
зированы строкой. Обратите внимание, что sizeof(msg)==25.

                       8.7 Имена Типов

     Иногда (для неявного задания преобразования  типов  и  в
качестве параметра sizeof или new) нужно использовать имя ти-
па данных. Это выполняется при помощи "имени типа" которое по
сути является   описанием  для объекта этого типа,  в котором
опущено имя объекта.

  имя_типа:
      спецификатор_типа абстрактный_описатель

  абстрактный_описатель:
      пустой
      * абстрактный_описатель
      абстрактный_описатель ( списоко_писателей_параметров)
      абстрактный_описатель [ константное_выражение opt ]
      ( абстрактный_описатель )

     Возможно единственным образом идентифицировать положение
в абстрактном_описателе,    где должен стоять идентификатор в
случае, если бы конструкция была описателем в описании. Тогда
именованный тип является - тот же,  что и тип гипотетического
идентификатора. Например,

  int
  int *
  int *[3]
  int (*)[3]
  int *()
  int (*)()

     именуют, соответсвенно,  типы "целое", "указатель на це-
лое", "массив из 3 указателей на целые", "указатель на массив
из 3   целых",  "функция,  возвращающая указатель на целое" и
"указатель на функцию, возвращающую целое".
               8.8 Typedef - Определение Типа

     Описания, содержащие спецификатор_описания typedef,  оп-

                                    - 248 -
ределяют идентификаторы,  которы позднее могут использоваться
так, как  если бы они были ключевыми словами,  именующими ос-
новные или производные типы.


  typedef-имя:
      идентификатор


     Внутри области видимости описания,  содержащего typedef,
каждый идентификатор,  возникающий как часть какого-либо опи-
сателя, становится  в этом месте синтаксически  эквивалентным
ключевому слову типа,  которое именует тип, ассоциированный с
идентификатором таким обрахом, как описывается в #8.4. Специ-
фикатор_описания typedef   не  может использоваться для члена
класса. Имя    класса   или   перечисления   также   является
typedef-именем. Например, после


  typedef int MILES, *KLICKSP;
  struct complex (* double re, im; *);


каждая из конструкций


  MILES distance;
  extern KLICKSP metricp;
  complex z, *zp;


     является допустимым описанием; distance имеет  тип  int,
metricp имеет тип "указатель на int".


     typedef вводит не новые типы, но только синонимы для ти-
пов, которые  могли бы быть определены другим путем.   Так  в
приведенном выше примере distance рассматривается как имеющая
в точности тот же тип, что и любой другой int объект.


  Но описание класса вводит новый тип. Например:


  struct X (* int a; *);
  struct Y (* int a; *);
  X a1;
  Y a2;
  int a3;


описывает три переменных трех различных типов.

  Описание вида


  описание_имени:
      сост идентификатор ;
      enum идентификатор ;


     специфицирует, что идентификатор является именем некото-
рого (возможно,  еще не определенного)  класса или перечисле-
ния. Такие  описания позволяют описывать классы,  ссылающихся
друг на друга. Например:

  class vector;

                                    - 249 -
  class matrix (*
      // ...
      friend vector operator*(matrix&, vector&);
  *);


  class vector (*
      // ...
      friend matrix operator*(matrix&, vector&);
  *);


               8.9 Перегруженные Имена Функций


     В тех  случаях,   когда для одного имени определено нес-
колько (различных)  описаний функций,  это имя называется пе-
регруженным. При использовании этого имени правильная функция
выбирается с помощью сравнения типов фактических параметров с
типами формальных параметров в описаниях функций.


     Поиск того,  какую функцию вызвать, осуществляется в три
отдельных шага:


     Искать точно соответствующую и использовать, если найде-
на.


     Искать соответствующую с использованием стандартных пре-
образований (#6.6-8) и использовать любую найденную.


     Искать соответствующую  с  использованием   определенных
пользователем преобразований   (#6.5.6).  Если найдено единс-
твенное множество преобразований, использовать ее.


     Ноль, char или short  считаются  точно  соответствующими
формальному параметру  типа int.  Float считаются точно соот-
ветствующими формальному параметру типа double.


     Над параметром перегруженной функции выполняются  только
следующе преобразования:  int в long, int в double и преобра-
зования указателей и ссылок (#6.7-8).

     Для того,  чтобы перегрузить имя функции не члена  и  не
функции operator,  любому описанию функции должно предшество-
вать описание overload, см. #8.1. Например:


  overload abs;
  double abs(double);
  int abs(int);


  abs(1); // вызывается abs(int);
  abs(1.0); // вызывается abs(double);


  Например:


  class X (* ... X (int); *);
  class Y (* ... Y (int); *);

                                    - 250 -
  class Z (* ... Z (char*); *);


  overload int f (X), f (Y);
  overload int g (X), g (Z);


  f (1); // недопустимо: f(X(1)) или f(Y(1))
  g (1); // g(X(1))
  g ("asdf"); // g(Z("asdf"))


     Операция взятия адреса & может применяться к перегружен-
ному имени   только  в присваивании или инициализации,  когда
ожидаемый тип определяет,  адрес какой функции брать.  Напри-
мер:


  int operator=(matrix&, matrix&);
  int operator=(vector&, vector&);
  int (*pfm)(matrix&, matrix&) = &operator=;
  int (*pfv)(vector&, vector&) = &operator=;
  int (*pfx)(...) = &operator=;


                 8.10 Описания Перечислений


     Перечисления являются типами int с именованными констан-
тами.


  enum_спецификатор:
      enum идентификатор opt (* enum_список *)


  enum_список:
      перечислитель
      enum_список , перечислитель


  перечислитель:
      идентификатор
      идентификатор = константное_выражение


     Идентификаторы в enum-списке описаны как константы и мо-
гут появляться во всех местах,  где требуются константы. Если
не появляется ни одного перечислителя с =,  то значения соот-
ветствующих констант начинаются с 0 и возрастают на 1 по мере
чтения описания слева нарпаво. Перечислитель с = дает ассоци-
ированному с ним идентификатору указанное значение; последую-
щие идентификаторы продолжают прогрессию от присвоенного зна-
чения.

     Имена перечислителей  должны  быть  отличными  от   имен
обычных переменных. Имена перечислителей с разными константа-
ми тоже должны быть различны. Значения перечислителей не обя-
зательно должны быть различными.

     Роль идентификатора    в    спецификаторе   перечисления
enum_спецификатор полностью аналогична роли имени класса;  он
именует определенный нутератор. Например:


  enum color (* red, yellow, green=20, blue *);
    color col = red;

                                    - 251 -
    color *cp = &col;
    if (*cp == blue) // ...


     делает color именем типа,  описывающего различные цвета,
и затем описывает col как объект этого типа,  а cp как указа-
тель на объект этого типа.  Возможные значения лежат во  мно-
жестве (* 0, 1, 20, 21 *).


                      8.11 Описание Asm


  Описание Asm имеет вид


    asm ( строка );


     Смысл описания asm неопределен.  Обычно оно используется
для передачи информации ассемблеру через компилятор.

                        9. Операторы

     Операторы выполняются последовательно  во  всех  случаях
кроме особо оговоренных.


                   9.1 Оператор Выражение


     Большинство операторов  является  операторами выражение,
которые имеют вид


  выражение ;


     Обычно операторы выражение являются присваиваниями и вы-
зовами функций.


              9.2 Составной Оператор, или Блок


     Составной оператор (называемый также "блок", что эквива-
лентно) дает  возможность использовать несколько операторов в
том месте, где предполагается использование одного:


  составной_оператор:
      (* список_операторов opt *)

  список_операторов:
      оператор
      оператор список_операторов

     Обратите внимание,  что описание - это вариант оператора
(#9.14).


                    9.3 Условный Оператор

     Есть два вида условных операторов

  if ( выражение ) оператор
  if ( выражение ) оператор else оператор

                                    - 252 -


     Выражение должно быть арифметического или  указательного
типа или классового типа,  для которого определено преобразо-
вание в арифметический или указательный тип (см. #8.5.6). Вы-
числяется выражение,  и если оно не ноль, то выполняется пер-
вый подоператор.    Если  используется  "else",   то   второй
подоператор выполняется,  если выражение есть 0.  Как обычно,
неоднозначность "else" разрешается посредством того, что else
связывается с последним встречнным if, не имеющим else.


                     9.4 Оператор While


     Оператор while имеет вид


  while ( выражение ) оператор


     Выполнение подоператора повторяется, пока значение выра-
жения остается ненулевым.  Проверка выполняется перед  каждым
выполнением оператора.  Выражение обрабатывается как в услов-
ном операторе (#9.3).


                       9.5 Оператор Do


     Оператор do имеет вид


  do оператор while ( выражение ) ;


     Выполнение подоператора повторяется до  тех  пор,   пока
значение остается не нулем. Проверка выполняется после каждо-
го выполнения оператора.  Выражение обрабатывается как в  ус-
ловном операторе (#9.3).

                      9.6 Оператор For


     Оператор for имеет вид


 for (оператор_1 выражение_1 opt; выражение_2 opt) оператор_2

     Этот оператор эквивалентен следующему:


  оператор_1
  while ( выражение_1 ) (*
      оператор_2
      выражение_2 ;
  *)


     за исключением  того,   что continue в операторе_2 будет
выполнять выражение_2 перед выполнением выражения_1.   Первый
оператор, таким  образом,  задает инициализацию цикла; первое
выражение задает выполняемую перед каждой итерацией проверку,
по которой производится выход из цикла, если выражение стано-
вится нулем; второе выражение часто задает приращение, выпол-
няемое после каждой итерации.


                                    - 253 -
     Каждое или оба выражения могут быть опущены.  Отсутствие
выражения_1 делает подразумеваемое while-предложение  эквива-
лентым while(1).  Заметьте, что если оператор_2 является опи-
санием, то область видимости описанного имени распространяеи-
ся до конца блока, охватывающего оператор for.


                     9.7 Оператор Switch


     Оператор switch  вызывает передачу управления на один из
нескольких операторов в зависимости от значения выражения. Он
имеет вид


  switch ( выражение ) оператор


     Выражение должно  быть  арифметичского или указательного
типа. Любой  оператор внутри оператора может быть помечен од-
ной или более меток case следующим образом:


  case константное_выражение :


     где константное  выражение должно иметь тот же тип что и
выражение-переключатель; производятся обычные  арифметические
преобразования. В одном операторе switch никакие две констан-
ты, помеченные  case,  не могут  иметь  одинаковое  значение.
Константные выражения определяются в #12.


     Также может быть не более чем одна метка вида


  default :

     Когда выполнен оператор switch, проведено вычисление его
выражения и сравнение его с каждой case константой. Если одна
из констант равна значению выражения, то управление передает-
ся на выражение,  следующее за подошедшей меткой case.   Если
никакая case   константа  не соответствует выражению,  и есть
метка default, то управление передается на выражение, которо-
му она предшествует. Если нет соответсвующих вариантов case и
default отсутствует,  то никакой из  операторов  в  операторе
switch не выполняется.

     Метки case  и default сами по себе не изменяют поток уп-
равления, который после задерки идет дальше, перескакивая че-
рез эти метки. Для выхода из switch см. break, #9.8.

     Обычно зависящий  от switch оператор является составным.
В голове этого оператора могут стоять описания,  но инициали-
зации автоматических и регистровых переменных являются безре-
зультатными.


                     9.8 Оператор Break

     Оператор


  break ;

     вызывает завершение выполнения наименьшего охватывающего
оператора while, do, for или switch; управление передается на

                                    - 254 -
оператор, следующий за завершенным.


                    9.9 Оператор Continue


     Оператор


  continue ;


     вызывает передачу управления на управляющую продолжением
цикла часть наименьшего охватывающего оператора while, do или
for; то есть на конец петли цикла. Точнее, в каждом из опера-
торов


  while (...) (* do (* for (...) (*
    ... ... ...
  contin: ; contin: ; contin: ;
  *) *) while (...); *)


     continue эквивалентно goto contin. (За contin: идет пус-
той оператор, #9.13.)


                    9.10 Оператор Return


     Возврат из функции в вызывающеую программу осуществляет-
ся с помощью оператора return, имеющего один из двух видов:

  return ;
  return выражение ;


     Первый может   использоваться  только  в  функциях,   не
возвращающих значения,  т.е. в функциях с типом возвращаемого
значения void.    Вторая  форма может использоваться только в
функциях, возвращающих значение; значение выражения возвраща-
ется тому, кто вызывал функцию. Если необходимо, то выражение
преобразуется, как  это делается при инициализации,   к  типу
функции, в которой оно появилось. Обход конца функции эквива-
лентен возврату return без возвращаемого значения.


                     9.11 Оператор Goto

     Можно осуществлять безусловную передачу упраления с  по-
мощью оператора

   goto идентификатор ;


     Идентификатор должен быть меткой (#9.12),  расположенной
в текущей функции.  Невозможно передать  управление  в  обход
описания с инициализатором (явным или неявным)  никак,  кроме
передачи управления в обход внутреннего блока  без  захода  в
него.

                  9.12 Помеченные Операторы

     Перед любым оператором может стоять метка, имеющий вид



                                    - 255 -
  идентификатор :


     которая служит  для  описания  идентификатора как метки.
Метка используется только как объект перехода для goto.   Об-
ластью видимости метки является текущая функция, исключая лю-
бой подблок,  в котором был переописан этот же идентификатор.
См. #4.1.


                    9.13 Пустой Оператор


     Пустой оператор имеет вид


  ;


     Пустой оператор  используется для помещения метки непос-
редственно перед *) составного оператора или того, чтобы
снабдить такие операторы, как while, пустым телом.


                   9.14 Оператор Описание


     Оператор описание используется для введения нового иден-
тификатора в блоке; он имеет вид


  Оператор_описание:
      описание


     Если введенный  описанием идентификатор был описан ранее
во внешнем блоке, внешнее описание становится скрытым на про-
тяжении блока, после чего оно вновь всупает в силу.

     Каждая инициализация auto и register переменных произво-
дится каждый раз,  когда  выполняется  их  оператор_описание.
Можно передавать управление в блок,  но не таким путем, кото-
рый приводит к невыполнению инициализаций, см. #9.11. Инициа-
лизации переменных  класса памяти static (#4.4)  производятся
только один раз, когда программа начинает выполняться.
                   10. Определения Функций

     Программа состоит из последовательности  описаний.   Код
(текст программы)    функции может быть задан только вне всех
блоков и внутри описаний классов.  Определения функций  имеют
вид


  определение_функции:
      спецификаторы_описания opt описатель_функции
  инициализатор_базового opt тело_функции


     Спецификаторы_описания register,  auto, typedef не могут
использоваться внутри описания класса  (#8.5),   а  friend  и
virtual могут использоваться только там.  Описатель функции -
это описатель "функции,  возвращающей ..."  (#8.4).Формальные
параметры находятся в области видимости самого внешнего блока
тела_функции. Описатели функции имеют вид


  описатель_функции:

                                    - 256 -
      описатель ( список_описаний_параметров )


     Если параметр специфицирован как register,  то соответс-
твующий фактический параметр будет по возможности копировать-
ся в регистр на входе в функцию.  Если для параметра специфи-
цировано константное выражение в качестве инициализатора,  то
это значение   используется как значение параметра по умолча-
нию.


  Тело функции имеет вид


  тело_функции:
      составной_оператор


  Вот простой пример полного определения функции:


  int max(int a, int b, int c)
  (*
      int m = (a < b) ? a : b;
      return (m > c) ? m : c;
  *)

     Здесь int - это спецификатор_типа; max(int a, int b, int
c) - это описатель_функции; (* ... *) - это тело_функции.


     Поскольку в контексте выражения имя моссива  (в  особен-
ности, как фактического параметра) принимается как означающее
указатель на первый элемент массива,  описания формальных па-
раметров, которые описаны как "массив из ...", корректируются
так, чтобы читались как "указатель на ...".

     В определении конструктора могут быть заданы инициализа-
торы для   базового класса и для членов.  Это главным образом
полезно для объектов класса, констант и ссылок, где семантика
инициализации и присваивания различаются. Инициализатор_базо-
вого имеет вид


  инициализатор_базового:
      : список_инициализаторов_членов


  список_инициализаторов_членов:
      инициализатор_члена
      инициализатор_члена , список_инициализаторов_членов


  инициализатор_члена:
      идентификатор opt ( список_параметров opt )

     Если в инициализаторе_члена дан идентификатор, то список
параметров используется   для инициализации названного члена;
если нет,  то список  параметров  используется  для  базового
класса. Например:

  struct base (* base(int); ... *);

  struct derived : base (*
      derived(int);
      base b;
      const c;

                                    - 257 -
  *);


  derived::derived(int a) : (a+1), b(a+2), c(a+3)
  (* /* ... */ *)


  derived d(10);


     Сначала конструктор базового класса вызывается для  объ-
екта d с параметром 11, затем вызывается конструктор для чле-
на b с параметром 12 и конструктор для члена c  с  параметром
13. Затем  выполняется тело derived::derived()  (см. #8.5.5).
Порядок, в котором вызываются конструкторы для членов, не ус-
тановлен. Если базовый класс имеет конструктор, который можно
вызывать без параметров,  не надо давать никакой список пара-
метров. Если класс члена имеет конструктор, который можно вы-
зывать без параметров, для этого члена не надо давать никакой
список параметров.

              11. Командные Строки Компилятора

     Компилятор содержит препроцессор,   способный  выполнять
макроподстановки, условную компиляцию и включение именованных
файлов. Строки,  начинающиеся с #, относятся к препроцессору.
Эти строки   имеют независимый от остального языка синтаксис;
они могут появляться в любом месте и оказывать влияние, кото-
рое распространяется   (независимо  от области видимости)  до
конца файла исходной программы.

     Учтите, что определения const и inline дают альтернативы
для большинства использований #define.

                     11.1 Замена Лексем


     Командная строка компилятора вида


  #define идентификатор строка_лексем
     вызывает замену   препроцессором  последующих  вхождений
идентификатора, заданного  строкой символов.  Точка с запятой
внутри (или   в  конце)  строки символов является частью этой
строки.


  Строка вида


  #define идентификатор( идентификатор , ... , идентификатор)
  строка_лексем

     где нет пробела между первым идентификатором и (,  явля-
ется макроопределением с параметрами.  Последующие  вхождения
первого идентификатора   с  идущими за ним (,  последователь-
ностью символов,  разграниченной запятыми,  и ),   заменяются
строкой символов, заданной в определении. Каждое местоположе-
ние идентификатора, замеченного в списке параметров определе-
ния, заменяется  соответствующей строкой из вызова. Фактичес-
кими параметрами вызова являются строки символов, разделенные
запятыми; однако запятые в строке, заключенной в кавычки, или
в круглых скобках не являются разделителями параметров. Число
формальных и фактических параметров должно совпадать.  Строки
и символьные константы в символьной строке сканируются в  по-
исках формальных параметров, но строки и символьные константы
в остальной программе не сканируются в  поисках  определенных

                                    - 258 -
(с помощью define) идентификаторов.


     В обоих  случаях  строка замещения еще раз сканируется в
поисках других определнных идентификаторов.  В обоих  случаях
длинное определение  может быть продолжено на другой строке с
помощью записи \ в конце продолжаемой строки.


  Командная строка вида


  #undef идентификатор


     влечет отмену препроцессорного определения идентификато-
ра.


                    11.2 Включение Файлов


     Командная строка компилятора вида


  #include "имя_файла"

     вызывает замену этой строки полным содержимым файла имя_
файла. Сначала  именованный файл ищется в директории первона-
чального исходного файла,  а затем в стандартных или заданных
местах. Альтернативный вариант, командная строка вида


   #include <имя_файла>


     производит поиск только в стандартном или заданном  мес-
те, и не ищет в директории исходного файла. (То, как эти мес-
та задаются, не является частью языка.)
     Включения с помощью #include могут быть вложенными.


                  11.3 Условная Компиляция


     Командная строка компилятора вида

  #if выражение


     проверяет, является ли результатом вычисления  выражения
не-ноль. Выражение  должно быть константным выражением, кото-
рые обсуждаются в #12.  Кроме обычных операций С++ может  ис-
пользоваться унарная операция defined. При применении к иден-
тификатору она дает значение не-ноль, если этот идентификатор
был ранее   определен с помощью #define и после этого не было
отмены определения с помощью #undef; иначе ее значение 0.
     Командная строка вида

  #ifdef идентификатор


     проверяет, определен  ли идентификатор в препроцессоре в
данный момент; то есть, был ли он объектом командной строки #
define. Командная строка вида



                                    - 259 -
  #ifndef идентификатор


     проверяет, является  ли  идентификатор  неопределенным в
препроцессоре в данный момент.


     После каждого из трех видов  может  стоять  произвольное
количество строк, возможно, содержащих командную строку


  #else


     и далее до командной строки


  #endif


     Если проверенное  условие  истинно,  то все строки между
#else и #endif игнорируются.  Если проверенное условие ложно,
то все  строки между проверкой и #else или,  в случае отсутс-
твия #else, #endif, игнорируются.

     Эти конструкции могут быть вложенными.


                   11.4 Управление Строкой


     Для помощи другим препроцессорам, генерирующим программы
на С++, строка вида


  #line константа "имя_файла"

     заставляет компилятор считать,  например,  в целях диаг-
ностики ошибок,  что константа задает номер  следущей  строки
исходного файла, и текущий входной файл именуется идентифика-
тором. Если  идентификатор отсутствует,  то  запомненное  имя
файла не изменяется.

                  12. Константные Выражения

     В нескольких местах С++ требует  выражения,   вычисление
которых дает константу:  в качестве границ массива (#8.4),  в
case выражениях (#9.7),  в качестве значений параметров функ-
ции по умолчанию (#8.3), и в инициализаторах (#8.6). В первом
случае выражение может включать только целые константы,  сим-
вольные константы, константы перечислений, значения несостав-
ных const,  инициализированных константными  выражениями,   и
sizeof выражения, возможно, связанные бинарными операциями


  + - * / % & ! ^ <<
  >> == != < > <= >= && !!

или унарными операциями


  + - ~ !

или тернарной операцией


  ?:

                                    - 260 -


     Скобки могут использоваться для группирования, но не для
вызова функций.


     Во всех  остальных  случаях  константное выражение может
также содержать унарную операцию &, примененную к внешним или
статическим объектам, или к внешним или статическим массивам,
индексированным константным выражением.  Унарная  операция  &
может также  быть применена неявно с помощью употребления не-
индексированных массивов и функций.  Основное правило состоит
в том,  что инициализаторы должны при вычислении давать конс-
танту или адрес ранее описанного  внешнего  или  статического
обйекта плюс или минус константа.

     Меньшая широта допустима для константных выражений после
#if: недопустимы  имена,  описанные const, sizeof выражения и
перечислимые константы.

                 13. Соображения Мобильности

     Определенные части С++ являются  машинно  зависимыми  по
своей сути.  Следующий ниже список мест возможных затруднений
не претендует на полноту,  но может указать  на  основные  из
них.


     Как показала практика,  характеристики аппаратуры в чис-
том виде, такие, как размер слова, свойства плавающей арифме-
тики и целого деления,  не создают особых проблем. Другие ап-
паратные аспекты    отражаются   на   различных   программных
разработках. Некоторые  из них,  особенно знаковое расширение
(преобразование отрицательного символа в отрицательное целое)
и порядок расположения байтов в слове, являются досадными по-
мехами, за  которыми надо тщательно следить.  Большинство ос-
тальных являются всего лишь мелкими сложностями.


     Число регистровых  переменных,  которые фактически могут
быть помещены в регистры, различается от машины к машине, как
и множество дейсвующих типов.  Тем не менее,  все компиляторы
на "своей" машине все делают правильно;  избыточные  или  не-
действующие описания register игнорируются.


     В языке  неопределен порядок вычисления параметров функ-
ции. На  некоторых машинах он слева направо,  а на  остальных
справа налево.  Порядок появления побочных эффектов также не-
детерминирован.


     Поскольку символьные константы в действительности  явля-
ются объектами   типа int,  то могут быть допустимы многосим-
вольные константы.  Однако конкретная реализация очень сильно
зависит от машины, поскольку порядок, в котором символы прис-
ваиваются слову, различается от машины к машине.

              14. Краткое Изложение Синтаксиса

     Эта краткая сводка синтаксиса С++ предназначается, чтобы
способствовать пониманию.  Она не является точной формулиров-
кой языка.


                       14.1 Выражения


                                    - 261 -

  выражение:
      терм
      выражение бинарная_операция выражение
      выражение ? выражение : выражение
      список_выражений


  список_выражений:
      выражение
      список_выражений , выражение


  терм:
      первичное_выражение
      унарная_операция терм
      терм ++
      терм --
      sizeof выражение
      sizeof ( имя_типа )
      ( имя_типа) выражение
      простое_имя_типа ( список_выражений )
      new имя_типа инициализатор opt
      new ( имя_типа )
      delete выражение
      delete [ выражение ] выражение


  первичное_выражение:
      id
      :: идентификатор
      константа
      строка
      this
      ( выражение )
      первичное_выражение[ выражение ]
      первичное_выражение ( список_выражений opt )
      первичное_выражение.id
      первичное_выражение->id


  id:
      идентификатор
      typedef-имя :: идентификатор
      typedef-имя :: имя_функции_операции


  операция:
      унарная_операция
      бинарная_операция
      специальная_операция
      операция_свободной_памяти


     Бинарные операции имеют приоритет, убывающий в указанном
порядке:






  бинарная_операция: одна из
      * / %
      + -
      << >>
      < >

                                    - 262 -
      == !=
      &
      ^
      !
      &&
      !!
      операция_присваивания


  операция_присваивания: одна из
      = += -= *= /= %= ^= &= != >>= <<=


   унарная_операция: одна из
       * & + - ~ ! ++ --


  специальная_операция: одна из
      () []

  операция_свободной_памяти: одна из
      new delete


  имя_типа:
      спецификаторы_описания абстрактный_описатель


  абстрактный_описатель:
      пустой
      * абстрактный_описатель
      абстрактный_описатель ( список_описаний_параметров )
      абстрактный_описатель [ константное_выражение opt ]

 
  простое_имя_типа:
      typedef-имя
      char
      short
      int
      long
      unsigned
      float
      double
      void




  typedef-имя:
      идентификатор


                        14.2 Описания

  описание:
      спецификаторы_описания opt список_описателей opt ;
      описание_имени
      asm-описание


  описание_имени:
      сост идентификатор ;
      enum идентификатор ;


  сост:

                                    - 263 -
      class
      struct
      union


  asm-описание:
      asm ( строка ) ;


  спецификаторы_описания:
      спецификатор_описания спецификаторы_описания opt


  спецификатор_описания:
      спецификатор_класса_памяти
      спецификатор_типа
      спецификатор_функции
      typedef
      friend

  спецификатор_типа:
      простое_имя_типа
      спецификатор_класса
      спецификатор_enum
      усложненный_спецификатор_типа
      const


  спецификатор_класса_памяти:
      auto
      extern
      register
      static


  спецификатор_функции:
      inline
      overload
      virtual


  усложненный_спецификатор_типа:
      ключ typedef-имя
      ключ идентификатор


  ключ:
      class
      struct
      union
      enum


  список_описателей:
      иниц-описатель
      иниц-описатель , список_описателей


  иниц-описатель:
      описатель инициализатор opt


  описатель:
      оп_имя
      ( описатель )
      * const opt описатель
      & const opt описатель

                                    - 264 -
      описатель ( список_описаний_параметров )
      описатель [ константное_выражение opt ]


  оп_имя:
      простое_оп_имя
      typedef-имя :: простое_оп_имя

  простое_оп_имя:
      идентификатор
      typedef-имя
      ~ typedef-имя
      имя_функции_операции
      имя_функции_преобразования


  имя_функции_операции:
      operator операция

  имя_функции_преобразования
      operator тип


  список_описаний_параметров:
      список_описаний_прм opt ... opt

  список_описаний_прм:
      список_описаний_прм , описание_параметра
      описание_параметра


  описание_параметра:
     спецификаторы_описания описатель = выражение
     спецификаторы_описания описатель = константное_выражение
     спецификаторы_описания абстракт_описатель = выражение
     спецификаторы_описания абстракт_описатель = выражение

  спецификатор_класса:
      заголовок_класса (* список_членов opt *)
      заголовок_класса (* список_членов opt public :
                         список_членов opt *)

  заголовок_класса:
      сост идентификатор opt
      сост идентификатор opt : public opt typedef-имя


  список_членов:
      описание_члена список_членов opt

  описание_члена:
      спецификаторы_описания opt описатель_члена
            инициализатор opt ;
      определение_функции opt


  описатель_члена:
      описатель
      идентификатор opt : константное_выражение


  инициализатор:
      = выражение
      = (* список_инициализаторов *)
      = (* список_инициализаторов , *)
      ( список_выражений )


                                    - 265 -

  список_инициализаторов:
      выражение
      список_инициализаторов , список_инициализаторов
      (* список_инициализаторов *)


  спецификатор_enum:
      enum идентификатор opt (* enum-список *)


  enum-список:
      перечислитель
      enum-список , перечислитель


  перечислитель:
      идентификатор
      идентификатор = константное_выражение


                       14.3 Операторы


  составной_оператор:
      (* список_операторов opt *)


  список_операторов:
      оператор
      оператор список_операторов


  оператор:
      описание
      составной_оператор
      выражение opt ;
      if ( выражение ) оператор
      if ( выражение ) оператор else оператор
      while ( выражение ) оператор
      do оператор while ( выражение ) ;
      for ( оператор выражение opt ; выражение opt ) оператор
      switch ( выражение ) оператор
      case константное_выражение : оператор
      default : оператор
      break ;
      continue ;
      return выражение opt ;
      goto идентификатор ;
      идентификатор : оператор


                  14.4 Внешние определения

  программа:
      внешнее_определение
      внешнее_определение программа


  внешнее_определение:
      определение_функции
      описание


  определение_функции:
      спецификаторы_описания opt описатель_функции
  инициализатор_базового opt тело_функции

                                    - 266 -

  описатель_функции:
      описатель ( список_описаний_параметров )


  тело_функции:
      составной_оператор


  инициализатор_базового:
      : ( список_инициализаторов_членов opt )

     14.5 Препроцессор


  #define идентификатор строка_лексем


  #define идентификатор( идентификатор,...,идентификатор )
           строка лексем
  #else
  #endif
  #if выражение
  #ifdef идентификатор
  #ifndef идентификатор
  #include "имя_файла"
  #include <имя_файла>
  #line константа "имя_файла"
  #undef идентификатор

                      15. Отличия от C

                       15.1 Расширения

     Типы параметров функции могут быть заданы (#8.4) и будут
проверяться (#7.1). Могут выполняться преобразования типов (#
7.1).


     Для выражений с числами с плавающей точкой может исполь-
зоваться плавающая арифметика одинарной точности; #6.2.


     Имена функций могут быть перегружены; #8.9.


     Операции могут быть перегружены; 7.16, #8.5.11.

     Функции могут быть inline-подставляемыми; #8.1.


     Объекты данных могут быть константными (const); #8.3.

     Могут быть описаны объекты ссылочного типа; #8.4, #8.6.3


     Операции new и delete обеспечивают свободное хранение  в
памяти, #7.2.


     Классы могут обеспечивать сокрытие данных (#8.5.9),  га-
рантированную инициализацию (#8.6.2),  определяемые пользова-
телем преобразвания   (#8.5.6),  и динамическое типизирование
через использование виртуальных функций (#8.5.4).

     Имя класса или перечисления является именем типа;  #8.5.


                                    - 267 -

     Любой указатель может присваиваться void* без  применеия
приведения к типу; #7.14.


     Описание внутри блока является оператором; #9.14.


     Можно описывать безымянные объединения; #8.5.13.

                15.2 Сводка Несовместимостей


     Большинство конструкций  C допустимы в С++ без изменения
их смысла. Исключения из этого следующие:


     Программы, использующие одно из новых ключевых слов

  class const delete friend inline
  new operator overload public signed
  this virtual volatile


     как идентификаторы, недопустимы.


     Описание функции f(); означает,  что f не получает пара-
метров, в  C же это значит, что f может получать параметр со-
вершенно любого типа.

     В C внешнее имя может определяться несколько раз, а в С+
+ оно должно быть определено ровно один раз.


     Имена классов в С++ находятся в том же пространстве, что
и прочие имена, поэтому конструкции вроде

  int s;
  struct s (* /* ... */ *);
  f() (* s = 1; *)


     использоваться не могут.  Однако,  для разрешения  боль-
шинства конфликтов   может  применяться  явное  использование
class, struct, union, enum (#8.2) или :: (#7.1). Например:


  int s;
  struct s (* /* ... */ *);
  void f() (*int s; struct s a; *)
  void g() (* ::s = 1; *)


                      15.3 Анахронизмы


     Изложенные здесь  расширения  могут  предоставляться для
того, чтобы  упростить использование C программ как С++ прог-
рамм. Обратите  внимание, что каждая из этих возможностей со-
держит нежелательные аспекты.  Предоставляющая их  реализация
должна также обеспечивать пользователю способ удостовериться,
что они не встречаются в исходном файле.


     Прежнее неопределенное имя может использоваться как  имя
функции в вызове.  В этом случае имя будет неявно описано как

                                    - 268 -
функция, возвращающая int с типом параметра (...).


     Ключевое слово void может  использоваться  для  указания
того, что  функция не получает параметров, так что (void) эк-
вивалентно ().


     Могут использоваться программы,  в которых  используется
синтаксис определения функций в C


  старое_определение_функции:
      спецификаторы_описания opt старый_описатель_функции
  список_описателей тело_функции

  старый_описатель_функции:
      описатель (* список_параметров *)


  список_параметров:
      идентификатор
      идентификатор , идентификатор


например,


  max(a,b) (* return (a<b) ? b : a; *)


     Если функция, описанная как эта, была ранее описана, тип
ее параметра будет принят (...), то есть, непроверенный. Если
она была описана,  ее тип должен согласоваться с типом описа-
ния.

     Вместо ::   может  использоваться точка для спецификации
имени в определении функции члена. Например:

  int cl.fct() (* /* ... */ *)


     Одно и то же имя может быть описано одновременно  и  для
класса или  перечисления,  и для объекта данных или функции в
одной и той же области видимости.
