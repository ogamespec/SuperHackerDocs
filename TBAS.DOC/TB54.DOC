 
                             Функции ERDEV,ERDEV$
                             --------------------

      Функция    ERDEV,ERDEV$        возвращают информацию о приводном
      -------                        устройстве.

      Синтаксис  y=ERDEV
      ---------  y=ERDEV$

      Замечания        Когда возникает ошибка устройства, целая функция
      ---------        ERDEV  возвращает  информацию  об ошибке в своем
      младшем  байте.  Этот байт представляет код ошибки INT24. Старший
      байт   содержит   биты   15,14,13,3,2,1  и  0  атрибутного  слова
      устройства. ERDEV$ содержит имя устройства: 8 байтов для литерных
      устройств  и  2  -  для  блочных  устройств. (См. более детальную
      информацию в техническом справочном руководстве по IBM DOS). 

      Пример:
             ON ERROR GOTO ОшибокОбработчик
             PRINT "Открыть путь на устройство А и нажать любую
                   клавишу..."
             WHILE NOT INSTAT:WEND
             FILES "A:\"." "
             END
             ОбработчикОшибок:
             PRINT USING "Угрожающая ошибка ## имела место
                         на & ":ERDEV,ERDEV$
             RESUME NEXT

                               Функции ERL,ERR
                               ---------------

      Функция    ERL И ERR     возврашают строку и код самой последней
      -------                  ошибки.

      Синтаксис  y=ERL
      ---------  y=ERR

      Замечания        ERL  возврашает  номер  строки  самой  последней
      ---------        ошибки.  Если  ошибка  произошла в операторе без
      номера строки, ERL возвращает номер ближайшей нумерованной строки
      в  направлении  к  началу  программы.  Если между точкой ошибки и
      началом  программы  нумерованных строк нет, ERL возвращает 0. ERR
      возвращает   номер   самой   последней  ошибки  периода  прогона.
      Тестируйте   ее  в  подпрограммах  отслеживания  ошибок  с  целью
      исполнения кода, подходящего для произошедшей ошибки по типу.
            Примечание:  Операторы  ERL RESUME и RESUME NEXT приводят к
      генерированию  компилятором  4-байтового  указателя  для  каждого
      оператора в программе. Следовательно программисты, имеющие дело с
      размером   генерируемых   ими  кодов,  должны  принимать  это  во
      внимание.   При   использовании   RESUME  [строка#]  генерируется
      единственная  инструкция  перехода.  ERL  обычно  используется  в
      отладочных  целях,  поэтому  все  это,  вероятно  имеет небольшое
      значение.

      Различия         Правила,  касающиеся  того,  с  какой   стороны
      --------         относительного  оператора  сравниваемый  по  ERL
      номер   должен  находится,  неприемлемы  для  Турбо-Бейсика.  Это
      связано  с  тем,  что в Турбо-Бейсике нет инструкции RENUM. Кроме
      того,  в Турбо-Бейсике неприемлен результат ERL Интерпретаторного
      Бейсика,   получающийся   при   возникновении   ошибки  во  время
      исполнения оператора DIRECT MODE.
         См.также  ERADR
                   ERROR
                   ON ERROR

      Пример:
             ON ERROR GOTO Ловушка
             DIM X%(10)
             FOR I%=1 TO 10
             40 READ X%(I%)
                PRINT X%(I%)
             NEXT I%
             'имеется недостаточное число элементов данных
             70 DATA 1,2,3,4,5,6,7
             80 END
             90 Ловушка:
             IF ERL=40 THEN
              RESTORE
              RESUME
             ELSE
              PRINT "Неизвестная ошибка":END
             ENDIF

                                Оператор ERROR
                                -------------

      Функция    ERROR         вынуждает ошибку периода прогона.
      -------

      Синтаксис  ERROR ОшибкиКод
      ---------

      Замечания        ОшибкиКод  -  это   целое   выражение  от  0  до
      ---------        255.  Если  ОшибкиКод - заранее определенный код
      ошибки (см.приложение Е), то ERROR вызывает такое поведение вашей
      программы,  как  если  бы произошла ошибка. Это предусмотрено для
      отладки подпрограмм отслеживания ошибок . 
            Чтобы  определить ваши собственные коды ошибок, используйте
      в    ОшибкиКод    такие   значения,   которые   не   используются
      Турбо-Бейсиком. Если вы не определяете процедуру обработки ошибок
      для   этих   новых  потребительских  кодов  ошибок,  Турбо-Бейсик
      отображает сообщение: 
             Ошибка n в программном счетчике:адрес
             (Error n at pgm-ct :адрес)
             где  n-код ошибки, адрес-значение из программного счетчика
      процессора во время обнаружения ошибки .

      Пример:
             DEF FN функ%=(x%)
             IF x%>65 THEN
              ERROR 5 'ошибка вызова незаконной функции
             ELSE
              FNфунк%=x%+100
             ENDIF
             END DEF
             PRINT FNфунк(65) 'вызвать ошибку незаконного вызова
             'функции

                                Оператор EXIT
                                -------------

      Функция    EXIT    преждевременно оставляет какую либо структуру.
      -------

      Синтаксис  EXIT{SELECT!DEF!FOR!IF!LOOP!SUB!WHILE}
      ---------

      Замечания        Оператор   EXIT   позволяет    вам    оставлять
      ---------        структурный оператор или определение процедуры и
      функции  в  каком-то  ином  месте,  чем  ее конец. Тип структуры,
      подвергаемой действию оператора EXIT, должен включать в себя, как
      составную  часть,  оператора  EXIT  в  соответствии  со  следущим
      списком:
             --------------------------------------------------
             EXIT-опция     Подвергаемая EXIT структура
             --------------------------------------------------
             SELECT         Оператор SELECT
             DEF            Определение функции
             FOR            Цикл FOR/NEXT
             IF             IF-блок
             LOOP           Цикл DO/LOOP
             SUB            Определение процедуры
             WHILE          Цикл WHILE/WEND
             --------------------------------------------------
         При использовании EXIT можно сэкономить на беспорядочных GOTO.

      Ограничения         Когда   EXIT   используется  для   выхода  из
      -----------         функции,    вы   должны   назначать   функции
      результата до исполнения EXIT.

      Пример:
         'Эта   программа  демонстрирует   все   операторы   EXIT.  Для
         'прекращения исполнения используются и процедура и функция.
             SUB Управление (Выб%,Пусто%)
             SELECT CASE Выб%
              CASE 1
             'использовать  оператор  CASE  для  сообщения пользователю
             'чего-то о вводимом числе 
             SELECT CASE Пусто%
               CASE<0
                PRINT "Число меньше нуля"
                'выити из оператора SELECT CASE
                EXIT SELECT
               CASE >0
                PRINT "Число больше нуля"
                EXIT SELECT
               CASE ELSE
                PRINT "Число равно нулю"
             END SELECT
             EXIT SUB
             CASE 2
              IF Пусто%<0 THEN
                PRINT "Число меньше нуля"
                EXIT IF
              ELSEIF Пусто%>0 THEN
               PRINT "Число больше нуля"
               EXIT IF
              ELSE
               PRINT "Число равно нулю"
              ENDIF
             END SELECT PRINT "Вы выбрали число 2"
             END SUB
             DEF FN Циклы(Выб%)
             'Параметр подаваемый в функцию, указывает какое EXIT будет
             'исполняться.  Каждая  цикловая структура делает одно и то
             'же,  чтобы  продемонстрировать  как  может использоваться
             'EXIT   для   завершения   исполнения   цикла.   Мы  также
             'демонстрируем  как  можно использовать EXIT для выхода из
             'функции.  EXIT DEF используется для выхода из первых двух
             'случаев  выбора.  Это предотвращает исполнение операторов
             'вывода на экран.
             'назначить значение результату функции
             FNциклы=-1
            SELECT CASE Выб%
             CASE 1
             'использовать EXIT, чтобы оставить этот цикл, вместо того,
             'чтобы позволить ему завершится нормально 
             FOR I%=1 TO 32767
              PRINT RND(Пусто%)
              EXIT FOR
             NEXT I%
             EXIT DEF
             CASE 2
             DO
              PRINT RND(Пусто%)
              EXIT LOOP
             LOOP
             EXIT DEF
             CASE 3
             WHILE 1
               PRINT RND(пусто%)
               EXIT LOOP
             WEND
             END SELECT
             PRINT "Вы исполнили выбор случая 3"
             END DEF
             'начать главную программу
             'сделать  три  вызова  циклов,  выбирая каждый раз иной из
             'имеющихся 
             PRINT FNЦиклы(1)
             PRINT FNЦиклы(2)
             PRINT FNЦиклы(3)
             INPUT "Введите число:"Пусто%
             FOR Счетчик%=1 to 2
               CALL Управление(Счетчик%,Пусто%)
               CALL Управление(Счетчик%,Пусто%)
             NEXT Счетчик%
             END

                           Функции EXP, EXP2, EXP10
                           ------------------------
                                        x             x          x
      Функция    EXP       возвращает  e  ; EXP10 - 10  ;EXP2 - 2 .
      -------

      Синтаксис  EXP:
      ---------  y=EXP(x)
                 EXP2:
                 y=EXP2(x)
                 EXP10:
                 y=EXP10(x)

      Замечания        EXP  возвращает  e  встепени  x, где x- числовое
      ---------        выражение,  а   e   -   основание    натуральных
      логарифмов,  равное  приблизительно 2.718252. Тот же результат вы
      получите  с помощью оператора e^x. Только с помощью EXP вы можете
      вычислить само e :e=EXP(1) 
             EXP2 возвращает 2 в степени x , где x -числовая переменная
      или  выражение.  Тот  же  результат  вы можете получить с помощью
      выражения 2^x. 
             EXP10 возвращает 10 в степени x, где x числовая переменная
      или  выражение.  Тот  же  результат  вы можете получить с помощью
      выражения 10^x. 
             EXP,EXP2,EXP10 возвращают результат двойной точности.

      Пример:
             FOR I=1 TO 10
              PRINT USING "Экспонента ##=####^^^^":I,EXP(I)
             NEXT I
             END

                                Оператор FIELD
                                --------------

      Функция     FIELD       определяет   переменные  поля  в  буфере
      -------                 файла произвольного доступа. 

      Синтаксис   FIELD [#]Файланом,ширина AS строчная переменная.
      ---------

      Замечания        Файланом  -  это   номер,  используемый,   когда
      ---------        файл  открывается,  ширина  -  это число байтов,
      распределяемой  для  переменной поля, а строчная переменная - это
      сама переменная поля. 
            Однажды  используемые в операторе FIELD строчные переменные
      приобретают  статус "переменная поля". Они должны назначаться при
      подготовке записи в указанный файл произвольного доступа только с
      использованием RSET и LSET.

      Ограничения      Идентификатор, используемый  в операторе  FIELD,
      -----------      никогда  не должен применяться с левой стороны в
      операторе   присваивания.   Если   это   происходит,   то  данный
      идентификатор  более  не  идентифицируется  с определениями полей
      файла произвольного доступа.
         См.также   LSET
                    RSET

      Пример:
             OPEN "FIELD.DTA" FOR OUTPUT AS #1 LEN=18
             FIELD  #1,2  AS  Целое$,4  AS  ДлинноеЦелое$,4 AS Единич-
              наяТочность$,8 AS ДвойнаяТочность$
             FIELD #1,2 AS A$,4 AS B$,4 AS C$,8 AS D$
             МаксЦелое%=32767
             FOR I%=1 TO 5
             LSET Целое;=MKI$(I%)
             LSET ДлинноеЦелое$=MKL$(I%+CLNG(МаксЦелое%))
             LSET ЕдиничнаяТочность$=MKS$(CSNG(I%*CSNG(МаксЦелое%)))
             LSET ДвойнаяТочность$=MKD$(МаксЦелое%-I%)
             PUT #1,I%
             NEXT I%
             FOR I% TO 5
             GET #1,I%
              PRINT CVI(A$),CVL(B$),CVS(C$),CVD(D$)
             NEXT I%
             CLOSE #1
             END

                                Оператор FILES
                                --------------

      Функция          FILES отображает содержание справочника (подобно
      -------          DIR -команде DOS).
 
      Синтаксис        FILES [файласпец]
      ---------

      Замечания        Файласпец - это  строчное  выражение,  следующее  
      ---------        соглашениям DOS об  именовании  файлов, и  может 
      опционально включать в себя спецификатор  привода  и информацию о
      проходе. Если   файласпец   опускается,  отображаются  все  файлы
      текущего   справочника.  Файласпец   может   содержать   свободно
      определяемые литеры: ?, *, аналогично DIR-команде из DOS.
             FILES *.*
      дает перечень всех файлов текущего справочника.
             FILES *.BAS
      дает перечень исходных файлов Турбо-Бейсика.
         В конце  FILES, отображается число свободных байтов на устрой-
         стве,  cодержащем текущий справочник.Файлы субсправочника ука-
         зываются суффиксом DIR.

      Ограничения      Спецификация несуществующего привода  или  спра-
      -----------      вочника в операторе FILES будет вызывать  ошибку
      периода прогона.

      Пример 
             INPUT "Введите привод и справочник, по которому вы 
                    желаете иметь перечень":Спр$
             FILES Спр$
             END


                          Функция FIX
                          -----------

      Функция          FIX дает усечение целого.
      -------

      Синтаксис        y=FIX(числовое выражение)
      ---------

      Замечания        FIX отсекает дробную часть аргумента и возвраща-
      ---------        ет  целую  (в отличии от CINT и INT, которые вы-
      полняют округление).
         См.также CEIL
                  CINT
                  INT

      Пример:
           FOR I=50 TO 52 STEP RND
              PRINT USING "Целая часть ##.##=##":x,FIX(x)
           NEXT I
           END


                        Операторы FOR/NEXT
                        ------------------

      Функция          FOR и NEXT определяют цикл с автоматическим на-
      -------          ращиванием (или уменьшением).

      Синтаксис   FOR переменная=x TO y [STEP z]
      ---------   .
                  .
                  .
                  NEXT [переменная[,переменная]...]
      Замечания        Переменная - это  числовая переменная,  служащая
      ---------        счетчиком цикла, тогда как x, y, z -это числовые
      выражения, определяющие условия начала и остановки цикла. X - на-
      чальное   значение   счетчика,  y - конечное значение счетчика, а 
      z - опциональное  значение наращивания.  Операторы  между  FOR  и
      NEXT используются в режиме повторения. При  каждом  проходе через
      цикл переменная наращивается на z. Если z опускается, то  шаговое
      значение по умолчанию равно 1.  Цикл  завершается, когда значение
      счетчика больше или  равно  y (или, для  отрицательного z, меньше
      или равно y). Циклы  FOR/NEXT прогоняются быстрее всего при целых
      переменных,  как  переменной  счетчика, так и константах x, y, z.
      Корпус цикла пропускается полностью,  если начальное  значение  x
      меньше  y. Циклы FOR/NEXT  могут  гнездоваться  в  других  циклах
      FOR/NEXT. Убедитесь в том, что используются уникальные переменные
      счетчиков и обеспечиваете гарантию появления оператора NEXT внут-
      реннего цикла ранее NEXT внешнего цикла. Этот цикл имеет  пересе-
      чение циклов и не будет компилироваться:
             FOR n=1 TO 10
             FOR m=1 TO 20
             .
             .
             .
             NEXT n
             NEXT m
         Если  множество  циклов  оканчивается  в одной и той же точке, 
      достаточно единственного оператора NEXT, содержащего каждую пере-
      менную счетчика:
             FOR n=1 TO 10
             FOR m=1 TO 20
             .
             .
             .
             NEXT m,n
         Переменная  счетчика в операторе NEXT может опускаться вовсе,
      но если вы включаете ее, она должна быть правильной.
      Например:
             FOR n=1 TO 10
             .
             .
             .
             NEXT
         Хотя  компилятор не заботится о таких вещах, делайте у ступ  в  
      операторах FOR/NEXT на два или три пробела для разметки структуры
      цикла.  Используйте  оператор  EXIT FOR  с  целью  покинуть  цикл 
      FOR/NEXT до его завершения. Если обнаруживается NEXT без соответ-
      ствующего FOR, возникает ошибка 1 .

      Пример 
          FOR I%=1 TO 10
             PRINT "Для цикловой итерации "I%
          NEXT I%
          PRINT "Нажмите любую клавишу ..."
          WHILE NOT INSTAT
          WEND
          FOR I% TO 50 STEP -5
             PRINT "Для цикловой итерации"(45-I%)\5
          NEXT
          END


             Функция FRE
             -----------

      Функция          FRE возвращает величину свободной памяти,  имею-
      -------          щейся для вашей программы .

      Синтаксис        y=FRE({строчное выражение!-1!-2})
      ---------

      Замечания        FRE  со строчным аргументом  возвращает  длинное
      ---------        целое, представляющее число байтов свободной RAM
      (с помощью произвольного доступа) в строчной памяти. FRE(-1) воз-
      вращает  свободную  RAM  в  пространстве  массивов вашей прораммы.
      FRE(-2) говорит как много места осталось в стеке.

      Различия         Функция FRE Турбо-Бейсика дает  больше  информа-
      --------         ции, чем аналогичная  функция  Интерпретаторного
      Бейсика. Оператор FRE в Интерпретаторном Бейсике возвращает вели-
      чину наличной памяти в сегментах  данных  Бейсика;  следовательно
      вызов FRE (S$) и FRE(0) возвращают одно и то  же  число.  Однако,
      поскольку Турбо-Бейсик обеспечивает больше памяти, в которой  ра-
      ботает, его  оператор  FRE  имеет  больше   функций. Турбо-Бейсик
      имеет отдельный строчный сегмент; следовательно FRE(S$) возвраща-
      ет наличное  строчное  пространство. Турбо-Бейсик  имеет  большое
      (64К)  массивное  пространство, поэтому FRE(-1) возврашает налич-
      ную память для массивов. И Турбо-Бейсик  поддерживает процедуры и
      рекурсивность,  поэтому   FRE(-2)   возвращает  наличное стековое 
      пространство.
      Пример:
             ON ERROR GOTO ОшибкиОбработчик
             PRINT FRE ("Строчное Пространство"),FRE(-1),FRE(-2)
             DIM DYNAMIC БольшойМассив(10000)
             БольшойМассив(6666)=66
             'отобразить память, имеющуюся в сегментах строк, 
             'данных и стека
             s$="abc...z"
             PRINT FRE("Строчное пространство"),FRE(-1),FRE(-2)
             'эта  программа  дает ошибку, если прогоняется с 
             'включенной привязкой границ
             PRINT БольшойМассив(6666)
             END
             ОшибкиОбработчик:
             PRINT "Ошибка типа "ERR"произошла по адресу "ERADR
             END


             Оператор GET (файлы)
             --------------------

      Функция          GET обеспечивает считывание записи из произволь-
      -------          ного файла.
 
      Синтаксис        GET [#]файланом[,записином]
      ---------

      Замечания        Файланом-это номер файла, под которым он был от-
      ---------        крыт, а записином  запись  подлежащая считыванию
      от 1 до 16777215. Если записином опускается, то считывается  сле-
      дующая по порядку запись (после специфицированной самым последним
      GET или PUT).

     Пример:
         OPEN "GET.DTA" AS #1 LEN 18
         FIELD #1,2 AS Целое$,4 AS ДлинноеЦелое$,4 as 
         ЕдиничнаяТочность$,8 AS ДвойнаяТочность$
         FIELD #1,2 AS a$,4 AS B$,4 AS C$,8 AS D$
         МаксЦелое%=32767
         FOR I% TO 5
          LSET Целое$=MKI$(I%)
          LSET ДлинноеЦелое$=MKL$(I%+CLNG(МаксЦелое%))
          LSET ЕдиничнаяТочность$=MKS$(CSNG(I%*CSNG(МаксЦелое%)))
          LSET ДвойноеЦелое$=MKD$(МаксЦелое%^I%)
          PUT #1,I%
         NEXT I%
         FOR I%=1 TO 5
          GET #1,I%
            PRINT CVI(A$),CVL(B$),CVS(C$),CVD(D$)
         NEXT I%
         CLOSE #1
         END


             Оператор GET (графика)
             ----------------------

      Функция          GET обеспечивает считывание всего или части гра-
      -------          фического экрана в массив.

      Синтаксис        GET (x1,y1)-(x2,y2),Массив
     ----------

      Замечания        (x1,y1) и (x2,y2) специфицируют верхнюю левую  и
      ---------        нижнюю правую границы зоны  графического экрана,
      подлежащей обработке оператором GET. Массив -это числовой массив.
      GET и его дополнительная команда PUT исползуются сначала для счи-
      тывания, а  затем  для записи  графических изображений на  экран.
      Единственное ограничение накладываемое на числовой массив,  кото-
      рый используется для хранения считываемых с экрана данных, состо-
      ит  в  том,  что он должен быть достаточно большим для этого. Для
      расчета  размера массива ,необходимого для хранения заданной доли
      экрана, используйте следующую формулу:
         Необходимо байтов: 4+INT((x*битов на пиксел+7/8)*y,
      где y и x-размеры захватываемой зоны по горизонтали и вертикали. 
      Битов на пиксель-константа, относящееся к режиму :
             2-для средней
             1-для высокой разрешающей способности.
             --------------------------------------
              Экран       Битов на пиксель
             --------------------------------------
                  1                  2
                  2                  1
                  7                  4
                  8                  4
                  9                  4
                 10                  2
             --------------------------------------
         Например для хранении изображения при средней разрешающей спо-
      собности  35  пикселей шириной  и 45 высотой вам необходим массив
      4+int((32*2+7)/8)*45 байтов или 409 байтов.  409 байтов представ-
      ляют собой целый массив из  205  элементов, следовательно  массив
      заявляемый с помощью  оператора  размера  DIM буфер%(204), примет
      проделанную работу. Помните, что по умолчанию каждый массив имеет
      нулевой элемент; так что в массиве буфер% имеется 205  двухбайто-
      вых элементов, от 0 до 204, т.е всего  410  байтов). Турбо-Бейсик
      хранит графические данные в следущем формате:
           буфер%(0): число битов по горизонтали
           буфер%(1): число битов по вертикали
           буфер%(2)
             .
             .  Собственно графическая информация
             .
           буфер%(204)

         В  силу  особенности  организации дисплейной памяти, оживление
      работы на базе GET и PUT идет быстрее, если вы выбираете зоны эк-
      рана, выровненные по  байтовым  границам. Для  средней  разрешаю-
      щей  способности  используйте значения x кратное 4;  для  высокой
      разрешающей способности - кратное 8. Базисная стратегия использо-
      вания GET и PUT для живой обработки  обьекта  от точки А до точки
      В состоит в следущем:
             Чертить обьект
             GET обьект в массив
             позиция=старая ячейка=точка А
             DO UNTIL позиция =точка В
              PUT XOR обьект в старой ячейке
              позиция=позиция + приращение
              PUT XOR обьект в позиции
              задержать,если необходимо
              старая позиция=позиция
             LOOP

      Пример:
             'разместить буфер для хранения графического образа
             DIM Буфер%(143)
             'Переключить на графический режим среднего разрешения
             SCREEN 1
             CIRCLE (16,16),8,2 'чертить окружность
             GET (0,0)-(31,31),Буфер% 'получить окружность
             'копировать все на экран
             FOR I%=0 TO 9
              PUT (I%*32,100),Буфер%
             NEXT I%
             END


                            Функция GET$
                            ------------

      Функция           GET$ считывает строку из файла, открытого в ре-
      -------           жиме BINARY (двоичном).
        
      Синтаксис         GET$ [#]файланом,счетчик,строчная переменная
      ---------

       Замечания       Счетчик -это целое выражение в диапазоне от 0 до
       ---------       32767. GET$  считывает  счетчик  байтов, начиная
       с текущей файловой позиции (которая  может быть установлена опе-
       ратором SEEK), из файла  номер  файланом  и  назначает считанное
       строчной переменной. Файл файланом должен быть  открыт  в режиме
       BINARY. После обработки GET$ текущая файловая позиция будет про-
       двинута вперед на счетчик байтов.
         GET$,  PUT$  и  SEEK  обеспечивают низкоуровневую альтернативу 
      приемов обработки последовательных и произвольных файлов, которая
      дает вам возможность иметь с файлами дело на байтовой основе.

      См.также  OPEN
                PUT$
                SEEK

      Пример:
             SUB создатьФайл
             'GET$ открывает файл и записывает в него 256 литер
             LOCAL I%
             OPEN "GET.DTA" FOR BINARY AS #1
             FOR I%=0 TO 256
             PUT$ #1,I%,CHR$(I%)
             NEXT I%
             END SUB
             DEF FNЧитатьЭл$(Начало%,Размер%)
             LOCAL времСтр$,Лит$,I%
             SEEK 1,Начало%
             GET$ #1,Размер%,ВремСтр$
             FNЧитатьЭл$=ВремСтр$
             END DEF
             CALL Создатьфайл
             PRINT "Введите строчную точку [0...255] и сколько"
             PRINT "байтов данных [0...255] вы желаете
             PRINT "считать из файла ",Ст%,Рз%
             PRINT FNчитать Эл$(Ст%,Рз%)
             END


                              Оператор GOSUB
                              --------------

      Функция          GOSUB возбуждает подпрограмму
      -------

      Синтаксис        GOSUB метка
      ---------

      Замечания        Оператор GOSUB вызывает переход Турбо-Бейсика  к
      ---------        оператору, имеющему  перед  собой  метку,  после
      предварительного обеспечения  хранения  текущего  адреса в стеке.
      Использование RETURN возвращает управление к оператору, следущему
      за GOSUB. Процедуры и функции Турбо-Бейсика  могут выполнять  ра-
      боту подпрограмм с добавлением выигрыша  в  рекурсивности, подачи
      параметров и локальных и статических переменных.

      См.также  DEF FN
                SUB
                RETURN

      Пример 
             PI#=ATN(1)*4
             радиус =55
             GOSUB РасчетПлощади
             радиус=13
             GOSUB РасчетПлощади
             END
             РасчетПлощади:
               Площадь=PI#*радиус^2
             PRINT Площадь
             RETURN


                          Оператор GOTO
                          -------------

      Функция          GOTO направляет программный поток к  оператору
      -------          идентифицируемуму меткой .

      Синтаксис        GOTO метка
      ---------

      Замечания        GOTO  вызывает безусловное смещение программного
      ---------        потока к коду идентифицирумому меткой. При  уме-
      ренном использовании операторы GOTO  представляют собой быстрое и
      эффективное средство программирования. При беззаботном  использо-
      вании   они   загромождают   программу  переплетениями, в которых
      невозможно разобраться (особенно через месяц и годы после написа-
      ния). В современной практике программирования стремятся минимизи-
      ровать применение GOTO с помощью подпрограмм, процедур и функций,
      а также структурных операторов, таких  как  FOR/NEXT, WHILE/WEND,
      DO/LOOP, IF BLOCK и SELECT. Уменьшению применения GOTO также спо-
      собствует оператор EXIT.
         См.также EXIT

      Пример:
             x=0
             Начало:
             x=x+1
             IF x<20 THEN
              GOTO Распечатать
             END IF
             END
             Распечатать:
             PRINT "Переменная x="x
             GOTO Начало


                          Функция HEX$
                          ------------

      Функция          HEX$ преобразует число в его шестнадцптиричный
      -------          строчный эквивалент.

      Синтаксис        s$=HEX$(числовое выражение)
      ---------

      Замечания        числовое выражение может находиться в  диапазоне
      ---------        от  -32768 до 65535. Любая дробная часть  число-
      вого выражения округляется перед созданием строки.  Если аргумент
      HEX$ отрицателен, то эта функция  возвращает  двоичное дополнение
      числа.
         См.также    BIN$
                     OCT$

      Пример:
               PRINT HEX$(65535)
               PRINT HEX$(-1)


                             Оператор IF
                             -----------

      Функция          IF тестирует условие и изменяет программный  по-
      -------          ток, если условие удовлетворяется.

      Синтаксис       IF целое выражение[,] THEN оператор(ы)
      ---------       [ELSE оператор(ы)]

      Замечания        Если целое выражение TRUE используются операторы
      ---------        следущие после THEN и любого опционального ELSE.
      Если выражение FALSE, то исполняются операторы после  ELSE.  Если
      опциональная статья  ELSE опускается, исполнение  продолжается со
      следущей строки программы. Обычно целое выражение будет результа-
      том, возвращаемым оператором отношения, хотя и не всегда, как по-
      казано ниже:
             IF ПринтерВкл THEN LPRINT Ответ$
      Здесь  оператор lprint используется только, "флаговая  переменная
      Принтервкл имеет ненулевое значение. Перед  ключевым словом  ELSE
      не должно появляться двоеточие; например, следущий оператор  ком-
      пилироваться не будет:
             IF a<b THEN c=d:ELSE e=f
         Оператор IF и все ассоциируемые с ним операторы, включая  сле-
      дущие после ELSE  должны  появляться  в одной и той же логической
      строке. Поэтому следущее незаконно:
             IF a<b THEN t=15:w=13:v=23
             ELSE t=17:w=16:v=15
      поскольку компилятор трактует вторую строку как  совершенно новый
      оператор, не связанный с находящимся выше него.  Если  количество
      ваших операторов больше, чем можно разместить в одной  строке, вы
      должны  воспользоваться  литерой  указания  непрерывности  строки,
      подчеркиванием  (_), применяемой для разделения единой логической
      строки на нескоько физических строк. Например:
             IF a<b THEN t=15:w=16:v=23_
             ELSE t=17:w=16:v=15
      однако лучшая альтернатива состоит в использовании блокового опе-
      ратора  IF. Вы можете использовать блоковый оператор IF такжк для
      формирования многострочного ряда IF -операторов.

         Различия Турбо-Бейсик имеет расширенный оператор  IF THEN ELSE
      для обеспечивания множества строк кода в структцре  IF THEN ELSE.
      Турбо-Бейсик обеспечивает также операторы ELSEIF, ENDIF  для бло-
      кового IF -оператора.

         См.также    IF блок
                     SELECT

       Пример:
             INPUT "Введите число",x
             IF x>100 THEN PRINT "Большое число" ELSE_
             PRINT "Малое число"
             END


                          Блоковый оператор IF
                          --------------------

      Функция          IF блок создает ряд IF-операторов
      -------

      Синтаксис       IF целое выражение [,] THEN
      ---------       .
                      .
                      . Операторы
                      [ELSEIF целое выражение [,] THEN
                      .
                      .
                      . Операторы]
                      [ELSE
                      .
                      .
                      .Операторы]
                      ENDIF


      Замечания        IF блок -это расширение Интерпретаторного Бейси-
      ---------        ка, позволяющее осуществлять множество тестов на
      множестве строк. При исполнении операторов IF блока проежде всего
      проверяется истинность выражения в операторе IF. Если  FALSE про-
      веряется по порядку кождый следущий оператор  ELSEIF.  Как только
      находится TRUE, Турбо-Бейсик  исполняющий  операторы следующие за
      соответствующим THEN, осуществляет переход к оператору следующему
      за оператором ENDIF без проведения дальнейших  тестов.  Операторы
      после опциональной статьи ELSE исполняются, если ни один из ранее
      проведенных тестов не оказался успешным.
         Следует заметить, что в первой строке IF блока после ключевого
      слова THEN ничего не может быть, таким образом компилятору  сооб-
      щается, что это IF блок, а не обычный оператор IF.
         Операторы IF блока могут гнездоваться,  т.е.  любые  операторы
      после любого  THEN  могут содержать IF блоки. (Полезно делать от-
      ступ операторов, находящихся под управлением каждого теста на па-
      ру пробелов, как показано в следущем ниже примере.
         Блоковые  операторы  IF  должны оканчиваться  END IF. Заметьте,
      что END IF записывается с пробелом, а ELSEIF без пробела.

         См. также    SELECT

      Пример:
             RANDOMIZE TIMER
             БанкРулетки=100:Ставка=5:ЗначЗадержки=.5
             WHILE NOT INSTAT 'нажать клавишу останова
             Рулетка=INT(RND(1)*6)+INT(RND(1)*6)+2
             PRINT STRING$ (30."_")
             PRINT Рулетка:DELAY ЗначениеЗадержки
             IF Рулетка=2 OR Рулетка=3 OR Рулетка=12 THEN_
                PRINT "Bы проиграли"
             БанкРулетки=БанкРулетки+Ставка
             ELSE
              PRINT "ваша точка есть" Рулетка
              Неточка=-1
              WHILE Неточка
               СледРулетка=INT(RND(1)*6)+INT(RND(1)*6)+2
               PRINT СледРулетка:DELAY ЗначениеЗадержки
               IF Рулетка=СледРулетка THEN
                 PRINT "Вы проиграли"
                 БанкРулетки=БанкРулетки+Ставка
                 Неточка=0
               ELSEIF СледРулетка=7 THEN
                PRINT "Вы проиграли"
                БанкРулетка=БанкРулетка-Ставка
                Неточка=0
             'закончить IF рулетка=блок СледРулетка
             END IF
             WEND
             END IF
             WEND


                          Оператор INCR
                          -------------

      Функция          INCR наращивает значение.
      -------

      Синтаксис        INCR числовая переменная[,размер]
      ----------

      Замечания        Размер -это опциональное числовое выражение, ко-
      ---------        торым указывается значение  добавляемое к специ-
      фицированной  переменной. Если размер опускается, используется 1.
      INCR  - это  быстрый  способ приращения переменной без применения
      оператора присваивания.

      Различия         Этого оператора в Интерпретаторном Бейсике 
      --------         не существует.

         См. также    DECR

      Пример:
             I%=-15
             J%=-500
             WHILE I%<0
             PRINT I%,J%
             INCR I%
             INCR J%,5
             WEND
             END




                          Функция INKEY$
                          --------------

      Функция          INKEY$ считывает клавиатуру без эхо - обработки
      -------          литеры.

      Синтаксис        s$=INKEY$
      ---------

      Замечания        INKEY$ возвращает строку из  0,  1 или  2 литер,
      ---------        отражающую состояние буфера клавиатуры. 
      Нуль-строка (LEN(s$)=0) означает, что буфер пуст.  Строка  длиной
      (LEN(s$)=1) означает, что строка содержит ASCII- значение клавиши
      нажатой самой последней; например, 13 для Enter (ввод), 65 для A.
      Двумерная строка (LEN(s$)=2) означает, что была нажата  не  ASCII
      -клавиша. Первая литера в этой строке имеет значение 0, а вторая-
      код расширенной  клавиатуры -  представляет  одну  из  клавиш  не
      ASCII-клавиатуры, такую как Home (исходное), PgDn (страница вниз)
      или клавиши стрелки (см. диаграмму кодов расширенной клавиатуры в
      приложении F).
         Если нажимается определенная функциональная клавиша (см.опера-
      тор KEY), то INKEY$  возврашает  последовательность литер (по од-
      ной на каждое возбуждение INKEY$), которая содержит литеры, кото-
      рые получились бы при их независимом наборе. INKEY$  как  пулене-
      пробиваемое устройство для получения  пользовательского  ввода  в
      вашу программу без ограничений оператора  INPUT. Поскольку INKEY$
      не ожидает литеру, подлежащую нажатию  до возвращения результата,
      вы  в  большинстве  случаев  будете  использовать ее внутри цикла
      низкоуровневой  подпрограммы, непрерывно  проверяющей  и строящей
      строку ввода, подлежащую проверке  подпрограммами  более высокого
      уровня.
         INKEY$ подает все удары по клавиатуре включая клавиши управле-
      ния, такие как Таб, Enter, Backspace в вашу программу без их ото-
      бражения или обработки, но при следующих исключениях :
         -  Ctrl-Break   (управление-разрыв)  завершает программу, если
                         опция разрыва клавиатуры  не была выключена во
                         время компилирования программы.
         -  Ctrl-Alt-Del (управление-изменить-стереть) вызывает повтор-
                         ную  установку системы.
         - Shift-PrtSc   (сдвиг-вывод на экран) выполняет сброс экрана.

         См. также INSTAT
  
      Пример:
                 PRINT "Введите несколько литер, за 
                        которыми следует <Enter>:"
                 WHILE лит$<>CHAR$(13)
                  лит$=INKEY$
                  ВводаСтрока$=ВводаСтрока+лит$
                 WEND
                 PRINT ВводаСтрока
                 END
