
                           Функции CVMD,CVMS
                           -----------------


      Функция          CVMD   и   CVMS преобразует строчные переменные,
      -------          считываемые  из  произвольных  файлов  в формате
      Микрософт, в числовую форму.

      Синтаксис        y!=CVMS(4-байтовая строка)
      ---------        y#=CVMD(8-байтовая строка)

      Замечания        CVMS  (Convert Microsoft Singl-precision string)
      ---------        преобразует  4-байтовую  строку,  представляющую
      значение   единичной  точности  в  формате  Микрософт,в  значение
      единичной  точности  в  формате IEEE Турбо-Бейсика. CVMD (Convert
      Microsoft Double-precision string) преобразует 4-байтовую строку,
      представляющую   значение   двойной   точности   в   формате  IEE
      Турбо-Бейсика.   Эти   функции  предусмотрены  исклбчительно  для
      совместимости с существующими файлами Интерпретаторного Бейсика.

         Пример:
            'открыть файл произвольного доступа
             open "cvmd.dta" as#1 len=12
             field#1,4 as Единичная$,as Двойная$
             for i=1 to 5 'записать некоторые данные в файл
             'преобразовать данные и назначить файл данных
             lset Единичная$=mkms$(i)
             lset Двойная$=mkmd$(i^i)
             put #1.1
             next i
             for i=1 to 5
             get #1,1
             print cvms(Единичная$),cvmd(Двойная$)
             next i%
             print cvs(x$),cvms(x$)
             close #1
             end


                                Оператор DATA
                                -------------

      Функция          DATA заявляет константы для операторов READ.
      -------

     Синтаксис         DATA константа[,константа]...
     ---------

      Замечания        Константа - это числовая или строчная константа.
      ---------        Числовые константы могут быть с плавающей точкой
      или  целые  и  опционально могут выражаться как шестнадцатиричные
      или  восьмеричные.  Строчные  константы  не  должны заключаться в
      кавычки,   если   они   не  содержат  разделители  (запятые  либо
      двоеточия)  или  значащие передние либо концевые пустоты, и могут
      свободно   размещаться   вперемежку   с   числовыми  константами.
      Например:

               DATA    Тако,.79,куриный   предел,2.29,.29 

         Программа  может  содержать  много  операторов  DATA  и они не
      обязательно  должны  быть  следующими  друг  за  другом строками.
      Каждое  может  содержать  столько  констант,  сколько умещается в
      строке.
         Во  время  прогона операторы READ получают доступ к константам
      DATA  слева  направо  и  сверху  вниз  в том порядке, в каком они
      появляются   в  исходной  программе.  Большинство  общих  ошибок,
      ассоциируемых   с   оператором   DATA  и  READ  получается  из-за
      несинхронности  и  попыток  загрузить  строчныю данные в числовую
      переменную;  в  результате  генерируется ошибка 2 (синтаксическая
      ошибка).  К  сожалению  вы  не получаете информацию об ошибке при
      загрузке  числовой константы в строчную переменную, даже если это
      не то, что вы намеревались сделать.
         Команда  RESTORE позволяет вам повторно считывать константы из
      первого  оператора  или любого специфицированного оператора DATA.
      Если  вы  пытаетесь реализовать READ большое число раз, чем имеет
      констант ваша программа, это приводит к ошибке 4 (вне данных).

      Ограничения      Вы  не  можете  использовать  в  операторах DATA
      -----------      литеры    с   непрерывным   подчеркиванием.   Не
      пользуйтесь  единичной  кавычкой (') для коментирования оператора
      DATA,  поскольку Турбо-Бейсик может принять ее за последний вход,
      а   ваш  комментарий  за  часть  данной  одной  длинной  строчной
      константы. Например:

          "Кнопки","собаки" и "свиньи'список животных."

         Вы можете, однако, безопасно использовать для этой цели :REM:

      См. также      READ
                     RESTORE

      Пример:
            'Эта программа демонстрирует использование оператора DATA
             sub ОбработкаРезультатов(СтудентаИмя$,СтудентаСредний%)
             local Всего%,Бал%,i%
                Всего%=0
                read СтудентаИмя$
                for i%=1 to 10
                 read Бал%
                 Всеге%=Всего%+Бал%
                next i%
                СтудентаСредний%=Всего%\10
             end sub
             for Студент%=1 to 3
               call ОбработкаРезультатов(Симя$,Средний%)
               print using "&'s средний равен ###";симя$,средний%
             next Студент%
             end
              Ваши результаты:
             DATA В.Перри,78,65,35,79,86,93,79,85,99,96
             DATA П.Ватсон ,98,94,70,88,99,100,75,96,100,95
             DATA М.Чикконе,65,59,75,82,56,79,82,76,69,89


                          Системная переменная DATE$
                          --------------------------

      Функция      DATE$ устанавливает и устанавливает системмную дату.
      -------

      Синтаксис        DATE$=s$   (установить  дату  в  соответствии  с
      ---------        информацией  в  s$) s$=DATE$ (s$ содержит теперь
      информацию о дате).

      Замечания        Системная   дата   устанавливается   назначением
      ---------        правильно  сформированного  строчного значения в
      DATE$. Назначение DATE$ строчной переменной делает системную дату
      доступной  для  обработки.  DATE$ возвращает 10-литерную строку в
      форме мм-дд-гггг, где мм-месяц, дд-день, гггг-год.
         Чтобы  изменить  дату,  ваша  строка  должнa иметь формат даты
      одного из следующих видов:
             мм-дд-гггг
             мм/дд/гг
             мм-дд-гггг
             мм/дд/гггг
      Например:

       "10-25-86" устанавливает системную дату на 25 октября 1986 года.

      Ограничения      Год,  назначенный  в системной переменной DATE$
      -----------      должен лежать в диапазоне 1980-2099.

      См. также TIME$

      Пример:
            'отобразить текущую системную дату
             print "текущая системная дата";DATE$
             input "пожалуйста, введите новую дату в форме
                    мм-дд-гг";НоваяДата$
             DATE$=НоваяДата$
             print "Текущая системная дата установлена на ",DATE$
             end


                                Оператор DECR
                                -------------

      Функция     DECR сбрасывает переменную.
      -------

      Синтаксис  DECR переменная[,размер]
      ---------

      Замечания        Переменная - это    численная    переменная,   а
      ---------        размер-опциональное  числовое выражение, которое
      указывает значение, которое должно вычитаться из переменной. Если
      размер опускается, используется 1.
         DECR-лучший  способ  сбрасывания  переменной.  Для  приращения
      переменной используйте оператор INCR.

      См. также        INCR

      Пример:
            i%=15
             j%=500
             while i%>0
             print i%,j%
             decr i%
             decr j%,5 'сбросить значение на 5
             wend
             end


                           Оператор DEF FN/END DEF
                           -----------------------

      Функция     DEF FN/END DEF определяет функцию.
      -------

      Синтаксис   Единичная строка:
      ---------   DEF FN идентификатор[(список аргументов)]=выражение
                  Многострочная:
                  DEF FN идентификатор[(список аргументов)]
                  [LOCAL список переменных]
                  [STATIC список переменных]
                  [SHARED список переменных]
                    .
                    .
                    .
                  [EXIT DEF]
                  [FN идентификатор=выражение]
                  END DEF

      Замечания        Идентификатор  -  это  уникальное  имя,  которое
      ---------        должно  ассоциироваться  с  функцией и следовать
      соглашению  об наименовании меток и переменных (т.е. представлять
      собой  букву,  за  которой  следует любое число букв и/или цифр).
      Список   аргументов  -  это  опциональная,  разделяемая  занятыми
      последовательность  формальныхпараметров. Параметры, используемые
      в  списке  аргументов, служат только для определения функции: они
      не имеют взаимосвязи с другими переменными программы, имеющими те
      же  имена.  Cкобки  DEF  FN и END DEF и имя подобной субпрограмме
      группы   операторов   называется   функцией.  Функции  может  оп-
      ционально  подаваться  один  или  более аргументов по назначению.
      Функции    возвращают    значение   (тип   которого   управляется
      соответсвенно  имени  функции, как если бы это была переменная) и
      поэтому  могут  вызываться  из любого оператора, которое способно
      принимать значение подходящего типа.

                   Оперделение функций и программный поток
                   ---------------------------------------

         Положение определений функций не имеет значения. Функция может
      быть  определена  в  строке  1  или  строке  1000  программы, вне
      зависимости  от того,где она используется и вам нет необходимости
      пропускать  программный  поток  непосредственно  через  функцию в
      качестве  шага возбуждения (что вы обязаны делать с однострочными
      функциями  в  Интерпретаторном Бейсике). Компилятор просматривает
      ваши определения, где бы они ни были. 
         Также,   в   отличии   от  подпрограмм,  исполнение  не  может
      неожиданно  "приняться"  за  функцию.  Для  всего,  что  касается
      исполнительного прохода программы, определения функций и процедур
      невидимы. Например:
             t=fnВыдатьШтат
             def fnВыдатьШтат
             print "Выдаю из fnВыдатьШтат"
             end def
         Когда  исполняется  эта  четырехстрочная  программа, сообщение
      появляется  только  один  раз,  поскольку  ВыдатьШтат  вызывается
      только в первой строке.
         Определения  функций  должны  трактоваться  как  изолированные
      острова  кода;  ни переходов в них, ни переходов из них с помощью
      оператора GOTO, GOSUB или RETURN не существует. Однако в пределах
      самих определений такие операторы существуют .
         Следует  заметить,  что  определения функций и процедур нельзя
      гнездовать,  т.е.  незаконно  определять  процедуру  или  функцию
      внутри  процедуры  или  функции (каждое определение процедуры или
      функции может содержать вызовы других процедур).

         Заявления локальных переменных(только многострочные функции)
         ------------------------------------------------------------
         Чтобы  заявить  локольные переменные в пределах функции, перед
      любыми   используемыми   операторами  в  определении  используйте
      оператор LOCAL. Например
             LOCAL a%,b#,БольшойМассив%()
      Создает  три  локальных  переменных:  a%,  b#,  (целое  и двойной
      точности  соответственно)  и  массив БольшойМассив%. Затем массив
      должен быть надлежащим образом образмерен:
             DIM DYNAMIC БольшойМассив%(1000)

                   Синтаксические и разделяемые переменные
                   ---------------------------------------

         По  умолчанию,  переменные  которые используются в определении
      функций,  имеют  атрибут  SHARED (разделяемые); т.е. они являются
      глобольными  для  остальной  программы.  Поскольку  это умолчание
      может  измениться,  вы  обязаны  затрачивать- усилия на заявление
      каждой используемой в функции переменной. 
         Заявляйте  переменные  с  атрибутом  STATIC,  если важно чтобы
      переменная  не  теряла  своего значения прикаждом возбуждении, но
      еще могла быть изменена только внутри функции. 
         Определение  многострочной  функции  обычно  включает  в  себя
      назначение  идентификатору  функции  и должно завершатся END DEF.
      Если  вы  делаете  выбор  не  включать  назначение идентификатору
      функции, то значение возвращаемое из функции неопределенно. 
         Используйте  для  возвращения  из функции где-то в ином месте,
      чем в конце ее, оператор EXIT DEF.

      См. также     LOCAL
                    SHARED
                    STATIC

      Пример:
           $STACK &H&FFF
             Всего=1
             def fn факториал%(i%)
             'Эта функция вычисляет факториал параметра i%
             Всего=Всего*i%
             if i%>1 then
               Саб%=fnфакториал%(i%)
             endif
             fnфакториал%=Всего
             end def 'конец функции fnфакториал
             print "Ввести число,которое вы желаете обсчитать"
             input "факториал:",j%
             print fnфакториал%(j%)
             end


               Операторы DEFINT, DEFLNG, DEFSNG, DEFDBL, DEFSTR
               ------------------------------------------------

      Функция    Заявляют тип идентификаторов переменных по умолчанию.
      --------

      Синтаксис  DEFтип буквенный диапазон[,буквенный диапазон]...
      ---------

      Замечания        Тип  представляет один из пяти типов переменных
      ---------        Турбо-Бейсика: INT (целое), LNG (длинная целая),
      SNG   (единичной   точности),   DBL   (двойной  точности)  и  STR
      (строчная). Буквенный диапазон - это  либо одна алфавитная литера
      (от  а до z, регистр безразличен), либо диапазон букв (две буквы,
      разделенные тире; например, А-М). 
         Оператор   DEFтип   сообщает  компилятору,  что  переменные  и
      определяемые    пользователем   функции,   начинающиеся   со
      специфицированных  букв  или  диапазона букв, будут определенного
      типа.  Это  дает вам возможность использовать переменные, иные,
      чем  с плавающей точкой единичной точности, в вашей программе без
      включения идентификаторов типа (например, %,#) 
         По умолчанию, когда компилятором обнаруживается имя переменной
      без   идентификатора   типа,   оно  предполагается  переменной  с
      плавающей точкой единичной точности. Например, в приведенном ниже
      операторе и N и M полагаются имеющими единичную точность:
             N=M+16
      Если, однако, этому оператору предшествовало DEFINT N,M, то N и M
      должны  быть  целыми,  как и любая другая переменная, имя которой
      начинается с N или M верхнего или нижнего регистра. 
         Исполнение  DEFтип  в Турбо-Бейсике отдичается от исполнения в
      Интерпретаторном    Бейсике.    Интерпретатор    судит   о   типе
      соответственно  тому,  где  появился  оператор  DEFтип  в порядке
      исполнения  программы.  Турбо-Бейсик,  как компилятор, рассматри-
      вает  положение DEFтип в исходном файле. Например, при исполнении
      этой программы: 
             10 goto 30
             20 defint a-m
             30 j=45.3:print j
      Интерпретаторный  Бейсик  никогда  не  заметит  заявление  типа в
      строке  20. Когда он добирается до j в строке 30 это j становится
      переменной   единичной   точности   и   не   читается  как  45.3.
      Турбо-Бейсик,  наоборот,  принимает  решение о типе переменной во
      время  компиляции  вне  зависимости от исполнительного прохода (о
      котором  во  время компилировании ничего не известно). Необходимо
      позаботится только отом, чтобы оператор DEFINT физически появился
      до  появления  j  впервые,  в результате чего j оказывается целой
      переменной и распечатывается 45.

      Ограничения      Оператором   DEFтип   будет переопределяться тип
      -----------      любых  соответствующих  переменных,  которые уже
      используются    в   программе.   Программа   следующего   примера
      демонстрирует этот крайне важный момент. 

      Пример:
            i=39567.999
             print "число ед.точности",i
             defsng i
             print "целое число",i
             defdbl a-c
             deflng j-z
             a=32767.1
             z=-1
             i=&H8FFF
             print "три разных типа",f,z,i
             end


                               Оператор DEF SEG
                               ----------------

      Функция          DEF SEG   определяет сегмент данных, подлежащих
      -------          использованию  операторами  BLOAD,  BSAVE, CALL,
      ABSOLUTE, PEEK и POKE.

      Синтаксис        DEF SEG [=числовое выражение]
      ---------

      Замечания        Числовое  выражение  может находится в диапазоне
      ---------        от 0 до 65535. DEF SEG определяет сегмент памяти
      в   котором   будут   специфицироваться  ответвления  последущими
      операторами BLOAD, BSAVE, CALL, ABSOLUTE, PEEK, POKE. Сегмент-это
      адресующая конструкция, используемая процессорами семейства Интел
      86.  Адреса  должны  специфицироваться  двумя  целыми,  сегмент и
      ответвление в сегмент.
         DEF  SEG  без  аргумента  возвращает  значение  сегмента к его
      значению  по  умочанию  на  момент  запуска.  Первые  256  байтов
      сегмента  по умолчанию содержат информацию, используемую системой
      поддержки  времени  прогона вашей программы. В этом сегменте есть
      один интересный адрес при ответвлении &HF4E. Значения вставленные
      командой POKE по этому адресу изменяют текст записанный на экране
      в  любом графическом режиме. Цвет зависит от того, в каком режиме
      вы  находились.  Другой  полезный  адрес  в  сегменте  данных  по
      умолчанию  находится  в  ячейке 0 и 1. Это слово содержит сегмент
      строк Турбо-Бейсика.

      См. также      COLOR

      Пример:
             'Эта  программа  позволяет  заполнить  экран буквами А,
             'вставленными непосредственно в видео-память, определить
             'функцию,   которая  устанавливает  адрес  видео-памяти,
             'получить тип видео-платы от пользователя 
             def fn ВидеоЭкран%
               local ЭкранаТип%
               print "тип экрана ?"
               input "[1 для моно,2 для цветного]",ЭкранаТип%
               select case ЭкранаТип%
                case 1
                  fn ВидеоЭкран%=&HB000
                case 2
                  fn ВидеоЭкран%=&HB800
                end select
              end def
             def seg=fnВидеоЭкран%
             for i%=0 to 4000 step 2
             poke i%,asc("A")
             next i%
             end


                                Оператор DELAY
                                --------------

      Функция    DELAY вставляет паузу
      -------

      Синтаксис  DELAY секунды
      ---------

      Замечания        секунда - это  числовое  выражение, определяющее
      ---------        число  секунд  паузы, выполняемой Турбо-Бейсиком
      перед   использованием  следущего  оператора.  Примечание:  DELAY
      принимает  аргументы с плавающей точкой, а дробные задержки можно
      специфицировать с разрешением примерно 0.054.
         Использование  DELAY, а не программного цикла ничегонеделания,
      сказывается  на  программах,  которые  прогоняются  на  машинах с
      разной   скоростью   обработки  (т.е.  базирующихся  на  8088  по
      сравнению  с  базирующимися  на 80286, или 6 Мгц по сравнению с 8
      Мгц).

      Пример:
             print "Нажмите любую кнопку для завершения программы"
             while not instat
             locate 10,30
             print time$
             delay 5
             wend
             end


                                 Оператор DIM
                                 ------------

      Функция     DIM заявляет массив
      -------

      Синтаксис        DIM{static!dynamic}переменная(подстрочный
                       индекс)[,переменная(подстрочный индекс )]...
         DIM {static!dynamic}переменная(мин:макс)[,мин:макс]...)[,пере-
         менная(мин:макс)[,мин:макс]...)]... 

      Замечание        Переменная - это идентификатор, используемый для
      ---------        массива.  Подстрочный  индекс  - это разделяемый
      запятыми  список  одного  или более целых выражений, определяющий
      размеры  массива.  DIM заявляет массивные переменные и определяет
      их  размер  и  число  измерений.  В  порядке улучшения синтаксиса
      интерпретаторного  Бейсика,  Турбо-Бейсик  дает  вам  возможность
      определять  диапазон  значений подстрочных индексов (мин:макс), а
      не только верхний предел, например: 
           DIM B(50:60)
      создает  массив из 11 элементов единичной точности, нумеруемых от
      50 до 60. Оператором 
             DIM C(50:60,25:45)
    создается двумерный массив с общим числом элементов 11*21.
    Синтаксис диапазона можно расширять на многомерные массивы:
             DIM рождения(1800:1899,1:12)
         Для  определения  наименьшего  элемента  в массиве можно также
      использовать  связанные  операторы  OPTION BASE, хотя диапазонный
      механизм более мощное и предпочтительное средство.
         Когда    программа    используется    впервые,    Турбо-Бейсик
      устанавливает  каждый  элемент  числового массива в 0, а строчные
      массивы-в нуль-строку (длина=0). Если программа запускается вновь
      с    помощью    оператора    RUN,   числовые   массивы   повторно
      устанавливаются в ноль, а строчные массивы в ноль-строку. 
         Если  массивная  переменная  используется  без предшествующего
      оператора   DIM,   максимальным   подстрочным  индексом  является
      значение  10  по  умолчанию,  как  если  бы  включили  (10) в ваш
      оператор   DIM.  Однако  предпочтительно  в  практической  работе
      заявлять каждый массив явно. 
         Минимальное  значение,  которое  можно использовать в качестве
      подстрочного  индекса в мaссивах, есть 0, если не специфицируется
      иное с помощью команды OPTION BASE. 
         Опциональные    аргументы    STATIC   и   DYNAMIC   управляют,
      соответственно,  тем,  будет  ли пространство для массива заранее
      распределяться    компилятором,    или   подлежит   распределению
      динамически.  Если этот аргумент опускается, массивы по умолчанию
      размещаются  как  статические,  если  уже  не  задан метаоператор
      $DYNAMIC,   если  в  заявлении  DIM  не  используется  какое-либо
      выражение,  если  имя массива не появляется в двух операторах DIM
      или если массив не заявлен локальным в процедуре либо функции. 
         Переключатель    проверки   границ,   доступный   через   меню
      опций,вызывает  создание  компилятором  кода, которым проверяется
      приемлемость подстрочных индексов при всякой ссылке на массив.

      Различия         Турбо-Бейсик   дает   возможность   программисту
      --------         специфицировать  начальный  и  конечный  индексы
      массива.    Интерпретаторный   Бейсик   размещает   все   массивы
      динамически,   но   Турбо-Бейсик  будет  пытаться  разместить  их
      статически   (во  время  компилирования),  что  делает  их  более
      быстродоступными.  Вы  можете явно преодолевать тип используемого
      размещения.

      См.также  $DYNAMIC
                FRE
                $STATIC

      Пример:
            %МаксРазм=20
             %МинРазм=1
             dim Массив%(%МинРазм:%МаксРазм)
             for счетчикi%=%МинРазм TO %МаксРазм
              Массив%(счетчикi%=%Минразм to %МаксРазм
              Массив%(счетчикi%)=int(rnd*10)
             next счетчикi%
             end


                               Оператор DO/LOOP
                               ----------------

      Функция       DO/LOOP-это цикл с текстом TRUE (истинно) или FALSE
      -------       (ложно) в верхней и/или нижней части цикла.

      Синтаксис   DO[{WHILE!UNTIL}выражение]
      ---------   .
                  . операторы [EXIT LOOP]
                  .
                  [LOOP!WEND][{WHILE!UNTIL}выражение]

      Замечания        Выражение - это   числовое  выражение, в котором
      ---------        ненулевые    значения   представляют   TRUE,   а
      нулевые-FALSE.
         DO  и LOOP представляют собой строительные элементы циклов для
      всех  случаев.  Они позволяют вам создавать циклы с тестированием
      условия  завершения в верхней части цикла, в нижней его части и в
      обоих  местах. Оператор DO всегда должен быть в паре с оператором
      LOOP  в  нижней  части  цикла.  Несоврадение DO и LOOP приводит к
      ошибкам периода компилирования. 
         Используйте  WHILE  и  UNTIL  для добавления какого-то теста к
      DO/LOOP.  Использование  резервированного  слова WHILE удобно при
      необходимости  повторения  цикла,  если  выражение  ИСТИННО и его
      прекращении, если выражение ЛОЖНО. UNTIL вызывает противоположный
      эффект,  т.е.  цикл  будет  прекращаться, если условие ИСТИННО, и
      будет повторятся, если оно ЛОЖНО.

      Например:
         DO WHILE a=13
             .
             .ОПЕРАТОРЫ
             .
             LOOP
             исполняет операторы между DO и LOOP,пока а равно 13.
             DO UNTIL a=13                            -
             .
             .ОПЕРАТОРЫ
             .
              LOOP
      исполняет  операторы между DO и LOOP, пока а не равно 13. В любой
      точке   DO/LOOP   вы  можете  включать  оператор  EXIT/LOOP.  Это
      эквивалентно   GOTO   к   оператору,  которое  выполняется  после
      завершения  LOOP. (Более подробно см. в описании оператора EXIT).
      Обратите внимание на то, что это DO/LOOP:
             DO WHILE A<B
             .
             .
             .
             LOOP
             имеет тот же эффект ,что и цикл WHILE/WEND:
             WHILE A<B
             .
             .
             .
             WEND
         Хотя  компилятором  не  реализуется  забота  о подобных вещах,
      делайте  отступ  для операторов между DO и LOOP на пару пробелов.
      Это помогает яснее представить структуру цикла.

      Пример:
            DO 'Эта программа ждет нажатия клавиши
             LOOP UNTIL INSTAT
             END


                             Оператор DRAW
                             -------------

      Функция          DRAW  обеспечивает  вычерчивание контуров на
      -------          графическом экране.

      Синтаксис        DRAW строчное выражение
      ---------

      Замечания        DRAW   дает   графику  обьектов  на  графическом
      ---------        экране  в соответствии с командами, заключенными
      в  строчный аргумент, который в него подается. В действительности
      "строчное выражение" есть программа для интерпретаторного "языка"
      DRAW.  Оператор  DRAW обеспечивает исполнение командных строк для
      получения  изображений  на  экране  во  многом  также  как и PLAY
      исполняет командные строки для создания музыки.

           -----------------------------------------------
             Перемещение             Команды
           -----------------------------------------------
             Un                 Переместить вверх
             Dn                 Переместить вниз
             Ln                 Переместить влево
             Rn                 переместить вправо
             En                 Переместить вверх и вправо
             Fn                 Переместить вниз и вправо
             Cn                 Переместить вниз и влево
             Hn                 Переместить вверх и влево
           -----------------------------------------------
         n  -  расстояние  перемещения  (см.Sn, масштабный коэффициент,
               обсуждаемый ниже).
         Перемещение   всегда   начинается   в   LRP  и  соответственно
      регулирует   LRP  (LRP  означает  "точка  последней  посылки")  и
      определяе  последнюю  точку,  на  которую  ссылались определенные
      чертежные  операторы.  Более  детальную  информацию см. в разделе
      графики ГЛАВЫ 4). 
             Например:
             DRAW "D10R5"
      обеспечивает  вычерчивание  L-образной формы (вниз 10, вправо 5),
      начиная   с   LPR.  При  этом  LPR  устанавливается  в  последнем
      задействованном пикселе.
         Мx,y  обеспечивает  перемещение в координату x,y. Если перед x
      стоит  знак  плюс или минус, перемещение относительное, иначе оно
      абсолютное, например: 
             DRAW "D10R5 M30,50"
      обеспечивает  вычерчивание  L-формы, а затем доводит ее линией до
      пиксела (30,50).
         Любой   команде  перемещения  могут  предшествовать  следующие
      префиксы: 
             В -обеспечивает перемещение без графического изображения
             N -обеспечивает перемещение, но также возврат в исходное
                положение по окончании.
      Например:
             DRAW "BM180,20NU10ND101L10NR10"
      обеспечивает  перемещение  без  вычерчивания в пиксел (180,20), а
      затем вычерчивание знака плюс.

                                Другие команды
                                --------------
         An  - обеспечивает установку угла n. Значение n может лежать в
      ------- диапазоне от 0 до 3, где 0 соответствует 0 градусов, 1-90
      градусам, 2-180 градусам и 3-270 градусам. 
         TAn - обеспечивает поворот на  n  градусов.  Значение  n может
      -------  находится  в  диапазоне от -360 до +360 градусов. Если n
      положительно,  поворот  осуществляется  против часовой стрелки, а
      если   n-отрицательно,   то  по  часовой  стрелке.  Значения  вне
      законного диапазона вызывают ошибку 5 периода прогона. 
         Cn   -  обеспечивает  вычерчивание  в  цвете  n.  Относительно
      -------  диапазона  n  сверяйтесь  с  оператором PALETTE в каждом
      режиме   отображения.  Цветом  по  умолчанию  является  наивысший
      законный атрибут. 
         Sn  - обеспечивает установку масштабного коэффициента как n/4,
      ------ где n может лежать в диапазоне от 0 дo 255. Например, если
      n=8,    масштабный   коэффициент   равен   2.В   операторе   DRAW
      осуществляется  умножение  масштабного  коэффициента на аргументы
      при  U,  D,  L,  R, E, F, G, H и относящихся к ним командам М для
      определения  крайнего  размера  обьектов. По умолчанию n равно 4,
      что    дает   масштабный   коэффициент   равный   1   (т.е.   без
      мастабирования). Видовое отношение дисплея которым вы пользуетесь
      определяется  взаимосвязью  X  и  Y. На идеальном, несуществующим
      дисплее  с  видовым отношением 1/1 точка в направлении X имеет ту
      же   длину,   что   и   в   направлении  Y.  Однако  дисплеи  для
      IBM-компьютеров имеют следущие видовые отношения: 
      ----------------------------------------------------------------
       Монитор-адаптер  Экран 1  Экран 2  Экран 7/8/9   Экран 10
      ----------------------------------------------------------------
          Цветной       5/6        5/12       нет          нет
          Улучшенный    5/6        5/12       8.76/12      нет
        Улучшенный моно нет        нет        нет        9.57/12
      ----------------------------------------------------------------
         X   VARPRT$(переменная)   обеспечивает  исполнение  субстроки,
      т.е.  исполняет вторую командную строку из первичной DRAW строки.
      X-команда в чем-то подобна GOSUB; например: 
             DRAW "X"+VARPRT$(x$)
         P  цвет,  граница  стартует  на  текущей  (x,y)  координате  и
      обеспечивает  заполнение  цветом  ЦВЕТ,  останавливаясь  на зонах
      цвета ГРАНИЦА. 
         В каждом случае аргумент n, x или y может быть либо константой
      либо переменной в форме 
             =VARPRT$(переменная);
             Например:
             DRAW "e15"
             то же ,что и
             а=15
             DRAW "e="+VARPRT$(a)
         DRAW  игнорирует  пробелы в своей командной строке - вы можете
      пожелать использовать их, чтобы сделать вашу DRAW-программу более
      читабельной. 

      Ограничения      Турбо -  Бейсик не распознает имена переменных в
      -----------      DRAW  строках.  Поэтому  вы должны для доступа к
      содержимому  переменных  в  пределах DRAW-строки во время прогона
      пользоваться  VARPRT$(n).  Вместо  DRAW  "U=I%"  используйте DRAW
      "U="+VARPRT$(I%) 

      Пример:
             screen 1            
             домик$="u20 c5 e20 h5 d20 l30
             draw домик$
             draw "be3"
             draw "p1,3"
             for i%=1 to 280 step 40
               draw "m="+varprt$(i%)+",40"
               draw домик$
             next i%
             end

                                 Оператор END
                                 ------------

      Функция         END завершает исполнение программы или определяет
      --------        конeц структурного блока. 

      Синтаксис       END[{DEF!IF!SELECT!SUB}]
      ---------

      Замечания       END   без   аргументов    завершает    исполнение
      ---------       программы.   Оператор  END  можно  размещать  где
      угодно  в программе и их может быть более одного. Обнаружение END
      вызывает  закрытие прораммой всех открытых файлов и возврат в DOS
      (или  в  Турбо-Бейсик, в зависимости от того откуда была запущена
      программа  в  работу). END компилятором строго не требуется, хотя
      практически   его   использовать  рекомендуется.  Если  программа
      выходит, исполнив все операторы, достигается тот же эффект. 
         END,  за  которым  следуют резервированные слова DEF, IF, SUB,
      SELECT, определяют конец структурного блока.
         См.также
             DEF
             IF
             SELECT
             STOP
             SUB

         Пример:
             sub Пустая Проц
             print "алло"
             endsub
             def fn Пустая Функц$
             end def
             input  "Исполнить процедуру или функцию [1или2]"; Который%
                     if Который%> 0 then 
             select case Который%
                 case 1
                   call Пустая Проц
                   end
                 case 2
                   print fnПустая Функц$
                   end
                 case else
                  print "Был сделан незаконный выбор"
                end select
             end if
             end


                               Оператор ENDMEM
                               ---------------

      Функция          ENDMEM возвращает адрес конца физической памяти.
      -------

      Синтаксис        y=ENDMEM
      ---------

      Замечания        ENDMEM возвращает длинное целое, представляющего
      ---------        адрес последнего байта физической памяти. ENDMEM
      в   сочетании   с   MEMSET   можно  использовать  для  размещения
      пространства  в  высокой памяти для программ на языке ассемблера.
      Пока  используется  программа,  находящаяся  в  памяти,  ENDMEM в
      действительности возврващает конец физической памяти минус размер
      символьной     таблицы.     Когда    Турбо-Бейсик    осуществляет
      компилирование  в  память,  он  обеспечивает  хранение символьной
      таблицы по наивысшему адресу памяти. 
      См.также MEMSET

      Пример     PRINT "Конец адресуемой памяти равен:",endmem
                 end


                               Оператор ENVIRON
                               ----------------

      Функция          ENVIRON модифицирует информацию в таблице среды.
      -------

      Синтаксис        ENVIRON строчное выражение
      ---------

      Замечания        Строчное  выражение  определяет  имя  параметра,
      ---------        подлежащего  изменению, добавлению или стиранию,
      и  собственно  информацию о новом параметре. Эти две части должны
      разделятся  знаком  равенства  (=).  ENVIRON  и  родственная  ему
      функция  ENVIRON$ используютяс для конфигурации среды, подлежащей
      подаче  в  программы,исполняемые через оператор SHELL. (Подробную
      информацию  см.  в  описании  оператора  SHELL  и  команды  SET в
      справочном руководстве по DOS) . 
      Например:
                      ENVIRON "PATH=\TURBOBAS"
      устанавливает DOS-параметр PATH на "TURBOBAS". Следовательно про-
      пущенная через SHELL копия COMMAND.COM будет автоматически искать
      справочник \TURBOBAS для нахождения файлов, которых нет в текущем
      справочнике. Чтобы стереть параметр из таблицы среды, после знака
      рквенства ставится только двоеточие (:): 
                      ENVIRON "PATH=:"
      стирает из таблицы среды параметр прохода(PATH)

      Ограничения      Вы не можете расширять пространство среды. Чтобы
      -----------      добавлять   новые  входы  вы  должны  освободить
      пространство, стирая существующие входы. 
      См. также   ENVIRON$
                  SHELL

      Пример      PRINT ENVIRON$("PATH")
                  ENVIRON "PATH=\"


                               Функция ENVIRON$
                               ----------------

      Функция          ENVIRON$ выдает параметр таблицы среды
      -------

      Синтаксис        s$=ENVIRON$(строка параметров)
      ---------        s$=ENVIRON$(n)

      Замечания        Строка   параметров - это  строчное   выражение,
      ----------       содержащее  параметр, подлежащий выдаче. n-целое
      выражение  в  диапазоне  от  1  до 255. ENVIRON$ и родственный ей
      оператор   ENVIRON   используются   для  конфигурирования  среды,
      подлежащей подаче в программы, используемые через оператор SHELL.
      Если  используется  строчный аргумент, ENVIRON$ возвращает текст,
      который  следует  за  строкой параметров в таблице среды. Следует
      заметить   ENVIRON$  делает  различие  букв  верхнего  и  нижнего
      регистров. Если строка параметров не обнаруживается или за знаком
      равенства  никакой  текст  не  следует, возврашается нуль-строка.
      Если  используется  числовая  форма,  ENVIRON$ возвращает строку,
      содержащую  n-ый  параметр,  считая  от начала таблицы. Если n-го
      параметра нет, возвращается нуль-строка. 


                                 Функция EOF
                                 -----------

      Функция          EOF     возвращает   состояние   конца    файла.
      -------

      Синтаксис        y=EOF(ФайлНом)
      ---------

      Замечания        ФайлНом - это значение, специфицированное  при
      ---------        открытии  файла.  EOF возвращает TRUE (-1), если
      на  специфицированном  файле  был  достигнут  конец  файла; иначе
      возвращается  FALSE  (0). EОF законна только для дисковых файлов,
      открытых  для  последовательного доступа и для коммуникационных
      файлов. Возвращение функцией EOF (-1) для коммуникационных файлов
      означает, что буфер пуст. 

      Пример     OPEN "TEXT.DTA" FOR INPUT AS #1
                 верх:
                 IF EOF(1) THEN
                 PRINT C"записей (строк) в файле TEXT.DTA"
                 ENDIF
                 INPUT#1,пусто$
                 C=C+1
                 GOTO верх
                 'или ,более элегантно
                 OPEN "TEXT.DTA" FOR INPUT AS #1
                 WHILE NOT EOF(1)
                 INPUT#1 пусто$
                 INCR c
                 WEND
                 PRINT c" записей (строк в файле TEXT.DTA":END




                                Функция ERADR
                                -------------

      Функция          ERADR  возвращает  адрес самой последней ошибки.
      -------

      Синтаксис        y=ERADR
      ---------

      Замечания        ERADR  возвращает  значение   длинного   целого,
      ---------        представляющего    положение   самой   последней
      ошибки.  ERADR  есть  некоторое  значение  программного счетчика,
      которое  выводилось  бы,  но не выведено, поскольку не включилось
      отслеживание   ошибок   (т.е.   его   можно   можно  использовать
      посредством  включения выбора ошибок из меню опций для нахождения
      положения в исходной программе того оператора, которое генерирует
      ошибку). 

         ERADR  предназначена  в  качестве  функции некоторой последней
      пересортировки  в  подпрограммах  обработки ошибок. Если какая-то
      подпрограмма  ошибок не располагает  схемой  обработки конкретной
      ошибки,  вы,  по  крайней мере, можете вывести код ошибки (ERR) и
      ERADR  на  экран,  и таким образом сообщить вашим пользователям о
      необходимости отчитаться о случившимся.
         См.также  ERL
                   ERR
                   ERROR
                   ON ERROR

      Пример    ON ERROR GOTO ЛОВУШКА
                DIM X%(10)
                FOR I%=1 TO 10
                READ X%(I%) 'СЧИТАТЬ X 10 РАЗ
                PRINT X%(I%) '
                NEXT I%
                'В ПАМЯТИ НЕДОСТАТОЧНОЕ ЧИСЛО ЭЛЕМЕНТОВ ДАННЫХ
                DATA 1,2,3,4,5,6,7
                END 'СЛЕДУЮЩИЙ ОБРАБОТЧИК ОШИБОК ВЫВОДИТ НОМЕР И АДРЕС
                     ОШИБКИ
                ЛОВУШКА :
                LOCATE 10,15
                'ВЫВЕСТИ СООБЩЕНИЕ В СЕРЕДИНЕ ЭКРАНА
                PRINT "ОШИБКА ТИПА "ERR" ПРОИЗОШЛА ПО АДРЕСУ "ERADR
                LOCATE 11,15
                PRINT "ПОЖАЛУЙСТА, ОТМЕТЬТЕ ЭТИ ЗНАЧЕНИЯ И СВЕРТЕСЬ С
                    РУКОВОДСТВОМ"
                END


                                Оператор ERASE
                                --------------

      Функция    ERASE     стирает  динамические  массивы  и  повторно
      -------              устанавливает статические.

      Синтаксис  ERASE имя массива[,имя массива]...
      ---------

      Замечания        Имя  массива  -  это  имя   того   массива(вов),
      ---------        который   вы  желаете  повторно  установить  или
      исключить  из  размещения. Следует заметить, что пустые скобки не
      должны  входить  в  ИМЯ  МАССИВА.  Если  ИМЯ  МАССИВА относится к
      динамическому  массиву, его пространство в памяти освобождается и
      это  имя  массива  в дальнейшем можно образмерить вновь с помощью
      другого  оператора  DIM.Если ИМЯ МАССИВА относится к статическому
      массиву,  при  стирании  с  помощью  ERASE  его  элементы  просто
      очищаются в 0 (или в нуль-строку, для строчных массивов).

      Ограничения      Вы не можете стереть массив, который никогда  не
      -----------      существовал,  или в случае динамических массивов
       уже был стерт. 

      Различия         Турбо - Бейсик   дает   возможность     создания
      --------         статических     массивов,     которые    быстрее
      динамических  массивов.  Интерпретаторный Бейсик допускает только
      динамические массивы. 
      См.также CLEAR
               DIM
               $DYNAMIC
               FRE
               $STATIC

      Пример      ON ERROE GOTO ОшибокОбработчик
                  PRINT FRE(-1)
                  DIM DYNAMIC БольщойМассив(10000)
                  БольшойМассив(6666)=66
                  PRINT FRE9-10
                  ERASE БольшойМассив
                  PRINT FRE(-1) 
                  'этот   оператор   будет   возвращать   ошибку,  если
                          программа будет 
                  'прогоняться с включенной проверкой границ
                  PRINT БольшойМассив(6666)
                  END
                  Ошибок Обработчик:
                  PRINT "ошибка типа "ERR
                  PRINT "произошла по адресу "ERADR
                  END
