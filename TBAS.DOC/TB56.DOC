
                               Заявление LOCATE
                               ----------------

      Функция   LOCATE    позиционирует курсор и/или определяет форму
      -------             курсора. 

      Синтаксис  LOCATE [ред] [,[колонка] [,[курсор][,пуск][,останов]]]
      ---------

      Замечания        Ряд - это целое выражение, определяющее  строку
      ---------        экрана,  в   которой  должен  позиционироваться
      курсор  (1-25).  Колонка  специфицирует  колонку (1-80). Курсор -
      числовое  значение,  которое  управляет тем, будет или нет курсор
      видимым   (0-означает   невидимый;   1-видимый).   25-ая   строка
      недоступна,  если  не выведено из активного состояния отображение
      фун- кциональных клавиш (см. о заявлении KEY OFF). 

         Пуск  и  останов  -  это  целые  выражения,  которые управляют
      размером  курсора  и  представляют сколь много строк сканирования
      будет  занимать  курсор.  Верхней  строкой  сканирования является
      строка  0;  нижней - строка 7 для цветных/графических Адаптеров и
      строка 13 для монохромных адаптеров.
         LOCATE  наиболее часто используется перед заявлением PRINT для
      управления прохождением вывода на экран.
         См. также     KEY OFF
         ---------
                       PRINT

      Пример:  CLS
               CRSLIN и POS
               INPUT "Ввести координаты X и Y:", X%, Y%
               'позиционировать курсор и изменить его форму
               LOCATE X%,Y%,1,4,5
               PRINT "Hi";
               WHILE NOT INSTAT: WEND  "ждать клавишу
               END   ' конец программы

                                ФУНКЦИЯ   LOF
                                -------------

      Функция     LOF     возвращает длину файла.
      -------
      Синтаксис   y =LOF(файланом)
      ---------
      Замечания        файланом  -  это  номер, под которым  был открыт
      ---------        файл.  LOF  возвращает  длину указанного файла в
      байтах.   Для  коммуникационных  файлов  LOF  возвращаетт  размер
      наличного пространства в коммуникационном буфере.
       Пример:  OPEN"TB.EXE" FOR BINARY AS#1
                PRINT "Размер турбо-Бейсика равен";LOF(1)
                CLOSE #1
                END

                           Функция LOG, LOG2 и LOG10
                           ------------------------

      Функция    LOG      возвращает натуральный (с основанием е) лога-
      -------             рифм;  LOG2  возвращает логарифм основания 2;
                          LOG10 - логарифм основания 10.

      Синтаксис       LOG:
      ---------
                      y=LOG (числовое выражение)
                      LOG2:
                      y=LOG2(числовое выражение)
                      LOG10:
                      y=LOG10(числовое выражение)

      Замечания  LOG   возвращает  натуральный  логарифм  (с основанием
      ---------        е, где  е=2,71828182845904523...)  своего  аргу-
      мента. Если числовое выражение меньше  или  равно  0,  это   дает
      ошибку 5 периода прогона, вызов незаконной  функции.  Натуральный
      логарифм  x  есть  показатель  степени,  в  которую  должно  быть
      возведено  основание е для  получения значения x. 
          LOG,LOG2 и LOG10 возвращают результат двойной точности.
      Пример:   FOR I!=1 TO 50 STEP 2.5
      ------    PRINT USING "Натуральный логарифм ##=## : I!, LOG(I!)
                 NEXT I!
                 END        'конец программы

                            Функция LPOS
                            ------------

      Функция   LPOS   возвращает "курсорную позицию" буфера печатающе-
      -------          го устройства.
      
      Синтаксис   y=LPOS (печатающее устройство)
      ---------

      Замечание        Печатающее устройство - это целое выражение от 0
      ---------        до 3, обеспечивающее выбор печатающего устройст-
      ва из следующего списка:
                  0,1          LPT1
                  2            LPT2
                  3            LPT3

         LPOS сообщает сколько литер уже послано на печатающее устройс-
      тво с момента вывода последней литеры возврата каретки.
         См. также  POS
      Пример: 
               'назначить ширину печатающего устройства
               'для именованных констант
                %Шир = 80
               'отобразить литеры ASCII и расширенного ASCII
               'на экране и печатающем устройстве.
                FOR I%=0 TO 255
                IF (I%>32) THEN
                  PRINT USING "1"; CHRS(I%);
                END IF
                'передвинуться на следующую строку, если имеет место 
                'выход за отведенное пространство
                IF LPOS(0)=%Шир THEN
                  LPRINT CHRS(13)+CHRS(10)
                END IF
                NEXT I%
                END  конец программы

                  Заявления LPRINT, LPRINT USING
                  ------------------------------

      Функция   LPRINT и LPRINT USING посылает данные на печатающее ус-
      -------                         тройство  (LPT1:).

      Синтаксис    LPRINT [список выражений [;] ]
      ---------    LPRINT USING формат строка; список выражений

      Замечания        Список выражений - это ряд числовых и/или строч-
      ---------        ных выражений разделяемых запятыми либо точкой с
      запятой. Формат-строка содержит  информацию о формате печати.
         LPRINT и  LPRINT  USING  выполняют  те-же  действия, что PRINT
      и PRINT USING, за исключением того,что список выражений посылает-
      ся  на  печатающее  устройство, а не на экран.
         Примечание:  По  умолчанию  Турбо-Бейсик  вставляет пару возв-
      рат каретки/подача  строки  после  распечатки  в  одной строке 80
      литер.
         Эта характеристика  может  быть  изменена  с помощью заявления
      WIDTH (ширина).
         См. также  LPOS
                    PRINT
                    PRINT USING
                    WIDTH

      Пример:   LPRINT USING"## -это мое счастливое число"; 7
                END


                           Заявление LSET
                           --------------

      Функция   LSET    перемещает срочные данные в буфер произвольного   
      -------           файла.
      
      Синтаксис   LSET переменная поля = строчное выражение
      ---------
      Замечания        LSET и родственное ему заявление RSET перемещают
      ---------        строчную информацию в переменные поля, определя-
      емые как  принадлежащие  буферу  произвольного файла.
         Если длина строчного выражения меньше размера переменной поля,
      специфицированной в заявлении FIELD, LSET выравнивает его в левую
      сторону  этого поля, заполняя оставшуюся часть пробелами.
         Это означает, что пробелы  добавляются  после последней литеры
      строчного выражения, так что после LSET- назначения LEN (перемен-
      ной поля) становится  равной ширине, определенной в соответствую-
      щем заявлении FIELD.
         RSET осуществляет выравнивание с помощью пробелов вправо (про-
      белы добавляются перед первой литерой строчного выражения).
         LSET и RSET могут также использоваться для  форматообразования
      вывода  на экран или печатающее устройство.
      Пример:
                а $=$ (20)
                RSET a$="Правое выравнивание"
                PRINT a$

         См. также  FIELD
                    LEN
                    RSET

      Пример:
       OPEN "LSET.DTA" AS#1 LEN=18      
       'Определить имена и размеры полей файла
       FIELD1,2 AS Файл цел $, 4 AS Файл  Длин $, - 4 AS Файл Един $,_
       & AS Файл Двойн $
       'назначить переменные полей и осуществить запись в файл 
       'произвольного  доступа
       FOR Счетчик% =1 TO S
       LSET Файл Цел $=MX1$ (счетчик %)
       LSET Файлдлин$=MXL $(счетчик %^2)
       LSET Файлtlby$=MXS $(счетчик %^2.1)
       lset ФайлДвойн$=MXD $ (счетчик %^4.4)
       PUT 1,счетчик %
       NEXT счетчик %
       CLOSE 1      'закрыт файл
       END          'конец главной программы

                        Заявление  MEMSET     
                        -----------------

      Заявление  MEMSET    заявляет верхнее ограничение памяти
      ---------

      Синтаксис  MEMSET адрес
      ---------

      Замечание        Адрес -это длинное целое выражение, определяющее
      ---------        абсолютный адрес  верхней  границы памяти Турбо-
      Бейсика. Адрес должен быть меньше  количества памяти, установлен-
      ной в системе. Практически адрес обычно вычисляется путем вычита-
      ния  некоторой  константы  из  значения,  возвращаемого  функцией
      ENDMEN.
         MEMSET сконструировано для установки отдельной памяти для под-
      программы  на  языке ассемблера. Если Турбо-Бейсик не в состоянии
      удовлетворить запрос в  силу  либо  неподходящего аргумента, либо
      недостаточности  памяти, возникает  ошибка 7 периода прогона, вне
      памяти.
         См. также  ENDMEN
      Пример:
       PRINT FRE (-1) 'отобразить наличное пространство для массивoв
       'хранить 128 байтов в верхней части памяти
       MEMSET ENDMEN - &H80
       PRINT FRE (-1)  'отобразить наличную память
       END              'конец программы

                            Заявление MID$
                            --------------

      Функция    MID$    возвращает литерную строку.
      -------
      Синтаксис  S$=MID$ (строчное выражение, n[,m] )
      ---------
      Замечания        n и m - это  числовые  переменные или выражения,
      ---------        которые  могут лежать в  диапазоне от 1 до 32767
      и от щ до 32767 соответственно.
         MID$ как функция, возвращает m-литерную строку, начиная с n-ой
      литеры строчного  выражения. Если m опускается или справа от n-ой
      литеры строчного выражения менее m литер, выдаются остальные  ли-
      теры  строчного  выражения  вплоть  до  n-ой и включая ее. Если n
      больше длины строчного выражения, MID$  возвращает нуль-строку.
         См. также     LEFT$
                       Заявление MID$
                       RIGHT$
      Пример:
                 INPUT 'Ввести строку:", Пустая стр$
                 Врем.Стр$ = Пустая Стр$
                 PRINT Пустая Стр $
                 'резервировать порядок литер, используя функцию и 
                 'заявление  MID$ одновременно.
                 FOR I% = 1 TO LEN (Пустая стр%)
                 MIDS (Пустая Стр %, I%,1) = MIDS (Врем Стр $,-_
                 (LEN (Врем Стр $)- I%) + 1,1)
                 NEXT I%
                 PRINT Пустая Стр%
                 END    'конец программы


                            Заявление MID$
                            --------------

      Функция   MIDS       замена литеры строки
      -------

      Синтаксис MID$ (строчнаая переменная, n[,m] )= строка-замена
      ---------
      Замечание        n  и  m - это числовые переменные или выражения,
      ---------        которые  могут  находиться  в  диапазоне от 1 до
      32767 и от 0 до 32767,соответственно.
         Как заявление, MID$ заменяет m литер строчной переменной,  на-
      чиная с литерной позиции n, сожержимым строки-замены.
         Если m включается, оно определяет сколько  литер строки-замены
      вставляется в строчную переменную.  Если опускается, используется
      вся  строка-замена. MID$ никогда не изменяет длину строки.
         См. также    LEFT$
                      Функция MID$
                      RIGHT$
      Пример:
              'MID$, заявление
              в $ = "Ураган Камилла"
              MID$ (в $,8) = "Карла--"  'опущен опциональный параметр m
              PRINT в $


                             Заявление MKDIR
                             ---------------

      Функция   MKDIR создает субсправочник (подобно DOS-команде MKDIR)
      -------
      
      Синтаксис MKDIR проход
      ---------

      Замечания        Проход -это строчное выражение, описывающее под-
      ---------        лежащий созданию справочник  (см.  информацию об
      именах и проходах файлов в главе 4)
         MKDIR (делать справочник) создает субсправочник, специфицируе-
      мый проходом.  Если  вы пытаетесь создать справочник, который уже
      существует, возникает  ошибка 5 периода прогона, вызов незаконной
      функции.

      Пример:
          'построить обработчик ошибок
          ON ERROR GOTO Спр ошибка
          PRINT "Пожалуйста введите справочник который вам нравится";
          INPUT "Создать:", Спр Имя $
          MKDIR Спр Имя $   'создать справочник
          END                'конец программы
       СпрОшибка:
       '---------
          PRINT "Возникла проблема в создании справочника"
          END

                   
                   Функции MKI$, MKL$, MKS$, MKD$
                   ------------------------------

      Функция  MKI$, MKL$, MKS$, MKD$ преобразуют числовые данные в
      -------              строки (для вывода в произвольные файлы)
      
      Синтаксис    S$=MKI$ (целое выражение)
      ---------    S$=MKL$ (длинное целое выражение)
                   S$=MKS$ (выражение единичной точности)
                   S$=MKD$ (выражение двойной точности)

      Замечания        Функция  MK (делать)  представляет  собой  часть
      ---------        процесса обработки получения числовых значений в
      файлы произвольного доступа. Поскольку заявления, которые записы-
      вают информацию в буфер произвольного файла (LSET и RSET) работа-
      ют только со строками, числовые  данные  должны  транслироваться,
      перед их обработкой заявлением PUT в произвольный  файл, в строч-
      ную форму.  MKI$(i)  возвращает двухлитерную строку, состоящую из
      двух битовых  значений, которые Турбо-Бейсик использует для внут-
      реннего представления  целого значения i. Функция MKL$ возвращает
      4-байтовый строчный эквивалент длинного целого.  MKS$  возвращает
      4-байтовый эквивалент значения единичной точности. MKD$ возвраща-
      ет 8-байтовый строчный эквивалент значения двойной точности.  До-
      полнительные функции CVI, CVL, CVD используются, когда произволь-
      ные  файлы считываются. Не путайте эти функции с STR$ и  VAL, ко-
      торые соответственно  обращают числовые выражения в распечатывае-
      мые формы и наоборот:
       i=123.45
       a$=STR$(i): в$=MKS$(i)
       'a$ содержит что-то, стоящее размещения на экране;
       'в$ - не содержит
       PRINT a$, в$
         
         См. также    СVD
                      CVI
                      CVL
                      CVS
      
      Пример:
              OPEN "MKILSD.DTA" AS#1 LEN=18
              'определить имена и размеры полей
              FIELD 1, 2AS файла цел$, 4AS файла длин$,_
              4AS файла един$,  8AS файла двойн$
             'назначить значения полям и осуществить запись в файл 
             'произвольного доступа
             FOR счетчик%  = 1TOS
             LSET Файла Цел$= MKI$ (счетчик%)
             LSET Файла Длин$= MKL$ (счетчик %^2)
             LSET Файла Един$=MKS$ (счетчик %^2.1)
             LSET Файла Един$=MKD$ (счетчик %^4.4)
             PUT 1, счетчик %
             NEXT счетчик %
             CLOSE 1        'закрыть файл
             END            'конец главной программы



                           Функции MKMD$,MKMS$
                           -------------------

      Функция  MKMD$  и  MKMS$   преобразуют числовые данные в строки
      -------                    формата Микрософт.
      
      Синтаксис       S$=MKMS$ (выражение единичной точности)
      ----------      S$\MKMD$ (выражение двойной точности)

      Замечания        Функции MKM  (делать  Микрософт)  предусмотрены
      ---------        лишь для совместимости  с существующими произво-
      льными файлами, которые  содержат значения  с  плавающей точкой в
      формате Микрософт.
         MKMS$  создает 4-байтовую строку формата Микрософт из значения
      единичной точности; 
         MKMD$ делает 8-байтовую Микрософт - форматную строку из задан-
      ного значения двойной точности.

         См.также    CVMD
         --------    CVMS

      Пример:
                    'открыть файл произвольного доступа
                    OPEN "CVMD.DTA" AS#1 LEN=12
                    FIELD#1, 4AS Единич.$, & AS Двойная $
                    МаксЦелое% =32767
                    FOR I%=1 TO 5 'записать данные в файл
                    LSET ДвойнаяS = MKMD$ (I%+МаксЦелое %)
                    PUT#1, I%
                    NEXT I%
                    FOR I% = 1TO 5  'читать данные из файла
                    GET#1, I%       'отобразить на экране
                    PRINT CVMS (Единичная$), CVMD (Двойная $)
                    NEXT I%
                    CLOSE#1        'закрыть файл
                    END            'конец программы



                        Функция и заявление MTIMER
                        --------------------------

      Функция   MTIMER   считывает или повторно устанавливает 
      -------            микротаймер.
      
      Синтаксис       Функция:       y=MTIMER
      ---------       Заявление:     MTIMER

       Замечания       MTIMER сконструированы  для  измерения истекшего
       ---------       времени, главным образом для очень коротких опе-
       раций.  Это дает значительное улучшение разрешающей способности;
       однако точность резко падает по истечение 54  миллисекунд.
          Как функция  MTIMER  возвращает число микросекунд, истекших с
       момента самого последнего заявления MTIMER.Точность MTIMER лежит
       в пределах примерно двух микросекунд.  Как заявление MTIMER пов-
       торно устанавливает микротаймер в ноль.

       Ограничения     Заявление  и функция MTIMER используются в паре.
       -----------     Вы должны выдать заявление  MTIMER, а затем выз-
       вать функцию для получения  результата.  Последующие  ссылки  на
       зту функцию будут давать значение ноль, если вы вновь  не запус-
       тили микротаймер с помощью заявления MTIMER. MTIMER и SOUND/PLAY
       используют  канал 2 таймерного типа 8255 и яиляются взаимоисклю-
       чающими. Поэтому исполнения заявленной SOUND или PLAY между  за-
       явлениями  и  функцией MTIMER вынудит повторную установку микро-
       таймера на ноль истекшего  времени.

       Пример:
                      'возбудить таймер
                      MTIMER
                      PI#=ATN(1) * 4     'вычислить "пи"
                      'получить значение таймера
                      Истекшее Время % = MTIMER
                      PRINT USING "Израсходовано #### миллисекунд";
                      PRINT "на расчет значения "пи" "
                      END   'конец программы



                       Заявление NAME
                       --------------

      Функция    NAME      Обеспечивает переименование файла
      -------              (подобно DOS-функции  REN)

      Синтаксис            NAME файласпец1AS файласпец2
      ---------

      Замечания        Файласпец1 и файласпец2 -это строчные выражения,
      ---------        удовлетворяющие DOS-соглащениям об  наименовании
      проходов и файлов.  Операция  NAME  обеспечивает передачу данных,
      представляющих файлспец1,  файлу  с  именем  файлспец2.  Так  как
      файлспец2 может содержать имя прохода, существует возможность пе-
      ремещения данных из одного справочника в другой,  но до тех  пор,
      пока вы не пытаетесь осуществить перенаименование с одного диска 
      на другой.

      Пример:
                 INPUT "Введите имя файла для перенаименования:",
                 Старое имя $
                 INPUT "Введите новое имя файла:", Новое имя $
                 выдаются старое имя $, Новое имя $
                 NAME Старое имя $ AS Новое имя $
                 END        ' конец программы



                       Функция OCT$
                       ------------

      Функция   OCT$   возвращает строку, представляющую  восьмеричную
      -------          (с основанием 8) форму числового выражения.

      Синтаксис    S$=OCT$ (числовое выражение)
      ----------

      Замечания        Числовое  выражение  находится  в  диапазоне  от
      ---------        -32768  до  65535. OCT$ возвращает строку, пред-
      ставляющую  восьмеричную форму своего целого аргумента. Если чис-
      ловое выражение имеет дробную часть,  перед  преобразованием  оно
      округляется. Для преобразования значений в  шестнадцатиричные или
      двоичные строки применяйте функции HEX$ и BIN$, соответственно.

         См.также        BIN$
                         HEX$

      Пример       PRINT OCT$(-1)
                   PRINT OCT$(65535)



                         Заявление ON COM(n)
                         -------------------

      Функция  ON COM(n)    заявляет  подпрограмму отслеживания событий 
      -------               на последовательном входном устройстве.

      Синтаксис     ON COM(n) GOSUB метка
      ---------
      Замечания        n-это номер (1 или 2) коммуникационного адаптера
      ---------        (последовательного  входного устройства), подле-
      жащего считыванию. Метка  идентифицирует  подпрограмму отслежива-
      ния. Если метка есть номер О особой строки, отслеживание запреща-
      ется.
         Заявление ON COM(n) не оказывает действия до тех пор, пока ко-
      ммуникационные события не оказываются доступными данному последо-
      вательному входному устройству, что обеспечивается подходящим за-
      явлением COM ON.  Если  заявление  COM ON  однажды уже исполнено,
      проверка имеет место между исполнениями  каждого следующего заяв-
      ления с целью установить, не поступила ли  какая-либо  литера  на
      специфицированное  последовательное  входное устройство. Если это
      произошло, выполняется GOSUB к назначенной подпрограмме.

         См. также      Приложение В,"Отслеживание событий"
       

                         Заявление ON ERROR
                         ------------------

      Функция   ON ERROR   специфицирует стандартную программу обработ-
      -------              ки ошибок и включает отслеживание ошибок.

      Синтаксис       ON ERROR GOTO метка
      ---------

      Замечания        Метка идентифицирует первую строку  подпрограммы
      ---------        отслеживания ошибок. Однажды включенная обработ-
      ка ошибок с помощью этого заявления обеспечивает переход к вашему
      коду  обработки  ошибок  при  возникновении  любых ошибок периода
      прогона вместо обычного отображения сообщения об ошибке и прекра-
      щения исполнения. Для продолжения исполнения  используйте заявле-
      ние RESUME (возобновить).
         Чтобы  запретить  отслеживание  ошибок  используйте   ON ERROR
      GOTO O. Вы  можете  воспользоваться  этим приемом, если возникает
      ошибка,  для  которой  у  вас  нет  определенного прохода на вос-
      становление; вы также можете остановить свой выбор на отображении
      в этот момент содержимого ERL  (строка  последней ошибки).
         Если вы  прогоняете  EXE-программу из DOS с выключенным отсле-
      живанием ошибок, любая ошибка периода прогона вызывает выдачу со-
      общения  о  ее  возникновении и прекращение исполнения программы.
      Сообщение имеет форму:
               EROR ошибкином at pgm-ctr = адрес
             (ошибка)          (при программном счетчике)
         Если программа запущена в рамках  Турбо-Бейсика  и  происходит
      ошибка, вы  переводитесь  в  редактор на местоположение ошибки. В
      строке состояний будет содержаться краткое описание ошибки перио-
      да прогона:
         ERROR ошибкином : сообщение об ошибках
         (ошибка)

         См. также    ERADR
                      ERL
                      ERR
                      ERROR
                      RESUME

      Пример:    'настроить обработчик ошибок
                 ON ERROR GOTO ошибок обработчик
                 WHILE I  'этот цикл оканчивается ошибкой
                 I =10/0  'это вызывает ошибку периода прогона
                 WEND
                 Ошибок обработчик
                 ------------------
                 PRINT "Обработчик захватил ошибку периода прогона"
                 PRINT ERR, "в строке" ERL
                 END


                           Заявление ON/GOSUB
                           ------------------

      Функция    ON/GOSUB    вызывает одну из нескольких возможных под-
      -------                программ  в соответствии со значением чис-
                             лового выражения.

      Синтаксис              ON n GOSUB метка [,метка]....
      ---------

      Замечания        n - это числовое выражение  в  диапазоне от 0 до
      ---------        255, а метка идентифицирует заявление на ветвле-
      ние к ней. n определяет к какой  из меток  осуществляется переход
      (например если n=4, получает управление четвертая метка в списке).
      Если n равно 0 или больше, чем число меток в списке, Турбо-Бейсик
      продолжает исполнение следующего по порядку заявления.
         Каждая подпрограмма должна оканчиваться ключевым словом RETURN
      для  обеспечения  возобнавления с того заявления, которое следует
      непосредственно за заявлением ON/GOSUB.
         Многопутевое ветвление может также реализоваться с помощью за-
      явлений  SELECT  и  IF - блоковое, причем  они  более гибкие, чем
      ON/GOSUB.

      Пример:
         FOR I% = 1 TO 3
         ON I% GOSUB обработчик один, обработчик два, обработчик три
         NEXT I%
         END     'конец главной программы
         Обработчик один
         ----------------
         PRINT "Обработчик номер" , I%
         RETURN
         Обработчик два
         ----------------
         PRINT "Обработчик номер", I%
         RETURN
         Обработчик три
         ---------------
         PRINT "Обработчик номер", I%
         RETURN


                        Заявление ON/GOTO
                        -----------------

      Функция    ON/GOTO      направляет программный поток по одному из
      -------                 нескольких  возможных  мест назначения на
                              основе значения числового выражения.

      Синтаксис               ON n GOTO метка [,метка]....
      ----------

      Замечания        n - это  числовое выражение в диапазоне от  0 до
      ---------        255, а метка идентифицирует заявление  программы
      на ветвление к ней.  n определяет к какой из меток осуществляется
      переход (например, если n=4 то управление получает четвертая мет-
      ка в списке).
         Если  n равно нулю или больше числа меток в списке, Турбо-Бей-
      сик продолжает исполнение следующего по порядку заявления.
         С большей гибкостью многопутевое ветвление может быть реализо-
      вано  с помощью заявлений SELECT и IF-блоковое.

      Пример:
          FOR I% =1 TO3
          ON I% GOTO обработчик один,обработчик два, обработчик три
          Обратно:
          NEXT I%
          END     'конец главной программы
          Обработчик один
          ----------------
          PRINT "Обработчик номер", I%
          GOTO обратно:
          Обработчик два
          ---------------
          PRINT "Обработчик номер"
          GOTO Обратно:
          Обработчик три
          ----------------
          PRINT "Обработчик номер", I%
          GOTO Обратно


                        Заявление ON KEY (n)
                        --------------------

      Функция  ON KEY (n)    заявляет подпрограмму отслеживания с целью
      -------                получения  его управления, если нажимается
                             особая клавиша.

      Синтаксис    ON KEY (n) GJSUB метка
      ---------
      Замечания        Метка идентифицирует первое значение подпрограм-
      ---------        мы отслеживания, а n - это целое выражение в ди-
      апазоне от 1 до 20, которым  описывается  подлежащая отслеживанию
      клавиша в соответствии со следующей таблицей.
       ---------------------------------------------------------------
            n                    Клавиша
       ---------------------------------------------------------------
          1-10        Функциональные клавиши F1-F10
           11         Курсор вверх
           12         Курсор влево
           13         Курсор вправо
           14         Курсор вниз
          15-25       Клавиши, определяемые заявлением KEY
           30         Функциональная клавиша F11
           31         Функциональная клавиша F12
       -----------------------------------------------------------------

         Заявление  ON KEY не имеют действия до тех пор, пока клавишные
      события  не  разрешаются заявлением KEY ON. Если заявление KEY ON
      однажды уже  исполнено,  Турбо-Бейсик осуществляет проверку между
      исполнениями  каждого  последующего заявления с целью установить,
      имело ли место нажатие специфицированной  клавиши.  Если это про-
      изошло, Турбо-Бейсик выполняет GOSUB к назначенной подпрограмме.
         Проверка клавиши n выключается заявлением KEY(n) OFF.  Исполь-
      зуйте  заявление  KEY для определения отслеживания клавиши, кото-
      рая не является функциональной или клавишей управления курсором.
         Для  высококачественного управления генерированием  Турбо-Бей-
      сиком кода проверки событий пользуйтесь метазаявлением $EVENT.

         См. также        $EVENT
                          KEY (n)

      Пример:
                   'Эта программа демонстрирует заявление KEY(n)
                   'включить проверку клавиш
                   KEY ON
                   'назначить строки для клавищ
                   KEY 1, "Алло" + CHR$(13)
                   KEY 2, "Досвидание" + CHR$(13)
                   KEY 10, CHR$ (13)
                   ' в дополнении к назначенной для этого строке
                   'построить отслеживание клавиши для F10
                   ON KEY(10) GOSUB Досвидание
                   'включить отслеживаниеF10
                    KEY(10) ON
                    'получить пользовательский ввод
                    INPUT "Нажмите F1:";Пусто$
                    INPUT "Нажмите F2:";Пусто$
                    PRINT "Теперь нажмите F10...."
                    'когда пользователь нажимает  теперь F10, будет вы-
                    'зываться  подпрограмма Досвидание
                    WHILE NOT INSTAT:WEND 'ждать клавишу F10
                    END    'конец программы
                    Досвидание:
                    KEY LIST 'перечислить определенные в данный момент 
                    'клавиши.
                    KEY(10) OFF 'выключить отслеживание
                   'теперь  когда пользователь нажимает F10, будет
                   'воспроизводиться литерная строка, назначенная 
                   'клавише
                    PRINT "Нажмите теперь F10 для того, чтобы покинуть
                           программу ......"
                    RETURN



                          Заявление ON PEN
                          ----------------

      Функция   ON PEN    заявляет  подпрограмму  отслеживания  с целью   
      -------             получения его управления, если  задействуется
                          световое перо

      Синтаксис    ON PEN GOSUB метка
      ---------
      Замечания       Метка идентифицирует новое заявление подпрограммы
      ---------       обработки  световогого  пера. Заявление ON PEN не
      имеет действия до тех пор, пока  события светового пера не разре-
      шаются заявлением  PEN ON. Если  заявление  PEN ON уже исполнено,
      осуществляется проверка между  всеми последующими  заявлениями  с
      целью проверки, было ли задействовано  световое  перо.  Если  это
      так, вызывается назначенная подпрограммая.
         Проверка светового пера выключается заявлением PEN OFF.  После
      захвата  светового  пера, с целью  удержать  от повторного вызова
      подпрограммы  отслеживания  из  нее самой (и переполнение стека),
      используется неявное  заявление PEN  STOP.  При закрытии подпрог-
      раммы обработки посредством RETURN автоматически выполняется  PEN
      ON, если стандартная подпрограмма не  исполняет  явное  заявление
      PENN OFF.
         Для более качественного управления генерированием Турбо-Бейси-
      ком  кода проверки событий пользуйтесь метазаявлением $EVENT
         См. также  $EVENT
                    PEN

      Пример:
                 ON PEN GOSUB ПераОбработчик 'установить обработчик со-
                 'бытий       
                 PEN ON   'включить отслеживание событий
                 PRINT "Нажмите для останова любую клавишу..."
                 WHILE NOT INSTAT
                 WEND
                 END        'конец программы

                 ПераОбработчик
                 ---------------
                  FOR I% = 1TO 9
                  PRINT PEN (I%)
                  NEXT 1
                  RETURN


                         Заявление ON PLAY
                         -----------------

      Функция   ON PLAY   заявляет подпрограмму  отслеживания  с  целью
      -------             получения его управления, если  буфер фоновой
                          музыки содержит менее специфицированного чис-
                          ла нот.

      Синтаксис   ON PLAY (нотсчетчик) GOSUB метка.
      ---------
      Замечания        Нотсчетчик -это целое выражение, а метка иденти-
      ---------        фицирует первое заявление в подпрограмме музыка-
      льного сопровождения.
         Заявление  ON PLAY не имеет действия до тех пор, пока проверка
      нот  не разрешается  заявлением  PLAY ON. Если PLAY ON уже испол-
      нено, Турбо-Бейсик  осуществляет проверку между исполнениями каж-
      дого последующего  заявления  с целью  проверить не меньше ли ос-
      талось нот в музыкальном буфере, чем  значение  нотсчетчика. Если
      это так, Турбо-Бейсик выполняет GOSUB к назначенной подпрограмме.
         Проверка музыкального буфера  выключается заявлением PLAY OFF.
      После  музыкальной  ловушки  исполняется  неявное  заявление PLAY
      STOP с  целью  удержать вызов  подпрограммы  отслеживания повтор-
      но из нее самой (и заполнения стека).  При  закрытии подпрограммы
      обработки посредством RETURN автоматически  выполняется заявление
      PLAY ON, если ранее в подпрограмме не было  исполнено явное заяв-
      ление PLAY OFF.
         Событие  PLAY  не  отслеживается, если  при исполнении PlAY ON
      буфер уже пуст. Для управления генерированием кода проверки собы-
      тий пользуйтесь метазаявлением  $EVENT. Для установки размера бу-
      фера фоновой музыки  пользуйтесь  метазаявлением $SOUND.
         См. также   $EVENT
                     PLAY(заявление)
                     $SOUND

      Пример:
                 Эта программа демонстрирует ON PLAY (n)
                 'разместить 30 байтов пространства звукового буфера
                  $SOUND 100
                  'включите проверку звуковых событий
                  PLAY ON
                  настройке проверку буфера музыкального сопровождения
                  ON PLAY (S)GOSUB наполнить игры буфер
                  НотыS = "GEAFDCFECFEDGGG "
                  'играть октавы со 2 по 4
                  Игры СтрS ="MB"
                  FOR октава % =2 TO 4
                  Октава S ="0" + STR$(октава%)
                  Игры СтрS = ИгрыСтрS + ОктаваS + НотыS
                  NEXT Октава %
                  PLAY Игры СтрS
                  DO
                  LOOP UNTIL INSTAT
                  CLEAR
                  END    'конец программы

                  Наполнить игры буфер
                  ---------------------
                  PRINT Игры СтрS
                  PLAY Игры cтрS
                  RETURN


                         Заявление ON STRIG
                         ------------------

      Функция   ON STRIG   заявляет  подпрограмму  отслеживания  кнопки
      -------              управления.
      
      Синтаксис   ON STRIG (n) GOSUB метка
      ---------
      Замечания       Метка идентифицирует первое заявление подпрограм-
      ---------       мы обработки "нажатой  кнопки",  а  n - это целое
      выражение, указывающее  подлежащую отслеживанию кнопку в соответ-
      ствии со следующей таблицей:
       ---------------------------------------------------------------
             n                        Кнопка
       ---------------------------------------------------------------
             0             Кнопка 1, ручка управления А
             2             Кнопка 1, ручка управления В
             4             Кнопка 2, ручка управления А
             6             Кнопка 2, ручка управления В
       ----------------------------------------------------------------

         Заявление ON STRIG не имеет действия до тех пор, пока  события
      на  кнопках  управления  не  разрешаются  с   помощью   заявления
      STRIG ON. Если  STRIG  ON уже  выполнено, проверка осуществляется
      между исполнениями всех последующих  заявлений с целью проверить,
      не была ли нажата  указанная  кнопка.  Если  это  так, вызывается
      назначенная подпрограмма.
         Для  выключения проверки указанной кнопки управления использу-
      ется заявление STRIG OFF.
         После захвата события исполняется заявление STRIG STOP c целью
      предотвратить  повторный  вызов  подпрограммы отслеживания из нее
      самой (и заполнение стека). Закрытие подпрограммы обработки с по-
      мощью  RETURN вызывает  автоматическое исполнения заявления STRIG
      ON, если ранее подпрограммой  уже  не исполнено  явное  заявление
      STRIG OFF. Для качественного генерирования кода  проверки событий
      используйте метазаявление $EVENT.
         См. также   $EVENT
                     STRING (n)

      Пример:      Ноль X =1
                   Ноль Y =1
                   Один Z
                   Два  Y =1
                   ЧетыреХ=3
                   Четыре Y=1
                   ШестьХ=Y
                   ШестьY=1
                   'настроить обработчики событий
                    ON STRIG (0) GOSUB переключить ноль
                    ON STRIG (2) GOSUB переключить два
                    ON STRIG (4) GOSUB переключить четыре
                    ON STRIG (6) GOSUB переключить шесть
                   'включить проверку событий
                    STRIG (0) ON
                    STRIG (2) ON
                    STRIG (4) ON
                    STRIG (6) ON
                    'пока кнопка не нажимается , отображать текущие
                    'координаты ручек управления
                    WHILE NOT INSTAT
                    LOGATE 15,15,0
                    PRINT STICK (0), STICK (1);
                    WEND
                    END       'конец программы

                    Переключить ноль:
                    LOGATE нольX,нольY
                    PRINT "Кнопка 1"
                    LOGATE 15,15,0
                    RETURN
                    Переключить два:
                    LOGATE ДваХ, ДваY
                    PRINT "Кнопка2"
                    LOGATE 15,15,0
                    RETURN
                    Переключить четыре:
                    LOGATE четыре Х, четыре Y
                    PRINT "Кнопка 4 "
                    LOGATE 15,15,0
                    RETURN
                    Переключить шесть:
                    LOGATE шесть Х, шесть Y
                    PRINT "КНОПКА 4"
                    LOGATE 15,15,0
                    RETURN

                          Заявление ON TIMER
                          ------------------
      Функция  ON TIMER   заявляет подпрограмму  отслеживания  с  целью
      -------             получения управления каждые n секунд.

      Синтаксис   ON TIMER(n) GOSUB метка
      ---------
      Замечания        Метка указывает  первое  заявление  подпрограммы
      ---------        обработки "истекшего времени", а n - целое выра-
      жение, указывающее  количество  секунд ожидания от 1 до 86400 (24
      часа).
         Заявление  ON TIMER  не имеет действия до тех пор, пока оно не
      разрешается заявлением  TIMER ON. Если TIMER ON уже исполнено на-
      чинается внутренний  отсчет  секунд и между исполнениями  каждого
      заявления делается проверка истечения числа секунд, идентифициро-
      ванного в заявлении. Если время истекло, вызывается подпрограмма,
      назначенная меткой.
         Заявление  TIMER OFF  включает проверку времени. После ловушки
      исполняется  неявное заявление TIMER STOP для предотвращения пов-
      торного вызова подпрограммы отслеживания из нее самой (и заполне-
      ние  стека).  При  закрывании  подпрограммы обработки посредством
      RETURN автоматически выполняется заявление  TIMER  ON,  если под-
      программа ранее не исполняет явное заявление TIMER OFF. Это озна-
      чает, что  счетчик  секунд  повторно устанавливается в ноль после
      таймерной ловушки.
         Для управления генерированием кода проверки  событий использу-
      ется метазаявление $EVENT.
         См. также     $EVENT
                       TIMER
       Пример:
                ON TIME R(1) GOSUB отобразить время
                настроить ловушку таймера
                'включить проверку таймерного события
                 TIMER ON
                 'ожидать нажатия клавиши
                 WHILE NOT INSTAT: WEND
                 END     'конец программы
                 Отобразить время:
                 LOGATE 1,70
                 PRINT TIME$: RETURN
